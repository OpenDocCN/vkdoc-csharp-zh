# 第二部分：创建模式

<!-- ch 3~6 -->

Creational Patterns

在像 C# 这样的“托管”语言中，创建一个新对象的过程很简单:只需`new`它并忘记它。嗯，有`stackalloc`，但是我们主要说的是需要持久化的对象。现在，随着依赖注入的扩散，另一个问题是手动创建对象是否仍然是可接受的，或者我们是否应该将基础设施的所有关键方面的创建推迟到专门的构造，例如工厂(稍后将详细介绍它们！)还是控制容器的倒置？

无论您选择哪一个选项，创建对象仍然是一件苦差事，尤其是如果构建过程很复杂或者需要遵守特殊的规则。这就是创造模式的用武之地:它们是与创建对象相关的常见方法。

万一您对 C# 中构造对象的方法感到生疏，让我们回顾一下主要的方法:

*   调用`new`在托管堆上创建一个对象。对象不需要被显式销毁，因为垃圾收集器(GC)会替我们处理它。

*   使用`stackalloc`的堆栈分配在堆栈上而不是堆上分配内存。堆栈分配的对象只存在于它们被创建的范围内，当它们超出范围时会被自动清除。此构造只能用于值类型。

*   您可以用`Marshal.AllocHGlobal`和`Co-TaskMemAlloc`分配非托管(本机)内存，并且必须用`Marshal.FreeHGlobal`和`CoTaskMem-Free`显式释放它。这主要是与非托管代码进行互操作所需要的。

不用说，一些托管组件可能在幕后使用非托管内存。这也是`IDisposable`接口存在的主要原因之一。这个接口只有一个方法`Dispose()`，它可以包含清理逻辑。如果你正在处理一个实现了`IDisposable`的对象，将它的使用封装在一个`using`语句中(我们现在也有了`using var`)可能是有意义的，这样一旦不再需要这个对象，它的清理代码就会被执行。