# 第三部分：结构模式

<!-- ch 7~13 -->

Structural Patterns

顾名思义，结构模式就是建立应用的结构，从而提高代码的一致性以及可用性和可维护性。

当涉及到确定物体的结构时，我们可以应用这些相当众所周知的方法:

*   *继承*:一个对象自动获取所有成员的基类。为了允许实例化，对象必须实现来自其父对象的每个抽象成员；如果没有，那它就是抽象的，不能被创造(但是你可以从中继承)。

*   *构成*:一般暗示孩子离开父母就无法存在。这通常是用嵌套类实现的。例如，一个类`Car`可以有一个嵌套类`Wheel`。

*   *聚合*:一个对象可以包含另一个对象，但是那个对象也可以独立存在。假设一个`Car`有一个`Person driver`字段或属性。

如今，组合和聚合都以相同的方式处理。如果你有一个字段类型为`Address`的`Person`类，你可以选择`Address`是外部类型还是嵌套类型。在这两种情况下，只要它是`public`，就可以将其实例化为`Address`或`Person.Address`。

我认为，当我们真正指的是聚合时，使用单词 *composition* 已经变得如此普遍，以至于我们也可以以可互换的方式使用它们。这里有一些证据:当我们谈到 IoC 容器时，我们谈到一个*组合根*。但是等等，IoC 容器不是单独控制每个对象的生存期吗？确实如此，所以当我们真正指“聚合”时，我们使用“组合”这个词

基本上，在 C# 中有三种定义数据结构的方法:

*   静态地:当你简单地编写类，然后它们被编译。这是最常见的情况。

*   *通过代码生成*:当从 ?? 模板或数据库或一些用户脚本中创建结构时，就会发生这种情况。例如，在 WinForms 或 Windows Presentation Foundation(WPF)应用中编辑用户界面时，会在后台生成大量代码。

*   *动态*，也就是运行时:这是最复杂的选项。高级库能够构建数据结构，并在应用执行的那一刻将它们编译成可执行代码。这种方法有时在设计模式中被利用，并导致它们的静态-动态二元性。

值得注意的是，许多数据结构是由编译器在幕后隐式创建的。这包括像`ValueTuple`这样的东西，匿名类型的类，以及负责编排枚举器(`yield`功能)或异步(`async/await`)操作的状态机。

在 F# 中，在后台创建的数据结构(和相应的分配)的数量是*巨大的*，这些数据结构的复杂性也是如此。例如，任何类型的 currying 操作都会产生深层次的继承。或者，让我们说，您决定将一个操作符(如`(+)`)作为参数传递给一个函数——在这种情况下，将创建一个完整的`struct`,纯粹是为了存放一个调用该操作符的方法。如果认为所有这样的分配在 JIT 编译期间都是自动内联的，那就太天真了！