# 4.经营者

*运算符*是用来对值进行运算的特殊符号。它们可以分为五种类型:算术、赋值、比较、逻辑和按位运算符。

## 算术运算符

算术运算符包括四种基本算术运算，以及用于获得除法余数的模数运算符(`%`)。

```cs
float x = 3 + 2; // addition (5)
      x = 3 - 2; // subtraction (1)
      x = 3 * 2; // multiplication (6)
      x = 3 / 2; // division (1)
      x = 3 % 2; // modulus (1)

```

请注意，除法符号给出了不正确的结果。这是因为它对两个整数值进行运算，因此会对结果进行舍入并返回一个整数。要获得正确的值，需要将其中一个数字转换为浮点数。

```cs
x = 3 / (float)2; // 1.5

```

## 赋值运算符

下一组是赋值操作符。最重要的是赋值操作符(`=`)本身，它给变量赋值。

```cs
int i = 0; // assignment

```

赋值运算符和算术运算符的一个常见用途是对变量进行运算，然后将结果保存回同一个变量中。使用组合赋值操作符可以缩短这些操作。

```cs
i += 5; // i = i+5;
i -= 5; // i = i-5;
i *= 5; // i = i*5;
i /= 5; // i = i/5;
i %= 5; // i = i%5;

```

### 递增和递减运算符

另一种常见的操作是将变量加 1 或减 1。这可以用增量(`++`)和减量(`--`)操作符来简化。

```cs
x++; // x = x+1;
x--; // x = x-1;

```

这两个运算符都可以用在变量之前或之后。

```cs
x++; // post-increment
x--; // post-decrement
++x; // pre-increment
--x; // pre-decrement

```

无论使用哪个变量，变量的结果都是相同的。不同的是，后运算符在改变变量之前返回原始值，而前运算符先改变变量，然后返回值。

```cs
int x, y;
x = 5; y = x++; // y=5, x=6
x = 5; y = ++x; // y=6, x=6

```

## 比较运算符

比较运算符比较两个值并返回`true`或`false`。它们主要用于指定条件，是评估为`true`或`false`的表达式。

```cs
bool b = (2 == 3); // equal to (false)
     b = (2 != 3); // not equal to (true)
     b = (2 > 3);  // greater than (false)
     b = (2 < 3);  // less than (true)
     b = (2 >= 3); // greater than or equal to (false)
     b = (2 <= 3); // less than or equal to (true)

```

## 逻辑运算符

逻辑运算符通常与比较运算符一起使用。如果左右两边都为真，则逻辑与(`&&`)计算为`true`，如果左右两边都为真，则逻辑或(`||`)计算为`true`。逻辑非(`!`)运算符用于反转布尔结果。请注意，对于“逻辑与”和“逻辑或”，如果左侧已经确定了结果，则不会计算运算符的右侧。

```cs
bool b = (true && false); // logical and (false)
     b = (true || false); // logical or (true)
     b = !(true);         // logical not (false)

```

## 按位运算符

按位运算符可以处理整数中的单个位。例如，按位 and ( `&`)运算符生成结果位`1`，如果该运算符两边的相应位都已设置。

```cs
int x = 5 & 4;  // and (0b101 & 0b100 = 0b100 = 4)
    x = 5 | 4;  // or (0b101 | 0b100 = 0b101 = 5)
    x = 5 ^ 4;  // xor (0b101 ^ 0b100 = 0b001 = 1)
    x = 4 << 1; // left shift (0b100 << 1 = 0b1000 = 8)
    x = 4 >> 1; // right shift (0b100 >> 1 = 0b10 = 2)
    x = ~4;     // invert (~0b00000100 = 0b11111011 = -5)

```

这些位操作符有速记赋值操作符，就像算术操作符一样。

```cs
int x=5; x &= 4;  // and (0b101 & 0b100 = 0b100 = 4)
    x=5; x |= 4;  // or (0b101 | 0b100 = 0b101 = 5)
    x=5; x ^= 4;  // xor (0b101 ^ 0b100 = 0b001 = 1)
    x=5; x <<= 1; // left shift (0b101 << 1 = 0b1010 = 10)
    x=5; x >>= 1; // right shift (0b101 >> 1 = 0b10 = 2)

```

## 运算符先例

在 C#中，表达式通常从左到右计算。但是，当表达式包含多个运算符时，这些运算符的优先级决定了它们的求值顺序。下表列出了优先顺序。同样的顺序也适用于许多其他语言，如 C++和 Java。

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"> <col class="tcol4 align-left"></colgroup> 
| 

在…之前

 | 

操作员

 | 

在…之前

 | 

操作员

 |
| --- | --- | --- | --- |
| `1` | `++ -- ! ~` | `7` | `&` |
| `2` | `* / %` | `8` | `^` |
| `3` | `+ -` | `9` | `&#124;` |
| `4` | `<< >>` | `10` | `&&` |
| `5` | `< <= > >=` | `11` | `&#124;&#124;` |
| `6` | `== !=` | `12` | `= op=` |

例如，逻辑 and ( `&&`)的绑定弱于关系运算符，而关系运算符的绑定又弱于算术运算符。

```cs
bool x = 2+3 > 1*4 && 5/5 == 1; // true

```

为了使事情更清楚，括号可以用来指定表达式的哪一部分将首先被求值。括号是所有运算符中优先级最高的。

```cs
bool x = ((2+3) > (1*4)) && ((5/5) == 1); // true

```