# 6.异步编程

异步编程是艰难和具有挑战性的，但也是有趣的。也被称为*异步*。整体概念不是一天进化出来的；这需要时间。async 和 await 关键字第一次出现在 C# 5.0 中是为了使它更容易。在此之前，不同的程序员使用不同的技术实现了这个概念。每种技术都有其优缺点。本章的目标是向你介绍异步编程，并通过一些常见的实现方法。

## 概观

我们先来讨论一下什么是异步编程。简单地说，你在你的应用程序中取一个代码段，并在一个单独的线程上运行它。关键优势是什么？简单的答案是，您可以释放原始线程，让它继续完成剩余的任务，并在一个单独的线程中执行不同的任务。这种机制帮助您开发现代应用程序；例如，当您实现一个高度响应的用户界面时，这些概念非常有用。

POINTS TO REMEMBER

概括地说，您会注意到异步编程中有三种不同的模式。

*   **IAsyncResult 模式:**这也被称为*异步编程模型(APM)* 。在这个模式中，您可以看到支持异步行为的`IAsyncResult`接口。在同步模型中，如果您有一个名为 XXX()的同步方法，在异步版本中，您会看到相应的同步方法使用了`BeginXXX()`和`EndXXX()`方法。比如在同步版本中，如果`Read()`方法支持读操作，在异步编程中，你看到`BeginRead()`和`EndRead()`方法异步支持相应的读操作。使用这个概念，您可以在演示 5、6 和 7 中看到`BeginInvoke`和`EndInvoke`方法。然而，新的开发不推荐这种模式。

*   **基于事件的异步模式** **:** 这种模式伴随而来。NET 框架 2.0。它基于一种事件机制。这里您可以看到带有`Async`后缀的方法名、一个或多个事件以及`EventArg`派生类型。新开发不推荐使用这种模式。

*   **基于任务的异步模式** **:** 这最早出现在。NET 框架 4。这是目前异步编程的推荐做法。在 C#中，你经常会看到这种模式中的`async`和`await`关键字。

为了更好地理解异步编程，让我们从它的对应物开始讨论:*同步编程*。同步方法很简单，代码路径也很容易理解；但是你需要等待来自特定代码段的结果，在那之前，你只是无所事事。考虑一些典型案例；例如，当您知道一段代码试图打开一个可能需要时间加载的网页时，或者当一段代码正在运行一个长时间运行的算法时，等等。如果您遵循同步方法，当您执行长时间运行的操作时，您必须闲置，因为您不能做任何有用的事情。

这就是为什么为了支持现代需求和构建高响应性的应用程序，对异步编程的需求越来越大。

## 使用同步方法

演示 1 执行一个简单的程序。让我们从同步方法开始。有两个简单的方法:`Method1()`和`Method2()`。在`Main()`方法内部，这些方法被同步调用(即先调用`Method1()`，再调用`Method2()`)。)我使用了简单的 sleep 语句，因此这些方法执行的任务需要花费大量的时间来完成。一旦您运行应用程序并注意到输出，您会看到只有在`Method1()`完成执行后，`Method2()`才开始执行。在这些方法完成它们的执行之前，`Main()`方法不能完成。

Note

在本章中，你会看到这些方法略有不同。我试图维护相似的方法(或操作),以便您可以比较异步编程的不同技术。出于演示的目的，`Method1()`需要更多的时间来完成，因为它执行了一个冗长的操作(我在其中强制了一个相对较长的睡眠)。`Method2()`执行一个小任务，所以我在里面放了一个短睡眠。此外，为了简单起见，我使用了简称。

### 演示 1

这是完整的演示。

```cs
using System;
using System.Threading;

namespace SynchronousProgrammingExample
{
      class Program
      {
          static void Main(string[] args)
          {
              Console.WriteLine("***Demonstration-1.A Synchronous Program Demo.***");
              Method1();
              Method2();
              Console.WriteLine("End Main().");
              Console.ReadKey();
          }
          // Method1
          private static void Method1()
          {
              Console.WriteLine("Method1() has started.");
              // Some big task
              Thread.Sleep(1000);
              Console.WriteLine("Method1() has finished.");
          }
          // Method2
          private static void Method2()
          {
              Console.WriteLine("Method2() has started.");
              // Some small task
              Thread.Sleep(100);
              Console.WriteLine("Method2() has finished.");
          }
      }
  }

```

#### 输出

这是输出。

```cs
***Demonstration-1.A Synchronous Program Demo.***
Method1() has started.
Method1() has finished.
Method2() has started.
Method2() has finished.
End Main().

```

## 使用线程类

如果您仔细观察演示 1 中的方法，您会发现它们并不相互依赖。如果您可以并行执行它们，您的应用程序的响应时间将会得到改善，并且您可以减少总的执行时间。让我们找到一些更好的方法。

你在第 5 章中学到了线程，所以你可以实现多线程的概念。演示 2 向您展示了一个使用线程的显而易见的解决方案。我保留了注释代码供您参考。这个演示的重点是在一个新线程中替换`Method1()`。

### 演示 2

```cs
using System;
using System.Threading;

namespace UsingThreadClass
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("***Asynchronous Programming Demonstration-1.***");
            //Method1();
            // Old approach.Creating a separate thread for the following // task(i.e Method1.)
            Thread newThread = new Thread(()=>
            {
                Console.WriteLine("Method1() has started on a separate thread.");
                // Some big task
                Thread.Sleep(1000);
                Console.WriteLine("Method1() has finished.");
                }
            );
            newThread.Start();
            Thread.Sleep(10);
            Method2();
            Console.WriteLine("End Main().");
            Console.ReadKey();
        }
        // Method1
        //private static void Method1()
        //{
        //    Console.WriteLine("Method1() has started.");
        //    // Some big task
        //    Thread.Sleep(1000);
        //    Console.WriteLine("Method1() has finished.");
        //}

        private static void Method2()
        {
            Console.WriteLine("Method2() has started.");
            // Some small task
            Thread.Sleep(100);
            Console.WriteLine("Method2() has finished.");
        }
    }
}

```

#### 输出

这是一种可能的输出。

```cs
***Asynchronous Programming Demonstration-1.***
Method1() has started on a separate thread.
Method2() has started.
Method2() has finished.
End Main().
Method1() has finished.

```

#### 分析

注意，虽然`Method1()`被提前调用，但是`Method2`不需要等待`Method1()`完成执行。此外，由于`Method2()`做得很少(睡眠时间为 100 毫秒)，它能够在`Method1()`完成执行之前完成。还要注意，因为主线程没有被阻塞，所以它能够继续执行。

### 问答环节

6.1 为什么在 Main 中执行 Method2()之前使用 sleep 语句？

接得好。这不是必须的，但是在某些情况下，您可能会注意到，即使您试图在当前线程中的`Method2()`之前启动`Method1()`在一个单独的线程上执行，这也不会发生，因此，您可能会注意到以下输出。

```cs
***Asynchronous Programming Demonstration-1.***
Method2() has started.
Method1() has started in a separate thread.
Method2() has finished.
End Main().
Method1() has finished.

```

在这个例子中，这个简单的 sleep 语句可以帮助你增加在`Method2()`之前开始`Method1()`的概率。

## 使用线程池类

通常不鼓励在现实世界的应用程序中直接创建线程。以下是这背后的一些主要原因。

*   维护太多的线程会导致困难和高成本的操作。

*   大量时间浪费在上下文切换上，而不是做真正的工作。

为了避免直接创建线程，C#为您提供了使用内置`ThreadPool`类的便利。有了这个类，您可以使用现有的线程，这些线程可以重用以满足您的需要。`ThreadPool`类在维护应用程序中的最佳线程数量方面非常有效。如果需要，您可以使用这个工具异步执行一些任务。

`ThreadPool`是一个包含`static`方法的静态类，其中一些方法还有一个重载版本。图 [6-1](#Fig1) 是 Visual Studio IDE 的部分截图，展示了`ThreadPool`类中的方法。

![../images/494901_1_En_6_Chapter/494901_1_En_6_Fig1_HTML.jpg](../images/494901_1_En_6_Chapter/494901_1_En_6_Fig1_HTML.jpg)

图 6-1

Visual Studio 2019 IDE 中 ThreadPool 类的截图

在本节中，我们的重点是`QueueUserWorkItem`方法。在图 [6-1](#Fig1) 中，注意这个方法有两个重载版本。要了解关于此方法的更多信息，让我们展开 Visual Studio 中的方法描述。例如，一旦展开此方法的第一个重载版本，就会看到以下内容。

```cs
//
// Summary:
//     Queues a method for execution. The method executes when a thread //     pool thread becomes available.
//
// Parameters:
//   callBack:
//     A System.Threading.WaitCallback that represents the method to be //     executed.
//
// Returns:
//     true if the method is successfully queued; System.//     NotSupportedException is thrown
//     if the work item could not be queued.
//
// Exceptions:
//   T:System.ArgumentNullException:
//     callBack is null.
//
//   T:System.NotSupportedException:
//     The common language runtime (CLR) is hosted, and the host does not//     support this action.
[SecuritySafeCritical]
public static bool QueueUserWorkItem(WaitCallback callBack);

```

如果您进一步研究方法参数，您会发现`WaitCallBack`是一个具有以下描述的委托。

```cs
//
// Summary:
//     Represents a callback method to be executed by a thread pool thread.
//
// Parameters:
//   state:
//     An object containing information to be used by the callback method.
[ComVisible(true)]
public delegate void WaitCallback(object state);

```

第二个重载版本的`QueueUserWorkItem`可以接受一个名为`state`的`object`参数。内容如下。

```cs
public static bool QueueUserWorkItem(WaitCallback callBack, object state);

```

如果查看细节，您会发现可以通过这个参数将有价值的数据传递给方法。在演示 3 中，我使用了两个重载版本，并且我引入了`Method3`，其中我传递了一个对象参数。

### 演示 3

为了有效地使用`QueueUserWorkItem`方法，您需要一个匹配`WaitCallBack`委托签名的方法。在下面的演示中，我在`ThreadPool`中对两个方法进行排队。在演示 2 中，Method2 不接受任何参数。如果将它传递给`QueueUserWorkItem`，会得到如下编译错误。

```cs
No overload for 'Method2' matches delegate 'WaitCallback'

```

让我们用一个虚拟对象参数来修改`Method2`，如下(我保留了注释供你参考)。

```cs
/* The following method's signature should match the delegate WaitCallback.*/
private static void Method2(Object state)
{
    Console.WriteLine("--Method2() has started.");
    // Some small task
    Thread.Sleep(100);
    Console.WriteLine("--Method2() has finished.");
}

```

接下来，我们来介绍一下使用了`Object`参数的`Method3,`。`Method3`描述如下。

```cs
static void Method3(Object number)
{
    Console.WriteLine("---Method3() has started.");
    int upperLimit = (int)number;
    for (int i = 0; i < upperLimit; i++)
    {
        Console.WriteLine("---Method3() prints 3.0{0}", i);
    }
     Thread.Sleep(100);
     Console.WriteLine("---Method3() has finished.");
}

```

现在来看下面的演示和相应的输出。

```cs
using System;
using System.Threading;

namespace UsingThreadPool
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("***Asynchronous Programming Demonstration.***");
            Console.WriteLine("***Using ThreadPool.***");

            // Using Threadpool
            // Not passing any parameter for Method2
            ThreadPool.QueueUserWorkItem(new WaitCallback(Method2));
            // Passing 10 as the parameter for Method3
            ThreadPool.QueueUserWorkItem(new WaitCallback(Method3), 10);
            Method1();

            Console.WriteLine("End Main().");
            Console.ReadKey();
        }

        private static void Method1()
        {
            Console.WriteLine("-Method1() has started.");
            // Some big task
            Thread.Sleep(1000);
            Console.WriteLine("-Method1() has finished.");
        }

        /* The following method's signature should match the delegate WaitCallback.
        It is as follows:
        public delegate void WaitCallback(object state)
        */
        //private static void Method2()//Compilation error
        private static void Method2(Object state)
        {
            Console.WriteLine("--Method2() has started.");
            // Some small task
            Thread.Sleep(100);
            Console.WriteLine("--Method2() has finished.");
        }
        /*
The following method has a parameter.This method's signature matches the WaitCallBack  delegate signature.Notice that this method also matches the ParameterizedThreadStart delegate signature; because it has a single parameter of type Object and this method doesn't return a value.
        */
        static void Method3(Object number)
        {
          Console.WriteLine("---Method3() has started.");
          int upperLimit = (int)number;
          for (int i = 0; i < upperLimit; i++)
          {
              Console.WriteLine("---Method3() prints 3.0{0}", i);
          }
          Thread.Sleep(100);
          Console.WriteLine("---Method3() has finished.");
        }
    }
}

```

#### 输出

这是一个可能的输出。

```cs
***Asynchronous Programming Demonstration.***
***Using ThreadPool.***
-Method1() has started.
---Method3() has started.
---Method3() prints 3.00
---Method3() prints 3.01
---Method3() prints 3.02
---Method3() prints 3.03
--Method2() has started.
---Method3() prints 3.04
---Method3() prints 3.05
---Method3() prints 3.06
---Method3() prints 3.07
---Method3() prints 3.08
---Method3() prints 3.09
--Method2() has finished.
---Method3() has finished.
-Method1() has finished.
End Main().

```

### 问答环节

**6.2 按照简单的委托实例化技术，如果我使用下面的代码行:**

```cs
ThreadPool.QueueUserWorkItem(Method2);

instead of this line:
ThreadPool.QueueUserWorkItem(new WaitCallback(Method2));

will the application compile and run?

Yes, but since you are learning to use the WaitCallback delegate now, I kept it for your reference.

```

## 对线程池使用 Lambda 表达式

如果您喜欢 lambda 表达式，您可以在类似的上下文中使用它。例如，在演示 3 中，您可以使用 lambda 表达式替换`Method3`，如下所示。

```cs
// Using lambda Expression
// Here the method needs a parameter(input).
// Passing 10 as the parameter for Method3
ThreadPool.QueueUserWorkItem((number) =>
{
     Console.WriteLine("---Method3() has started.");
     int upperLimit = (int)number;
     for (int i = 0; i < upperLimit; i++)
     {
         Console.WriteLine("---Method3() prints 3.0{0}", i);
     }
     Thread.Sleep(100);
     Console.WriteLine("---Method3() has finished.");
  }, 10
);

```

在演示 3 中，您可以注释掉下面的代码行，并用前面显示的 lambda 表达式替换`Method3`。

```cs
ThreadPool.QueueUserWorkItem(new WaitCallback(Method3), 10);

```

如果您再次执行该程序，您会得到类似的输出。演示 4 是完整的实现，供您参考。

### 演示 4

```cs
using System;
using System.Threading;

namespace UsingThreadPoolWithLambdaExpression
{
    class Program
    {
        static void Main(string[] args)
        {
              Console.WriteLine("***Asynchronous Programming Demonstration.***");
              Console.WriteLine("***Using ThreadPool with Lambda Expression.***");

              // Using Threadpool
              // Not passing any parameter for Method2
              ThreadPool.QueueUserWorkItem(Method2);
              //  Using lambda Expression
              // Here the method needs a parameter(input).
              // Passing 10 as the parameter for Method3
              ThreadPool.QueueUserWorkItem( (number) =>
              {
                  Console.WriteLine("--Method3() has started.");
                  int upperLimit = (int)number;
                  for (int i = 0; i < upperLimit; i++)
                  {
                      Console.WriteLine("---Method3() prints 3.0{0}", i);
                  }
                  Thread.Sleep(100);
                  Console.WriteLine("--Method3() has finished.");
              }, 10

            );

            Method1();
            Console.WriteLine("End Main().");
            Console.ReadKey();
        }

        private static void Method1()
        {
            Console.WriteLine("-Method1() has started.");
            // Some task
            Thread.Sleep(500);
            Console.WriteLine("-Method1() has finished.");
        }

        /* The following method's signature should match the delegate WaitCallback.
        It is as follows:
        public delegate void WaitCallback(object state)
        */
        //private static void Method2()//Compilation error
        private static void Method2(Object state)
        {
            Console.WriteLine("--Method2() has started.");
            // Some task
            Thread.Sleep(100);
            Console.WriteLine("--Method2() has finished.");
        }
    }
}

```

#### 输出

这是一个可能的输出。

```cs
***Asynchronous Programming Demonstration.***
***Using ThreadPool with Lambda Expression.***
-Method1() has started.
--Method3() has started.
---Method3() prints 3.00
--Method2() has started.
---Method3() prints 3.01
---Method3() prints 3.02
---Method3() prints 3.03
---Method3() prints 3.04
---Method3() prints 3.05
---Method3() prints 3.06
---Method3() prints 3.07
---Method3() prints 3.08
---Method3() prints 3.09
--Method2() has finished.
--Method3() has finished.
-Method1() has finished.
End Main().

```

Note

这一次，您看到了 lambda 表达式在`ThreadPool`类中的使用。在演示 2 中，您看到了 lambda 表达式在`Thread`类中的使用。

## 使用 IAsyncResult 模式

`IAsyncResult`接口帮助您实现异步行为。让我们回忆一下我早些时候告诉你的话。在同步模型中，如果有一个名为 XXX 的同步方法，在异步版本中，`BeginXXX`和`EndXXX`方法就是对应的同步方法。让我们仔细看看。

### 使用异步委托进行轮询

到目前为止，您已经看到了委托的许多不同用法。在本节中，您将了解另一种用法，即通过使用委托，您可以异步调用方法。轮询是一种重复检查条件的机制。在演示 5 中，让我们检查一个委托实例是否完成了它的任务。

### 演示 5

有两种方法叫做`Method1`和`Method2`。让我们再次假设`Method1`比`Method2`花费更多的时间来完成它的任务。简单来说，`Sleep()`语句在这些方法内部传递。在这个例子中，`Method1`接收一个休眠 3000 毫秒的参数，`Method2`休眠 100 毫秒。

现在看看代码的重要部分。首先，创建一个委托实例来匹配`Method1`签名。`Method1`如下。

```cs
// Method1
private static void Method1(int sleepTimeInMilliSec)
{
    Console.WriteLine("Method1() has started.");
   Console.WriteLine("Inside Method1(),Thread id {0} .",  Thread.CurrentThread.ManagedThreadId);
    // Some big task
    Thread.Sleep(sleepTimeInMilliSec);
    Console.WriteLine("\nMethod1() has finished.");
}

```

为了匹配签名，如下声明`Method1Delegate`。

```cs
    public delegate void Method1Delegate(int sleepTimeinMilliSec);

```

稍后，如下实例化它。

```cs
Method1Delegate method1Del = Method1;

```

到目前为止，一切都很简单。现在我们来看代码中最重要的一行，如下所示。

```cs
IAsyncResult asyncResult = method1Del.BeginInvoke(3000, null, null);

```

你还记得在委托的上下文中，你可以使用`Invoke()`方法吗？但是上一次，代码遵循同步路径。现在我们正在探索异步编程，您会看到`BeginInvoke`和`EndInvoke`方法的使用。当 C#编译器看到 delegate 关键字时，它会为动态生成的类提供这些方法。

`BeginInvoke`方法的返回类型是`IAsyncResult`。如果您将鼠标悬停在`BeginInvoke`上或者注意它的结构，您会看到虽然`Method1`只接受一个参数，但是`BeginInvoke`方法总是接受两个额外的参数——一个类型为`AsyncCallback`，一个类型为`object`。我很快会讨论它们。

在这个例子中，我只使用第一个参数，并将 3000 毫秒作为`Method1`的参数。但是对于`BeginInvoke`的最后两个参数，我通过了`null`。

`BeginInvoke`的结果很重要。我将结果保存在一个`IAsyncResult`对象中。`IAsyncResult`具有以下只读属性。

```cs
public interface IAsyncResult
{
    bool IsCompleted { get; }
    WaitHandle AsyncWaitHandle { get; }
    object AsyncState { get; }
    bool CompletedSynchronously { get; }
 }

```

目前，我关注的是`isCompleted`属性。如果您进一步扩展这些定义，您会看到`isCompleted`的定义如下。

```cs
//
// Summary:
//     Gets a value that indicates whether the asynchronous operation has//     completed.
//
// Returns:
//     true if the operation is complete; otherwise, false.
bool IsCompleted { get; }

```

很明显，您可以使用这个属性来验证委托是否已经完成了它的工作。

在下面的例子中，我检查另一个线程中的委托是否已经完成了它的工作。如果工作没有完成，我会在控制台窗口中打印星号(*)，并强制主线程短暂休眠。这就是您在本演示中看到下面这段代码的原因。

```cs
while (!asyncResult.IsCompleted)
{
    // Keep working in main thread
    Console.Write("*");
    Thread.Sleep(5);
}

```

最后，`EndInvoke`方法接受一个类型为`IAsyncResult`的参数。我通过`asyncResult`作为这个方法中的一个参数。

现在进行完整的演示。

```cs
using System;
using System.Threading;

namespace PollingDemo
{
    class Program
    {
        public delegate void Method1Delegate(int sleepTimeinMilliSec);
        static void Main(string[] args)
        {
            Console.WriteLine("***Polling Demo.***");
            Console.WriteLine("Inside Main(),Thread id {0} .", Thread.CurrentThread.ManagedThreadId);
            // Synchronous call
            //Method1(3000);

            Method1Delegate method1Del = Method1;
            IAsyncResult asyncResult = method1Del.BeginInvoke(3000, null, null);
            Method2();
            while (!asyncResult.IsCompleted)
            {
                // Keep working in main thread
                Console.Write("*");
                Thread.Sleep(5);
            }

            method1Del.EndInvoke(asyncResult);
            Console.ReadKey();
        }
        // Method1
        private static void Method1(int sleepTimeInMilliSec)
        {
            Console.WriteLine("Method1() has started.");
            Console.WriteLine("Inside Method1(),Thread id {0} .", Thread.CurrentThread.ManagedThreadId);
            // Some big task
            Thread.Sleep(sleepTimeInMilliSec);
            Console.WriteLine("\nMethod1() has finished.");

        }
        // Method2
        private static void Method2()
        {
            Console.WriteLine("Method2() has started.");
            Console.WriteLine("Inside Method2(),Thread id {0} .", Thread.CurrentThread.ManagedThreadId);
            // Some small task
            Thread.Sleep(100);
            Console.WriteLine("Method2() has finished.");
        }

    }
}

```

#### 输出

这是一种可能的输出。

```cs
***Polling Demo.***
Inside Main(),Thread id 1 .
Method2() has started.
Inside Method2(),Thread id 1 .
Method1() has started.
Inside Method1(),Thread id 3 .
Method2() has finished.
***********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
Method1() has finished.

```

### 问答环节

**6.3 上一个案例中，Method1 带一个参数，** `BeginInvoke` **带三个参数。如果** `Method1` **接受** `n` **数量的参数，那么** `BeginInvoke` **就会有** `n+2` **参数。**

是的，初始的参数集是基于您的方法的，但是对于最后两个参数，一个是类型`AsyncCallback`的，最后一个是类型`object`的。

POINTS TO REMEMBER

*   这种类型的例子在。NET 框架 4.7.2。如果你在。NET Core 3.0，你得到一个异常说“系统。PlatformNotSupportedException:此平台不支持操作。其中一个主要原因是异步委托实现依赖于中不存在的远程处理功能。NET 核心。关于这一点的讨论是在 [`https://github.com/dotnet/runtime/issues/16312`](https://github.com/dotnet/runtime/issues/16312) 。

*   如果您不想在控制台窗口中检查和打印星号(*)，您可以在主线程完成执行后简单地调用委托类型的`EndInvoke()`方法。`EndInvoke()`方法一直等到代理完成它的工作。

*   If you don’t explicitly examine whether the delegate finishes its execution or not, or you simply forget to call `EndInvoke()`, the thread of the delegate is stopped after the main thread dies. For example, if you comment out the following segment of code from the prior example,

    ```cs
    //while (!asyncResult.IsCompleted)
    //{
    //    Keep working in main thread
    //    Console.Write("*");
    //    Thread.Sleep(5);
    //}
    //method1Del.EndInvoke(asyncResult);
    //Console.ReadKey();

    ```

    并再次运行应用程序，您可能看不到`"Method1() has finished."`语句。

*   `BeginInvoke`通过使用`EndInvoke`帮助调用线程稍后获得异步方法调用的结果。

### 使用 IAsyncResult 的 AsyncWaitHandle 属性

现在我将向您展示一种使用另一个属性`AsyncWaitHandle`的替代方法，这个属性在`IAsyncResult`中也是可用的。如果看到`IAsyncResult`的内容，发现`AsyncWaitHandle`返回`WaitHandle`，有如下描述。

```cs
//
// Summary:
//     Gets a System.Threading.WaitHandle that is used to wait for an //     asynchronous operation to complete.
//
// Returns:
//     A System.Threading.WaitHandle that is used to wait for an //     asynchronous operation to complete.
WaitHandle AsyncWaitHandle { get; }

```

Visual Studio IDE 确认`WaitHandle`是一个等待对共享资源进行独占访问的抽象类。在`WaitHandle`中，你可以看到有五个不同重载版本的`WaitOne()`方法。

```cs
public virtual bool WaitOne(int millisecondsTimeout);
public virtual bool WaitOne(int millisecondsTimeout, bool exitContext);
public virtual bool WaitOne(TimeSpan timeout);
public virtual bool WaitOne(TimeSpan timeout, bool exitContext);
public virtual bool WaitOne();

```

通过使用`WaitHandle,`,你可以等待一个委托线程完成它的工作。在演示 6 中，使用了第一个重载版本，并提供了一个可选的超时值，单位为毫秒。如果等待成功，控制从`while`循环中退出；但是如果超时发生，`WaitOne()`返回 false，并且`while`循环继续并在控制台中打印星号(*)。

### 演示 6

```cs
using System;
using System.Threading;

namespace UsingWaitHandle
{
    class Program
    {
        public delegate void Method1Delegate(int sleepTimeinMilliSec);
        static void Main(string[] args)
        {
            Console.WriteLine("***Polling and WaitHandle Demo.***");
            Console.WriteLine("Inside Main(),Thread id {0} .", Thread.CurrentThread.ManagedThreadId);
            // Synchronous call
            //Method1(3000);
            // Asynchrous call using a delegate
            Method1Delegate method1Del = Method1;
            IAsyncResult asyncResult = method1Del.BeginInvoke(3000, null, null);
            Method2();
            // while (!asyncResult.IsCompleted)
            while (true)
            {
                // Keep working in main thread
                Console.Write("*");
                /* There are 5 different overload method for WaitOne().Following method blocks the current thread until the current System.Threading.WaitHandle receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.
                */
                if (asyncResult.AsyncWaitHandle.WaitOne(10))
                {
                    Console.Write("\nResult is available now.");
                    break;
                }
            }
            method1Del.EndInvoke(asyncResult);
            Console.WriteLine("\nExiting Main().");
            Console.ReadKey();
        }
        // Method1
        private static void Method1(int sleepTimeInMilliSec)
        {
            Console.WriteLine("Method1() has started.");
            // It will have a different thread id
            Console.WriteLine("Inside Method1(),Thread id {0} .", Thread.CurrentThread.ManagedThreadId);
            // Some big task
            Thread.Sleep(sleepTimeInMilliSec);
            Console.WriteLine("\nMethod1() has finished.");

        }
        // Method2
        private static void Method2()
        {
            Console.WriteLine("Method2() has started.");
            // Main thread id and this thread id will be same
            Console.WriteLine("Inside Method2(),Thread id {0} .", Thread.CurrentThread.ManagedThreadId);
            // Some small task
            Thread.Sleep(100);
            Console.WriteLine("Method2() has finished.");
        }
    }
}

```

#### 输出

这是一种可能的输出。

```cs
***Polling and WaitHandle Demo.***
Inside Main(),Thread id 1 .
Method2() has started.
Inside Method2(),Thread id 1 .
Method1() has started.
Inside Method1(),Thread id 3 .
Method2() has finished.
*************************************************************************************************************************************************************
Method1() has finished.
*
Result is available now.
Exiting Main().

```

#### 分析

如果将这个演示与上一个进行比较，您会注意到这里您等待异步操作以不同的方式完成。这次你没有使用`IsCompleted`属性，而是使用了`IAsyncResult`的`AsyncWaitHandle`属性。

### 使用异步回调

让我们回顾一下前两次演示中的`BeginInvoke`方法。

```cs
// Asynchrous call using a delegate
Method1Delegate method1Del = Method1;
IAsyncResult asyncResult = method1Del.BeginInvoke(3000, null, null);

```

这意味着为最后两个方法参数传递了两个`null`值。如果您将鼠标悬停在这些先前演示的行上，您会注意到在本例中,`BeginInvoke`期望一个`IAsyncCallback`委托作为第二个参数，一个`object`作为第三个参数。

让我们调查一下`IAsyncCallback`代表。Visual Studio IDE 说此委托是在系统命名空间中定义的；它有以下描述。

```cs
//
// Summary:
//   References a method to be called when a corresponding asynchronous //   operation completes.
//
// Parameters:
//   ar:
//     The result of the asynchronous operation.
  [ComVisible(true)]
  public delegate void AsyncCallback(IAsyncResult ar);

```

你可以使用一个`callback`方法来执行一些有用的东西(例如，家务工作)。`AsyncCallback`委托有一个`void`返回类型，它接受一个`IAsyncResult`参数。让我们定义一个可以匹配这个委托签名的方法，并在`Method1Del`实例完成执行后调用这个方法。

下面是一个示例方法，将在接下来的演示中使用。

```cs
// Method3: It's a callback method.
// This method will be invoked when Method1Delegate completes its work.
private static void Method3(IAsyncResult asyncResult)
{
    if (asyncResult != null) // if null you can throw some exception
    {
        Console.WriteLine("\nMethod3() has started.");
        Console.WriteLine("Inside Method3(),Thread id {0} .", Thread.CurrentThread.ManagedThreadId);
        // Do some housekeeping work/ clean-up operation
        Thread.Sleep(100);
        Console.WriteLine("Method3() has finished.");
    }
}

```

### 演示 7

现在查看完整的实现。

```cs
using System;
using System.Threading;

namespace UsingAsynchronousCallback
{
    class Program
    {
        public delegate void Method1Delegate(int sleepTimeinMilliSec);
        static void Main(string[] args)
        {
            Console.WriteLine("***Using Asynchronous Callback.***");
            Console.WriteLine("Inside Main(),Thread id {0} .", Thread.CurrentThread.ManagedThreadId);
            // Synchronous call
            //Method1(3000);
            // Asynchrous call using a delegate
            Method1Delegate method1Del = Method1;
            IAsyncResult asyncResult = method1Del.BeginInvoke(3000,Method3, null);

            Method2();
            while (!asyncResult.IsCompleted)
            {
                   // Keep working in main thread
                   Console.Write("*");
                   Thread.Sleep(5);
            }

            method1Del.EndInvoke(asyncResult);
            Console.WriteLine("Exit Main().");
            Console.ReadKey();
        }
        // Method1
        private static void Method1(int sleepTimeInMilliSec)
        {
            Console.WriteLine("Method1() has started.");
            Console.WriteLine("Inside Method1(),Thread id {0} .", Thread.CurrentThread.ManagedThreadId);
            // Some big task
            Thread.Sleep(sleepTimeInMilliSec);
            Console.WriteLine("\nMethod1() has finished.");

        }
        // Method2
        private static void Method2()
        {
            Console.WriteLine("Method2() has started.");
            Console.WriteLine("Inside Method2(),Thread id {0} .", Thread.CurrentThread.ManagedThreadId);
            //Some small task
            Thread.Sleep(100);
            Console.WriteLine("Method2() has finished.");
        }
        /* Method3: It's a callback method.This method will be invoked when Method1Delegate completes its work.*/
        private static void Method3(IAsyncResult asyncResult)
        {
            if (asyncResult != null)//if null you can throw some exception
            {
                Console.WriteLine("\nMethod3() has started.");
                Console.WriteLine("Inside Method3(),Thread id {0} .", Thread.CurrentThread.ManagedThreadId);
                // Do some housekeeping work/ clean-up operation
                Thread.Sleep(100);
                Console.WriteLine("Method3() has finished.");
            }
        }
    }
}

```

#### 输出

这是一个可能的输出。

```cs
***Using Asynchronous Callback.***
Inside Main(),Thread id 1 .
Method2() has started.
Inside Method2(),Thread id 1 .
Method1() has started.
Inside Method1(),Thread id 3 .
Method2() has finished.
**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
Method1() has finished.

Method3() has started.
Inside Method3(),Thread id 3 .
Exit Main().
Method3() has finished.

```

#### 分析

请注意，Method3 仅在 Method1()完成执行后才开始工作。还要注意的是`Method1()`和`Method3()`的线程 ID 是相同的。这是因为`Method3()`是从运行 Method1()的线程中调用的。

### 问答环节

**6.4 什么是回调方法？**

通常，它是一个仅在特定操作完成后调用的方法。您经常会在异步编程中看到这种方法的使用，在异步编程中，您不知道某个操作的确切完成时间，但希望在前一个任务结束后开始某个特定的任务。例如，在前面的示例中，如果 Method1()在执行期间分配了资源，Method3 可以执行一些清理工作。

我发现 Method3()没有从主线程调用。这是意料之中的吗？

是的。这里您使用了回调方法。在这个例子中，Method3()是回调方法，它只能在 Method1()完成工作后开始执行。因此，从运行 Method1()的同一个线程中调用 Method3()是有意义的。

我可以在这个例子中使用 lambda 表达式吗？

接得好。为了获得类似的输出，在前面的演示中，没有创建一个新方法`Method3()`，而是使用下面的代码行，

```cs
IAsyncResult asyncResult = method1Del.BeginInvoke(3000, Method3, null);

```

您可以使用 lambda 表达式替换它，如下所示。

```cs
IAsyncResult asyncResult = method1Del.BeginInvoke(3000,
 (result) =>
{
    if (result != null)//if null you can throw some exception
    {
        Console.WriteLine("\nMethod3() has started.");
        Console.WriteLine("Inside Method3(),Thread id {0} .", Thread.CurrentThread.ManagedThreadId);
        // Do some housekeeping work/ clean-up operation
        Thread.Sleep(100);
        Console.WriteLine("Method3() has finished.");
    }
 },
null);

```

**6.7 当您在** `BeginInvoke` **方法中使用回调方法 Method3 时，您传递的不是一个对象作为最终参数，而是一个空值。这有什么具体原因吗？**

不，我没有在这些演示中使用该参数。因为它是一个对象参数，你可以传递任何对你有意义的东西。使用回调方法时，可以传递委托实例。它可以帮助您的回调方法分析异步方法的结果。

但是为了简单起见，让我们修改前面的演示并传递一个字符串消息作为`BeginInvoke`中的最后一个参数。假设您正在修改现有的代码行，

```cs
IAsyncResult asyncResult = method1Del.BeginInvoke(3000,Method3, null);

```

有了下面这个。

```cs
IAsyncResult asyncResult = method1Del.BeginInvoke(3000, Method3, "Method1Delegate, thank you for using me." );

To accommodate this change, let’s modify the Method3() method too.The newly added lines are shown in bold.
private static void Method3(IAsyncResult asyncResult)
{
    if (asyncResult != null) // if null you can throw some exception
    {
        Console.WriteLine("\nMethod3() has started.");
        Console.WriteLine("Inside Method3(),Thread id {0} .", Thread.CurrentThread.ManagedThreadId);
        // Do some housekeeping work/ clean-up operation
        Thread.Sleep(100);
        // For Q&A
        string msg = (string)asyncResult.AsyncState;
        Console.WriteLine("Method3() says : '{0}'",msg);
        Console.WriteLine("Method3() has finished.");
    }
}

```

如果您再次运行该程序，这一次您可能会看到以下输出。

```cs
***Using Asynchronous Callback.***
Inside Main(),Thread id 1 .
Method2() has started.
Inside Method2(),Thread id 1 .
Method1() has started.
Inside Method1(),Thread id 3 .
Method2() has finished.
***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
Method1() has finished.

Method3() has started.
Inside Method3(),Thread id 3 .
Exit Main().
Method3() says : 'Method1Delegate, thank you for using me.'
Method3() has finished.

```

POINTS TO REMEMBER

您已经看到了使用委托实现轮询、等待句柄和异步回调。这个编程模型也存在于。NET 框架；比如`HttpWebRequest`级的`BeginGetResponse`、`BeginGetRequestStream`，或者`SqlCommand`级的`BeginExecuteNonQuery()`、`BeginExecuteReader()`、`BeginExecuteXmlReader()`。这些方法也有重载。

## 使用基于事件的异步模式(EAP)

在本节中，您将看到 EAP 的用法。起初，基于事件的模式似乎很难理解。根据应用程序的复杂性，这种模式可以有多种形式。

以下是这种模式的一些关键特征。

*   一般来说，异步方法是其同步版本的精确副本，但是当您调用它时，它在一个单独的线程上启动，然后立即返回。这种机制允许在后台运行预期操作的同时继续调用线程。这些操作的例子可以是长时间运行的过程，例如加载大图像、下载大文件、连接和建立到数据库的连接，等等。EAP 在这些情况下是有帮助的。例如，一旦长时间运行的下载操作完成，就可以引发一个事件来通知信息。事件的订阅者可以根据该通知立即采取行动。

*   您可以同时执行多个操作，并在每个操作完成时收到通知。

*   使用这种模式，您可以利用多线程，但同时也隐藏了整体的复杂性。

*   在最简单的情况下，你的方法名会有一个 ***Async*** 后缀来告诉其他人你正在使用一个异步版本的方法。同时，您有一个带有 ***完成*** 后缀的相应事件。在理想情况下，您应该有一个相应的 cancel 方法，并且它应该支持显示进度条/报告。支持取消操作的方法也可以命名为*method name****async cancel***(或者简称为 ***CancelAsync*** )。

*   像`SoundPlayer`、`PictureBox`、`WebClient`和`BackgroundWorker`这样的组件是这种模式的常见代表。

演示 8 是`WebClient`的一个简单应用。我们开始吧。

### 演示 8

在程序的开始，您会看到我需要包含一些特定的名称空间。我用注释来说明为什么这些对于这个演示是必要的。

在这个案例研究中，我想将一个文件下载到我的本地系统中。但是我没有使用来自互联网的真实的`URL`,而是将源文件存储在我的本地系统中。这可以给你带来两大好处。

*   运行此应用程序不需要互联网连接。

*   由于您没有使用互联网连接，下载操作会相对较快。

现在看看下面的代码块，您将在完整的示例中看到它。

```cs
WebClient webClient = new WebClient();
// File location
Uri myLocation = new Uri(@"C:\TestData\testfile_original.txt");
// Target location for download
string targetLocation = @"C:\TestData\downloaded_file.txt";
webClient.DownloadFileAsync(myLocation, targetLocation);
webClient.DownloadFileCompleted += new AsyncCompletedEventHandler(Completed);

```

到目前为止，事情简单明了。但是我想让你注意下面几行代码。

```cs
webClient.DownloadFileAsync(myLocation, targetLocation);
webClient.DownloadFileCompleted += new AsyncCompletedEventHandler(Completed);

```

你可以看到在第一行中，我使用了一个在`WebClient`中定义的叫做`DownloadFileAsync`的方法。在 Visual Studio 中，方法描述告诉我们以下内容。

```cs
// Summary:
//     Downloads, to a local file, the resource with the specified URI. //     This method does not block the calling thread.
//
// Parameters:
//   address:
//     The URI of the resource to download.
//
//   fileName:
//     The name of the file to be placed on the local computer.
//
// Exceptions:
//   T:System.ArgumentNullException:
//     The address parameter is null. -or- The fileName parameter is null.
//
//   T:System.Net.WebException:
//     The URI formed by combining System.Net.WebClient.BaseAddress and //     address is invalid.
//     -or- An error occurred while downloading the resource.
//
//   T:System.InvalidOperationException:
//     The local file specified by fileName is in use by another thread.
public void DownloadFileAsync(Uri address, string fileName);

```

从方法总结中，您了解到当您使用此方法时，调用线程不会被阻塞。(实际上，`DownloadFileAsync`是`DownloadFile`方法的异步版本，在`WebClient.`中也有定义)

现在来看下一行代码。

```cs
webClient.DownloadFileCompleted += new AsyncCompletedEventHandler(Completed);

```

Visual Studio 对`DownloadFileCompleted`事件的描述如下。

```cs
/ Summary:
//     Occurs when an asynchronous file download operation completes.
public event AsyncCompletedEventHandler DownloadFileCompleted;

```

它对`AsyncCompletedEventHandler`的描述如下。

```cs
// Summary:
//     Represents the method that will handle the MethodNameCompleted event //     of an asynchronous operation.
//
// Parameters:
//   sender:
//     The source of the event.
//
//   e:
//     An System.ComponentModel.AsyncCompletedEventArgs that contains the //     event data.
public delegate void AsyncCompletedEventHandler(object sender, AsyncCompletedEventArgs e);

```

您可以订阅`DownloadFileCompleted`事件来显示下载操作完成的通知。为此，使用以下方法。

```cs
private static void DownloadCompleted(object sender, AsyncCompletedEventArgs e)
{
    Console.WriteLine("Successfully downloaded the file now.");
}

```

Note

`DownloadCompleted`方法匹配`AsyncCompletedEventHandler`委托的签名。

既然您已经掌握了委托和事件的概念，您知道您可以替换这一行代码

```cs
webClient.DownloadFileCompleted += new AsyncCompletedEventHandler(DownloadCompleted);

```

使用下面的代码行。

```cs
webClient.DownloadFileCompleted += DownloadCompleted;

```

为了更好的可读性，我保留了长版本。

现在查看完整的示例和输出。

```cs
using System;
// For AsyncCompletedEventHandler delegate
using System.ComponentModel;
using System.Net; // For WebClient
using System.Threading; // For Thread.Sleep() method

namespace UsingWebClient
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("***Demonstration-.Event Based Asynchronous Program Demo.***");
            // Method1();
            #region The lenghty operation(download)
            Console.WriteLine("Starting a download operation.");
            WebClient webClient = new WebClient();
            // File location
            Uri myLocation = new Uri(@"C:\TestData\OriginalFile.txt");
            // Target location for download
            string targetLocation = @"C:\TestData\DownloadedFile.txt";
            webClient.DownloadFileAsync(myLocation, targetLocation);
            webClient.DownloadFileCompleted += new AsyncCompletedEventHandler(Completed);
            #endregion
            Method2();
            Console.WriteLine("End Main()...");
            Console.ReadKey();
        }
        // Method2
        private static void Method2()
        {
            Console.WriteLine("Method2() has started.");
            // Some small task
            // Thread.Sleep(10);
            Console.WriteLine("Method2() has finished.");
        }

        private static void Completed(object sender, AsyncCompletedEventArgs e)
        {
            Console.WriteLine("Successfully downloaded the file now.");
        }
    }
}

```

#### 输出

这是一个可能的输出。

```cs
***Demonstration-.Event Based Asynchronous Program Demo.***
Starting a download operation.
Method2() has started.
Method2() has finished.
End Main()...
Successfully downloaded the file now.

```

#### 分析

您可以看到下载操作是在`Method2()`开始执行之前开始的。然而，`Method2()`在下载操作完成之前完成了它的任务。如果你有兴趣看`Original.txt`的内容，如下。

```cs
Dear Reader,
This is my test file.It is originally stored at C:\TestData in my system.

```

您可以测试一个类似的文件及其内容，以便在您的终端上进行快速验证。

#### 附加说明

当你引入一个进度条时，你可以使这个例子更好。您可以使用 Windows 窗体应用程序来获得对进度条的内置支持。我们先忽略`Method2`，把重点放在异步下载操作上。你可以做一个基本的表单，如图 [6-2](#Fig2) 所示，包含三个简单的按钮和一个进度条。(您需要首先将这些控件拖放到您的表单上。我假设你知道这些活动)。

![../images/494901_1_En_6_Chapter/494901_1_En_6_Fig2_HTML.jpg](../images/494901_1_En_6_Chapter/494901_1_En_6_Fig2_HTML.jpg)

图 6-2

一个简单的 UI 应用程序，演示基于事件的异步

下面这段代码是不言自明的。

```cs
using System;
using System.ComponentModel;
using System.Net;
using System.Threading;
using System.Windows.Forms;

namespace UsingWebClientWithWinForm
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
        }

        private void StartDownload_Click(object sender, EventArgs e)
        {
         WebClient webClient = new WebClient();
         Uri myLocation = new Uri(@"C:\TestData\testfile_original.txt");
         string targetLocation = @"C:\TestData\downloaded_file.txt";
         webClient.DownloadFileAsync(myLocation, targetLocation);
         webClient.DownloadFileCompleted += new AsyncCompletedEventHandler(DownloadCompleted);
         webClient.DownloadProgressChanged += new DownloadProgressChangedEventHandler(ProgressChanged);
         Thread.Sleep(3000);
         MessageBox.Show("Method1() has finished.");
    }
    private void DownloadCompleted(object sender, AsyncCompletedEventArgs e)
    {
         MessageBox.Show("Successfully downloaded the file now.");
    }
    private void ProgressChanged(object sender, DownloadProgressChangedEventArgs e)
    {
         progressBar.Value = e.ProgressPercentage;
    }

    private void ResetButton_Click(object sender, EventArgs e)
    {
         progressBar.Value = 0;
    }

    private void ExitButton_Click(object sender, EventArgs e)
    {
        this.Close();
    }
    }
}

```

#### 输出

一旦点击`StartDownload button`，就会得到如图 [6-3](#Fig3) 所示的输出。

![../images/494901_1_En_6_Chapter/494901_1_En_6_Fig3_HTML.jpg](../images/494901_1_En_6_Chapter/494901_1_En_6_Fig3_HTML.jpg)

图 6-3

UI 应用程序运行时的运行时屏幕截图

### 问答环节

基于事件的异步程序有哪些优点和缺点？

以下是与这种方法相关的一些常见的优点和缺点。

赞成的意见

*   您可以调用一个长时间运行的方法并立即获得一个返回。当方法完成时，您会收到一个通知。

骗局

*   因为您已经分离了代码，所以理解、调试和维护通常很困难。

*   当您订阅了一个事件，但后来忘记取消订阅时，可能会出现一个大问题。这个错误会导致应用程序中的内存泄漏，影响可能非常严重；例如，您的系统可能会挂起或没有响应，您可能需要经常重新启动系统。

## 了解任务

要理解基于任务的异步模式，首先要知道的是,*任务*只是您想要执行的一个工作单元。您可以在同一个线程或不同的线程中完成这项工作。通过使用任务，您可以更好地控制线程；例如，您可以在任务完成后执行后续工作。父任务可以创建子任务，因此您可以组织层次结构。当你级联你的消息时，这种层次结构是重要的；例如，在您的应用程序中，您可能决定一旦父任务被取消，子任务也应该被取消。

您可以用不同的方式创建任务。在下面的演示中，我用三种不同的方式创建了三个任务。请注意下面这段带有支持性注释的代码。

```cs
#region Different ways to create and execute task
// Using constructor
Task taskOne = new Task(MyMethod);
taskOne.Start();
// Using task factory
TaskFactory taskFactory = new TaskFactory();
// StartNew Method creates and starts a task.
// It has different overloaded version.
Task taskTwo = taskFactory.StartNew(MyMethod);
// Using task factory via a task
Task taskThree = Task.Factory.StartNew(MyMethod);
#endregion

```

您可以看到所有三个任务都在执行相同的操作。它们中的每一个都在执行`MyMethod()`，描述如下。

```cs
private static void MyMethod()
{
    Console.WriteLine("Task.id={0} with Thread id {1} has started.", Task.CurrentId, Thread.CurrentThread.ManagedThreadId);
    // Some task
    Thread.Sleep(100);
    Console.WriteLine("MyMethod for Task.id={0} and Thread id {1} is completed.", Task.CurrentId,  Thread.CurrentThread.ManagedThreadId);
    }

```

你可以看到在`MyMethod()`内部，为了区分任务和线程，它们对应的 id 被打印在控制台中。

最后一件事。您可以看到方法名作为参数被传递到了`StartNew()`方法中。这个方法在编写时有 16 个重载版本，我使用的是如下定义的那个。

```cs
//
// Summary:
//     Creates and starts a task.
//
// Parameters:
//   action:
//     The action delegate to execute asynchronously.
//
// Returns:
//     The started task.
//
// Exceptions:
//   T:System.ArgumentNullException:
//     The action argument is null.
public Task StartNew(Action action);

```

因为在这种情况下`MyMethod()`匹配`Action`委托的签名，所以对`StartNew`使用这种方法没有问题。

### 演示 9

现在进行完整的演示和输出。

```cs
using System;
using System.Threading;
using System.Threading.Tasks;

namespace CreatingTasks
{
    class Program
    {
     static void Main(string[] args)
     {
            Console.WriteLine("***Using different ways to create tasks.****");
            Console.WriteLine("Inside Main().Thread ID:{0}", Thread.CurrentThread.ManagedThreadId);

            #region Different ways to create and execute task
            // Using constructor
            Task taskOne = new Task(MyMethod);
            taskOne.Start();
            // Using task factory
            TaskFactory taskFactory = new TaskFactory();
            // StartNew Method creates and starts a task.
            // It has different overloaded version.
            Task taskTwo = taskFactory.StartNew(MyMethod);
            // Using task factory via a task
            Task taskThree = Task.Factory.StartNew(MyMethod);
            #endregion
            Console.ReadKey();
        }

        private static void MyMethod()
        {
            Console.WriteLine("Task.id={0} with Thread id {1} has started.", Task.CurrentId, Thread.CurrentThread.ManagedThreadId);
            Thread.Sleep(100);
            Console.WriteLine("MyMethod for Task.id={0} and Thread id {1} is completed.", Task.CurrentId, Thread.CurrentThread.ManagedThreadId);
        }
    }
}

```

#### 输出

这是一个可能的输出。

```cs
***Using different ways to create tasks.****
Inside Main().Thread ID:1
Task.id=2 with Thread id 6 has started.
Task.id=1 with Thread id 5 has started.
Task.id=3 with Thread id 4 has started.
MyMethod for Task.id=1 and Thread id 5 is completed.
MyMethod for Task.id=3 and Thread id 4 is completed.
MyMethod for Task.id=2 and Thread id 6 is completed.

```

#### 问答环节

**6.9** `StartNew()` **只能用于匹配动作委托签名的方法。这是正确的吗？**

不。我在一个接受参数的`StartNew`重载中使用了它，参数是匹配动作委托签名的方法的名称。但是，还有其他过载版本的`StartNew`；例如，考虑以下情况。

```cs
public Task<TResult> StartNew<[NullableAttribute(2)]TResult>
(Func<TResult> function, TaskCreationOptions creationOptions);
Or,
public Task<TResult> StartNew<[NullableAttribute(2)]TResult>
(Func<TResult> function, CancellationToken cancellationToken);

```

**6.10 在之前的一个 Q & A 中，我看到了** `TaskCreationOptions` **的用法。这是什么意思？**

这是一个`enum`。您可以使用它来设置任务的行为。下面描述了这个`enum`，并包括您拥有的不同选项。

```cs
public enum TaskCreationOptions
{
        None = 0,
        PreferFairness = 1,
        LongRunning = 2,
        AttachedToParent = 4,
        DenyChildAttach = 8,
        HideScheduler = 16,
        RunContinuationsAsynchronously = 64,
}

```

在接下来的演示中，您将看到一个叫做`TaskContinuationOptions`的重要`enum`的使用，它也有助于设置任务行为。

## 使用基于任务的异步模式(TAP)

TAP 最早出现在 C# 4.0 中。是 C# 5.0 中出现的`async/await`的基础。TAP 引入了`Task`类及其通用变体，当异步代码块的返回值不是问题时，使用`Task<TResult>. Task`，但是当您希望返回值进一步处理时，您应该使用`Task<TResult>`通用版本`.`。让我们用这个概念来实现使用`Method1()`和`Method2()`的 TAP。

### 演示 10

这是一个完整的演示。

```cs
using System;
using System.Threading;
using System.Threading.Tasks;

namespace UsingTAP
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("***Using Task-based Asynchronous Pattern.****");
            Console.WriteLine("Inside Main().Thread ID:{0}", Thread.CurrentThread.ManagedThreadId);
            Task taskForMethod1 = new Task(Method1);
            taskForMethod1.Start();
            Method2();
            Console.ReadKey();
        }

        private static void Method1()
        {
            Console.WriteLine("Method1() has started.");
            Console.WriteLine("Inside Method1(),Thread id {0} .", Thread.CurrentThread.ManagedThreadId);
            // Some big task
            Thread.Sleep(3000);
            Console.WriteLine("Method1() has completed its job now.");
        }

        private static void Method2()
        {
            Console.WriteLine("Method2() has started.");
            Console.WriteLine("Inside Method2(),Thread id {0} .", Thread.CurrentThread.ManagedThreadId);
            Thread.Sleep(100);
            Console.WriteLine("Method2() is completed.");
        }
    }
}

```

#### 输出

这是一个可能的输出。

```cs
***Using Task-based Asynchronous Pattern.****
Inside Main().Thread ID:1
Method2() has started.
Inside Method2(),Thread id 1 .
Method1() has started.
Inside Method1(),Thread id 4 .
Method2() is completed.
Method1() has completed its job now.

```

您刚刚看到了一个基于任务的异步模式的示例演示。我不关心`Method1`的返回值。但是假设你想看`Method1`执行成功与否。为了简单起见，我使用一条`string`消息来表示成功完成。这次你会看到任务的一个普通变体`Task<string>`。对于 lambda 表达式爱好者，我在这个例子中用 lambda 表达式修改了`Method1`。为了满足关键需求，我调整了返回类型。这次我添加了另一个叫做`Method3()`的方法。出于比较的目的，最初这个方法将被注释掉，程序将被执行，输出将被分析。稍后我将取消对它的注释，并使用该方法创建一个任务层次结构。一旦完成，程序将被再次执行，你会注意到当`Method1()`完成它的工作时`Method3()`执行。为了更好的理解，我保留了评论。

现在来看一下接下来的演示。

### 演示 11

这是一个完整的演示。

```cs
using System;
using System.Threading;
using System.Threading.Tasks;

namespace UsingTAPDemo2
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("***Using Task-based Asynchronous Pattern.Using lambda expression into it.****");
            Console.WriteLine("Inside Main().Thread ID:{0}", Thread.CurrentThread.ManagedThreadId);
            // Task taskForMethod1 = new Task(Method1);
            // taskForMethod1.Start();
            Task<string> taskForMethod1 = Method1();
            // Wait for task to complete.It’ll be no more             //asynchonous now.
            // taskForMethod1.Wait();
            // Continue the task
            // The taskForMethod3 will continue once taskForMethod1 is             // finished
            // Task taskForMethod3 = taskForMethod1.ContinueWith(Method3, TaskContinuationOptions.OnlyOnRanToCompletion);
            Method2();
            Console.WriteLine("Task for Method1 was a : {0}", taskForMethod1.Result);
            Console.ReadKey();
        }
        // Using lambda expression
        private static Task<string> Method1()
        {
            return Task.Run(() =>
            {
                string result = "Failure";
                try
                {
                    Console.WriteLine("Inside Method1(),Task.id={0}", Task.CurrentId);
                    Console.WriteLine("Method1() has started.");
                    Console.WriteLine("Inside Method1(),Thread id {0} .", Thread.CurrentThread.ManagedThreadId);
                    //Some big task
                    Thread.Sleep(3000);
                    Console.WriteLine("Method1() has completed its job now.");
                    result = "Success";
                }
                catch (Exception ex)
                {
                    Console.WriteLine("Exception caught:{0}", ex.Message);
                }
                return result;
            }
            );
        }

        private static void Method2()
        {
            Console.WriteLine("Method2() has started.");
            Console.WriteLine("Inside Method2(),Thread id {0} .", Thread.CurrentThread.ManagedThreadId);
            Thread.Sleep(100);
            Console.WriteLine("Method2() is completed.");
        }
        private static void Method3(Task task)
        {
            Console.WriteLine("Method3 starts now.");
            Console.WriteLine("Task.id is:{0} with Thread id is :{1} ", Task.CurrentId, Thread.CurrentThread.ManagedThreadId);
            Thread.Sleep(20);
            Console.WriteLine("Method3 for Task.id {0} and Thread id {1} is completed.", Task.CurrentId, Thread.CurrentThread.ManagedThreadId);
        }
    }
}

```

#### 输出

```cs
***Using Task-based Asynchronous Pattern.Using lambda expression into it.****
Inside Main().Thread ID:1
Method2() has started.
Inside Method2(),Thread id 1 .
Inside Method1(),Task.id=1
Method1() has started.
Inside Method1(),Thread id 4 .
Method2() is completed.
Method1() has completed its job now.
Task for Method1 was a : Success

```

#### 分析

你注意到我没有对`taskForMethod1`使用`Start()`方法吗？相反，我使用了`Task`类中的`Run()`方法来执行`Method1()`。我为什么这么做？嗯，在`Task`类里面，`Run`是一个静态方法。Visual Studio 中的方法总结告诉我们关于这个`Run`方法的如下内容:`"Queues the specified work to run on the thread pool and returns a System.Threading.Tasks.Task`1 object that represents that work."`在编写的时候，这个方法有八个重载版本，如下。

```cs
public static Task Run(Action action);
public static Task Run(Action action, CancellationToken cancellationToken);
public static Task<TResult> Run<TResult>(Func<TResult> function);
public static Task<TResult> Run<TResult>(Func<TResult> function, CancellationToken cancellationToken);
public static Task Run(Func<Task> function);
public static Task Run(Func<Task> function, CancellationToken cancellationToken);
public static Task<TResult> Run<TResult>(Func<Task<TResult>> function);
public static Task<TResult> Run<TResult>(Func<Task<TResult>> function, CancellationToken cancellationToken);

```

现在检查这个例子中的另一个要点。如果取消对下面一行的注释

```cs
// Task taskForMethod3 = taskForMethod1.ContinueWith(Method3, TaskContinuationOptions.OnlyOnRanToCompletion);

```

并再次运行该应用程序，您可以得到类似下面的输出。

```cs
***Using Task-based Asynchronous Pattern.Using lambda expression into it.****
Inside Main().Thread ID:1
Method2() has started.
Inside Method1(),Task.id=1
Method1() has started.
Inside Method1(),Thread id 4 .
Inside Method2(),Thread id 1 .
Method2() is completed.
Method1() has completed its job now.
Task for Method1 was a : Success
Method3 starts now.
Task.id is:2 with Thread id is :5
Method3 for Task.id 2 and Thread id 5 is completed.

```

`ContinueWith()`方法有助于继续任务。你可能还会注意到下面的部分。

```cs
TaskContinuationOptions.OnlyOnRanToCompletion

```

它只是声明当`taskForMethod1`完成它的工作时，任务将继续。同样，您可以通过使用`TaskContinuationOptions` `enum`来选择其他选项，其描述如下。

```cs
public enum TaskContinuationOptions
{
    None = 0,
    PreferFairness = 1,
    LongRunning = 2,
    AttachedToParent = 4,
    DenyChildAttach = 8,
    HideScheduler = 16,
    LazyCancellation = 32,
    RunContinuationsAsynchronously = 64,
    NotOnRanToCompletion = 65536,
    NotOnFaulted = 131072,
    OnlyOnCanceled = 196608,
    NotOnCanceled = 262144,
    OnlyOnFaulted = 327680,
    OnlyOnRanToCompletion = 393216,
    ExecuteSynchronously = 524288
}

```

### 问答环节

6.11 我可以一次分配多项任务吗？

是的，你可以。在前面修改过的例子中，假设您有一个名为`Method4`的方法，描述如下。

```cs
private static void Method4(Task task)
{
    Console.WriteLine("Method4 starts now.");
    Console.WriteLine("Task.id is:{0} with Thread id is :{1} ", Task.CurrentId, Thread.CurrentThread.ManagedThreadId);
            Thread.Sleep(10);
    Console.WriteLine("Method4 for Task.id {0} and Thread id {1} is completed.", Task.CurrentId, Thread.CurrentThread.ManagedThreadId);
}

```

你可以写下面几行。

```cs
Task<string> taskForMethod1 = Method1();
Task taskForMethod3 = taskForMethod1.ContinueWith(Method3, TaskContinuationOptions.OnlyOnRanToCompletion);
 taskForMethod3 = taskForMethod1.ContinueWith(Method4, TaskContinuationOptions.OnlyOnRanToCompletion);

```

这意味着一旦 taskForMethod1 完成了任务，您就会看到 taskForMethod3 的后续工作，它执行 Method3 和 Method4。

还需要注意的是，延续工作可以有延续工作。例如，让我们假设您想要以下内容。

*   一旦 taskForMethod1 完成，然后继续 taskForMethod3。

*   一旦 taskForMethod3 完成，就只能继续 taskForMethod4

你可以写类似下面的东西。

```cs
// Method1 starts
Task<string> taskForMethod1 = Method1();
// Task taskForMethod3 starts after Task taskForMethod1
Task taskForMethod3 = taskForMethod1.ContinueWith(Method3,
TaskContinuationOptions.OnlyOnRanToCompletion);
// Task taskForMethod4 starts after Task taskForMethod3
Task taskForMethod4 = taskForMethod3.ContinueWith(Method4, TaskContinuationOptions.OnlyOnRanToCompletion);

```

### 使用 async 和 await 关键字

使用`async`和`await`关键字使得点击模式非常灵活。本章使用了两种方法，其中第一种方法是长时间运行的方法，比第二种方法需要更多的时间来完成。我继续用同样的`Method1()`和`Method2()`方法`.`进行案例研究

在接下来的演示中，我使用`async`和 await 关键字。我从一个非 lambda 版本开始，但是在*分析部分*，我给出了 lambda 表达式*代码的变体。*首先我们来看`Method1() again`。

```cs
private static void Method1()
{
    Console.WriteLine("Method1() has started.");
    Console.WriteLine("Inside Method1(),Thread id {0} .", Thread.CurrentThread.ManagedThreadId);
    // Some big task
    Thread.Sleep(3000);
    Console.WriteLine("Method1() has completed its job now.");
}

```

当您使用 lambda 表达式和一个`async/await`对时，您的代码可能如下所示。

```cs
// Using lambda expression
private static async Task ExecuteMethod1()
{
    await Task.Run(() =>
    {
        Console.WriteLine("Method1() has started.");
        Console.WriteLine("Inside Method1(),Thread id {0} .", Thread.CurrentThread.ManagedThreadId);
        // Some big task
        Thread.Sleep(3000);
        Console.WriteLine("Method1() has completed its job now.");
            }
            );
        }

```

你有没有注意到同步版本和异步版本非常相似？但是许多早期实现异步编程的解决方案并不是这样的。(我也相信它们是复杂的。)

等待是做什么的？当你分析代码时，你会发现一旦你得到一个`await`，调用线程就会跳出这个方法，继续做别的事情。在接下来的演示中，`Task.Run is used;`它导致异步调用在一个单独的线程上继续。*然而，需要注意的是，这个*并不意味着延续工作应该在一个新的线程*上完成，因为*你可能不*总是关心*不同的线程*；例如，当您的呼叫等待通过网络建立连接以下载某些内容时。*

在非 lambda 版本中，我使用下面的代码块。

```cs
private static async Task ExecuteTaskOne()
{
    await Task.Run(Method1);
}

```

在`Main()`内部，`ExecuteTaskOne()`不调用`Method1()`，而是异步执行`Method1()`。我通过了`Run`方法里面的`Method1`。我在这里使用了最短的重载版本的`Run`方法。由于`Method1`匹配一个`Action`委托的签名(记住这个委托封装了任何没有参数和`void`返回类型的方法)，您可以在`Task`类的`Run`方法中将它作为参数传递。

### 演示 12

这是完整的演示。

```cs
using System;
using System.Threading;
using System.Threading.Tasks;

namespace UsingAsyncAwaitDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("***Exploring task-based asynchronous pattern(TAP) using async and await.****");
            Console.WriteLine("Inside Main().Thread ID:{0}", Thread.CurrentThread.ManagedThreadId);
            /*
             * This call is not awaited.So,the current method
             * continues before the call is completed.
             */
            ExecuteTaskOne();//Async call,this call is not awaited
            Method2();
            Console.ReadKey();
        }

        private static async Task ExecuteTaskOne()
        {
            await Task.Run(Method1);
        }
        private static void Method1()
        {
            Console.WriteLine("Method1() has started.");
            Console.WriteLine("Inside Method1(),Thread id {0} .", Thread.CurrentThread.ManagedThreadId);
            // Some big task
            Thread.Sleep(3000);
            Console.WriteLine("Method1() has completed its job now.");
        }

        private static void Method2()
        {
            Console.WriteLine("Method2() has started.");
            Console.WriteLine("Inside Method2(),Thread id {0} .", Thread.CurrentThread.ManagedThreadId);
            Thread.Sleep(100);
            Console.WriteLine("Method2() is completed.");
        }
    }
}

```

#### 输出

这是一个可能的输出。

```cs
***Exploring task-based asynchronous pattern(TAP) using async and await.****
Inside Main().Thread ID:1
Method1() has started.
Inside Method1(),Thread id 4 .
Method2() has started.
Inside Method2(),Thread id 1 .
Method2() is completed.
Method1() has completed its job now.

```

#### 分析

您可以看到`Method1()`开始得更早，但是`Method2()`的执行并没有因此而被阻塞。还要注意，`Method2()`在一个主线程中运行，而`Method1()`在一个不同的线程中执行。

和前面的例子一样，如果您喜欢 lambda 表达式，您可以替换下面的代码段:

```cs
private static async Task ExecuteTaskOne()
{
        await Task.Run(Method1);
}

private static void Method1()
{
        Console.WriteLine("Method1() has started.");
        Console.WriteLine("Inside Method1(),Thread id {0} .", Thread.CurrentThread.ManagedThreadId);
        // Some big task
        Thread.Sleep(3000);
        Console.WriteLine("Method1() has completed its job now.");
}

```

有了这个:

```cs
// Using lambda expression
private static async Task ExecuteMethod1()
{
    await Task.Run(() =>
    {
           Console.WriteLine("Method1() has started.");
           Console.WriteLine("Inside Method1(),Thread id {0} .", Thread.CurrentThread.ManagedThreadId);
           // Some big task
           Thread.Sleep(3000);
           Console.WriteLine("Method1() has completed its job now.");
        }
        );
}

```

在演示 12 中，您可以直接调用`ExecuteMethod1()`方法来获得类似的输出，而不是调用`ExecuteTaskOne()`。

在前面的示例中，您会看到下面一行的警告消息:`ExecuteMethod1();`，它陈述了以下内容。

```cs
Warning  CS4014  Because this call is not awaited, execution of the current method continues before the call is completed. Consider applying the 'await' operator to the result of the call.

```

如果你将鼠标悬停在这里，你会得到两个建议。第一个建议您应用丢弃，如下所示:

```cs
_ = ExecuteMethod1(); // applying discard

```

Note

从 C #7.0 开始支持丢弃。它们是应用程序中临时的、虚拟的和未使用的变量。因为这些变量可能不在分配的存储中，所以它们可以减少内存分配。这些变量可以增强可读性和可维护性。使用下划线(_)表示应用程序中被丢弃的变量。

下面使用第二个建议，并在该行之前插入`await`。

```cs
await ExecuteMethod1();

```

在这种情况下，编译器会引发另一个错误。

```cs
Error  CS4033  The 'await' operator can only be used within an async method. Consider marking this method with the 'async' modifier and changing its return type to 'Task'.

```

要消除这个错误，您需要使包含方法`async`(即，从如下行开始:

```cs
static async Task Main(string[] args)

```

在应用了`async/await`对之后，`Main()`方法可能如下所示。

```cs
class Program
{
    // static void Main(string[] args)
    static async Task Main(string[] args)
    {
        Console.WriteLine("***Exploring task-based asynchronous pattern(TAP) using async and await.****");
        Console.WriteLine("Inside Main().Thread ID:{0}", Thread.CurrentThread.ManagedThreadId);
        await ExecuteMethod1();
        // remaining code

```

这种全面的讨论提醒您一起应用 async/await，并正确放置它们。

我用另一个演示来结束这一章，在这个演示中，我稍微修改了应用程序的调用序列。我用的`Method3(),`和`Method2()`差不多。该方法从`ExecuteTaskOne()`调用，其结构如下。

```cs
private static async Task ExecuteTaskOne()
{
     Console.WriteLine("Inside ExecuteTaskOne(), prior to await() call.");
     int value=await Task.Run(Method1);
     Console.WriteLine("Inside ExecuteTaskOne(), after await() call.");
     // Method3 will be called if Method1 executes successfully
     if (value != -1)
     {
          Method3();
     }
}

```

这段代码简单地说，我想从`Method1()`获取返回值，并基于该值决定是否调用`Method3()`。这次，`Method1()`的返回类型不是`void`；相反，它返回一个`int` (0 表示成功完成；否则为–1)。这个方法用如下所示的`try-catch`块进行了重构。

```cs
private static int Method1()
{
    int flag = 0;
    try
    {
           Console.WriteLine("Method1() has started.");
           Console.WriteLine("Inside Method1(),Thread id {0} .", Thread.CurrentThread.ManagedThreadId);
           // Some big task
           Thread.Sleep(3000);
           Console.WriteLine("Method1() has completed its job now.");
 }
 catch (Exception e)
 {
        Console.WriteLine("Caught Exception {0}", e);
        flag = -1;
 }
 return flag;
}

```

现在来看看下面的例子。

### 演示 13

这是完整的演示。

```cs
using System;
using System.Threading;
using System.Threading.Tasks;

namespace UsingAsyncAwaitDemo3
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("***Exploring task-based asynchronous pattern(TAP) using async and await.****");
            Console.WriteLine("***This is a modified example with three methods.***");
            Console.WriteLine("Inside Main().Thread ID:{0}", Thread.CurrentThread.ManagedThreadId);
            /*
             * This call is not awaited.So,the current method
             * continues before the call is completed.
             */
            _=ExecuteTaskOne();//Async call,this call is not awaited
            Method2();
            Console.ReadKey();
        }

        private static async Task ExecuteTaskOne()
        {
            Console.WriteLine("Inside ExecuteTaskOne(), prior to await() call.");
            int value=await Task.Run(Method1);
            Console.WriteLine("Inside ExecuteTaskOne(), after await() call.");
            // Method3 will be called if Method1 executes successfully
            if (value != -1)
            {
                Method3();
            }
        }

        private static int Method1()
        {
            int flag = 0;
            try
            {
                Console.WriteLine("Method1() has started.");
                Console.WriteLine("Inside Method1(),Thread id {0} .", Thread.CurrentThread.ManagedThreadId);
                //Some big task
                Thread.Sleep(3000);
                Console.WriteLine("Method1() has completed its job now.");
            }
            catch (Exception e)
            {
                Console.WriteLine("Caught Exception {0}", e);
                flag = -1;
            }
            return flag;
        }
        private static void Method2()
        {
            Console.WriteLine("Method2() has started.");
            Console.WriteLine("Inside Method2(),Thread id {0} .", Thread.CurrentThread.ManagedThreadId);
            Thread.Sleep(100);
            Console.WriteLine("Method2() is completed.");
        }
    private static void Method3()
    {
        Console.WriteLine("Method3() has started.");
           Console.WriteLine("Inside Method3(),Thread id {0} .", Thread.CurrentThread.ManagedThreadId);
           Thread.Sleep(100);
           Console.WriteLine("Method3() is completed.");
        }
    }
}

```

#### 输出

```cs
***Exploring task-based asynchronous pattern(TAP) using async and await.****
***This is a modified example with three methods.***
Inside Main().Thread ID:1
Inside ExecuteTaskOne(), prior to await() call.
Method1() has started.
Inside Method1(),Thread id 4 .
Method2() has started.
Inside Method2(),Thread id 1 .
Method2() is completed.
Method1() has completed its job now.
Inside ExecuteTaskOne(), after await() call.
Method3() has started.
Inside Method3(),Thread id 4 .
Method3() is completed.

```

#### 分析

密切注意输出。你可以看到`Method3()`需要等待`Method1()`的完成，但是`Method2()`可以在`Method1()`结束执行之前完成它的执行。这里，如果`Method1()`的返回值不等于–1，则`Method3()`可以继续。这个场景类似于您在演示 11 中看到的`ContinueWith()`方法。

最重要的是，再次注意下面的代码行。

```cs
int value=await Task.Run(Method1);

```

它只是将代码段分为两部分:*对* `await`的前调用和*对* `await`的后调用。这个语法类似于任何同步调用，但是通过使用`await`(在一个`async`方法中)，您应用了一个暂停点并使用了异步编程的力量。

我用微软的一些有趣的笔记来结束这一章。当您进一步探索 async/await 关键字时，它们非常方便。记住以下几点。

*   await 运算符不能出现在 lock 语句的正文中。

*   您可能会在一个`async`方法的主体中看到多个`await`。在一个`async`方法中没有`await`不会引发任何编译时错误。相反，您会得到一个警告，并且该方法以同步方式执行。注意下面类似的警告:`Warning CS1998 This async method lacks 'await' operators and will run synchronously. Consider using the 'await' operator to await non-blocking API calls, or 'await Task.Run(...)' to do CPU-bound work on a background thread` `.`

## 最后的话

又一个大篇章！希望我能够揭开异步编程不同方法的神秘面纱。尽管在未来的开发中不再推荐使用`IAsyncResult`模式和`event-based asynchrony`,但我在本章中讨论了它们，以帮助您理解遗留代码，并向您展示异步程序的发展。毫无疑问，你将来会发现它很有用。

现在你已经准备好跳入异步编程的汪洋大海，探索剩下的边角案例了，没有自我实践是无法掌握的。所以，继续努力。

到目前为止，您已经看到了许多基于委托、事件和 lambda 表达式的应用程序！现在让我们进入最后一章，关于数据库编程。它有点不同，但非常有用和有趣。

## 摘要

本章讨论了以下关键问题。

*   什么是异步程序？它与同步程序有什么不同？

*   如何使用`Thread`类编写异步程序？

*   什么是线程池？如何使用`ThreadPool`类编写异步程序？

*   如何在异步程序中使用 lambda 表达式？

*   如何按照基于事件的异步模式编写异步程序？

*   什么是任务？如何在你的程序中使用`Task`类？

*   如何按照基于任务的异步模式编写异步程序？

*   如何使用`async/await`关键字编写一个异步程序？

*   你如何在你的应用程序中使用丢弃？

*   当你在程序中使用`async/await`关键字时，有哪些重要的限制？