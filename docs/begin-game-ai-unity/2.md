# 二、基础知识

正如 Edwin Abbott 在他的书 *Flatland* 中巧妙地解释的那样，现实是由许多维度构成的，根据你的感知技能，你只能看到其中的一部分并对其采取行动。在电子游戏中也是如此:电子游戏可以设置在 3D 或 2D 世界中，这种区别决定了代理人感知周围世界的方式，从而决定了他们移动和行动的能力。

N 维空间是一种几何设置，其中空间中的点由 N 个值或参数来标识，通常以字母表的最后几个字母命名。

在二维空间(2D 空间或平面)中，空间中的点由两个值定义，这两个值称为宽度和高度(通常称为 x 和 y)。你可以在 2D 空间中表现的对象是点、线以及所有的平面几何图形，如三角形、正方形、圆形等等(图 [2-1](#Fig1) )。

![img/491049_1_En_2_Chapter/491049_1_En_2_Fig1_HTML.jpg](img/491049_1_En_2_Chapter/491049_1_En_2_Fig1_HTML.jpg)

图 2-1

2D 空间有两个维度:宽度和高度

在三维空间(3D space)——也就是我们能够感知的空间——中，空间中的点由三个参数来标识:高度、宽度和深度，通常称为`x`、`y`、`z`。在 3D 空间中，您可以表示所有 2D 对象以及除了高度和宽度之外还具有第三维度:深度的所有对象。三维的几何物体有立方体、球体、金字塔，以及……嗯，基本上所有我们知道的宇宙中的物质(图 [2-2](#Fig2) )！

![img/491049_1_En_2_Chapter/491049_1_En_2_Fig2_HTML.jpg](img/491049_1_En_2_Chapter/491049_1_En_2_Fig2_HTML.jpg)

图 2-2

三维空间有三个维度:宽度、高度和深度

所以，正如我们所说的，根据空间的维数，你需要足够数量的值来标识空间中的一个点。这些值由矢量表示。

## 2.1 矢量

向量是在 N 维空间中由 N 个值定义的量，它有大小和方向。向量的大小基本上就是向量的大小，而方向就是它在空间中的方位(图 [2-3](#Fig3) )。

![img/491049_1_En_2_Chapter/491049_1_En_2_Fig3_HTML.jpg](img/491049_1_En_2_Chapter/491049_1_En_2_Fig3_HTML.jpg)

图 2-3

向量的基本表示

矢量的一个简单例子是加速度。假设你正以 50 km/h 的速度驾驶一辆汽车，如果你一直以 50 km/h 的速度行驶，加速度为 0km/h<sup>2</sup>；如果你再多踩一点油门，速度会以 5 公里/小时的速度增长 <sup>2</sup> 。这个加速度值是一个向量，方向等于汽车的方位，大小为 5 km/h <sup>2</sup> 。

所以，有了向量，我们可以追踪空间中的运动和作用力。例如，在电子游戏(2D 或 3D，无所谓)中，角色从一个点`A`移动到一个点`B`的运动由一个向量![$$ \overrightarrow{\mathtt{AB}} $$](img/491049_1_En_2_Chapter/491049_1_En_2_Chapter_TeX_IEq1.png)表示，该向量的大小`m = B-A`和方向等于从`A`到`B`的箭头的方向(图 [2-4](#Fig4) )。

![img/491049_1_En_2_Chapter/491049_1_En_2_Fig4_HTML.jpg](img/491049_1_En_2_Chapter/491049_1_En_2_Fig4_HTML.jpg)

图 2-4

箭头表示 2D 平台中角色的运动向量

在 Unity 中，向量使用特定的数据类型来表示。您可以使用`Vector2`定义一个 2D 矢量，使用`Vector3`定义一个 3D 矢量。

您可以使用它们的构造函数来声明它们，如下所示:

```cs
Vector2 my2DVector = new Vector2(x, y);
Vector3 my3DVector = new Vector3(x, y, z);

```

向量是 N-空间中所有运算的核心，无论是线性代数还是 Unity。例如，对象的位置由 3D 向量及其比例值表示。这两个值可以通过向量运算来修改。让我们快速看一下向量最重要的操作以及它们在视频游戏环境中的意义。

### 添加

如图 [2-5](#Fig5) 所示，相同类型的两个向量(例如两个 3D 向量)之间的相加是通过计算两个向量的分量之和来实现的。

![img/491049_1_En_2_Chapter/491049_1_En_2_Fig5_HTML.jpg](img/491049_1_En_2_Chapter/491049_1_En_2_Fig5_HTML.jpg)

图 2-5

两个向量 A 和 B 之和的图形表示

因此，举例来说，如果你想对两个向量`[1, 2, 3]`和`[4, 5, 6]`求和，你只需计算出结果向量`[1+4, 2+5, 3+6]`，也就是`[5, 7, 9]`。

由于一个矢量可以表示空间中的一个点，所以两个矢量之和用来表示从该点到空间中一个新点的运动。所以，基本上，当你把一个矢量`A`和一个矢量`B`相加时，矢量`A`将是起点，矢量`B`是引导你到新的点`C = A+B`的偏移量。

在 Unity 中，您可以使用`+`(加号)运算符对两个向量求和，如下所示:

```cs
Vector3 result = new Vector3(1,2,3) + new Vector3(4,5,6);

```

### 减法

两个向量之间的减法非常类似于加法。唯一不同的是二次元的方向反了。

例如，如果你想计算一个向量`A = [4,5,6]`和一个向量`B = [1,2,3]`之间的差，你必须计算得到的向量`C = A - B = [4,5,6] - [1,2,3] = [4,5,6] + [-1,-2,-3] = [4-1, 5-2, 6-3] = [3, 3, 3`。

两个向量之间的减法用于找出它们之间的差，在空间上下文中，差表示由两个向量表示的两点之间的距离。

在 Unity 中，您可以使用-(减号)运算符减去两个向量，如下所示:

```cs
Vector3 result = new Vector3(4,5,6) - new Vector(1,2,3);

```

### 标量乘法

我们说过，矢量有大小和方向。幅度是矢量的长度。

为了计算矢量`V = [ a, b, c ]`的幅度|V|,我们应用以下公式:

|V| = ![$$ \sqrt{{\mathtt{a}}^{\mathtt{2}}+{\mathtt{b}}^{\mathtt{2}}+{\mathtt{c}}^{\mathtt{2}}\ } $$](img/491049_1_En_2_Chapter/491049_1_En_2_Chapter_TeX_IEq2.png)

您可以通过将向量的所有值乘以或除以所需的量来更改向量的大小。图 [2-6](#Fig6) 显示了向量上标量乘法的图形表示。

![img/491049_1_En_2_Chapter/491049_1_En_2_Fig6_HTML.jpg](img/491049_1_En_2_Chapter/491049_1_En_2_Fig6_HTML.jpg)

图 2-6

向量上标量乘法的图形表示

例如，如果你想将向量`V = [1, 2, 3]`的大小乘以一个标量值`x = 2`，你可以将`V`的每个元素乘以`x`，就像这样:`V*x = [1*2, 2*2, 3*2] = [2, 4, 6]`。

类似地，如果你想用一个标量值`x = 2`来减少一个向量`W = [2, 4, 6]`的大小，你可以用`x`来除`W`的每个元素，就像这样:`W/x = [2/2, 4/2, 6/2] = [1, 2, 3]`。

### 点积

向量的另一个重要运算是点积。这是一个代数运算，你可以对两个向量进行运算来得到一个标量值。两个向量点积的结果是它们所面对的方向之差。

通常，点积应用于归一化向量，即长度为 1 的向量。这是因为当我们想要计算两个向量的方向之差时，我们并不太关心它们的长度，而只关心它们的方向。

当您将点积应用于一对归一化向量时，结果包含在`1`和`-1`之间的范围内。如果得到的值是`1`，两个向量面向同一个方向；如果是`0`，它们是垂直的；如果是`-1`，他们面向相反的方向(图 [2-7](#Fig7) )。

![img/491049_1_En_2_Chapter/491049_1_En_2_Fig7_HTML.jpg](img/491049_1_En_2_Chapter/491049_1_En_2_Fig7_HTML.jpg)

图 2-7

点积对于计算 3D 空间中的亮度值非常有用

点积的一个实际应用是根据光源的位置计算表面的亮度。设`L`为光线矢量，表示光源的位置和方向，`N`为表示一个曲面的法向量的矢量(指垂直于一个曲面的矢量)。计算`B = L dot N`会给我们`B`一个浮点数，代表表面的亮度，其中`N`是法向量，小于或等于`0`的值表示黑暗，`1`表示最大亮度。

在 Unity 中，您可以使用 Vector3 的点函数来计算我们在前面的示例中提到的两个向量`L`和`N`的点积，如下所示:

```cs
float B = Vector3.Dot(N, L);

```

## 2.2 第一个项目！

之前，我们说过向量是如何用来表示位置和方向的。让我们用 Unity 来实践这一点吧！

打开 Unity，点击新建按钮创建一个新项目(图 [2-8](#Fig8) )。

![img/491049_1_En_2_Chapter/491049_1_En_2_Fig8_HTML.jpg](img/491049_1_En_2_Chapter/491049_1_En_2_Fig8_HTML.jpg)

图 2-8

在 Unity Hub 中创建新项目

从模板列表中选择 3D 项目模板，并为您的新项目选择一个名称和文件夹，如图 [2-9](#Fig9) 所示，然后点击`Create`。

![img/491049_1_En_2_Chapter/491049_1_En_2_Fig9_HTML.jpg](img/491049_1_En_2_Chapter/491049_1_En_2_Fig9_HTML.jpg)

图 2-9

在 Unity Hub 中创建 3D 项目

Unity 将在几秒钟内为您建立一个项目。

创建项目时，您将看到经典布局，其中不同部分专用于项目的不同部分。下面就来探究一下主要的！以下列表参照图 [2-10](#Fig10) 和 [2-11](#Fig11) :

![img/491049_1_En_2_Chapter/491049_1_En_2_Fig11_HTML.jpg](img/491049_1_En_2_Chapter/491049_1_En_2_Fig11_HTML.jpg)

图 2-11

该图显示了 Unity 编辑器 UI 的一些重要部分(在前面的编号列表中可以找到解释)

![img/491049_1_En_2_Chapter/491049_1_En_2_Fig10_HTML.jpg](img/491049_1_En_2_Chapter/491049_1_En_2_Fig10_HTML.jpg)

图 2-10

该图显示了 Unity 编辑器 UI 的一些重要部分(在前面的编号列表中可以找到解释)

1.  **工具栏**:它可以让你访问一些基本的功能，比如操作场景视图和其中的游戏对象的工具，运行和停止游戏的按钮以及调试游戏的步骤按钮，访问云服务和版本控制功能的按钮。

2.  **层次窗口**:显示当前场景中所有对象的列表。从“层次”面板中，您可以通过检查器访问每个对象并修改它们的属性。

3.  **检查器窗口**:检查器向您显示与当前选择的资产相关的所有详细信息。此窗口没有标准视图，因为不同种类的资产具有不同种类的属性。

4.  **项目窗口**:它基本上是一个资产浏览器，显示并列出与您的项目相关的所有资产。随着新资产的创建，它们将显示在项目窗口中。

5.  **场景视图**:显示选中的场景，允许你浏览和编辑其中的游戏对象。通过选择相应的按钮，可以在 3D 或 2D 模式下与场景视图中的场景进行交互。

6.  游戏视图(Game View):它可以让你看到你最终渲染的游戏是什么样子。按下播放按钮，您可以在此视图中开始游戏。

7.  **控制台窗口**:显示由 Unity 生成的错误、警告和其他信息，或由程序员使用调试程序创建的自定义信息。日志，调试。日志警告和调试。LogError 函数。

### 2.2.1 第一现场！

在我们的第一个项目中，我们希望通过创建一个允许我们通过修改对象的位置向量来移动对象的应用来探索向量的基础。该应用将包括一个简单的立方体上的平面。使用鼠标，我们可以点击平面的不同部分，并通过修改立方体的位置向量来改变立方体的位置。

可以想象，3D 对象在 3D 空间中是由它们顶点的 3D 位置向量定义的。不过，在 Unity 中，为了简单起见，我们只需要修改一个称为轴心点的向量。枢轴点是与表示其在 3D 空间中的位置的对象相关联的向量。

所以，让我们从添加一些 3D 物体到我们的起始场景开始。

右键单击层次或资产面板，并从上下文菜单中选择`3D Object` ➤ `Plane`。这将在场景中创建一个平面。

现在，我们想改变我们的平面的位置，这样我们就可以让它正好在场景的中心。要做到这一点，我们需要修改枢轴点，正如我们刚才所说，这是一个三维向量。左键单击层次窗口中的平面，对象的信息和属性将显示在检查器面板中。找到**转换**段，将`x`、`y`、`z`属性改为`x = 0`、`y = 0`、`z = 0`。这将在场景的原点捕捉我们的平面(图 [2-12](#Fig12) )。

![img/491049_1_En_2_Chapter/491049_1_En_2_Fig12_HTML.jpg](img/491049_1_En_2_Chapter/491049_1_En_2_Fig12_HTML.jpg)

图 2-12

在检查器中看到的平面对象

Tip

原点是任意 N 空间的点 0。在 2D 空间的情况下，像笛卡尔平面一样，原点在位置`x = 0`、`y = 0`。在 3D 空间中，就像我们在 Unity 中的场景一样，它位于`x = 0`、`y = 0`、`z = 0`的位置。

现在用同样的方法创建一个立方体，右击“资产”或“层次”面板并选择`3D object` ➤ `cube`。通过在“层次”窗口中左键单击立方体来选择它，使其属性列在检查器页面中。在这里，将变换位置部分的`x`、`y`和`z`属性的值更改为`x = 0`、`y = 0.3`和`z = 0`(图 [2-13](#Fig13) )。

![img/491049_1_En_2_Chapter/491049_1_En_2_Fig13_HTML.jpg](img/491049_1_En_2_Chapter/491049_1_En_2_Fig13_HTML.jpg)

图 2-13

在检查器中看到的立方体对象

现在我们已经有了 3D 物体，我们唯一需要的就是一个好的视角！游戏中的可视场景是由`Camera`对象定义的，它是一个由许多属性组成的`GameObject`，允许你从不同的视角和不同的图形设置来展示你的游戏世界。无论如何，我们不会在这方面陷得太深，因为这会使我们远离本书的范围。我们唯一需要知道的是，`Camera`允许我们定义我们能看到什么以及如何看到。同样，摄像机的位置是由一个我们需要修改的向量定义的。

在层次窗口中选择`Main Camera`对象，导航到检查器的变换位置部分，将其`x`、`y`、`z`属性更改为`x = 0`、`y = 4`、`z = 0`。在检查器中，定位`Transform Rotation`属性，将`x`、`y`和`z`设置为`x = 90`、`y = 0`和`z = 0`(图 [2-14](#Fig14) )。

![img/491049_1_En_2_Chapter/491049_1_En_2_Fig14_HTML.jpg](img/491049_1_En_2_Chapter/491049_1_En_2_Fig14_HTML.jpg)

图 2-14

在检查器中看到的主摄像机

好了，现在场景完成了！我们让摄像机俯视立方体位于其中心的平面。我们现在需要添加功能，使立方体移动到鼠标指向的不同位置。我们可以使用 C#脚本来做到这一点。让我们看看如何！

### 2.2.2 第一个剧本！

如你所知，如果你已经使用过 Unity，脚本是通过编写脚本文件并将它们分配给对象来实现的。每个脚本都可以实现标准函数，这些函数定义了执行动作的时刻。我们要做的是不断检查鼠标的位置，如果用户点击，我们希望立方体移动到这些坐标。

通过右键单击项目窗口并选择`Create` ➤ `C# Script`来创建脚本。将剧本重命名为`Move`。现在双击脚本打开文本编辑器，开始编写代码。

您刚刚创建的脚本将包含以下模板代码:

```cs
 1\.   using System.Collections;
 2\.   using System.Collections.Generic;
 3\.   using UnityEngine;
 4
 5   public class Move : MonoBehaviour
 6   {
 7       // Start is called before the first frame update
 8       void Start()
 9       {
10
11       }
12
13       // Update is called once per frame
14       void Update()
15       {
16
17       }
18   }

```

**第 1–3 行**只是包含一些库和模块的行。有趣的部分紧接着开始:一个新的具有文件名的类被声明继承自类`MonoBehaviour` ( **第 5 行**)；这允许我们覆盖一些有用的方法，比如每次游戏开始时调用的`Start` ( **line 8** )和每帧调用的`Update` ( **line 14** )。我们可以去掉`Start`功能，因为我们不会使用它。

计划是等待用户单击空间中的一个点，然后读取鼠标光标的坐标，并将立方体移动到这些坐标。为此，我们将利用`raycasting`技术，该技术在 Unity 中被广泛用于许多目的。每一帧，我们都会从相机到鼠标位置投一个`ray`，当用户点击时，我们会计算光线与 3D 平面碰撞的位置，并将立方体移动到那个位置。

首先要做的是将我们刚刚创建的脚本分配给立方体对象，因此在层次窗口中找到该对象，并通过单击它来选择它。该对象的属性将显示在检查器中。现在拖动移动脚本并将其放在显示立方体属性的层次窗口中。就这样！现在，您的脚本与该对象相关联(图 [2-15](#Fig15) )。

![img/491049_1_En_2_Chapter/491049_1_En_2_Fig15_HTML.jpg](img/491049_1_En_2_Chapter/491049_1_En_2_Fig15_HTML.jpg)

图 2-15

检查器中显示的立方体对象，其中列出了它的所有设置

既然脚本与多维数据集相关联，我们可以开始修改它并添加功能。双击脚本，在您喜欢的编辑器/IDE 中打开它，并用以下代码替换内容:

```cs
 1\.   using UnityEngine;
 2.
 3\.   public class Move : MonoBehaviour
 4\.   {
 5\.       private void Update()
 6\.       {
 7\.           RaycastHit hit;
 8\.           Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
 9\.           if (Physics.Raycast(ray, out hit) && Input.GetMouseButtonDown(0))
10\.           {
11\.               Vector3 newPosition = new Vector3(hit.point.x, this.transform.position.y, hit.point.z);
12\.               this.transform.position = newPosition;
13\.               Debug.Log("Current position vector: " + newPosition.ToString());
14\.           }
15\.       }
16\.   }

```

这是添加我们谈到的功能的完整代码；还是更好的分析一下吧！

我们已经看到了文件的结构，以及 using 语句和类声明。我们不需要`Start`方法，所以我们可以去掉它。我们将只需要`Update`方法；让我们看看如何！

在**的第 7 行**，我们声明了`RaycastHit`类型的`hit`变量。这是一个用于从`ray`与`Collider`的碰撞中获取信息的结构。

这个想法是当用户点击鼠标时，从相机向光标的坐标投射光线。光线和第一个碰撞器之间的碰撞点——在本例中，是 3D 平面的碰撞器——将存储在`hit`变量中。这将允许我们计算我们想要立方体移动到的位置。

在**的第 8 行**，我们创建了`Ray`类型的`ray`变量:这是我们要通过函数`ScreenPointToRay`将鼠标在向量`Input.mousePosition`中的位置作为参数从相机射到鼠标位置的实际光线。

在**第 9 行**，我们调用`Physics.Raycast(ray, out hit)`函数将光线从相机投射到鼠标位置。如果射线击中了碰撞器，该函数返回`true`，击中的位置存储在我们传递给该函数的`hit`变量中。在同一行中，我们还调用了`Input.GetMouseButtonDown(0)`函数，如果按下索引为`0`的鼠标按钮，该函数将返回`true`。可以想象，默认情况下，索引为`0`的鼠标是一级按钮:左键；右边的按钮标记为`1`，中间的按钮标记为`2`。我们使用 AND 操作符将这两个函数调用放在一起。；如果两者都返回 true，我们执行从**第 11 行到第 13 行**的指令。

在**第 11 行**，我们使用在`hit`变量中找到的`x`和`z`坐标创建新的位置向量(光线击中 3D 平面碰撞器的坐标),对于`y`坐标，我们使用立方体对象的坐标，这样我们可以保持它在相同的高度。

在**第 12 行**，我们将位置向量分配给当前对象的位置，在**第 13 行**我们使用`Debug.Log`函数将该信息打印到调试控制台，只是为了查看位置向量值的变化。

现在我们有了第一个脚本，我们可以玩游戏并测试它了。按下播放按钮编译并运行游戏。你将看到场景和立方体在中心(图 [2-16](#Fig16) )。单击 3D 平面中的任意位置，将立方体移动到那里。

![img/491049_1_En_2_Chapter/491049_1_En_2_Fig16_HTML.jpg](img/491049_1_En_2_Chapter/491049_1_En_2_Fig16_HTML.jpg)

图 2-16

玩游戏时，你将从中心的立方体开始。当你点击一个点时，立方体将移动到那里

现在我们已经在实践中探索了一些向量，让我们更进一步。让立方体朝着我们点击的点移动，而不是仅仅传送到那里，这将是很好的。让我们看看我们如何能做到这一点。

### 2.2.3 向一个点移动

在上一节中，我们设法通过单击鼠标将立方体立即移动到我们选择的某个位置。我们在这一部分想要实现的是，在一定的时间内，将它逐渐向选定的点移动。基本的区别在于，物体不是一次移动到那个点，而是向目标位置迈出几小步。

我们想在一定的时间跨度内重建从一点`A`到一点`B`的空间运动概念；为此，我们可以使用**几何平移**的概念。

几何平移是将图形或空间的所有点向同一方向移动的几何变换。这种运动是通过在图形的每一点上加上一个恒定的矢量来实现的；这个恒定矢量就是运动矢量，它定义了我们想要到达的空间点。

在 Unity 中，我们有 Transform 类的 Translate 方法，它实现了几何平移的概念。Unity 场景中的每个对象都有一个变换，允许存储和操作对象的位置、旋转和缩放。

我们可以用这样的运动矢量统一平移一个物体:

```cs
myObject.transform.Translate(myMovementVector);

```

运动矢量是我们希望物体在某个方向上移动的空间量。我们希望对象在每一个时间间隔内都要遍历将它与目标分开的一小部分空间，但是我们如何计算对象每秒应该遍历多少空间呢？

在物理学中，以一定速度运动的物体在一个时间间隔内走过的平均空间称为δ`s`(δ空间)，用下面的公式描述:

Δs = v <sub>m</sub> * Δt

其中`v` <sub>`m`</sub> 是物体移动的平均速度，δ`t`是物体移动量δ`s`(我们要计算的量)的时间量。

所以如果我们的运动矢量是δ`s`，要计算它，我们只需要把平均速度乘以时间间隔。

我们想要移动物体的**速度**是一个我们可以虚构的任意量。我将选择值 1，这意味着物体将以每秒 1 个单位的速度移动。

对于时间间隔δ`t`，Unity 向我们提供了一个值，该值已经准备好了该信息。这是`Time.deltaTime`，是上一帧的帧时间和当前帧的帧时间之差。

Note

帧时间是渲染一帧所需的时间。它是一个浮点值，可以根据要渲染的场景的复杂程度而逐帧变化。当然，不稳定的平均帧时间值(意味着每一帧的所有帧时间之间的平均值)是糟糕性能的征兆，因为它可能会导致口吃，破坏玩家的体验。

`Time.deltaTime`以秒表示；这意味着它也帮助我们将运动表示为以速度`v` <sub>`m`</sub> 每秒穿越的空间量。

我们可以把这个概念用于我们的运动矢量，就像这样:

```cs
myObject.transform.Translate(0, 0, speed * Time.deltaTime);

```

我们申请转型。平移一个向量`[0, 0, speed * Time.deltaTime]`，因为我们希望对象向前移动。

我们只需要一点点！既然我们在向前移动我们的对象，我们也需要让它转向新的位置。为此，Unity 在 transform 类中提供了一个非常方便的函数:LookAt。我们可以很容易地使用 LookAt，就像这样:

```cs
this.transform.LookAt(positionToLookAt);

```

其中 positionToLookAt 是一个 Vector3，表示我们希望对象转向的空间点。

让我们看看如何将这些新信息应用到我们的代码中:

```cs
 1\.   using UnityEngine;
 2\.   using System.Collections;
 3.
 4\.   public class Move : MonoBehaviour
 5\.   {
 6\.       Vector3 goal;
 7\.       float speed = 1.0f;
 8\.       float accuracy = 1.0f;
 9.
10\.       void Start()
11\.       {
12\.           goal = this.transform.position;
13\.       }
14.
15\.       void Update()
16\.       {
17\.           RaycastHit hit;
18\.           Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
19.
20\.           if(Physics.Raycast(ray, out hit) && Input.GetMouseButtonDown(0))
21\.           {
22\.               goal = new Vector3(hit.point.x, this.transform.position.y, hit.point.z);
23\.           }
24.
25\.           this.transform.LookAt(goal);
26\.           if(Vector3.Distance(transform.position, goal) > accuracy)
27\.           {
28\.               this.transform.Translate(0,0, speed*Time.deltaTime);
29\.           }
30\.       }
31\.   }

```

在**的第 6–8 行**，我们定义了我们将在后面的代码中使用的变量来定义目标位置、移动速度和精确度。精度是一个偏移值，我们需要它来避免对象不断地做微小的运动，而是使用一种更近似的运动。这意味着，如果物体足够接近该点，它将停止，这种近似的精度由`accuracy`变量表示。

我们恢复了`Start`方法，并使用它来初始化目标向量，该向量在开始时存储对象的当前位置(**第 10–13 行**)。

我们已经看到，我们需要创建在`Physics.Raycast`方法(**第 20 行**)中使用的`hit`和`ray`变量(**第 17–18 行**)。单击鼠标左键时，我们将使用从`hit`变量中获取的坐标设置目标 3D 矢量，但保持当前的 y 坐标(**第 20–23 行**)。

在**线 25** 处，我们将物体转向面对我们想要到达的新位置，如果物体与目标之间的距离大于我们设定的精度值(**线 26** ，我们使用`Translate`方法以我们定义的速度将物体移向目标(**线 28** )。

保存代码并按下播放按钮进行测试！现在，当您单击 3D 平面上的某个点时，立方体将一点一点地(取决于您设置的速度)向您单击的点移动。

在这里，你刚刚创建了你的第一个 NPC 走向一个点！

我们想更进一步，让我们的立方体逐渐向目标旋转，就像我们在实际运动中所做的那样。这个概念被称为*转向*，它在游戏中非常常用来模拟物体的自然旋转。让我们看看它是如何工作的！

### 转向行为

转向行为对于几乎每一种游戏都是非常重要的，尤其是对于像汽车游戏这样的模拟游戏，它们通常使用线性插值的概念来实现。不用深入数学，两点`A`和`B`之间的线性插值计算出从点`A`到点`B`的点。这个概念可以应用于从 A 点到 B 点的空间遍历，以及将对象从角度旋转到角度β。

有两种非常流行的技术来实现线性插值以旋转对象:

*   线性插值

*   球形线性插值

两者的主要区别在于，Lerp 使用恒定速度移动对象，而 Slerp 使用可变速度来移动对象。这个变速基本上就是物体开始移动后逐渐加速，然后在接近目标时逐渐减速的效果。

在 Unity 中，我们可以使用 Slerp 和`Quaternion.Slerp`方法，如下所示:

```cs
Quaternion.Slerp(startingRotation, goalRotation, rotationSpeed);

```

该函数返回以速度`rotationSpeed`从`startingRotation`转到`goalRotation`所需旋转的一小部分。我们的`startingRotation`将是立方体当前旋转角度的值，而`goalRotation`必须使用静态类`Quaternion`中的方法`LookRotation`来计算。例如，如果我们想计算旋转角度以转向我们的目标位置的方向，我们会这样做:

```cs
Vector3 direction = goal - this.transform.position;
goalRotation = Quaternion.LookRotation(direction);

```

这看起来很简单，是吗？让我们在我们的脚本中使用它！

打开`Move.cs`让我们做一些修改！首先声明一个名为`rotSpeed`的`float`变量来定义物体的旋转速度，就在`goal`、`speed`和`accuracy`的声明下:

```cs
float rotSpeed = 2f;

```

然后，删除`LookAt`行，用这两行替换:

```cs
Vector3 direction = goal - this.transform.position;
this.transform.rotation = Quaternion.Slerp(this.transform.rotation, Quaternion.LookRotation(direction), Time.deltaTime*rotSpeed);

```

这里，我们声明了一个`direction`向量，它告诉我们目标相对于立方体当前位置的距离和方向；然后我们使用这个信息通过`LookRotation`方法计算旋转角度，我们将这个信息连同当前立方体的旋转值和旋转速度乘以时间增量一起传递给`Slerp`方法。

该脚本现在应该如下所示:

```cs
 1\.   using UnityEngine;
 2\.   using System.Collections;
 3.
 4\.   public class Move : MonoBehaviour
 5\.   {
 6\.       Vector3 goal;
 7\.       float speed = 1.0f;
 8\.       float accuracy = 0.5f;
 9\.       float rotSpeed = 2f;
10.
11\.       void Start()
12\.       {
13\.           goal = this.transform.position;
14\.       }
15.
16\.       void Update()
17\.       {
18\.           RaycastHit hit;
19\.           Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
20.
21\.           if(Physics.Raycast(ray, out hit) && Input.GetMouseButtonDown(0))
22\.           {
23\.               goal = new Vector3(hit.point.x, this.transform.position.y, hit.point.z);
24\.           }
25.
26\.           Vector3 direction = goal - this.transform.position;
27.
28\.           if (Vector3.Distance(transform.position, goal) > accuracy)
29\.           {
30\.               this.transform.rotation = Quaternion.Slerp(this.transform.rotation, Quaternion.LookRotation(direction), Time.deltaTime * rotSpeed);
31\.               this.transform.Translate(0,0, speed*Time.deltaTime);
32\.           }
33\.       }
34\.   }

```

再一次，让我们保存脚本并按播放！你会看到现在立方体在前进的同时会逐渐向目标点旋转。

干得好！您刚刚创建了第一个也是最基本的算法，将一个对象从点`A`移动到点`B`！这是接下来的重要基础:寻路！

在下一章中，我们将学习寻路的基础，让我们的小立方体找到通往目标的路，即使有障碍和没有明显的路径。

## 2.3 考考你的知识！

1.  什么是 2D 空间？

2.  2D 空间中的点是如何定义的？

3.  什么是 3D 空间？

4.  3D 空间中的点是如何定义的？

5.  什么是向量？

6.  2D 和 3D 矢量有什么区别？

7.  向量在电子游戏中有哪些可能的应用？

8.  向量和是如何工作的？

9.  向量减法是如何工作的？

10.  什么是标量乘法？它是如何工作的？

11.  什么是点积？它是如何工作的？你如何在电子游戏中使用它？

12.  什么是几何平移？你怎么能在电子游戏中使用它呢？

13.  解释转向行为的概念。为什么重要？

14.  如何在 Unity 中实现转向行为？

15.  分析我们刚刚为这一章的项目写的代码，找出所有我们使用(或者 Unity 可能在幕后使用)我们刚刚学到的向量运算的地方。