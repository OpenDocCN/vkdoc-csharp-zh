# 五、组装螺母和螺栓

到目前为止，我们已经了解了很多关于 Unity 提供的构建游戏的工具，现在我们将开始把它们放在一起。在这一章中，我们将为玩家、敌人和游戏中可能出现的任何其他角色构建 C# 类结构。我们还将创建一些玩家可以捡起的预设，包括硬币和电源，并学习如何指定我们的游戏逻辑关心和不关心哪些对象碰撞。我们将回顾一个重要的 Unity 专用工具，称为脚本化对象，以及利用它们来构建一个干净的、可扩展的游戏架构的技巧。

## 字符类

在这一部分，我们将为游戏中每个角色、敌人或玩家的职业结构打下基础。在我们的游戏中，每个“活着的”角色都会有一些特征，比如健康的概念。

生命值或“生命值”被用来衡量一个角色在死亡前所能承受的伤害。生命值是过去桌面战争游戏的延续术语，但是现在各种类型的游戏都有生命值或生命值的概念。

在图 [5-1](#Fig1) 中，一张由这个庞然大物开发的游戏*城堡毁灭者*的截图，展示了有多少游戏选择在视觉上表现一个角色剩余的生命值。这个截屏展示了一个常见的技术:在屏幕顶部的每个角色名字下面有一个红色的生命值或生命值条。

![img/464283_1_En_5_Chapter/464283_1_En_5_Fig1_HTML.jpg](img/464283_1_En_5_Chapter/464283_1_En_5_Fig1_HTML.jpg)

图 5-1

生命值在屏幕顶部显示为不同长度的红色条

现在，我们只是记录生命值，但最终我们会建立自己的生命值栏来直观地显示玩家的剩余生命值。

在名为 MonoBehaviours 的脚本下创建一个新文件夹。因为我们将创建更多的 MonoBehaviours，所以为他们提供自己的文件夹是有意义的。将 MovementController 脚本移动到此文件夹中，因为它继承自 MonoBehaviour。

在 MonoBehaviours 文件夹中，创建一个名为 Character 的新 C# 脚本。双击角色脚本在我们的编辑器中打开它。

我们将建立一个普通的角色类，我们的玩家和敌人都将继承它。这个角色类将包含我们游戏中所有角色类型共有的功能和属性。

输入以下代码，完成后不要忘记保存。像往常一样，不要输入行注释。

```cs
using UnityEngine;

// 1
public abstract class Character : MonoBehaviour {

// 2
    public int hitPoints;
    public int maxHitPoints;
}

```

```cs
// 1

```

我们将在 C# 中使用 Abstract 修饰符来表示这个类不能被实例化，必须由子类继承。

```cs
// 2

```

跟踪字符当前的`hitPoints`以及最大数量的`hit-points`。一个角色的“健康”程度是有限的。

完成后，请务必保存该脚本。

## 玩家等级

接下来我们将创建基本的玩家类。在我们的 MonoBehaviours 文件夹中，创建一个名为 Player 的新 C# 脚本。这个玩家类一开始会非常简单，但是我们会随着时间的推移添加一些功能。

输入以下代码。我们已经删除了`Start()`和`Update()`函数。

```cs
  using UnityEngine;

  // 1
  public class Player : Character
  {
    // Empty, for now.
  }

```

```cs
// 1

```

我们现在想做的就是从`Character`类继承来获得类似`hitPoints`的属性。

保存脚本，然后切换回 Unity 编辑器。

选择玩家预设。将玩家脚本拖放到玩家对象中，并设置其属性，如图 [5-2](#Fig2) 所示。给玩家 5 点生命值和 10 点最大生命值。

![img/464283_1_En_5_Chapter/464283_1_En_5_Fig2_HTML.jpg](img/464283_1_En_5_Chapter/464283_1_En_5_Fig2_HTML.jpg)

图 5-2

配置我们的玩家脚本

我们开始时玩家的生命值低于他们的最大生命值，因为在本章的后面，我们将建立一个功能，玩家可以获得心脏能量来增加他们的生命值。

## 专注于预设

对于我们的冒险家来说，生活并不全是娱乐和游戏，即使是无畏的英雄也需要以某种方式谋生。让我们在场景中创建一些硬币让她捡起来。

从本书的下载游戏资产文件夹中，选择标题为“hearts-and-coins s32x 32 . png”的 spritesheet，它听起来完全像 20 世纪 80 年代的魅力摇滚金属乐队，并将其拖到资产➤ Sprites ➤对象文件夹中。

检查器中的导入设置应设定为以下内容:

*   纹理类型:精灵(2D 和用户界面)

*   精灵模式:多重

*   每单位像素:32

*   过滤器模式:点(无过滤器)

*   确保选择底部的默认按钮，并将压缩设置为:无

按下应用按钮，然后打开精灵编辑器。

从“切片”菜单中，选择“按单元格大小划分网格”,并将像素大小设置为宽度:32，高度:32。按下应用并关闭精灵编辑器。

### 创建一个硬币预置

在这一部分，我们将创建硬币预置本身。

在项目视图中创建一个新的游戏对象，并将其重命名为 CoinObject。从切片的心形硬币火焰精灵中选择四个单独的硬币精灵，并将其拖动到硬币对象上，以创建一个新的动画。按照第三章中我们创建玩家和敌人动画的相同步骤。重命名动画剪辑为“硬币旋转”，并将其保存到动画➤动画文件夹。将生成的控制器重命名为“CoinController ”,并将其移动到 Controllers 文件夹中。

在精灵渲染器组件中，单击“精灵”表单旁边的小圆点，并选择在场景视图中预览该组件时使用的精灵。

通过选择 Sprite 渲染器组件中的排序层下拉菜单创建一个新的排序层，单击“添加排序层”，然后在地面和字符层之间添加一个名为“对象”的新层。

再次选择 CoinObject，将其排序图层设置为:Objects。

为了允许玩家捡起硬币，我们需要配置 CoinObject 的两个方面:

1.  检测玩家与硬币碰撞的方法

2.  硬币上的定制标签，表示可以被取走

### 建立环形对撞机 2D

再次选择 CoinObject 并添加一个圆形碰撞器 2D 组件。圆形碰撞器 2D 是一种原始的碰撞器，我们可以用它来检测玩家何时撞上硬币。将圆形碰撞器 2D 的半径设置为:0.17，这样它和精灵的大小差不多。

我们要写的脚本逻辑要求玩家穿过硬币捡起它。为了做到这一点，我们将使用圆形对撞机 2D 有点不同于我们使用其他对撞机。如果我们简单地给硬币对象添加一个圆形碰撞器 2D，玩家将无法穿过它。我们希望 CoinObject 上的圆形碰撞器 2D 充当某种“触发器”,并在另一个碰撞器与之交互时进行检测。我们不希望环形对撞机 2D 阻止其他对撞机穿过它。

要使用圆形对撞机 2D 作为触发器，我们需要确保“是触发器”属性被选中，如图 [5-3](#Fig3) 所示。

![img/464283_1_En_5_Chapter/464283_1_En_5_Fig3_HTML.jpg](img/464283_1_En_5_Chapter/464283_1_En_5_Fig3_HTML.jpg)

图 5-3

选中圆形碰撞器上的触发框

### 设置自定义标签

我们还想向 CoinObject 添加一个标记，脚本可以用它来检测是否可以拾取另一个对象。

让我们从标签和层菜单中创建一个新标签，名为“CanBePickedUp”:

1.  从项目视图中选择 CoinObject

2.  在检查器的左上方，从“标签”菜单中选择“添加标签”。

3.  创建 CanBePickedUp 标记

4.  再次选择 CoinObject 并将其标签设置为:CanBePickedUp

我们准备好创建预制品了。

通过将 CoinObject 拖动到 prefabs 文件夹中来创建一个预置。创建预设后，可以从项目视图中删除 CoinObject。

总之，创建一个可交互的预置的步骤是:

1.  创建一个游戏对象并重新命名。

2.  为预设动画添加精灵。这将把一个精灵渲染器组件附加到游戏对象上。

3.  设置预设的精灵属性。这个精灵将被用来代表场景中的预设。

4.  设置排序层，使预设可见并以正确的顺序渲染。

5.  添加一个适合精灵形状的碰撞器 2D 组件。

6.  根据你创建的预设类型，set:是碰撞器的触发器。

7.  创建名为 CanBePickedUp 的标记，并将对象的标记设置为 CanBePickedUp。

8.  如果需要，请更改图层。

9.  将游戏对象拖到预设文件夹中作为预设使用。

10.  从层级视图中删除原始游戏对象。

### 小费

拖放一个硬币预置到场景中，然后选择它。取消硬币预设上的触发框。请注意文本“Is Trigger”是如何变成粗体蓝色的。这是 Unity 提醒我们的方式，这个值只在预置的这个实例上被改变。如果我们想为预设的所有实例保存此设置，请按检查器右上角的“应用”按钮。确保完成后检查是否触发，这样硬币预设才能正常工作。

## 基于层的碰撞检测

我们想让我们的角色扮演游戏中的玩家能够通过走进硬币来捡起硬币。我们的游戏也会有敌人在地图上走来走去，但是我们希望敌人直接走过硬币而不要捡起来。

正如我们在第三章中讨论的，层被用来定义游戏对象的集合。连接到同一层上的游戏对象的碰撞器组件将会知道彼此并且可以交互。我们可以根据这些交互创建逻辑来做一些事情，比如拿起物体。

还有一种技术可以让不同层上的碰撞器组件相互感知。这种方法使用一种称为**的统一特性，基于层的碰撞检测**。

我们将使用这个特性，这样玩家和硬币碰撞器，尽管在不同的层上，也能互相感知。我们还会配置一些东西，让敌人的对撞机不知道硬币，因为他们不能捡起它们。如果两个对撞机彼此不了解，它们就不会相互作用。敌人会直接穿过硬币而不会捡起来。

要看到这个功能的运行，首先我们需要创建层并分配给相关的游戏对象。

我们在第 3 章中学习了如何创建新层，但是如果你需要复习:

1.  在层次中选择 CoinObject

2.  在检查器中，选择“层”下拉菜单

3.  选择:“添加层”

4.  创建一个新的层称为:“消耗品”

5.  创建另一层称为:“敌人”

消耗品层将用于诸如硬币、心脏和其他我们希望玩家消费的物品。敌人层将用于:你猜对了-敌人。

创建两个新层后，检查员应该如图 [5-4](#Fig4) 所示。

![img/464283_1_En_5_Chapter/464283_1_En_5_Fig4_HTML.jpg](img/464283_1_En_5_Chapter/464283_1_En_5_Fig4_HTML.jpg)

图 5-4

添加敌人层

去编辑菜单➤项目设置➤物理二维。查看 Physics2DSettings 视图底部的**层碰撞矩阵**。在这里，我们将配置图层，让敌人可以直接穿过硬币、电源和我们选择的任何东西。

通过选中和取消选中一列和一行交叉处的框，我们可以配置哪些层相互了解并将进行交互。如果选中两个层相交处的框，不同层的对象上的碰撞器可以交互。

我们想配置玩家和硬币对象，这样他们的碰撞器就能互相感知。我们希望敌人的对撞机不知道硬币对撞机。

取消勾选消耗品和敌人交叉点的方框，使其看起来像图 [5-5](#Fig5) 。敌人层中的物体将不再与消耗品层中的物体发生碰撞而触发互动。这两个不同的层现在彼此不知道对方。我们还没有给敌人设定绕关卡行走的脚本——这是以后的事。但当我们这样做时，敌人不会意识到硬币，因为这两层没有配置为相互作用。

![img/464283_1_En_5_Chapter/464283_1_En_5_Fig5_HTML.jpg](img/464283_1_En_5_Chapter/464283_1_En_5_Fig5_HTML.jpg)

图 5-5

层碰撞矩阵允许我们配置层相互作用

选择 CoinObject 预设，并更改其层为:消耗品。当我们在这的时候，在预置文件夹中选择敌人对象预置，并改变它的层为:敌人。

现在拖动一个 CoinObject 预置到场景中的某个地方。

按下播放键，让角色走到硬币前。你会注意到玩家可以走过硬币。CoinObject 在消耗品层，Player 在阻挡层。因为我们在碰撞矩阵中为这些层选中了框，所以当它们各自的对象发生碰撞时，这些层会相互感知。我们将利用这种意识编写逻辑脚本，允许玩家捡起硬币。

## 触发器和脚本

正如我们前面提到的，对撞机不仅仅用于检测两个物体的碰撞。碰撞器也可以用来定义一个对象周围的范围，并检测另一个游戏对象已经进入该范围。当另一个游戏对象在范围内时，脚本行为可以相应地被*触发*。

“Is Trigger”属性用于检测另一个对象何时进入碰撞器定义的范围。当玩家的碰撞器接触到硬币的圆形碰撞器时，方法:`void OnTriggerEnter2D(Collider2D collision)`在两个附加到碰撞器的物体上自动调用。我们可以使用这个方法自定义两个对象碰撞时应该发生的行为。因为我们设置的是触发器，碰撞器不再阻止玩家穿过硬币。

打开 Player.cs 脚本，在底部添加以下方法。

```cs
// 1
void OnTriggerEnter2D(Collider2D collision)
{
// 2
    if (collision.gameObject.CompareTag("CanBePickedUp"))
    {
// 3
        collision.gameObject.SetActive(false);
    }
}

```

让我们来看看这个方法的实现。

```cs
// 1

```

每当该对象与触发碰撞器重叠时，就会调用`OnTriggerEnter2D()`。

```cs
// 2

```

使用碰撞来取回玩家碰撞过的`gameObject`。检查被碰撞的`gameObject`的标签。如果标签是“`CanBePickedUp`”，那么继续在 If 语句中执行。

```cs
// 3

```

我们知道另一个游戏对象可以被拿起，所以我们将创建一个对象已经被拿起的印象，并将它隐藏在场景中。我们实际上还没有编写拾取对象的功能脚本——这是以后的事情。

在 Visual Studio 中按 Save，然后返回 Unity 编辑器并按 play。带玩家走到场景中的硬币前，看着玩家触摸硬币时硬币消失。

总结一下，当玩家与硬币发生碰撞时，碰撞器会检测到交互，脚本逻辑会确定这个对象是否可以被拾取，如果可以，我们会将硬币设置为非活动状态。相当整洁！

### 小费

确保在你修改脚本时按下保存键，否则这些修改不会在 Unity 编辑器中编译，也不会反映到你的游戏中。很常见的情况是做一个快速的改变，然后又回到 Unity，奇怪为什么你看不到任何不同的事情发生。

## 可编写脚本的对象

可脚本化的对象是一个重要的概念，对于任何想要建立一个干净的游戏架构的 Unity 游戏开发者来说都需要学习。可脚本化的对象可以被认为是可重用的数据容器，通过 C# 脚本定义，通过“资源”菜单生成，并作为资源保存在 Unity 项目中。

可编写脚本的对象有两种主要的使用情形:

*   通过存储对可脚本化对象资产的单个实例的引用来减少内存使用。这样做是为了避免每次使用对象时都复制每个对象的所有值，从而增加内存使用量。

*   预定义的可插入数据集。

为了解释第一个用例，让我们考虑一个虚构的例子:

想象一下，我们创建了一个包含这本书全部文本的 string 属性的预置。每次我们创建该预置的另一个实例时，我们也会创建这本书的整个文本的新副本。你可以想象，这种方法会很快耗尽游戏的内存。

如果我们在预设中使用一个可脚本化的对象来保存这本书的全部文本，那么每次我们创建预设的一个新实例时，它都会引用这本书文本的相同副本。我们可以生成尽可能多的预置副本，而书中文本使用的内存将保持不变。

关于第一个用例，使用可脚本化对象时要记住的一个重要事项是，每次我们引用可脚本化对象资产时，我们都是在引用内存中的同一个可脚本化对象。这种方法的结果是，如果我们改变这个可脚本化的对象引用中的任何数据，我们将改变可脚本化的对象资产本身中的数据，并且当我们停止运行我们的游戏时，这些改变将保持不变。如果我们想在运行时更改可脚本化对象资产的任何值，而不永久更改原始数据，那么我们应该首先在内存中创建一个副本。

Unity 开发者也经常在他们的游戏架构中使用可脚本化的对象来定义可插入的数据集。可以定义数据集来描述玩家可能在商店或库存系统中找到的物品。可脚本化的对象也可以用于定义属性，例如数字版本的纸牌游戏中的攻击和防御级别。

可脚本化的对象继承自`ScriptableObject`类，(它又继承自`Object`)，而不是`MonoBehaviour`，所以我们不能访问`Start()`和`Update()`方法。无论如何，使用这些方法实际上没有意义，因为可脚本化的对象是用来存储数据的。因为可脚本化的对象不是从`MonoBehaviour`继承的，所以不能附加到游戏对象上。除了附加到游戏对象，使用可脚本化对象的一种常见方式是从继承自`MonoBehaviour`的 Unity 脚本内部创建对它们的引用。

### 创建可编写脚本的对象

我们将创建一个名为“Item”的可脚本化对象来保存玩家可以消费或拾取的对象的数据。我们将在一个从`MonoBehaviour`派生的脚本中引用这个可脚本化的对象，并将该脚本附加到物品的预设上。当一个玩家与预设发生碰撞时，我们将抓取一个可脚本化的对象的引用，并给人一种该物品已经被取消激活的印象。最终，我们会将这些对象添加到我们将要构建的清单中。

在脚本目录中创建一个名为“可编写脚本的对象”的文件夹。然后右键单击并创建名为 Item 的新脚本。

将以下内容键入 Item.cs，完成后不要忘记保存。像往常一样，我们将详细解释代码做什么。

```cs
using UnityEngine;

// 1
[CreateAssetMenu(menuName = "Item")]

// 2
public class Item : ScriptableObject {

// 3
    public string objectName;

// 4
    public Sprite sprite;

// 5
    public int quantity;

// 6
    public bool stackable;

// 7
    public enum ItemType
    {
        COIN,
        HEALTH
    }

// 8
    public ItemType itemType;
}

```

让我们看一下项目脚本:

```cs
// 1

```

CreateAssetMenu 在创建子菜单中创建一个条目，如图 [5-6](#Fig6) 所示。这使我们能够轻松地创建 Item 可脚本化对象的实例。

![img/464283_1_En_5_Chapter/464283_1_En_5_Fig6_HTML.jpg](img/464283_1_En_5_Chapter/464283_1_En_5_Fig6_HTML.jpg)

图 5-6

从“创建”子菜单中实例化项目实例

这些可编写脚本的对象实例实际上作为单独的资源文件存储在项目中，并且可以通过检查器在对象本身上修改它们的属性。

```cs
// 2

```

继承自`ScriptableObject`，而不是`Monobehaviour`。

```cs
// 3

```

`The`字段:`objectName`，可以有几种不同的用途。它肯定会在调试时派上用场，也许你的游戏会显示店面中某个物品的名称，或者另一个游戏角色会提到它。

```cs
// 4

```

存储一个对物品精灵的引用，这样我们就可以在游戏中显示它。

```cs
// 5

```

跟踪这个特定项目的数量。

```cs
// 6

```

*可堆叠*是一个术语，用来描述相同项目的多个副本如何存储在同一个地方，并可以由玩家同时进行交互。硬币是可堆叠物品的一个例子。我们设置布尔属性`Stackable`来表示一个项目是否是可堆叠的。如果一个项目不可堆叠，则该项目的多个副本不能同时交互。

```cs
// 7

```

定义用于指示项目类型的枚举。虽然`objectName`可以在游戏中的某些点上显示给玩家，但是`ItemType`的属性永远不会显示给玩家，只会被游戏逻辑用来在内部识别对象。继续我们的硬币项目的例子，你的游戏可能有不同类型的硬币，但他们都将被归类为`ItemType:`硬币。

```cs
// 8

```

使用`ItemType`枚举创建一个名为`itemType`的属性。

### 构建可消费的脚本

可脚本化的对象不从`MonoBehaviour`继承，所以它们不能被附加到游戏对象。我们将编写一个继承自`MonoBehaviour`的小脚本，它有一个保存项目引用的属性。因为这个脚本将继承自`MonoBehaviour`，所以它可以附加到一个游戏对象上。在 MonoBehaviours 文件夹中，右键单击并创建一个名为“Consumable”的新 C# 脚本。

```cs
using UnityEngine;

// 1
public class Consumable : MonoBehaviour {

//2
    public Item item;
}

```

```cs
// 1

```

从 MonoBehaviour 继承，这样我们可以将这个脚本附加到一个游戏对象。

```cs
// 2

```

当`Consumable`脚本被添加到游戏对象中时，我们将为`item`属性分配一个项目。这将在可消费脚本中存储对可脚本化对象资产的引用。因为我们已经声明了它`public`，它仍然可以从其他脚本中访问。

如前所述，如果我们改变这个可脚本化对象引用中的任何数据，我们将改变可脚本化对象资产本身中的数据，并且当我们停止运行我们的游戏时，这些改变将保持不变。如果我们想在运行时改变可脚本化对象的任何值，而不改变原始数据，那么我们应该首先复制它。

保存耗材脚本并切换回 Unity 编辑器。

### 组装我们的产品

选择 CoinObject 预置并将可消费脚本拖到它上面。我们需要将图 [5-7](#Fig7) 中的消耗品属性设置为一个可脚本化的项目对象。我们将创建一个可脚本化的项目对象来附加。

![img/464283_1_En_5_Chapter/464283_1_En_5_Fig7_HTML.jpg](img/464283_1_En_5_Chapter/464283_1_En_5_Fig7_HTML.jpg)

图 5-7

可消耗项目属于项目类型，这是一个可脚本化的对象

在“可编写脚本的对象”文件夹中，右键单击并选择“资源”菜单顶部的“创建➤项目”,以创建项目可编写脚本的对象。如果您更喜欢使用 Unity 编辑器顶部的菜单栏，您可以选择资产➤创建➤项目。

将可编写脚本的对象重命名为“Item”。确保选择项目可编写脚本的对象，然后检查 Unity 检查器。将该项目的设置更改为图 [5-8](#Fig8) 。将对象命名为“coin”，勾选“Stackable ”,然后从项目类型下拉列表中选择 COIN。

![img/464283_1_En_5_Chapter/464283_1_En_5_Fig8_HTML.jpg](img/464283_1_En_5_Chapter/464283_1_En_5_Fig8_HTML.jpg)

图 5-8

设置硬币项目的属性

将 sprite 属性设置为 sprite，名称为:“hearts-and-coins s32x 32 _ 4”，如图 [5-8](#Fig8) 和 [5-9](#Fig9) 所示。这个 sprite 是项目的清晰表示，当我们想要在静态上下文中显示项目时，例如在库存工具栏中，就会用到它。这不同于我们在动画精灵出现在场景中时显示它们的方式。

![img/464283_1_En_5_Chapter/464283_1_En_5_Fig9_HTML.jpg](img/464283_1_En_5_Chapter/464283_1_En_5_Fig9_HTML.jpg)

图 5-9

选择一个精灵来代表硬币项目

回到硬币预置中的消耗脚本，将消耗物品设置为我们的硬币物品，如图 [5-10](#Fig10) 所示。

![img/464283_1_En_5_Chapter/464283_1_En_5_Fig10_HTML.jpg](img/464283_1_En_5_Chapter/464283_1_En_5_Fig10_HTML.jpg)

图 5-10

将可消耗物品设置为我们的新硬币物品

### 玩家冲突

我们的 Player 类已经有了检测与硬币预置碰撞的逻辑，但是现在我们想获取一个对可脚本化对象的引用，这样我们就可以在玩家遇到它时隐藏它。这将起到把硬币添加到玩家物品栏的作用。

在 Player 类中，在`OnTriggerEnter2D method`中，修改我们之前编写的现有 if 语句，如下所示:

```cs
if (collision.gameObject.CompareTag("CanBePickedUp"))
{

// 1
// Note: This should all be on a single line
  Item hitObject = collision.gameObject.GetComponent<Consumable>().item;

// 2
    if (hitObject != null)
    {

// 3
        print("it: " + hitObject.objectName);
        collision.gameObject.SetActive(false);
    }
}

```

这里发生了很多事情，所以我们将一点一点地讲述。总的来说，我们的目标是在`Consumable`类中检索对`Item`(一个可脚本化的对象)的引用，并将其分配给`hitObject`。

```cs
// 1

```

首先，我们获取对附加到`collision`的`gameObject`的引用。记住每一个`collision`都会有一个与它相撞的游戏物体附在`collision`上。在我们游戏的这一点上，`gameObject`将会是一枚硬币，但稍后它可能会是任何带有标签“`CanBePickedUp`”的游戏对象。

我们在脚本名称中的`gameObject and`通道上调用`GetComponent()`，以检索附加的`Consumable`脚本组件。我们之前附上了`Consumable`脚本。最后，我们从`Consumable`组件中检索名为`item`的属性，并将其分配给`hitObject`。

```cs
// 2

```

检查`hitObject`是否为空。如果`hitObject`不是`null`，那么我们已经成功地取回了`hitObject`。如果`hitObject`是`null`，则什么都不做。像这样的安全检查有助于避免路上的错误。

```cs
// 3

```

为了确保我们已经检索到了`item`，打印出`objectName`属性，这是我们之前在检查器中设置的。

保存脚本并切换回 Unity 编辑器。按下播放按钮，将玩家带入硬币中。您应该会在控制台上看到图 [5-11](#Fig11) 中打印出来的文本。

![img/464283_1_En_5_Chapter/464283_1_En_5_Fig11_HTML.jpg](img/464283_1_En_5_Chapter/464283_1_En_5_Fig11_HTML.jpg)

图 5-11

与硬币的碰撞已被正确检测到

### 创造心脏能量

现在我们知道了如何创建脚本化的对象，让我们创建另一个玩家可以选择的对象:心脏能量。使用我们之前从“hearts-and-coins 32 x 32 . png”sprite-sheet 中截取的 sprite。

让我们回顾一下创建预置的步骤。

1.  创建一个 GameObject，重命名为“HeartObject”。

2.  为预设动画添加精灵。使用标题为“hearts-and-coins s32x 32”的精灵，以 0、1、2 和 3 结尾。命名新创建的动画，“心脏旋转”，并将其保存到动画➤动画文件夹。

3.  从心脏对象中创建一个预设，方法是将它拖到预设文件夹中，然后从层次中删除原始对象。

4.  选择文件夹中的心脏预设，并设置预设的精灵属性。在场景中预览时使用该属性。

5.  在精灵渲染器组件上，将排序层设置为对象，以便预设可见。

6.  添加一个碰撞器 2D 组件。我们可以使用圆形碰撞器，盒子，或者多边形 2D，但是对于心形的精灵，多边形 2D 会更好。如果需要，编辑碰撞器形状。

7.  根据你创建的预设类型，set:是碰撞器的触发器。

8.  在游戏对象上设置标签。我们将使用:CanBePickedUp，对于这个预置。

9.  将图层更改为“耗材”

10.  将游戏对象拖到预设文件夹中作为预设使用。

11.  从层级视图中删除原始游戏对象。

### 小费

如果您同时为一个动画选择多个精灵，您可以在检查器中预览它们。在图 [5-12](#Fig12) 中，我们同时选择了四个心脏精灵。

![img/464283_1_En_5_Chapter/464283_1_En_5_Fig12_HTML.jpg](img/464283_1_En_5_Chapter/464283_1_En_5_Fig12_HTML.jpg)

图 5-12

在检查器中一次预览多个精灵

点击并拖动一个心形预置到场景中的某个地方(图 [5-13](#Fig13) )。

![img/464283_1_En_5_Chapter/464283_1_En_5_Fig13_HTML.jpg](img/464283_1_En_5_Chapter/464283_1_En_5_Fig13_HTML.jpg)

图 5-13

一颗心的预制，等待被拾起

我们将设置心脏预设，这样它就像硬币预设一样包含一个可脚本化对象的引用。通过选择预设，然后按“添加组件”按钮并键入“消耗品”，将可消耗脚本添加到心脏预设。

现在我们需要创建 Item 可脚本化对象的新实例。这个新实例将是它自己的资产，与我们项目中的所有其他资产一起存储在项目视图中。

在项目视图中打开“可编写脚本的对象”文件夹。右键单击，然后选择创建➤项目，然后将创建的项目重命名为“心脏”。选择心脏项目，并将设置更改为图 [5-14](#Fig14) 中的设置。

![img/464283_1_En_5_Chapter/464283_1_En_5_Fig14_HTML.jpg](img/464283_1_En_5_Chapter/464283_1_En_5_Fig14_HTML.jpg)

图 5-14

心脏可脚本化对象的设置

我们将新的 heart 项目命名为“Heart”，给它一个 sprite，我们稍后将在库存中显示它，并将其数量设置为 1。当玩家捡起红心时，这个值将被用来增加玩家的生命值。我们还将项目类型设置为健康。不要点击可堆叠，因为红心不会被储存在玩家的库存中，而是会被立即消耗。

因为我们在心脏预设上有可消耗的脚本，我们可以按下可消耗物品属性旁边的圆圈并添加我们的新心脏物品，如图 [5-15](#Fig15) 所示。

![img/464283_1_En_5_Chapter/464283_1_En_5_Fig15_HTML.jpg](img/464283_1_En_5_Chapter/464283_1_En_5_Fig15_HTML.jpg)

图 5-15

将心脏项目分配给消耗品项目属性

就是这样！如果你按下 play，让玩家走进屏幕上的心形预设，你应该会在控制台上看到图 [5-16](#Fig16) 中的文本。

![img/464283_1_En_5_Chapter/464283_1_En_5_Fig16_HTML.jpg](img/464283_1_En_5_Chapter/464283_1_En_5_Fig16_HTML.jpg)

图 5-16

记录确认玩家跑进了心脏预设

我们希望玩家每捡起一颗红心就增加一次`hitPoints`。切换回 Visual Studio 并打开 Player 类。

将`OnTriggerEnter2D()`方法更改如下。本章前面已经讨论了一些代码，所以我们不再赘述。

```cs
void OnTriggerEnter2D(Collider2D collision)
    {
        if (collision.gameObject.CompareTag("CanBePickedUp"))
        {

    Item hitObject = collision.gameObject.GetComponent<Consumable>().item;

            if (hitObject != null)
            {
                print("Hit: " + hitObject.objectName);

// 1
                switch (hitObject.itemType)
                {
// 2
                    case Item.ItemType.COIN:
                        break;
// 3
                    case Item.ItemType.HEALTH:
                        AdjustHitPoints(hitObject.quantity);
                        break;
                    default:
                        break;
                }

                collision.gameObject.SetActive(false);
            }
        }
    }

// 4
    public void AdjustHitPoints(int amount)
    {

// 5
        hitPoints = hitPoints + amount;
        print("Adjusted hitpoints by: " + amount + ". New value: " + hitPoints);
    }

```

让我们看一下这段代码。

```cs
// 1

```

使用一个`switch`语句来匹配`hitObject`属性:`itemType`，并在项目类中定义`ItemType`枚举。这允许我们编写与每个项目类型冲突时的特定行为。

```cs
// 2

```

在`hitObject`是硬币类型的情况下，暂时不要做任何事情。我们将学习如何在创建库存时收集硬币。

```cs
// 3

```

在玩家遇到健康类型的物品的情况下，调用我们将要编写的方法`AdjustHitPoints(int amount)`。该方法接受一个类型为`int`的参数，我们将从`hitObject`属性`quantity`中获取该参数。

```cs
// 4

```

这个方法会根据参数中的数值来调整玩家的生命值。将命中点调整逻辑放在单独的函数中，而不是将逻辑放在 switch 语句中，有两个主要优点。

第一个优点是清晰。清晰的代码更容易阅读和理解，因此错误也更少。我们希望始终保持代码的意图和组织尽可能清晰。

第二个优点是，通过将逻辑放入函数中，我们可以很容易地从其他地方调用它。理论上来说，可能会有玩家的生命值被其他东西调整的情况，而不是碰到健康物品。

```cs
// 5

```

将 amount 参数添加到现有的生命点数中，然后将结果赋给`hitPoints`。这个方法也可以通过为`amount`参数传入一个负数来减少`hitPoints`。当玩家受到伤害时我们会使用这个。

保存玩家脚本并切换回 Unity 编辑器。

按下播放，让玩家跑进心脏预设。您应该在控制台中看到图 [5-17](#Fig17) 输出中的消息。

![img/464283_1_En_5_Chapter/464283_1_En_5_Fig17_HTML.jpg](img/464283_1_En_5_Chapter/464283_1_En_5_Fig17_HTML.jpg)

图 5-17

调整玩家的生命值

### 摘要

在这一章中，我们已经开始将不同的 Unity 元素整合到游戏机制中。我们已经建立了基本的 C# 脚本，将用于我们游戏中的所有角色类型，并创建了玩家可以与之互动的几种类型的预设。碰撞检测是游戏开发的一个基本方面，我们已经了解了 Unity 引擎提供的检测和定制碰撞检测的工具。我们还学习了可脚本化的对象，它们是可重用的数据容器，使我们的游戏架构更加简洁。