# 八、人工智能和弹弓

这一章涵盖了很多，但是到最后，你会有一个游戏的功能原型。我们将构建一些有趣的功能，如具有追逐行为的可重用人工智能组件。我们勇敢的玩家也将最终得到她选择的武器:一把弹弓，用来保护自己。您将学习一种在游戏编程中广泛使用的优化技术，称为对象池，并运用一些您从未想过会用到的高中数学知识。本章还演示了混合树的使用，这是一种更有效的制作动画的方式，从长远来看，对你的游戏架构更好。最后，我们将向您展示如何在 Unity 之外编译您的游戏，并谈一谈您的游戏编程冒险的下一步。

## 游走算法

在这一节中，我们将利用我们所学的协程编写一个脚本，让敌人在棋盘上随机游走。如果敌人察觉到玩家就在附近，敌人就会追击她，直到她逃跑，杀死敌人，或者玩家死亡。

Wander 算法听起来可能很复杂，但是当我们一步一步地分解它时，你会发现它是完全可以实现的。

图 [8-1](#Fig1) 是游走算法的示意图。我们将分阶段实现每个部分，并在过程中进行解释，这样您就不会感到不知所措。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig1_HTML.png](img/464283_1_En_8_Chapter/464283_1_En_8_Fig1_HTML.png)

图 8-1

游走算法

### 入门指南

选择敌人的预设，并将其拖入场景中，使我们的生活更容易。选择 EnemyObject 并向其添加 CircleCollider2D 组件。选中圆形碰撞器上的 Is 触发框，将碰撞器的半径设置为:1。圆形碰撞器应该看起来像图 [8-2](#Fig2) 。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig2_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig2_HTML.jpg)

图 8-2

设置是触发器和半径

这个圆形对撞机代表了敌人能“看”多远。换句话说，当玩家的对撞机穿越圆形对撞机时，敌人可以看到玩家。记住触发碰撞器是如何工作的:因为我们已经检查了圆形碰撞器上的是触发框，它可以穿过其他物体。敌人会“看到”玩家穿越对撞机，然后改变航向，追击她。

### 创建漫游脚本

我们将创建一个单行为的漫游脚本，这样它就可以被重复使用，并在将来附加到敌人以外的其他游戏对象上。

添加一个新的脚本，名为:“Wander”。在 Visual Studio 中打开该脚本，并添加以下内容:

```cs
// 1
using System.Collections;
using UnityEngine;

// 2
[RequireComponent(typeof(Rigidbody2D))]
[RequireComponent(typeof(CircleCollider2D))]
[RequireComponent(typeof(Animator))]
public class Wander : MonoBehaviour
{

}

```

```cs
// 1

```

我们将在 Wander 算法中使用协程和`IEnumerator`。正如在第 7 章中提到的，`IEnumerator`是`System.Collections`名称空间的一部分，所以我们在这里导入它。

```cs
// 2

```

确保我们将来附加漫游脚本的任何游戏对象都有一个`Rigidbody2D`、一个`CircleCollider2D`和一个`Animator`。这三个组件都是 Wander 脚本所必需的。

通过使用`RequireComponent`，这个脚本附加到的任何脚本将自动添加所需的组件(如果它还不存在的话)。

### 漂移变量

接下来我们将勾画出游走算法所需的变量。将以下变量添加到 Wander 类中:

```cs
// 1
    public float pursuitSpeed;
    public float wanderSpeed;
    float currentSpeed;

// 2
    public float directionChangeInterval;

// 3
    public bool followPlayer;

// 4
    Coroutine moveCoroutine;

// 5
    Rigidbody2D rb2d;
    Animator animator;

// 6
    Transform targetTransform = null;

// 7
    Vector3 endPosition;

// 8
    float currentAngle = 0;

```

```cs
// 1

```

这三个变量将用于设置敌人追击玩家的速度，不追击时的一般游荡速度，以及将是前两个速度之一的当前速度。

```cs
// 2

```

`The directionChangeInterval`通过 Unity 编辑器设置，将用于确定敌人应该多久改变一次游荡方向。

```cs
// 3

```

这个脚本可以附加到游戏中的任何角色上，添加流浪行为。你可能希望最终创造一个不追逐玩家而只是四处游荡的角色。可以设置`followPlayer`标志来开启和关闭玩家追逐行为。

```cs
// 4

```

变量 moveCoroutine 是我们保存对当前运行的移动协程的引用的地方。这个协程将负责在每一帧中向目的地移动敌人一点点。我们需要保存对协程的引用，因为在某个时候我们需要停止它，为此我们需要一个引用。

```cs
// 5

```

附加在游戏对象上的刚体 2D 和动画。

```cs
// 6

```

`We use targetTransform`敌人追击玩家时。该脚本将从 PlayerObject 中检索转换，并将其分配给`targetTransform`。

```cs
// 7

```

敌人游荡的目的地。

```cs
// 8

```

当选择一个新的方向漫游时，一个新的角度将添加到现有的角度。该角度用于生成一个矢量，该矢量成为目的地。

### 构建开始()

现在我们已经有了目前需要的所有变量，让我们构建 Start()方法。

```cs
    void Start()
    {
// 1
        animator = GetComponent<Animator>();

// 2
        currentSpeed = wanderSpeed;

// 3
        rb2d = GetComponent<Rigidbody2D>();

// 4
        StartCoroutine(WanderRoutine());
    }

```

```cs
// 1

```

抓取并缓存当前游戏对象的动画组件。

```cs
// 2

```

将当前速度设置为`wanderSpeed`。敌人开始悠闲地游荡。

```cs
// 3

```

我们需要参考`Rigidbody2D`来实际移动敌人。存储一个引用，而不是每次需要时都检索它。

```cs
// 4

```

启动`WanderRoutine()`协程，这是 Wander 算法的入口点。接下来我们写`WanderRoutine()`。

### 流浪的协程

除了追踪逻辑外，`WanderRoutine()`协程包含本章前面图 [8-1](#Fig1) 中描述的 Wander 算法的所有高级逻辑。我们仍然需要编写一些从`WanderRoutine()`内部调用的方法，但是这个协程是 Wander 算法的大脑。

```cs
// 1
public IEnumerator WanderRoutine()
{

// 2
    while (true)
    {

// 3
        ChooseNewEndpoint();

//4
        if (moveCoroutine != null)
        {

// 5
            StopCoroutine(moveCoroutine);
        }

// 6
        moveCoroutine = StartCoroutine(Move(rb2d, currentSpeed));

// 7
        yield return new WaitForSeconds(directionChangeInterval);
    }
}

```

```cs
// 1

```

这个方法是一个协程，因为它无疑会在多个框架上运行。

```cs
// 2

```

我们希望敌人无限期地游荡，所以我们将使用 while(true)来无限期地循环这些步骤。

```cs
// 3

```

`ChooseNewEndpoint()`方法确实如其名。它会选择一个新的终点，但不会让敌人朝它移动。接下来我们将编写这个方法。

```cs
// 4

```

通过检查`moveCoroutine`是否为`null`或是否有值来检查敌人是否已经在移动。如果它有一个值，那么敌人可能正在移动，所以我们需要在移动到新的方向之前先阻止它。

```cs
// 5

```

停止当前运行的运动协程。

```cs
// 6

```

启动`Move()`协程，并在`moveCoroutine`中保存对它的引用。`Move()`协程负责实际移动敌人。我们很快就会写出来。

```cs
// 7

```

让协程执行`directionChangeInterval`秒，然后重新开始循环并选择一个新的端点。

## 选择新端点

我们已经写出了起点和 Wander 协程，所以是时候开始填充由`WanderCoroutine()`调用的方法了。`ChooseNewEndpoint()`方法负责随机选择一个新的终点供敌人行进。

```cs
// 1
void ChooseNewEndpoint()
{

// 2
    currentAngle += Random.Range(0, 360);

// 3
    currentAngle = Mathf.Repeat(currentAngle, 360);

// 4
    endPosition += Vector3FromAngle(currentAngle);
}

```

```cs
// 1

```

通过省略访问修饰符使这个方法私有，因为它只在 Wander 类中需要。

```cs
// 2

```

选择一个 0 到 360 之间的随机值来表示新的行进方向。该方向以角度表示，单位为度。我们把它加到当前角度。

```cs
// 3

```

方法`Mathf.Repeat(currentAngle, 360)`将循环值:`currentAngle`,使其永远不会小于 0，也不会大于 360。我们有效地将新角度保持在 0 到 360 度的范围内，然后用结果替换`currentAngle`。

```cs
// 4

```

调用一个方法将角度转换成一个`Vector3`，并将结果添加到`endPosition`。变量`endPosition`将被`Move()`协程使用，我们很快就会看到。

### 角度到弧度到矢量！

该方法以度为单位获取一个角度参数，将其转换为弧度，并返回一个由`ChooseNewEndpoint()`使用的方向向量 3。

```cs
Vector3 Vector3FromAngle(float inputAngleDegrees)
{

// 1
    float inputAngleRadians = inputAngleDegrees * Mathf.Deg2Rad;

// 2
    return new Vector3(Mathf.Cos(inputAngleRadians), Mathf.Sin(inputAngleRadians), 0);
}

```

```cs
// 1

```

通过乘以角度到弧度的转换常量，将输入角度从角度转换为弧度。Unity 提供了这个常量，所以我们可以快速转换。

```cs
// 2

```

使用输入角度(以弧度为单位)创建敌人方向的归一化方向向量。

### 敌人行走动画

到目前为止，敌人只有一个动画:闲置。是时候利用我们在第 [3](3.html) 章创建的敌人行走动画剪辑了。

选择敌人预设，然后打开动画窗口，如图 [8-3](#Fig3) 所示。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig3_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig3_HTML.jpg)

图 8-3

选择了敌人对象的动画窗口

如果空闲状态是默认状态，它将显示为橙色。如果不是默认状态，右击“敌人-闲置-1”状态，选择:设置为层默认状态。

正如你所看到的，敌人-步行-1 状态是存在的，有一个动画剪辑，但目前没有被使用。计划是创建一个动画参数，并使用该参数在空闲和行走状态之间切换。

点击动画师参数部分的加号，选择 Bool，如图 [8-4](#Fig4) 所示。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig4_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig4_HTML.jpg)

图 8-4

选择 Bool 以创建类型为 Bool 的动画参数

将该参数命名为“isWalking”，如图 [8-5](#Fig5) 所示。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig5_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig5_HTML.jpg)

图 8-5

创建 isWalking Bool 参数

我们的漫游脚本将使用这个参数在空闲和行走之间切换敌人的动画状态。为了保持简单，行走动画将作为追逐玩家时跑步以及悠闲行走的替身。

右键点击敌人-闲置-1 状态并选择:进行转换。创建空闲状态和行走状态之间的转换。然后在行走状态和空闲状态之间创建另一个转换。当你完成后，动画状态窗口应该如图 [8-6](#Fig6) 所示。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig6_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig6_HTML.jpg)

图 8-6

创建空闲和行走状态之间的转换

点击从敌人-闲置-1 到敌人-步行-1 的转换状态，并使用以下设置，如图 [8-7](#Fig7) 所示。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig7_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig7_HTML.jpg)

图 8-7

过渡设置

点击从敌人-步行-1 到敌人-空闲-1 的转换，并使用图 [8-7](#Fig7) 中的相同设置进行配置。

设置每个过渡以使用我们刚刚创建的动画参数:isWalking。设置条件:isWalking 为真，如图 [8-8](#Fig8) 所示，从敌方空闲-1 过渡到敌方步行-1。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig8_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig8_HTML.jpg)

图 8-8

如果 isWalking == true，则满足此条件

在敌人-步行-1 到敌人-空闲-1 的转换中，将 isWalking 设置为 false。

就这样！敌人行走动画设置完毕。要使用新的动画状态，我们只需要在我们的`Move()`协程中将`isWalking`改为`true`，你很快就会看到。

在检查器中点击“应用”,将这些改变应用到所有敌人的预设上。

### Move()协程

`Move()`协程负责将给定`speed`处的刚体 2D 从其当前位置移动到`endPosition`变量。

将以下方法添加到 Wander 脚本中。

```cs
public IEnumerator Move(Rigidbody2D rigidBodyToMove, float speed)
{

// 1
    float remainingDistance = (transform.position - endPosition).sqrMagnitude;

// 2
    while (remainingDistance > float.Epsilon)
    {

// 3
        if (targetTransform != null)
        {
            endPosition = targetTransform.position;
        }

// 4
        if (rigidBodyToMove != null)
        {

// 5
            animator.SetBool("isWalking", true);

// 6
            Vector3 newPosition = Vector3.MoveTowards(rigidBodyToMove.position, endPosition, speed * Time.deltaTime);

// 7
            rb2d.MovePosition(newPosition);

// 8
            remainingDistance = (transform.position - endPosition).sqrMagnitude;
        }

// 9
        yield return new WaitForFixedUpdate();
    }

// 10
    animator.SetBool("isWalking", false);
}

```

```cs
// 1

```

等式:`(transform.position – endPosition)`产生一个向量 3。我们使用一个名为`sqrMagnitude`的属性，它在 Vector3 类型上可用，来检索敌人当前位置和目的地之间的大致剩余距离。使用`sqrMagnitude`属性是 Unity 提供的执行快速矢量幅度计算的方法。

```cs
// 2

```

检查当前位置和终点位置之间的剩余距离是否大于等于零的`float.Epsilon,`。

```cs
// 3

```

当敌人正在追击玩家时，值`targetTransform`将被设置为玩家变形而不是空值。然后我们覆盖了`endPosition`的原始值，使用`targetTransform`来代替。敌人移动的时候会朝着玩家移动，而不是朝着原来的`endPosition`移动。因为`targetTransform`实际上是玩家的变身，它会随着玩家新的位置不断更新。这使得敌人可以动态地跟随玩家。

```cs
// 4

```

`Move()`方法需要一个`RigidBody2D`，用它来移动敌人。在我们继续之前，确保我们确实有一个`RigidBody2D`要移动。

```cs
// 5

```

将`Bool`类型的动画参数`isWalking`设置为`true`。这将启动状态转换到行走状态，并播放敌人行走动画。

```cs
// 6

```

`Vector3.MoveTowards`方法用于计算刚体 2D 的运动。它实际上并没有移动刚体 2D。该方法采用三个参数:当前位置、结束位置和在帧中移动的距离。记住变量:`speed`会变，取决于敌人是在追击还是悠闲的在场景周围徘徊。这个值将在追踪代码中改变，我们还没有写出来。

```cs
// 7

```

使用`MovePosition()`将刚体 2D 移动到新位置，在前一行中计算。

```cs
// 8

```

使用`sqrMagnitude`属性更新剩余距离。

```cs
// 9

```

直到下一次固定帧更新。

```cs
// 10

```

敌人已经到达`endPosition`等待选择新的方向，所以将动画状态改为空闲。

保存这个脚本并切换回 Unity 编辑器。

### 配置漫游脚本

选择敌人的预设，并配置漫游脚本，看起来像图 [8-9](#Fig9) 。将追踪速度设置为比漫游速度稍快的速度。方向改变间隔是漂移算法调用`ChooseNewEndpoint()`选择新的漂移方向的频率。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig9_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig9_HTML.jpg)

图 8-9

在漫游脚本中使用这些设置

在检查器中按“应用”,然后从层次视图中删除 EnemyObject。

现在按播放键。注意敌人是如何在场景中游荡的。如果玩家走近敌人，他们还不会追击她。接下来我们要添加追踪逻辑。

### 二维标记()

因此，除了追踪逻辑，我们已经实现了几乎所有的 Wander 算法。在这一节中，我们将编写一些简单的逻辑来插入游走算法，让敌人追击玩家。

追踪逻辑依赖于`OnTriggerEnter2D()`方法，每个单行为都提供了这个方法。正如我们在第五章[中了解到的，触发碰撞器(设置了 Is Trigger 属性的碰撞器)可以用来检测另一个游戏对象进入碰撞器。当这种情况发生时，会对冲突中涉及的 MonoBehaviours 调用`OnTriggerEnter2D()`方法。](5.html)

当玩家进入附属于敌人的 CircleCollider2D 时，敌人可以“看见”玩家，应该会追击她。

让我们写下这个逻辑。

```cs
void OnTriggerEnter2D(Collider2D collision)
{

// 1
    if (collision.gameObject.CompareTag("Player") && followPlayer)
    {

// 2
        currentSpeed = pursuitSpeed;

// 3
        targetTransform = collision.gameObject.transform;

// 4
        if (moveCoroutine != null)
        {
            StopCoroutine(moveCoroutine);
        }

// 5
        moveCoroutine = StartCoroutine(Move(rb2d, currentSpeed));
    }
}

```

```cs
// 1

```

检查碰撞中对象上的标签，查看它是否是 PlayerObject。还要检查`followPlayer`当前是否为真。该变量通过 Unity 编辑器设置，用于打开和关闭追踪行为。

```cs
// 2

```

在这一点上，我们已经确定`collision`和玩家在一起，所以将`currentSpeed`改为`pursuitSpeed`。

```cs
// 3

```

设置`targetTransform`等于玩家的变换。`Move()`协程将检查`targetTransform`是否不为空，然后将其作为 endPosition 的新值。敌人就是这样不断的追击玩家，而不是漫无目的的游荡。

```cs
// 4

```

如果敌人正在移动，`moveCoroutine`将不会为空。需要在再次启动之前停止它。

```cs
// 5

```

因为`endPosition`现在被设置为玩家对象的变换，调用`Move()`会将敌人移向玩家。

### 2d control success()

如果敌人`pursuitSpeed`比玩家`movementSpeed`小，玩家可以跑得比任何敌人都快。随着玩家逃离敌人，她将退出敌人触发碰撞器，导致`OnTriggerExit2D()`被调用。当这种情况发生时，敌人实际上失去了玩家的视线，并继续漫无目的地游荡。

这种方法几乎与`OnTriggerEnter2D()`相同，只是做了一些调整。

```cs
void OnTriggerExit2D(Collider2D collision)
{

// 1
    if (collision.gameObject.CompareTag("Player"))
    {

// 2
        animator.SetBool("isWalking", false);

// 3
        currentSpeed = wanderSpeed;

// 4
        if (moveCoroutine != null)
        {
            StopCoroutine(moveCoroutine);
        }

// 5
        targetTransform = null;
    }
}

```

```cs
// 1

```

检查标签，看看玩家是否正在离开碰撞器。

```cs
// 2

```

敌人在失去玩家的视线后感到困惑，并停顿了一会儿。将`isWalking`设置为 false，将动画更改为 idle。

```cs
// 3

```

将`currentSpeed`设置为`wanderSpeed`，下次敌人开始移动时使用。

```cs
// 4

```

因为我们希望敌人停止追击玩家，所以我们需要阻止`moveCoroutine`。

```cs
// 5

```

敌人不再跟踪玩家，所以将`targetTransform`设置为`null`。

保存这个脚本并返回到 Unity 编辑器。按播放。

将玩家移动到敌人的视野中，注意敌人将如何追击她，直到她跑出视野。

### 小发明

Unity 支持可视化调试和设置工具 Gizmos 的创建。这些工具是通过一组方法创建的，并且只出现在 Unity 编辑器中。当你的游戏在用户的硬件上编译和运行时，它们不会出现在你的游戏中。

我们将创建两个小发明来帮助可视化调试 Wander 算法。我们将创建的第一个小发明将显示圆形对撞机 2D 的电线轮廓，用于检测玩家何时在敌人的视线范围内。这个小发明将使人们更容易看到追逐行为应该何时开始。

将以下变量添加到 Wander 类的顶部，这里有其他变量:

```cs
CircleCollider2D circleCollider;

```

然后给`Start()`加上下面一行。它可以放在方法中的任何位置:

```cs
circleCollider = GetComponent<CircleCollider2D>();

```

这一行检索当前敌人对象的`CircleCollider2D`组件。我们将使用它在屏幕上画一个圆，直观地表示当前的圆形碰撞器。

要实现 Gizmo，实现 MonoBehaviour 提供的名为`OnDrawGizmos()`的方法:

```cs
void OnDrawGizmos()
{

// 1
    if (circleCollider != null)
    {

// 2
        Gizmos.DrawWireSphere(transform.position, circleCollider.radius);
    }
}

```

```cs
// 1

```

在我们尝试使用它之前，确保我们有一个圆形碰撞器的参考。

```cs
// 2

```

调用`Gizmos.DrawWireSphere()`并为其提供位置和半径，绘制一个球体。

保存脚本并返回到 Unity 编辑器。确保 Gizmos 按钮已按下，然后按播放。当敌人四处游荡时，注意敌人周围的小玩意，如图 [8-10](#Fig10) 所示。这个小控件的周长和位置对应于`CircleCollider2D`。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig10_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig10_HTML.jpg)

图 8-10

代表敌人周围的`CircleCollider2D`的小发明

如果你没有看到圆形小控件出现，确保你在游戏窗口的右上角启用了小控件，如图 [8-11](#Fig11) 所示。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig11_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig11_HTML.jpg)

图 8-11

启用小控件

如果我们有一条显示敌人目的地的线，就更容易看到游走算法如何将敌人移向一个位置。让我们在屏幕上从当前敌人位置到终点位置画一条线。

我们将使用`Update()`方法，这样每一帧都会画出一条线。

```cs
void Update()
{
// 1
    Debug.DrawLine(rb2d.position, endPosition, Color.red);
}

```

```cs
// 1

```

当启用小控件时，方法`Debug.DrawLine()`的结果是可见的。该方法获取当前位置、结束位置和线条颜色。

在图 [8-12](#Fig12) 中我们可以看到，从敌人的中心到目的地(endPosition)画了一条红线。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig12_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig12_HTML.jpg)

图 8-12

从敌人阵地到终点画了一条红线

## 自卫

我们勇敢的玩家除了用智慧引导她和用弹弓防御之外，将一无所有。每按一次鼠标按钮，我们的玩家就会向鼠标点击的位置发射一发弹弓子弹。我们将编写弹药的行为脚本，这样当它在空中飞行时，它会沿着一条弧线而不是直线飞向目标。

### 需要的类别

我们需要三个不同职业的组合来给玩家保护自己的能力。

武器类将封装弹弓的功能。这个职业将附属于玩家预设，并负责一些不同的事情:

*   确定何时按下鼠标按钮，并使用按钮按下的位置作为目标

*   从当前动画切换到射击动画

*   制造弹药并向目标移动

我们需要一个类来表示弹弓发射的弹药。这个**弹药**班将负责:

*   确定附加的弹药游戏对象何时与敌人发生碰撞

*   记录它与敌人碰撞时造成的伤害

我们还将构建一个 **Arc** 类，负责以夸张的弧线将弹药游戏对象从起始位置移动到结束位置。否则弹药会直线前进。

## 弹药等级

目前，我们希望游戏中的弹药只能伤害敌人，但是你也可以在将来很容易地扩展这个功能来伤害其他东西。每个 AmmoObject 将在 Unity 编辑器中显示一个属性，描述它造成的伤害。我们将把这个氨物体变成一个预制体。如果你想给玩家提供两种不同类型的弹药，创建第二个弹药预置，改变上面的精灵和造成的伤害是一个简单的任务。

在项目层次中创建一个新的游戏对象，并将其重命名为“AmmoObject”。我们将创建 AmmoObject，配置它，编写脚本，然后将它变成一个预置。

### 导入资产

从你下载的资源中，将标题为“Ammo.png”的 spritesheet 拖到资源➤ Sprites ➤对象文件夹中。

选择弹药 spritesheet，并在检查器中使用以下导入设置:

*   纹理类型:精灵(2D 和用户界面)

*   精灵模式:单个

*   每单位像素:32

*   过滤器模式:点(无过滤器)

*   确保选择了底部的默认按钮，并将压缩设置为:无

按下应用按钮。

Unity 编辑器将自动检测精灵的边界，所以没有必要打开精灵编辑器或切片精灵。

### 添加组件，设置层

将 Sprite 渲染器组件添加到 AmmoObject。

在 Sprite 渲染器上，将排序层设置为:Characters，并将 Sprite 属性设置为:Ammo。弹药是我们刚刚进口的雪碧。

向 AmmoObject 添加 CircleCollider2D。确保选中“触发”设置，并将半径设置为 0.2。如果你需要调整碰撞器，点击编辑碰撞器按钮，移动手柄直到你满意碰撞器包围弹药精灵。

创建一个名为“弹药”的新层，并用它来设置 AmmoObject 上的层，如图 [8-13](#Fig13) 所示。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig13_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig13_HTML.jpg)

图 8-13

将层设置为:弹药

### 更新层碰撞矩阵

如果你还记得在第 5 章中，我们学习了基于层的碰撞检测。总而言之，只有当层碰撞矩阵被配置为相互感知时，不同层中的两个碰撞器才会相互作用。

进入编辑菜单➤项目设置➤物理 2D，配置图层碰撞矩阵，如图 [8-14](#Fig14) 。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig14_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig14_HTML.jpg)

图 8-14

配置弹药层

我们想让一个弹药碰撞机与一个敌人的碰撞机相互作用，但不与任何其他碰撞机相互作用。回到第五章，我们配置了敌人来使用敌人层，我们也配置了 AmmoObject 来使用弹药层。

### 构建弹药脚本

给 AmmoObject 添加一个名为“弹药”的新脚本。在 Visual Studio 中打开弹药脚本。

使用下面的代码来构建弹药类。

```cs
using UnityEngine;

public class Ammo : MonoBehaviour
{

// 1
    public int damageInflicted;

// 2
    void OnTriggerEnter2D(Collider2D collision)
    {
// 3
if (collision is BoxCollider2D)
        {

// 4
            Enemy enemy = collision.gameObject.GetComponent<Enemy>();

// 5
            StartCoroutine(enemy.DamageCharacter(damageInflicted, 0.0f));

// 6
            gameObject.SetActive(false);
        }

    }
}

```

```cs
// 1

```

弹药对敌人造成的伤害。

```cs
// 2

```

当另一个物体进入弹药游戏物体的触发碰撞器时调用。触发器碰撞器只是一个设置了:Is Trigger 属性的碰撞器。在这种情况下，它是一个`CircleCollider2D`。

```cs
// 3

```

重要的是检查我们是否击中了敌人内部的`BoxCollider2D`。记住敌人也有一个`CircleCollider2D`，它在漫游脚本中用来探测玩家是否在附近。`BoxCollider2D`是我们用来探测与敌人实际碰撞的物体的对撞机。

```cs
// 4

```

从`collision`中检索`gameObject`的敌方脚本组件。

```cs
// 5

```

启动协程来伤害敌人。如果您还记得第 7 章[中的](7.html)，那么`DamageCharacter()`的方法签名如下所示:

```cs
DamageCharacter(int damage, float interval)

```

第一个参数:`damage`，是对敌人造成的伤害量。第二个参数:`interval`，是施加`damage`之间等待的时间。通过`interval` = 0 将造成`damage`一次。我们将变量`damageInflicted`作为第一个参数传递，它是弹药类的一个实例变量，将通过 Unity 编辑器设置。

```cs
// 6

```

因为弹药已经击中了敌人，所以将 AmmoObject 的`gameObject`设置为非活动状态。

为什么我们要将`gameObject`设置为非活动状态，而不是调用`Destroy(gameObject)`并完全删除它？

好问题——很高兴你问了。我们将 AmmoObject 设置为非活动状态，这样我们就可以使用一种叫做**对象池**的技术来保持游戏的良好性能。

### 在我们忘记之前...使氨对象成为预设的

在我们进入对象池之前，最后一件事——让我们把 AmmoObject 变成一个预置。遵循同样的过程，我们总是用游戏对象来创建预置:

1.  从层次视图拖动一个对象到预设文件夹来创建一个预设。

2.  从层次视图中删除原始 AmmoObject。

## 对象池

如果你的游戏有大量的对象在短时间内被实例化然后销毁，你可能会看到游戏暂停，速度变慢，整体性能下降。这是因为在 Unity 中实例化和销毁对象比简单地激活和停用对象更消耗性能。销毁一个对象将调用 Unity 的内部内存清理过程。短时间内重复调用这个过程，尤其是在内存受限的环境中，比如移动设备或 web，会影响性能。这些对性能的影响不会随着对象数量的减少而显现出来，但是如果你的游戏需要制造大量的敌人或子弹，你就需要考虑一个更优化的方法。

为了避免与对象创建和销毁相关的性能问题，我们将使用一种称为对象池的优化技术。要使用对象池，请提前为场景预实例化一个对象的多个副本，取消激活它们，然后将它们添加到对象池中。当场景需要一个对象时，遍历对象池并返回找到的第一个非活动对象。当场景使用完该对象后，将其置于非活动状态，并将其返回到对象池，以便场景将来重用。

简而言之，对象池重用对象，最大限度地减少由于运行时内存分配和清理导致的性能下降。对象最初将被设置为非活动状态，只有在使用时才被激活。当使用一个对象完成场景时，该对象再次被设置为非活动状态，表明它可以在需要时被重用。

通过反复点击鼠标按钮，弹弓武器将快速连续发射多发子弹。这是一个教科书式的场景，对象池可以提高运行时性能。

以下是在 Unity 中使用对象池的三个关键步骤:

*   在需要对象之前，预先实例化对象的集合(一个“池”)，并将其设置为非活动状态

*   当游戏需要一个对象时，不要实例化一个新的对象，从池中抓取一个不活动的对象并激活它

*   使用完对象后，只需将其置于非活动状态，即可将其放回池中

## 建造武器类

我们将在武器类中创建并存储弹药对象池。如前所述，这个类将包含弹弓功能，并最终控制显示玩家发射弹弓的动画。

我们将通过创建用来存放弹药的对象池来开始构建基本的弹弓功能。

选择 PlayerObject 预设，并添加一个名为“武器”的新脚本。在 Visual Studio 中打开此脚本。使用下面的代码开始构建武器类。

```cs
// 1
using System.Collections.Generic;
using UnityEngine;

// 2
public class Weapon : MonoBehaviour
{

// 3
    public GameObject ammoPrefab;

// 4
    static List<GameObject> ammoPool;

// 5
    public int poolSize;

// 6
    void Awake()
    {

// 7
        if (ammoPool == null)
        {
            ammoPool = new List<GameObject>();
        }

// 8
        for (int i = 0; i < poolSize; i++)
        {
            GameObject ammoObject = Instantiate(ammoPrefab);
            ammoObject.SetActive(false);
            ammoPool.Add(ammoObject);
        }
    }
}

```

```cs
// 1

```

我们需要导入`System.Collections.Generic`，这样我们就可以使用`List`数据结构。`List`类型的变量将用于表示对象池——预实例化对象的集合。

```cs
// 2

```

武器继承自`MonoBehaviour`，因此可以附加到游戏对象上。

```cs
// 3

```

属性`ammoPrefab`将通过 Unity 编辑器设置，并用于实例化 AmmoObject 的副本。这些副本将被添加到`Awake()`方法中的对象池中。

```cs
// 4

```

类型为`List`的属性`ammoPool`用于表示对象池。

C# 中的`List`是强类型对象的有序集合。因为它们是强类型的，所以您必须提前声明`List`将保存什么类型的对象。试图插入任何其他类型的对象将导致编译时出错，您的游戏将无法运行。这个`List`被宣布只持有`GameObjects`。

变量`ammoPool`是一个静态变量。如果您回忆一下第 7 章[中的](7.html)，`static`变量属于类本身，并且只有一个副本存在于内存中。

```cs
// 5

```

属性允许我们设置对象池中预实例化的对象数量。因为这个属性是`public`，所以可以通过 Unity 编辑器进行设置和调整。

```cs
// 6

```

创建对象池和预初始化 AmmoObjects 的代码将包含在`Awake()`方法中。`Awake()`在脚本的生命周期中被调用一次:当脚本被加载时。

```cs
// 7

```

检查`ammoPool`对象池是否已经初始化。如果它还没有被初始化，创建一个新的类型为`List`的`ammoPool`来保存`GameObjects`。

```cs
// 8

```

使用`poolSize`作为上限创建一个循环。在循环的每次迭代中，实例化一个新的`ammoPrefab`副本，将其设置为非活动的，并将其添加到`ammoPool`。

对象池(`ammoPool`)已经创建好，可以在场景中使用了。你很快就会看到，每当玩家用弹弓发射弹药时，我们会从`ammoPool`中抓取一个不活动的 AmmoObject 并激活它。当场景使用 AmmoObject 完成后，它被停用并返回到`ammoPool`。

### 根除方法

方法存根是尚未开发的代码的替代品。它们还有助于找出特定功能所需的方法。让我们为其余的基本武器功能列出我们需要的各种方法。

将以下代码添加到武器类中。

```cs
// 1
    void Update()
    {

// 2
        if (Input.GetMouseButtonDown(0))
        {

// 3
            FireAmmo();
        }
    }

// 4
    GameObject SpawnAmmo(Vector3 location)
    {
       // Blank, for now...
    }

// 5
    void FireAmmo()
    {
       // Blank, for now...
    }

// 6
    void OnDestroy()
    {
        ammoPool = null;
    }

```

```cs
// 1

```

在`Update()`方法中，检查每一帧，看看用户是否点击了鼠标来发射弹弓。

```cs
// 2

```

`GetMouseButtonDown()`方法是输入类的一部分，接受单个参数。这个方法将检查鼠标左键是否被点击和释放。方法参数`0`表示我们对第一个(左)鼠标按钮感兴趣。如果我们对鼠标右键感兴趣，我们将传递值:`1`。

```cs
// 3

```

因为已经单击了鼠标左键，所以调用我们将要编写的`FireAmmo()`方法。

```cs
// 4

```

`SpawnAmmo()`方法将负责从对象池中检索并返回一个 AmmoObject。该方法采用一个参数:`location`，指示实际放置检索到的 AmmoObject 的位置。`SpawnAmmo()`返回一个`GameObject`——从`ammoPool`对象池中检索到的激活的 AmmoObject。

```cs
// 5

```

`FireAmmo()`将负责将 AmmoObject 从在`SpawnAmmo()`中产生的起始位置移动到鼠标按钮被点击的结束位置。

```cs
// 6

```

设置`ammoPool = null`销毁对象池并释放内存。`OnDestroy()`方法是`MonoBehaviour`自带的，当附属的`GameObject`被销毁时会被调用。

### 产卵弹药法

SpawnAmmo 方法将遍历预先实例化的 AmmoObjects 的集合或“池”,并找到第一个非活动对象。然后它将激活 AmmoObject，设置`transform`。`position`，然后返回 AmmoObject。如果不存在非活动的 AmmoObjects，则返回`null`。因为弹药池是用设定数量的 AmmoObjects 初始化的，所以一次可以出现在屏幕上的 AmmoObjects 的数量有一个固有的限制。这个限制可以通过改变 Unity 编辑器中的`poolSize`来调整。

### 小费

找出在对象池中预实例化的对象的理想数量的最好方法是经常玩这个游戏，然后相应地调整这个数量。

让我们在武器类中实现 SpawnAmmo()方法。

```cs
    public GameObject SpawnAmmo(Vector3 location)
    {

// 1
        foreach (GameObject ammo in ammoPool)
        {

// 2
            if (ammo.activeSelf == false)
            {

// 3
                ammo.SetActive(true);

// 4
                ammo.transform.position = location;

// 5
                return ammo;
            }
        }
// 6
        return null;
    }

```

```cs
// 1

```

在预先实例化的对象池中循环。

```cs
// 2

```

检查当前对象是否处于非活动状态。

```cs
// 3

```

我们发现了一个不活动的对象，所以将其设置为活动的。

```cs
// 4

```

将对象上的`transform.position`设置为参数:`location`。当我们调用`SpawnAmmo()`时，我们将传递一个`location`，让它看起来像是从弹弓中射出的氨物体。

```cs
// 5

```

返回活动对象。

```cs
// 6

```

找不到非活动对象，因此当前正在使用池中的所有对象。返回`null`。

### 弧类和线性插值

Arc 脚本将负责实际移动 AmmoObject。我们希望弹药沿着弧线飞向目标。我们将创建一个名为“Arc”的新 MonoBehaviour 来包含此功能。因为我们将 Arc 创建为一个独立的 MonoBehaviour，所以我们可以在将来将这个脚本附加到其他游戏对象上，使它们也能以弧形运行。

为了简单起见，我们将首先实现沿直线行进的 Arc 脚本。在我们做好工作后，我们将添加一个小的调整来使弹药以一个好看的弧线运行。

在项目视图中选择 AmmoObject 预设，并添加一个名为“Arc”的新脚本。在 Visual Studio 中打开 Arc 脚本，并编写以下代码:

```cs
using System.Collections;
using UnityEngine;

// 1
public class Arc : MonoBehaviour
{

// 2
    public IEnumerator TravelArc(Vector3 destination, float duration)
    {

// 3
        var startPosition = transform.position;

// 4
        var percentComplete = 0.0f;

// 5
        while (percentComplete < 1.0f)
        {

// 6
            percentComplete += Time.deltaTime / duration;

// 7
            transform.position = Vector3.Lerp(startPosition, destination, percentComplete);

// 8
            yield return null;
        }
// 9
        gameObject.SetActive(false);
    }
}

```

```cs
// 1

```

因为 Arc 是一个单体行为，所以它可以附加到游戏对象上。

```cs
// 2

```

是沿着弧线移动游戏对象的方法。将`TravelArc()`设计成协程是有意义的，因为它将在几个帧的过程中执行。`TravelArc()`带两个参数:`destination`和`duration`。定义如下:`destination`是结束位置，`duration`是将附属`gameObject`从起始位置移动到`destination`所需的时间。

```cs
// 3

```

抓取当前游戏对象的`transform.position`并将其分配给`startPosition`。我们将在位置计算中使用`startPosition`。

```cs
// 4

```

`percentComplete`用于本方法后面使用的`Lerp`或线性插值计算。我们将解释它的用法。

```cs
// 5

```

检查`percentComplete`是否小于 1.0。把 1.0 想象成 100%的十进制形式。我们只希望这个循环运行到`percentComplete`是 100%。当我们在下一行解释线性插值时，这将是有意义的。

```cs
// 6

```

我们希望将 AmmoObject 平稳地移向它的目的地。每一帧弹药移动的距离取决于我们希望移动持续的时间，以及已经过去的时间。

自上一帧以来经过的时间量除以运动的总期望持续时间，等于总持续时间的百分比。

`Take a look at this line again: percentComplete += Time.deltaTime / duration;`

`Time.deltaTime`是自绘制最后一帧以来经过的时间。这一行中的结果:`percentageComplete`，是我们将总持续时间的百分比与之前完成的百分比相加得到的结果，从而得到到目前为止已经完成的持续时间的总百分比。

我们将在下一行中使用这个总完成百分比来平滑地移动 AmmoObject。

```cs
// 7

```

为了实现一个效果，即一个物体以恒定的速度在两点之间平滑移动，我们使用了一种在游戏编程中广泛使用的技术，叫做**线性插值**。线性插值需要起始位置、结束位置和百分比。当我们使用线性插值来确定每帧要行进的距离时，线性插值方法的百分比参数:`Lerp()`，是完成时长的百分比(`percentComplete)`)。

在`Lerp()`方法中使用持续时间`percentComplete`意味着无论我们在哪里发射 AmmoObject，都需要相同的时间到达那里。这对于现实世界的模拟来说显然是不现实的，但是对于电子游戏来说，我们可以暂停现实世界的规则。

基于这个百分比，`Lerp()`方法将返回起点和终点之间的一个点。我们将结果赋给 AmmoObject 的`transform.position`。

```cs
// 8

```

暂停协程的执行，直到下一帧。

```cs
// 9

```

如果电弧已经到达其目的地，关闭附加的`gameObject`。

别忘了保存这个脚本！

### 屏幕点数和世界点数

在我们写下一个方法之前，我们应该谈谈屏幕点和世界点。

*屏幕空间*是屏幕上实际可见的空间，以像素为单位定义。例如，我们的屏幕空间目前是 1280 × 720 或水平 1280 像素垂直 720 像素。

*世界空间*是真实的游戏世界，没有大小限制。它的大小理论上是无限的，用单位来定义。当我们在第 [4](4.html) 章中设置 PPU 时，我们配置了摄像机来将世界单位映射到屏幕单位。

当我们在游戏中移动物体时，因为它们可以移动到任何地方，而不仅限于在屏幕上移动，所以我们相对于世界空间移动它们。Unity 提供了一些从屏幕转换到世界空间的简便方法。

### 火弹药法

现在我们已经构建了移动 AmmoObject 的 Arc 组件，切换回武器类，让我们使用下面的代码实现`FireAmmo()`方法。

首先，将下面的变量添加到武器类的顶部，在`poolSize`变量之后。这个变量将用于设置弹弓发射弹药的速度:

```cs
public float weaponVelocity;

```

然后使用下面的代码实现`FireAmmo()`方法:

```cs
    void FireAmmo()
    {

// 1
        Vector3 mousePosition = Camera.main.ScreenToWorldPoint(Input.mousePosition);

// 2
        GameObject ammo = SpawnAmmo(transform.position);

// 3
        if (ammo != null)
        {

// 4
            Arc arcScript = ammo.GetComponent<Arc>();

// 5
             float travelDuration = 1.0f / weaponVelocity;

// 6
            StartCoroutine(arcScript.TravelArc(mousePosition, travelDuration));
        }
    }

```

```cs
// 1

```

因为鼠标使用屏幕空间，我们将鼠标位置从屏幕空间转换到世界空间。

```cs
// 2

```

通过`SpawnAmmo()`方法从弹药对象池中获取一个激活的 AmmoObject。传递当前武器的`transform.position`作为取回 AmmoObject 的起始位置。

```cs
// 3

```

检查以确保`SpawnAmmo()`返回了一个 AmmoObject。记住，如果所有预实例化的对象都已经被使用了，那么`SpawnAmmo()`可能会返回`null`。

```cs
// 4

```

检索对 AmmoObject 的`Arc`组件的引用，并将其保存到变量`arcScript`。

```cs
// 5

```

数值`weaponVelocity`将在 Unity 编辑器中设置。用 1.0 除以`weaponVelocity`得到一个分数，我们将把这个分数用作一个氨物体的移动持续时间。例如，1.0 / 2.0 = 0.5，所以弹药将需要半秒钟穿过屏幕到达目的地。

这个公式的结果是，当目的地较远时，弹药的速度会加快。想象一个玩家向附近的东西开火的场景。如果我们不能保证无论距离远近，飞行时间总是 0.5 秒，那么子弹很可能会从弹弓中快速射向敌人，以至于你真的看不到它。如果我们制作一个第一人称射击游戏，这可能是好的。但是在我们的 RPG 中，我们希望随时都能看到弹弓发射的弹药。这样看起来更“有趣”。

```cs
// 6

```

调用我们之前在`arcScript`写的 TravelArc 方法。召回方法签名:`TravelArc(Vector3 destination, float duration)`。对于`destination`参数，传递鼠标点击的位置。对于`duration`参数，传递我们在前一行中计算的`travelDuration that`:

```cs
float travelDuration = 1.0f / weaponVelocity;

```

回想一下，`TravelArc()`中的`duration`参数用于确定 AmmoObject 从起始位置移动到`destination`需要多长时间。我们将在下一步配置武器脚本时设置`weaponVelocity`的值。

### 配置武器脚本

我们快完成了！在玩家使用弹弓之前，还需要整理一些东西。保存武器脚本，切换到 Unity 编辑器，并选择 PlayerObject。因为我们已经将武器脚本添加到 PlayerObject 中，所以将 AmmoObject 预设拖到武器脚本的弹药预设属性中。如图 [8-15](#Fig15) 所示，设置池大小为 7，武器速度为 2。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig15_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig15_HTML.jpg)

图 8-15

配置武器脚本

我们选择用`0.5`来表示武器的速度，因为这感觉像是弹弓子弹飞行的自然时间。你可以随意调整这个值，让它看起来自然有趣。

我们准备好出发了。按下 Play 并点击一个敌人发射弹弓和像素化的死亡雨。

太棒了！弹弓发射弹药，但它不是以弧线运行。让我们解决这个问题。

### 形成电弧

切换回 Visual Studio 中的 Arc 脚本。我们将稍微调整一下脚本，使弧线脚本名副其实，实际上是沿着弧线轨迹行进。

修改 Arc 脚本中的`while()`循环，如下所示:

```cs
    while (percentComplete < 1.0f)
    {
                 // Leave this existing line alone.
                 percentComplete += Time.deltaTime / duration;

// 1
        var currentHeight = Mathf.Sin(Mathf.PI * percentComplete);

// 2
        transform.position = Vector3.Lerp(startPosition, destination, percentComplete) + Vector3.up * currentHeight;

                 // Leave these existing lines alone.
        percentComplete += Time.deltaTime / duration;
        yield return null;
    }

```

```cs
// 1

```

为了理解这里发生的事情，我们需要一点高中三角学的知识。波的“周期”是完成一个完整周期所需的时间。根据图 [8-16](#Fig16) ，正弦波的周期为(2 * π)，正弦波的一半周期正好为(π)。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig16_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig16_HTML.jpg)

图 8-16

正弦曲线

通过将(`percentComplete` × `Mathf.PI)`的结果传递给正弦函数，我们有效地每隔`duration`秒沿着正弦曲线移动 PI 距离。结果被分配给`currentHeight`。

```cs
// 2

```

`Vector3.up`是单位提供的变量，表示 Vector3(0，1，0)。将`Vector3.up * currentHeight`与`Vector3.Lerp()`的结果相加，调整位置，使 AmmoObject 不再沿直线移动，而是沿 Y 轴向上然后向下朝着`endPosition`移动。

保存脚本，返回 Unity 编辑器，然后按 Play。发射弹弓，注意它是如何以弧线飞行的。

你会注意到，当玩家发射弹弓时，我们实际上并没有播放任何类型的射击动画。我们将在下一节中解决这个问题。

## 制作弹弓动画

我们已经创建了一个武器，并编写了开火的代码，但玩家看起来有点奇怪，因为她只是站在那里，看着弹药神秘地出现并飞向目标。在这一节中，我们将构建播放玩家发射弹弓的动画的功能。您还将学习一种简化动画状态管理的新方法。

为了简单起见，我们首先将这种新的状态管理方法应用于行走动画，因为我们已经熟悉了状态机的工作方式，以及动画应该是什么样子。一旦我们适应了新的方法，我们将把它应用于发射弹弓。

### 动画和混合树

回到第 [3](3.html) 章，我们为玩家设置了一个动画状态机，由包含动画剪辑的动画状态组成。这些状态通过转换连接起来，我们通过在 Animator 组件上设置动画参数来控制转换。

玩家的状态机目前类似于图 [8-17](#Fig17) 。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig17_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig17_HTML.jpg)

图 8-17

播放器动画状态机

因为玩家可以向四个不同的方向行走，所以她也可以向四个不同的方向发射弹弓。如果我们为四个发射方向添加另外四个动画状态，这个状态机将开始看起来相当拥挤。如果我们最终想要向状态机添加更多的状态，事情将很快变得难以管理，视觉上令人困惑，并降低整体开发速度。

幸运的是，Unity 为我们提供了一个解决方案—输入:混合树。

## 混合树木

游戏编程经常需要在两个动画之间混合，例如当一个角色在行走时，然后逐渐开始奔跑。混合树可用于将多个动画平滑地混合成一个平滑的动画。虽然我们不会在游戏中混合多个动画，但是混合树还有一个我们将要用到的次要用途。

当用作动画状态机的一部分时，混合树可用于**平滑地从一个动画状态过渡到另一个动画状态。混合树可以将各种动画捆绑到一个节点中，使您的游戏架构更加清晰和易于管理。混合树由在 Unity 编辑器中配置并在代码中设置的变量控制。**

我们将创建两个混合树。由于我们已经熟悉了行走动画状态机，我们创建的第一个混合树将用于重新创建行走状态。我们还将更新玩家的 MovementController 代码来使用这个混合树。重建熟悉的东西将是一个很好的方式来适应混合树。

一旦我们有了行走混合树，我们将添加四个射击状态作为他们自己的射击混合树，并更新武器类来使用射击混合树。

### 清理动画师

是时候告别陈旧的动画状态管理方式了。选择 PlayerObject，打开 Animator 视图。从动画状态机中删除四个原始玩家行走状态。移除任何状态和空闲状态之间的转换，因为我们也不再需要它了。

当你完成后，动画视图应该如图 [8-18](#Fig18) 所示。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig18_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig18_HTML.jpg)

图 8-18

移除了旧玩家行走状态的动画视图

我们将创建一个混合树节点，作为其中各种行走动画状态的容器。包含所有四个行走动画的混合树节点将在 Animator 视图中显示为单个节点。可以想象，随着状态数量的增加，这种方法使得开发人员更容易可视化和管理状态。

### 构建行走混合树

1.  在 Animator 窗口中右键单击并选择:从新混合树创建状态➤。

2.  选择创建的**混合节点**，并在检查器中将其名称更改为:“行走树”。

3.  双击“行走树”节点以查看混合树图形。

混合树应该如图 [8-19](#Fig19) 所示。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig19_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig19_HTML.jpg)

图 8-19

空混合树形图

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig22_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig22_HTML.jpg)

图 8-22

混合树中包含四个动画剪辑的四个运动

1.  再添加三个动作，并添加以下动画剪辑:玩家走南、玩家走西、玩家走北，如图 [8-22](#Fig22) 所示。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig21_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig21_HTML.jpg)

图 8-21

在运动中使用 player-walk-east 动画剪辑

1.  在“选择运动选择器”打开的情况下，选择 player-walk-east 动画剪辑。运动现在应该如图 [8-21](#Fig21) 所示。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig20_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig20_HTML.jpg)

图 8-20

单击点以打开“选择运动选择器”

1.  选择混合树节点，并将检查器中的**混合类型**更改为:2D 简单方向。完成混合树的配置后，我们将讨论更多的混合类型。

2.  选择混合树节点，右键单击，然后选择:添加运动。一个**动作**保存一个动画剪辑的引用和相应的输入参数。当我们为过渡使用混合树时，输入参数用于确定应该播放什么运动。

3.  在检查器中，单击我们刚刚添加的运动旁边的点(图 [8-20](#Fig20) )以打开选择运动选择器。

添加完所有四个动作后，动画窗口应该如图 [8-23](#Fig23) 所示。每个运动都显示为混合树节点的子节点。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig23_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig23_HTML.jpg)

图 8-23

具有四个运动节点的混合树，包含动画剪辑

### 一层层，一直往下

我们在这里所做的是将所有四个动画状态包装到一个容器中——一个混合树节点。该混合树节点位于基础层的子层内。如果你点击 Animator 视图左上角的基础层按钮，如图 [8-24](#Fig24) 所示，Animator 视图将返回到“基础层”并显示一个混合树节点。当使用动画师时，如果适合你的架构，你可以在层内嵌套层。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig24_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig24_HTML.jpg)

图 8-24

单击“基础层”按钮返回到基础 Animator 视图

正如我们在图 [8-25](#Fig25) 中看到的，这种简化的管理状态的方法将使你的游戏架构在未来保持整洁和易于管理。行走混合树是动画器中的一个节点。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig25_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig25_HTML.jpg)

图 8-25

Animator 中带有单个混合树(行走树)节点的基础层

### 关于混合类型的注记

混合类型用于描述混合树应该如何混合运动。如你所知，我们实际上并没有混合运动，所以术语*混合类型*有点误导。我们在它们之间转换，所以我们配置了混合树来使用 2D 简单方向混合。这种混合类型有两个参数，最适合表示*不同*方向的动画，例如向北走、向南走等等。因为我们使用混合树在向北、向南、向东和向西行走之间进行过渡，所以 2D 简单方向混合非常适合我们的用例。

### 动画参数

我们过去曾经使用过动画参数，当我们第一次为播放器配置动画状态机并创建“Animation State”参数时。

删除 Animator 窗口左侧的 AnimationState 参数。我们已经删除了依赖它的动画过渡。我们将用混合树和它自己的参数替换这个参数和相关的状态。这些参数将用于我们将在武器类中编写的代码中。

创建这三个动画参数。大写很重要，因为我们将在代码中引用它们:

*   类型的 is walking:Bool

*   xDir 类型:Float

*   yDir 类型:Float

参数:Blend 是在创建动画师时创建的。请随意删除该参数，因为我们不需要它。

动画师的动画参数部分应该如图 [8-26](#Fig26) 所示。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig26_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig26_HTML.jpg)

图 8-26

行走混合树的新动画参数

### 小费

创建动画参数时，一个常见的错误来源是使用错误的数据类型创建它们。

### 使用参数

选中混合树，从检查器的下拉菜单中选择 xDir 和 yDir 参数，如图 [8-27](#Fig27) 所示。我们将在下一步中使用这两个参数。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig27_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig27_HTML.jpg)

图 8-27

从下拉菜单中选择参数:xDir 和 yDir

选择“混合树”节点后，查看检查器中参数下方的可视化窗口。将多个运动添加到混合树后，可视化窗口将自动出现。

想象一个(0，0)穿过窗口中心的笛卡尔坐标平面(图 [8-28](#Fig28) )。四个坐标(1，0)、(0，-1)、(-1，0)和(0，1)可以相应地映射到下面的虚线的末端。可视化窗口的目的是帮助开发人员可视化配置。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig28_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig28_HTML.jpg)

图 8-28

想象一个笛卡尔坐标平面

在图 [8-28](#Fig28) 中，有四个蓝点聚集在 0，0 处，你看不到它们，因为它们被红色的中心点遮住了。这些点中的每一个都代表了我们之前添加的四个动作中的一个。

设置第一个动作的位置 X 和位置 Y，使代表玩家向东走动作的蓝点位于位置:(1，0)，如图 [8-29](#Fig29) 所示。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig29_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig29_HTML.jpg)

图 8-29

为所有四个动作设置位置 X 和 Y

我们还想相应地设置其他三个运动的 X 和 Y 位置。例如，玩家向南行走的运动位置应该设置为(0，-1)。如图 [8-29](#Fig29) 所示设置所有四个动作的位置。

### 好吧，但是*为什么是*？

因此，我们已经设置了混合树来使用我们的动画参数，并注意为每个动作设置位置 X 和位置 Y，但是*对*来说是什么呢？

正如我们在本节开始时提到的，我们可以通过在 animator 组件上设置变量来管理混合树中的 2D 状态转换。这就好比我们在第 [3](3.html) 章动画状态机上设置变量一样。

换句话说，要使用混合树，我们将编写类似下面的代码。目前不要在任何类中编写这段代码——这只是出于说明的目的。

```cs
// 1
movement.x = Input.GetAxisRaw("Horizontal");
movement.y = Input.GetAxisRaw("Vertical");

// 2
animator.SetBool("isWalking", true);

// 3
animator.SetFloat("xDir", movement.x);
animator.SetFloat("yDir", movement.y);

```

```cs
// 1

```

从用户那里获取输入值。变量:`movement`的类型为:`Vector2`。

```cs
// 2

```

设置动画参数:`isWalking`，表示玩家正在行走。这将过渡到行走混合树。

```cs
// 3

```

设置混合树用于过渡到特定运动的动画参数。这些是类型:`Float`，因为机芯`Vector2`包含了`Floats`。

当用户向右按压时，输入值将是(0，1)。我们在 Animator 上设置这个，混合树播放玩家向右走的动画剪辑。

### 循环时间

选择混合树的四个子节点中的每一个，如果默认情况下没有选中，检查循环时间属性，如图 [8-30](#Fig30) 所示。该属性告诉动画制作者在这种状态下连续循环播放动画剪辑。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig30_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig30_HTML.jpg)

图 8-30

检查循环时间属性

如果我们不选中这个框，动画将播放一次，然后停止。

### 创建过渡

最后但同样重要的是，我们需要创建空闲状态和新的行走混合树之间的过渡。

右键单击动画器中的空闲状态节点，并选择:进行过渡。将过渡连接到行走混合树。选择过渡并使用以下设置:

*   具有退出时间:未选中

*   固定持续时间:未选中

*   过渡持续时间:0

*   过渡偏移:0

*   中断源:无

使用我们创建的`isWalking`变量创建一个条件。设置为:`true`。

在行走混合树和空闲状态之间创建另一个过渡。选择过渡并使用与前面相同的设置，除了当您创建`isWalking`条件时，将其设置为:`false`。

## 更新运动控制器

是时候使用行走混合树了。打开 MovementController 类。

**从 MovementController 中删除**以下所有代码，因为我们不再需要它:

```cs
string animationState = "AnimationState";

```

并删除整个`CharStates`枚举:

```cs
enum CharStates
{
    walkEast = 1,
    walkSouth = 2,
 // etc
}

```

将现有的`UpdateState()`方法替换为:

```cs
void UpdateState()
{

// 1
    if (Mathf.Approximately(movement.x, 0) && Mathf.Approximately(movement.y, 0))
    {

// 2
        animator.SetBool("isWalking", false);
    }
    else
    {

// 3
        animator.SetBool("isWalking", true);
    }

// 4
    animator.SetFloat("xDir", movement.x);
    animator.SetFloat("yDir", movement.y);
}

```

```cs
// 1

```

检查运动向量是否大约等于 0，表明玩家是静止不动的。

```cs
// 2

```

因为玩家是站着不动的，所以把`isWalking`设为`false`。

```cs
// 3

```

否则`movement.x`、`movement.y`，或者两者都是非零数字，说明玩家在移动。

```cs
// 4

```

用新的移动值更新`animator`。

保存这个脚本并切换回 Unity 编辑器。按下播放键，让玩家在场景中走动。您已经摆脱了旧的动画状态，并使用混合树重建了行走动画。

### 导入战斗精灵

第一步是导入用于玩家战斗动画的精灵。将名为“PlayerFight32x32.png”的 spritesheet 拖动到 sprites 播放器文件夹中。

选择玩家战斗画面，并在检查器中使用以下导入设置:

*   纹理类型:精灵(2D 和用户界面)

*   精灵模式:多重

*   每单位像素:32

*   过滤器模式:点(无过滤器)

*   确保选择了底部的默认按钮，并将压缩设置为:无

按下应用按钮，然后打开精灵编辑器。

从“切片”菜单中，选择“按单元大小划分网格”，并将像素大小设置为 32。按下应用并关闭精灵编辑器。

### 创建动画剪辑

下一步是创建动画剪辑。在前面的章节中，我们通过为动画的每一帧选择精灵来创建动画剪辑，然后将它们拖动到游戏对象上。Unity 会自动创建一个动画剪辑并添加一个动画控制器(如果还没有的话)。

这次我们将创建一个稍微不同的动画剪辑，因为我们将创建一个混合树来管理动画。

转到精灵➤播放器文件夹，展开我们刚刚切片的精灵工作表。选择前四帧，如图 [8-31](#Fig31) 所示。这些精灵对应于玩家拉回弹弓并发射它。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig31_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig31_HTML.jpg)

图 8-31

在项目视图中选择前四个玩家战斗精灵

右键选择创建➤动画，如图 [8-32](#Fig32) 所示。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig32_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig32_HTML.jpg)

图 8-32

手动创建动画

将创建的动画重命名为:“玩家-火-东”。选择接下来的四个精灵，并遵循相同的步骤。将生成的动画命名为:“玩家-火-西”。

开火北动画只有两帧:“PlayerFight32x32_8”和“PlayerFight32x32_9”。使用这些帧来创建“玩家-火-北”。

击南动画有三帧:“PlayerFight32x32_10”、“PlayerFight32x32_11”、“PlayerFight32x32_12”。使用那些帧来创建“玩家-火-南方”。

将我们刚刚创建的所有动画剪辑移动到动画➤动画文件夹。

### 建立战斗混合树

1.  不要选中混合树子节点中的循环时间框。我们只想播放一次射击动画。

2.  创建空闲状态和新的火焰混合树之间的过渡。选择过渡并使用以下设置:
    *   具有退出时间:未选中

    *   固定持续时间:未选中

    *   过渡持续时间:0

    *   过渡偏移:0

    *   中断源:无

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig34_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig34_HTML.jpg)

图 8-34

为每个动作设置位置 X 和位置 Y

1.  为每个动作设置位置 X 和位置 Y，如图 [8-34](#Fig34) 所示。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig33_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig33_HTML.jpg)

图 8-33

配置动画参数

1.  在 Animator 窗口中右键单击并选择:从新混合树创建状态➤。

2.  选择创建的混合节点，并在检查器中将其名称更改为:“火树”。

3.  双击“火焰树”,在它自己的层上查看混合树图形。

4.  选择混合树节点，并将检查器中的混合类型更改为:2D 简单方向。

5.  选择混合树节点，右键单击，然后选择:添加运动。

6.  在检查器中，单击我们刚刚添加的运动旁边的点，以打开“选择运动选择器”。

7.  选择 player-fire-east 动画剪辑。

8.  再添加 3 个动作，并添加 player-fire-south、player-fire-west 和 player-fire-north 的动画剪辑。

9.  创建以下动画参数:`isFiring`(类型:`Bool`)、`fireXDir`(类型:`Float`)、`fireYDir`(类型:`Float`)，删除混合参数。

10.  配置混合树使用下拉框中的动画参数，如图 [8-33](#Fig33) 所示。

使用我们创建的`isFiring`变量在转换中创建一个条件。设置为:`true`。

1.  在火焰混合树和空闲状态之间创建另一个过渡。选择过渡并使用与前面相同的设置，但有两处不同:
    *   创建`isFiring`条件时，将其设置为:`false`。

    *   检查退出时间属性，并将退出时间的值设置为:1。

### 退出时间

过渡的“退出时间”属性用于告诉动画制作人，在动画播放了多少百分比之后，过渡才会生效。通过将“开火➤”空闲过渡的“退出时间”属性设置为:1，我们说我们希望在过渡前播放 100%的开火动画。

### 更新武器等级

下一步是更新武器类，以利用我们刚刚建立的火焰混合树。

将`RequireComponent`属性添加到武器类的顶部:

```cs
[RequireComponent(typeof(Animator))]
public class Weapon : MonoBehaviour

```

我们将要添加的代码需要一个 Animator 组件，所以要确保总有一个可用的组件。

### 添加变量

我们需要一些额外的变量来激活玩家。将以下变量添加到武器类的顶部。

```cs
// 1
bool isFiring;

// 2
[HideInInspector]
public Animator animator;

// 3
Camera localCamera;

// 4
float positiveSlope;
float negativeSlope;

// 5
enum Quadrant
{
    East,
    South,
    West,
    North
}

```

```cs
// 1

```

描述玩家是否正在发射弹弓。

```cs
// 2

```

将`[HideInInspector]`属性与`public`访问器一起使用，这样就可以从这个类的外部访问 animator，但它不会显示在检查器中。没有理由在检查器中显示`animator`,因为我们计划以编程方式检索对 Animator 组件的引用。

```cs
// 3

```

使用`localCamera`保存一个对摄像机的引用，这样我们就不必每次需要时都检索它。

```cs
// 4

```

存储我们将在本章后面进行的象限计算中使用的两条线的斜率。

```cs
// 5

```

用于描述玩家射击方向的枚举。

### 开始()

添加`Start()`方法，我们将使用它来初始化和设置在整个武器类中需要的变量。

```cs
void Start()
{

// 1
    animator = GetComponent<Animator>();

// 2
    isFiring = false;

// 3
    localCamera = Camera.main;
}

```

```cs
// 1

```

通过获取对 Animator 组件的引用进行优化，这样我们就不必在每次需要时都检索它。

```cs
// 2

```

首先将`isFiring`变量设置为`false`。

```cs
// 3

```

获取并保存对本地摄像机的引用，这样我们就不必在每次需要时都检索它。

### 更新更新()

对`Update()`方法做两个小的修改，如下所示:

```cs
void Update()
{
    if (Input.GetMouseButtonDown(0))
    {

// 1
        isFiring = true;
        FireAmmo();
    }

// 2
    UpdateState();
}

```

```cs
// 1

```

当鼠标左键被按下并抬起时，将`isFiring`变量设置为`true`。这个变量将在`UpdateState()`方法中被检查。

```cs
// 2

```

`UpdateState()`方法将更新每一帧的动画状态，不管用户是否按下了鼠标按钮。我们将很快编写这个方法。

### 确定方向

为了确定播放哪个动画剪辑，我们需要确定用户相对于播放器单击的方向。如果用户点击播放器的西边，只是为了播放向东发射弹弓的动画，这看起来不会很好。

为了确定用户点击的方向，我们将屏幕分成四个象限:北、南、东和西。我们应该认为所有的用户点击都是相对于玩家的，所以这四个象限都以玩家为中心，如图 8-35 所示。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig35_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig35_HTML.jpg)

图 8-35

基于当前玩家位置的四个象限

我们可以检查用户点击了哪个象限，以确定玩家发射弹弓的方向，以及要播放的正确动画剪辑。

根据玩家的位置将屏幕划分为象限是有意义的，但是我们实际上如何通过编程来确定用户点击了哪个象限呢？

回想一下你高中数学时代的斜率截距形式:

*   *y = mx + b，*

其中:

*m* =斜率(可以是正斜率，也可以是负斜率)

*x* 和 *y* 是一个点的坐标

*b* =是*y*-截距，或直线与*y*-轴相交的点。

这种形式允许我们沿着一条线找到任何一点。正如我们在图 [8-35](#Fig35) 中看到的，我们通过将屏幕分成象限创建了两条线。如果我们想象用户在屏幕上的任何一点点击鼠标，我们可以想象另一组两条线从点击的点出现。

诀窍是:我们可以根据鼠标点击的正斜线是在玩家的正斜线之上还是之下来确定用户点击了哪个象限。同样，我们检查鼠标点击的负斜线是高于还是低于玩家的负斜线。

看一下图 [8-36](#Fig36) 以获得可视化的帮助。记住向上倾斜的线有一个正斜率，向下倾斜的线有一个负斜率。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig36_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig36_HTML.jpg)

图 8-36

点击西象限

两条斜率相等的直线意味着它们彼此平行。

为了检查一条线是否在另一条线之上，斜率相等，我们简单地比较它们的*y*-截距。如图 [8-36](#Fig36) 所示，如果鼠标点击线的*y*-截距在负玩家线之下，但在正玩家线之上，则用户点击了西象限。

关于这种方法，有一些事情你应该内化。如果玩家站在屏幕的正中央，每条线都会从一个角走到另一个角。当玩家在场景中移动时，线条也跟着移动。象限的可见大小发生了变化，但是划分屏幕的两条线的斜率保持不变。每条线的斜率保持不变，因为屏幕尺寸永远不会改变——只有她的位置会改变。

当我们编写代码时，我们将重新排列斜率截距形式 *y = mx + b* ，以便更容易比较 *y* 截距。因为我们在比较 *y* 截距，我们需要求解 *b* 。所以重排后的形式是:*b = y–MX。*

让我们继续写代码。

### 斜率法

给定一条直线上的两点，计算直线斜率的标准方程为:*(y2–y1)/(x2–x1)= m*，其中 *m* =斜率。

写出来，那就是:第二个*y*-坐标减去第一个*y*-坐标，除以第二个*x*-坐标减去第一个*x*-坐标。

将以下方法添加到武器类以计算直线的斜率:

```cs
float GetSlope(Vector2 pointOne, Vector2 pointTwo)
{
    return (pointTwo.y - pointOne.y) / (pointTwo.x - pointOne.x);
}

```

### 计算斜率

让我们使用`GetSlope()`方法。将以下内容添加到`Start()`方法中。

```cs
// 1
Vector2 lowerLeft = localCamera.ScreenToWorldPoint(new Vector2(0, 0));
Vector2 upperRight = localCamera.ScreenToWorldPoint(new Vector2(Screen.width, Screen.height));
Vector2 upperLeft = localCamera.ScreenToWorldPoint(new Vector2(0, Screen.height));
Vector2 lowerRight = localCamera.ScreenToWorldPoint(new Vector2(Screen.width, 0));

// 2
positiveSlope = GetSlope(lowerLeft, upperRight);
negativeSlope = GetSlope(upperLeft, lowerRight);

```

```cs
// 1

```

创建四个向量来代表屏幕的四个角。Unity 屏幕坐标(不同于我们用来创建清单和健康栏的 GUI 坐标)从左下角的(0，0)开始。

我们也将每个点在分配之前从屏幕坐标转换到世界坐标。我们这样做是因为我们将要计算的斜率将与玩家相关。玩家在世界空间中移动，世界空间使用世界坐标。正如我们在本章前面所描述的，世界空间是真实的游戏世界，在大小方面没有限制。

```cs
// 2

```

使用`GetSlope()`方法得到每条线的斜率。一条线从左下角到右上角，另一条线从左上角到右下角。因为屏幕尺寸将保持不变，所以斜率也将保持不变。我们计算斜率并将结果保存到一个变量中，这样我们就不必在每次需要时重新计算。

### 比较*y*-截距

在`HigherThanPositiveSlopeLine()`方法中，我们计算鼠标点击是否高于穿过玩家的正斜线。将以下内容添加到武器类。

```cs
bool HigherThanPositiveSlopeLine(Vector2 inputPosition)
{

// 1
    Vector2 playerPosition = gameObject.transform.position;

// 2
    Vector2 mousePosition = localCamera.ScreenToWorldPoint(inputPosition);

// 3
    float yIntercept = playerPosition.y - (positiveSlope * playerPosition.x);

// 4
    float inputIntercept = mousePosition.y - (positiveSlope * mousePosition.x);

// 5
    return inputIntercept > yIntercept;
}

```

```cs
// 1

```

为清晰起见，保存对当前`transform.position`的引用。这个脚本附加到玩家对象，所以这将是玩家的位置。

```cs
// 2

```

将鼠标位置`inputPosition`转换到世界空间并保存一个参考。

```cs
// 3

```

稍微重排一下 *y = mx + b* 来求解 *b* 。这将很容易比较每条线的*y*-截距。这条线上的形式是:*b = y–MX。*

```cs
// 4

```

使用重新排列的形式:*b = y–MX*，找到`inputPosition`(鼠标)创建的正斜线的*y*-截距。

```cs
// 5

```

比较鼠标点击的*y*-截距和穿过玩家的线的*y*-截距，如果鼠标点击更高则返回。

### HigherThanNegativeSlopeLine()

除了我们将鼠标点击的 *y* 截距与穿过播放器的负斜线进行比较之外，`HigherThanNegativeSlopeLine()`方法与`HigherThanPositiveSlopeLine()`相同。将以下内容添加到武器类。

```cs
bool HigherThanNegativeSlopeLine(Vector2 inputPosition)
{
    Vector2 playerPosition = gameObject.transform.position;
    Vector2 mousePosition = localCamera.ScreenToWorldPoint(inputPosition);

    float yIntercept = playerPosition.y - (negativeSlope * playerPosition.x);

    float inputIntercept = mousePosition.y - (negativeSlope * mousePosition.x);

    return inputIntercept > yIntercept;
}

```

我们将放弃对`HigherThanNegativeSlopeLine()`方法的解释，因为它与前面的方法几乎相同。

### GetQuadrant()方法

`GetQuadrant()`方法负责确定用户点击了四个象限中的哪一个，并返回一个`Quadrant`。它利用了我们之前编写的`HigherThanPositiveSlopeLine()`和 HigherThanNegativeSlopeLine()方法。

```cs
// 1
Quadrant GetQuadrant()
{

// 2
    Vector2 mousePosition = Input.mousePosition;
    Vector2 playerPosition = transform.position;

// 3
    bool higherThanPositiveSlopeLine = HigherThanPositiveSlopeLine(Input.mousePosition);

    bool higherThanNegativeSlopeLine = HigherThanNegativeSlopeLine(Input.mousePosition);

// 4
    if (!higherThanPositiveSlopeLine && higherThanNegativeSlopeLine)
    {

// 5
        return Quadrant.East;
    }
    else if (!higherThanPositiveSlopeLine && !higherThanNegativeSlopeLine)
    {
        return Quadrant.South;
    }
    else if (higherThanPositiveSlopeLine && !higherThanNegativeSlopeLine)
    {
        return Quadrant.West;
    }
    else
    {
        return Quadrant.North;

    }
}

```

```cs
// 1

```

返回描述用户点击位置的象限。

```cs
// 2

```

抓取用户点击位置和当前玩家位置的引用。

```cs
// 3

```

检查用户是否单击了正斜线和负斜线的上方(高于)。

```cs
 // 4

```

如果用户的点击不高于正斜线，但高于负斜线，则用户点击了东象限。如果这还不太有意义，请回头参考图 [8-36](#Fig36) 。

```cs
// 5

```

返回`Quadrant.East`枚举。

其余的 if 语句检查剩余的三个象限并返回它们各自的`Quadrant`值。

### UpdateState()方法

`UpdateState()`方法检查玩家是否开火，检查用户点击了哪个象限，并更新 Animator 以便混合树可以显示正确的动画剪辑。

```cs
void UpdateState()
{

// 1
    if (isFiring)
    {

// 2
        Vector2 quadrantVector;

// 3
        Quadrant quadEnum = GetQuadrant();

// 4
        switch (quadEnum)
        {

// 5
            case Quadrant.East:
                quadrantVector = new Vector2(1.0f, 0.0f);
                break;
            case Quadrant.South:
                quadrantVector = new Vector2(0.0f, -1.0f);
                break;
            case Quadrant.West:
                quadrantVector = new Vector2(-1.0f, 1.0f);
                break;
            case Quadrant.North:
                quadrantVector = new Vector2(0.0f, 1.0f);
                break;
            default:
                quadrantVector = new Vector2(0.0f, 0.0f);
                break;
        }

// 6
        animator.SetBool("isFiring", true);

// 7
        animator.SetFloat("fireXDir", quadrantVector.x);
        animator.SetFloat("fireYDir", quadrantVector.y);

// 8
        isFiring = false;

    }
    else
    {

// 9
        animator.SetBool("isFiring", false);
    }
}

```

```cs
// 1

```

在`Update()`方法中，我们检查用户是否点击了鼠标按钮。如果是，变量`isFiring`被设置为等于`true`。

```cs
// 2

```

创建一个`Vector2`来保存我们将传递给混合树的值。

```cs
// 3

```

调用`GetQuadrant()`来确定用户点击了哪个象限，并将结果分配给`quadEnum`。

```cs
// 4

```

打开象限(`quadEnum`)。

```cs
// 5

```

如果`quadEnum`是东，在新的`Vector2`中给`quadrantVector`赋值(1，0)。

```cs
// 6

```

将动画师内部的`isFiring`参数设置为`true`，这样它会过渡到火焰混合树。

```cs
// 7

```

将 animator 中的`fireXDir`和 fireYDir 变量设置为用户点击的象限的相应值。这些变量将被火焰混合树拾取。

```cs
// 8

```

将`isFiring`设置回 false。动画将在停止之前一直播放，因为我们将过渡中的退出时间设置为 1。

```cs
// 9

```

如果`isFiring`为假，将动画器中的`isFiring`参数也设置为`false`。

保存武器脚本并返回到 Unity 编辑器。

按下播放键，在场景周围的各个地方点击鼠标，发射弹弓。请注意玩家动画如何显示她向特定方向发射弹弓，然后返回空闲状态。

## 受损时的 flickr

当一个角色在电子游戏中被损坏时，有一个视觉效果来表示他们已经被损坏是很有帮助的。为了给我们的游戏增加一点光泽，让我们创建一个效果，将任何角色染成红色一会儿，也许是十分之一秒，以显示他们受伤了。这种闪烁效果会在几帧内发生，因此作为协程来实现是有意义的。

打开字符类，并在底部添加以下代码:

```cs
public virtual IEnumerator FlickerCharacter()
{

// 1
    GetComponent<SpriteRenderer>().color = Color.red;

// 2
    yield return new WaitForSeconds(0.1f);

// 3
    GetComponent<SpriteRenderer>().color = Color.white;
}

```

```cs
// 1

```

将`Color.red`分配给 SpriteRenderer 组件会将 sprite 染成红色。

```cs
// 2

```

产出执行 0.1 秒。

```cs
// 3

```

默认情况下，SpriteRenderer 使用白色的淡色。将 SpriteRenderer 色调更改回默认颜色。

### 更新玩家和敌人的职业

打开玩家和敌人类，更新每个类中的`DamageCharacter()`方法如下。更新`DamageCharacter()`时，务必将`StartCoroutine`调用添加到`while()`循环的顶部。

```cs
public override IEnumerator DamageCharacter(int damage, float interval)
{
    while (true)
    {

// 1
        StartCoroutine(FlickerCharacter());

              //... Pre-existing code

```

```cs
// 1

```

启动`FlickerCharacter()`协程将字符暂时染成红色。

就这样！按下播放并向敌人发射弹弓。被击中时，它应该会短暂闪烁红色。如果一个敌人设法赶上玩家并伤害她，她也会闪烁红色。

## 为平台而建

在这一节，我们将学习如何编译你的游戏在 Unity 编辑器之外的几个平台上运行。

转到菜单栏中的文件➤构建设置。您应该会看到一个类似图 [8-37](#Fig37) 的屏幕。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig37_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig37_HTML.jpg)

图 8-37

构建设置屏幕

构建设置屏幕允许您选择目标平台，调整一些设置，选择要包含在构建中的场景，然后创建构建。如果您的游戏包含多个场景，请单击“添加开放场景”按钮来添加它们。

我们将选择 Mac OS X，但如果您在 PC 上工作，应该已经选择了它。

按下“构建”按钮。选择二进制文件的名称和保存位置，然后按 save 按钮。Unity 将创建构建，并在成功时通知您。

要玩游戏，请转到您保存游戏的位置，双击图标。当出现图 [8-38](#Fig38) 所示的屏幕时，确保为您使用的计算机选择正确的分辨率。如果你使用错误的分辨率，你的游戏可能会出现起伏。

![img/464283_1_En_8_Chapter/464283_1_En_8_Fig38_HTML.jpg](img/464283_1_En_8_Chapter/464283_1_En_8_Fig38_HTML.jpg)

图 8-38

为您的计算机选择分辨率

该屏幕还允许用户选择图形质量，如果他们有一台旧机器，这很重要。

**按下播放！按钮来玩你的游戏！**

## 退出游戏

天下没有不散的宴席，在某个时候，用户会想要退出你的游戏。在这一节中，我们将学习如何构建允许用户按 Escape 键退出游戏的功能。

当在 Unity 编辑器中玩游戏时，这种游戏结束功能将不起作用——它只适用于当你在编辑器外运行游戏时。

打开 RPGGameManager 类并添加以下内容:

```cs
void Update()
{
    if (Input.GetKey("escape"))
    {
        Application.Quit();
    }
}

```

`Update()`方法将检查每一帧，看用户是否按了退出键。如果是这样，退出应用。

## 摘要

咻——这一章我们讲了很多。您已经使用协程构建了智能追逐行为，并且在这样做的过程中，为玩家构建了第一个真正的挑战。玩家现在可以死亡，需要能够保护自己，所以我们做了一个弹弓，可以向敌人发射弹药。slingshot 利用了一种广泛使用的优化技术，称为对象池。我们利用了一些高中水平的轨迹弧三角学。我们学习了混合树，以及如果我们想在未来添加额外的动画，它们如何帮助我们更好地组织我们的游戏架构和简化状态机。我们也知道了为 PC 或 Mac 开发游戏并在 Unity 之外运行它是多么简单。

你可能对如何改变和改进你的游戏有一些想法。伟大的事情是:你现在有这样做的技能！尝试、打破常规、修补脚本、阅读文档，并检查其他人的代码以从中学习。你能做什么的唯一限制是你愿意投入多少努力。

## 下一步是什么

你可能想知道接下来会发生什么——你如何提高你的游戏开发知识并开发出更好的游戏。一个很好的起点是参与游戏开发者社区。

### 团体

没有人天生是任何方面的专家。成为更好的开发人员的关键是向更有经验的开发人员学习。你永远不想成为房间里最好的开发者。如果你是，确保其他开发人员也很棒，这样你就可以向他们学习。

Meetup.com 是一个寻找每月游戏开发者聚会的好地方。Meetup 也有官方 Unity 用户组 meetup 的列表。可能你所在的城市有一个团结聚会，而你并不知道。世界各地都有官方的 Unity 用户组。如果你所在的城市或城镇没有当地的团结聚会，考虑开一个吧！

Discord 是一款专门为游戏玩家设计的语音和文本聊天应用。这也是一个虚拟会见开发者的好地方。不和谐社区可以回答问题，也可以与社区进行有益的互动。有时游戏开发者会创建他们自己的专用于他们游戏的 Discord 服务器，在那里他们收集反馈，收集 bug 报告，并分发早期版本。

如果不提及 Twitter，任何关于社区的讨论都是不负责任的。Twitter 有助于宣传和营销你的游戏，也有助于联系其他 Unity 开发者。

Reddit 维护了两个对游戏开发者有用的活动子 Reddit:*/r/unity 2d*和 */r/gamedev* 。这些子 reddits 可以是一个很好的地方来发布你的工作演示和收集反馈，以及与其他热情的游戏开发者进行讨论。 */r/gamedev* 子 reddit 也有自己的 Discord 服务器。

### 了解更多信息

Unity 在其网站 [`https://unity3d.com/learn/`](https://unity3d.com/learn/) 上托管了大量频繁更新的教育内容。内容从绝对初学者到高级都有，一定要去看看。

这个网站: [`https://80.lv`](https://80.lv) ，有游戏开发者感兴趣的各种主题的文章。一些文章是 Unity 特有的，而另一些是更通用的技术。

YouTube 也有助于学习新技术，尽管内容质量可能差异很大。在 YouTube 上可以很容易地找到过去 Unity 会议的许多演讲。

### 哪里可以找到帮助

每个人都会在某个时候遇到一个无论如何都无法解决的问题。对于这种情况，有几个重要的资源需要了解。

Unity Answers ( [`https://answers.unity.com`](https://answers.unity.com) )是一个有用的资源，是为问答(Q & A)而不是扩展讨论而构建的。例如，一个问题的标题可能是:“调试这个运动脚本有问题。”

Unity 论坛( [`https://forum.unity.com`](https://forum.unity.com) )是 Unity 员工和其他游戏开发者经常光顾的活跃留言板。论坛旨在围绕主题进行讨论，而不是简单的问答互动。你会发现很多有用的“有什么技术可以优化它”的讨论，比你在 Unity 的回答中发现的更多。

最后， [`https://gamedev.stackexchange.com`](https://gamedev.stackexchange.com) 是 Q & A 网站的栈交换网络的一部分。它不像 Unity 网站那样繁忙，但如果你遇到问题，绝对值得你花时间。

### 游戏堵塞

游戏堵塞是构建视频游戏的黑客马拉松。他们通常有一个时间限制，比如 48 小时，这意味着给参与者施加压力，让他们只关注游戏中必要的东西，同时鼓励他们的创造力。游戏堵塞需要所有类型的参与者:艺术家、程序员、游戏设计师、声音设计师和作家。有时候游戏卡顿会有一个特定的主题，通常会提前保密。

游戏堵塞可以是一种奇妙的方式来满足本地(或远程)游戏开发商，推动自己，扩大你的知识，并带走(希望)一个完成的游戏。全球游戏大赛( [`https://globalgamejam.org`](https://globalgamejam.org) )是一年一度的全球游戏大赛，有世界各地的不同站点和数百名参与者。Ludum Dare ( [`https://ldjam.com`](https://ldjam.com) )是一个每四个月举办一次的周末游戏。如果你想看并制作一些令人惊奇的游戏，这两个游戏都是很好的参与方式。另一个找到在线游戏堵塞的好地方是 itch.io/jams.

### 新闻和文章

Gamasutra.com 是游戏新闻、工作和行业事件的旗手。另一个不错的网站是 indiegamesplus.com，有新闻、评论和对独立游戏开发者的采访。

### 游戏和资产

正如我们在第 [1](1.html) 章中提到的，Unity 资产商店包含数以千计的免费和付费游戏资产，以及脚本、纹理和着色器。关于资产商店，你应该注意的常见批评是，严格使用商店中的资产制作的游戏看起来“千篇一律”

Itch.io 是一个广为人知的发布独立游戏和资源的社区。你可以上传自己制作的游戏，免费玩其他独立游戏，或者通过购买其他开发者的游戏来支持他们。Itch.io 也是为你的游戏购买美术或声音资源的好地方。Gamejolt.com 类似于 itch.io，但完全专注于独立游戏，没有资产。

OpenGameArt.org 有大量用户上传的游戏作品，可以通过各种许可获得。

## 超越！

如果你已经和我在一起这么久了，那么你就有毅力通读一本几百页的编程书。这种坚韧将在游戏编程中很好地为你服务，因为尽管有大量的例子和书籍教授游戏编程的基础知识，但真正独特和有趣的游戏往往包含没有教程的元素。构建有趣的游戏可能非常困难，但很少有其他有创意的冒险是值得的。要想在游戏编程方面做得更好，最重要的是要记住**继续做游戏！游戏开发就像任何其他学科一样——如果你坚持练习，总有一天你会回头看看你开始的地方，让自己大吃一惊。**