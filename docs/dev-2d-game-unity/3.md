# 3.基础

现在我们已经熟悉了 Unity 编辑器，是时候开始制作我们的游戏了。这一章将带你了解如何构造对象和编写游戏代码。我们将讨论 Unity 中使用的软件设计模式，以及计算机科学中的一些高级原则，以及它们如何与制作游戏相关。您还将学习如何在屏幕上控制播放器和播放播放器动画。

## 游戏对象:我们的容器实体

Unity 中的游戏是由场景组成的，一个场景中的所有东西都被称为 GameObject。在你的 Unity 冒险中，你会遇到脚本、碰撞器和其他类型的元素，所有这些都是游戏对象。将游戏对象视为一种容器是有帮助的，它由许多独立实现的功能组成。正如我们在第 [2](2.html) 章中讨论的，游戏对象甚至可以包含父子关系中的其他游戏对象。

我们将创建我们的第一个游戏对象，然后讨论为什么 Unity 使用游戏对象作为构建游戏的一个基本方面。

在层级视图中，选择左上角的创建按钮(图 [3-1](#Fig1) )，然后选择创建空。这在层级视图中创建了一个新的游戏对象。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig1_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig1_HTML.jpg)

图 3-1

在层级视图中创建新游戏对象的一种方法

有几种不同的方法来创建游戏对象。你也可以右击等级视图面板本身，或者去顶部菜单的游戏对象➤创建空白。

右键单击新的游戏对象并选择重命名。称之为“PlayerObject”这个 PlayerObject 将包含我们 RPG 中与勇敢玩家相关的所有逻辑！

制作第二个游戏对象，并将其命名为“敌人对象”这个敌人对象将包含与我们的玩家必须击败的敌人相关的所有逻辑。

当我们学习如何在 Unity 中构建游戏时，我们还将学习计算机科学概念，这些概念将使你成为一名更好的程序员，以及这些概念将如何使你作为游戏开发者的生活更轻松。

## 实体组件设计

计算机科学中有一个概念叫做“关注点分离”关注点分离是一种设计原则，它描述了如何根据软件执行的功能将软件划分为模块。每个模块负责一个应该被该模块完全封装的单一功能“关注点”。当涉及到实现时，关注点可能是一个有点松散和解释性的术语——这些关注点可能广泛到在屏幕上渲染图形的责任，或者具体到计算空间中的一个三角形何时与另一个三角形重叠。

在软件设计中分离关注点的主要动机之一是减少开发人员编写重复或重叠功能时看到的浪费。例如，如果您有在屏幕上呈现图像的代码，您应该只需要编写一次该代码。一个视频游戏会有几十或几百种需要将图形渲染到屏幕上的情况，但开发者只需编写一次代码，就可以在任何地方重用它。

Unity 建立在关注点分离的哲学之上，在游戏编程中有一个非常流行的设计模式，叫做实体-组件设计。实体组件设计倾向于“组合胜于继承”，即对象或“实体”应该通过包含封装特定功能的类的实例来鼓励代码重用。实体通过这些组件类的实例获得对功能的访问。如果使用得当，组合可以减少代码，更容易理解和维护。

这不同于普通的设计方法，在普通的设计方法中，对象从父类继承功能。使用继承的一个缺点是，它会导致继承树变得又深又宽，改变父类中的一件小事会产生连锁反应，带来意想不到的后果。

在 Unity 的实体组件设计中，一个叫做游戏对象的东西就是实体，而组件实际上叫做“组件”Unity 场景中的所有东西都被认为是游戏对象，但是游戏对象本身并不做任何事情。我们在组件中实现我们所有的功能，然后将这些组件添加到我们的游戏对象中，给它们我们想要的行为。向实体添加功能和行为变得像向实体添加组件一样简单。组件本身可以被认为是不同的模块，只关注一件事，与其他关注点和代码无关。

请看下图，以更好地理解我们如何在一个假想的游戏环境中使用实体组件设计。提供行为的组件在顶部的 x 轴上，游戏中的实体在左边的 y 轴上。

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"> <col class="tcol4 align-left"> <col class="tcol5 align-left"></colgroup> 
|   | 

**图形渲染器**

 | 

**碰撞检测**

 | 

**物理整合**

 | 

**音频播放器**

 |
| --- | --- | --- | --- | --- |
| 运动员 | X | X | X | X |
| 敌军 | X | X | X | X |
| 矛(武器) | X | X | X |   |
| 树 | X | X |   |   |
| 村民 | X | X |   | X |

如你所见，玩家和敌人都需要所有四个组件功能。矛武器将需要大部分功能，尤其是投掷时的物理功能，但不需要音频。这棵树不需要物理或音频——只需要图形渲染和碰撞检测来确保任何撞到它的东西都无法穿过它。上例中的村民需要图形和碰撞检测，但他们只是在场景中走动，所以他们不需要物理。如果我们希望我们的游戏播放村民与玩家互动的音轨，他们可能需要音频。

Unity 实体-组件设计并不是没有它的局限性，特别是对于大型项目来说，并且在许多年后已经开始显示出它的年龄。它将在未来被更加面向数据的设计所取代。

现在，让我们将这些新发现的知识付诸实践。

## 组件:构建基块

在层次视图中选择我们的 PlayerObject，注意检查器中的值是如何变化的。您应该会看到类似图 [3-2](#Fig2) 的东西。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig2_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig2_HTML.jpg)

图 3-2

变换组件

Unity 中所有游戏对象通用的一个元素是 Transform 组件，它用于确定场景中游戏对象的位置、旋转和缩放。当我们想移动我们的玩家角色时，我们将在游戏中使用转换组件。

## 鬼怪；雪碧

如果你是游戏开发新手，你可能会问，“什么是精灵？”视频游戏开发环境中的*精灵*只是 2D 的形象。如果你曾经在任天堂上看过*超级马里奥兄弟*(图 [3-3](#Fig3) )，或者玩过像*星谷*(图 [3-4](#Fig4) )、 *Celeste、Thimbleweed Park* 或者 *Terraria* 这样的游戏，你就玩过使用精灵的游戏。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig4_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig4_HTML.jpg)

图 3-4

在这幅星空谷的图像中，鸡、鸭、稻草人、蔬菜、树和所有其他的图像都是独立的精灵

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig3_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig3_HTML.jpg)

图 3-3

超级马里奥兄弟(任天堂)中的英雄水管工马里奥的个人精灵

2D 游戏中的动画效果可以使用类似于制作动画电影、动画或卡通的技术来实现。就像卡通中的单个细胞(帧)一样，精灵会被提前显示并保存到磁盘中。以快速顺序显示单个精灵可以传达运动的印象，例如角色行走、战斗、跳跃或不可避免的死亡。

为了在屏幕上看到玩家角色，我们需要使用 Sprite 渲染器组件来显示图像。我们将把这个精灵渲染器组件添加到玩家游戏对象中。有一些不同的方法来添加一个组件到一个游戏对象，但是我们第一次将使用添加组件按钮。

从检查器中选择添加组件按钮，然后键入“sprite”并选择 Sprite 渲染器(图 [3-5](#Fig5) )。这将组件添加到我们的玩家游戏对象中。相反，我们可以创建一个带有精灵渲染器的游戏对象，方法是转到游戏对象菜单，然后选择 2D 对象➤精灵。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig5_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig5_HTML.jpg)

图 3-5

将精灵渲染器组件添加到玩家游戏对象中

使用相同的技术将 Sprite 渲染器组件添加到 EnemyObject。

保存场景是一个需要养成的好习惯，所以让我们现在就保存场景。键入 Control (PC) / CMD (Mac) + s，然后新建一个文件夹，命名为“Scenes”。将场景保存为“LevelOne”。我们已经创建了一个新的文件夹来保存这个场景以及我们将为游戏创建的其他场景。

接下来，在项目视图中创建一个名为“Sprites”的文件夹。正如您可能已经猜到的，这将保存我们项目的所有 sprite 资产。在这个精灵文件夹下创建另一个名为“玩家”和“敌人”的文件夹。在项目视图中选择 Sprites 文件夹，然后转到下载目录中的文件夹，桌面，或者任何你放有本书下载的游戏资源的解压缩文件夹的地方。

在为第 3 章下载的资源中，选择名为 Player.png、EnemyWalk_1.png 和 EnemyIdle_1.png 的文件，并将它们拖到项目视图的 Sprites 文件夹中。一旦它们在主精灵文件夹中，把它们拖到各自的玩家和敌人文件夹中。你的项目视图应该类似于图 [3-6](#Fig6) 。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig6_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig6_HTML.jpg)

图 3-6

添加播放器精灵表后的项目视图。敌人的精灵在敌人文件夹里

现在在项目视图中选择播放器精灵表。注意它的属性是如何出现在右边的检查器中的。我们将在检查器中配置资产导入设置，然后使用精灵编辑器将这个精灵表分割成单独的精灵。

设置纹理类型为“精灵(2D 和用户界面)”，选择精灵模式下拉选择器，并选择“多个”这表明该子画面资产中有多个子画面。

将每单位像素更改为 32。当我们谈论相机时，我们将解释每单位像素或 PPU 设置。

将滤镜模式更改为“点(无滤镜)”这将使精灵纹理在近处看起来呈块状，这对于我们艺术作品的像素化外观来说是完美的。

在底部，按下默认按钮，选择“无”进行压缩。

再次检查检查器中的属性是否与图 [3-7](#Fig7) 相匹配。

按下“应用”按钮来应用我们的更改，然后按下检查器中的“精灵编辑器”按钮。是时候把我们的精灵表分割成精灵了。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig7_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig7_HTML.jpg)

图 3-7

播放器精灵表的属性，如检查器中所示

Unity 引擎中内置的精灵编辑器工具非常方便地获取由许多精灵组成的精灵表，并将它们分割成单独的精灵资产。

选择左上角的“切片”，并选择“按单元格大小划分网格”作为类型。这允许我们设置切片的尺寸。对于像素大小，分别为 X 和 Y 输入 32 和 32。

按下“切片”按钮。如果你仔细观察图 [3-8](#Fig8) ，你会看到一条模糊的白线勾勒出我们每个玩家精灵的轮廓。这条白线表示 sprite 工作表被切片的位置。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig8_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig8_HTML.jpg)

图 3-8

为导入的播放器精灵表设置像素大小

现在按下“应用”按钮，将切片应用到精灵表。关闭精灵编辑器。

我们能够输入这个 sprite 工作表的精确尺寸，因为我们提前知道它们。当你在自己的游戏中工作时，你会遇到各种尺寸的精灵，你可能不得不调整一下尺寸以使它们恰到好处。Unity Sprite 编辑器还能够自动检测导入的 Sprite 表中的 sprite 尺寸，方法是在 sprite 编辑器➤切片菜单中选择“自动”。根据您使用的 sprite 工作表，这种技术可能会产生不同的结果，但这是一个起点。

那些切片和切块对我们有什么好处？单击播放器精灵表旁边的小三角形，查看从精灵表中提取的所有单个精灵(图 [3-9](#Fig9) )。我们将使用新切割的玩家精灵创建一些动画。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig9_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig9_HTML.jpg)

图 3-9

从播放器精灵表得到的切片精灵

让我们把这些精灵的工作。选择播放器对象。在检查器视图中，一直到 Sprite 属性的右边，你会看到一个小圆圈(图 [3-10](#Fig10) )。点击该圆圈，调出精灵选择器屏幕，如图 [3-11](#Fig11) 所示。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig10_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig10_HTML.jpg)

图 3-10

按此按钮调出选择精灵屏幕

在精灵选择器屏幕中，双击选择一个玩家精灵，当我们编辑我们的游戏时，作为我们的 PlayerObject 在场景中的替身(图 [3-11](#Fig11) )。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig11_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig11_HTML.jpg)

图 3-11

当游戏停止时，选择一个玩家精灵来代表我们的玩家

现在我们有了所有的玩家精灵，让我们导入敌人的精灵表。选择“enemy idle _ 1”sprite 工作表，并在检查器中将其导入设置设置为与我们的 PlayerObject 相同:

*   纹理类型:精灵(2D 和用户界面)

*   精灵模式:多重

*   每单位像素:32

*   过滤器模式:点(无过滤器)

*   压缩:无

按下应用按钮。

使用 sprite 编辑器将 sprite sheet 分割成单个 32 × 32 像素的 Sprite。确保白色切片线出现在正确的位置，然后按下应用按钮并关闭精灵编辑器。对“EnemyWalk_1”精灵表执行相同的步骤，将其分割为单个精灵。

## 动画片

让我们创建一个新文件夹来保存我们将要创建的动画。你还记得怎么做吧？从项目视图中选择资产，右键单击，然后选择创建➤文件夹。或者，您可以单击项目视图左上角的“创建”按钮。把这个文件夹叫做“动画”。选择动画文件夹，并在其中创建另外两个子文件夹，标题为“动画”和“控制器”。

在项目视图中单击播放器精灵旁边的小箭头，展开播放器精灵。选择第一个玩家精灵—这应该是向东走的玩家的精灵。按住 shift 键选择它旁边的三个精灵。将这四个精灵一起拖动到 PlayerObject 上，如图 [3-12](#Fig12) 所示。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig12_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig12_HTML.jpg)

图 3-12

将精灵拖动到 PlayerObject 上以创建新的动画

将出现一个屏幕，提示您创建新的动画(图 [3-13](#Fig13) )。导航到动画➤动画子目录，我们以前创建的，并保存这个动画为“播放器-步行-东”。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig13_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig13_HTML.jpg)

图 3-13

创建并保存新的动画对象

现在选择 PlayerObject 并查看检查器视图。注意我们有两个新组件(图 [3-14](#Fig14) ):精灵渲染器和动画器。

精灵渲染器组件负责显示或渲染精灵。Unity 还添加了一个 Animator 组件，它包含一个 Animator 控制器，允许播放动画。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig14_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig14_HTML.jpg)

图 3-14

自动添加了两个新组件:精灵渲染器和动画器

将精灵拖动到 PlayerObject 并创建新的动画导致这两个组件被添加到 PlayerObject。

当我们向 PlayerObject 添加动画时，Unity 编辑器足够聪明，知道我们需要某种方式来播放和控制动画。于是它自动创建了一个 Animator 组件来播放动画，并附加了一个动画控制器对象“PlayerObject”。我们也可以按下检查器中的 Add Component 按钮，搜索“Animator”，然后手动添加一个 Animator。

名为“PlayerObject”的动画控制器将默认出现在我们保存“player-walk-east”动画的文件夹中。动画控制器的默认名称是“PlayerObject”(图 [3-15](#Fig15) )，这很容易混淆，因为我们的主玩家游戏对象也被称为“PlayerObject”。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig15_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig15_HTML.jpg)

图 3-15

自动创建的动画控制器:PlayerObject，以及我们的第一个动画对象:player-walk-east

让我们将动画控制器重命名为更具描述性的名称。选择 PlayerObject，按 Enter 键，或右键单击，并将该对象重命名为“PlayerController”。

选择、拖动 PlayerController 对象，并将其移动到我们创建的控制器文件夹中。

双击 PlayerController 对象打开 Animator 窗口。

### 动画师状态机

动画控制器维护一组称为状态机的规则，用于根据玩家所处的状态来确定为关联对象播放哪个动画剪辑。玩家对象使用的状态的一些例子可能是:行走、攻击、空闲、进食和死亡。我们进一步将这些状态划分为方向，因为当我们的玩家在这些状态时，他们可能面向北、南、东或西。这些状态的可视化流程图显示在 Animator 窗口中，如图 [3-16](#Fig16) 所示。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig16_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig16_HTML.jpg)

图 3-16

动画窗口

将动画控制器视为控制动画的“大脑”是很有帮助的。动画状态机中的每个状态都由一个附加到它的动画对象表示。该动画对象包含为该状态播放的实际动画剪辑。动画控制器还维护如何在动画状态之间转换的细节。

正如您在 Animator 窗口中看到的，我们的动画控制器有以下状态:进入状态、任意、退出和我们刚刚添加的状态:玩家-行走-东。当你想转换到一个状态时，使用“任何状态”,例如从任何其它状态“跳转”。

如果您没有看到退出状态，您可能需要稍微滚动窗口来找到它。您也可以使用鼠标或触控板上的滚动按钮来放大和缩小，以便更好地查看事物，并在拖移背景时按住 Option / Alt 键，以便在 Animator 窗口中移动。在任何时候，你都可以随意移动这些动画对象，并以你认为有意义的方式排列它们。

让我们添加其余的动画。回到精灵文件夹，选择接下来的四个精灵。这些是玩家向西行走时使用的精灵。将这四个拖动到 PlayerObject 上，就像我们创建之前的行走动画一样。当创建新的动画保存窗口提示时，键入“球员-步行-西方”并保存到动画➤动画文件夹。你应该看到这个新的动画出现在动画窗口。

按照相同的步骤为其他精灵创建新的动画。请注意，“向南走”和“向北走”动画只有两帧，而不是四帧。将他们的动画命名为“玩家走南”和“玩家走北”，并将它们保存到动画➤动画文件夹中。

此时，你的动画窗口应该类似于图 [3-17](#Fig17) 所示的四个动画对象。这四个动画对象代表四种不同的行走状态，并且也包含对动画剪辑的引用。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig17_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig17_HTML.jpg)

图 3-17

将所有四个玩家行走动画添加到 PlayerObject 后，显示这些动画的 Animator 窗口

我们已经做了所有这些工作，但我们仍然没有任何东西在屏幕上动画。还有最后一步——在层次视图中，选择主相机游戏对象，并将大小属性设置为 1。这是暂时的，所以你可以清楚地看到球员动画。我们将在本书后面解释更多关于相机的内容。

按下工具栏中的播放按钮。如果一切顺利，你会看到我们无畏的玩家在原地疯狂奔跑，如图 [3-18](#Fig18) 所示。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig18_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig18_HTML.jpg)

图 3-18

我们尝到了像素化胜利的甜蜜滋味

让我们让疯狂的玩家慢下来。通过双击 PlayerObject Animator 或选择 Animator 窗口选项卡打开 Animator 窗口。选择“player-walk-east”动画，并将速度值更改为 0.6，如图 [3-19](#Fig19) 所示。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig19_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig19_HTML.jpg)

图 3-19

更改动画速度

然后再次按下 play，观看她以更可持续的速度行走。你可以把这个速度调整到任何你觉得看起来自然的速度。

再次按下播放按钮，停止播放场景。

现在为我们的 EnemyWalk_1 和 EnemyIdle_1 动画创建并保存动画。每个动画都包含五个精灵。命名动画:敌人-步行-1，和敌人-闲置-1。将 EnemyObject 动画控制器重命名为 EnemyController，并将其移动到“动画➤控制器”子文件夹。移动敌人动画到动画➤动画子文件夹。

## 煤矿工人

接下来我们要学习对撞机。碰撞器被添加到游戏对象中，并被 Unity 物理引擎用来确定两个对象之间何时发生碰撞。碰撞器的形状是可调的，它们的形状通常或多或少像它们所代表的物体的轮廓。有时，勾画出一个物体的精确形状在计算上是不允许的，而且通常是不必要的，因为一个物体形状的近似值对于碰撞目的来说已经足够了，并且玩家在运行时无法区分。使用一种称为“原始碰撞器”的碰撞器来近似物体形状也不需要太多处理器。在 Unity 2D 有两种类型的原始对撞机:2D 箱式对撞机和 2D 圆形对撞机。

选择 PlayerObject，然后在检查器中选择“添加组件”按钮。搜索并选择“2D 箱式对撞机”，将 2D 箱式对撞机添加到 PlayerObject 中，如图 [3-20](#Fig20) 所示。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig20_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig20_HTML.jpg)

图 3-20

将长方体碰撞器 2D 添加到 PlayerObject

我们需要知道玩家何时与敌人碰撞，所以也给敌人添加一个 2D 碰撞器。

## 刚体组件

添加到游戏对象的刚体组件允许游戏对象与 Unity 物理引擎交互。这就是 Unity 知道如何对游戏对象施加重力之类的力。刚体也允许你通过脚本对游戏对象施加力。例如，你的游戏可能有一个名为“汽车”的游戏对象，它包含一个刚体。你可以对汽车物体施加一定的力，使其向当前方向移动，这取决于玩家按下的按钮:油门或涡轮。

选择 PlayerObject，单击检查器中的“添加组件”按钮，搜索“刚体 2D”，并将其添加到 PlayerObject。在刚体组件的 Body Type 下拉列表中，选择“ **Dynamic** ”动态刚体将与其他物体相互作用和碰撞。将刚体 2D 的以下属性设置为 0:线性阻力、角阻力和重力比例。将质量设定为 1。

下拉菜单中的第二种体型是**运动学**。运动学刚体 2D 组件不受重力等外部物理力的影响。它们确实有速度，但只有当我们移动它们的变换组件时才会移动，通常是通过脚本。这是一种不同于我们之前描述的通过施加力来移动游戏对象的方法。第三种体型是**静态**，针对游戏中根本不会移动的物体。

选择 EnemyObject，并添加一个动力学类型的刚体 2D 组件。

现在我们已经为玩家和敌人添加了刚体 2D，他们将受到重力的影响。因为我们的游戏使用自上而下的视角，所以让我们关闭重力，这样我们的玩家就不会飞出屏幕。转到编辑➤项目设置➤物理 2D，并将重力 y 的值从–9.81 更改为 0。

## 标签和层

### 标签

标签允许我们在游戏运行时标记游戏对象，以便于参考和比较。

选择播放器对象。在检查器左上方的标签下拉菜单下，选择播放器标签，为我们的 PlayerObject 添加一个标签，如图 [3-21](#Fig21) 所示。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig21_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig21_HTML.jpg)

图 3-21

在检查器中选择播放器标签，将其分配给我们的 PlayerObject

玩家标签是 Unity 中每个场景的默认标签，但是你也可以根据需要添加标签。

创建一个名为“敌人”的新标签，并使用它来设置 EnemyObject 标签。随着游戏的发展，我们将为其他物品添加标签。

### 层

层用于定义游戏对象的集合。这些集合用于冲突检测，以确定哪些层相互了解，从而可以进行交互。然后，我们可以在脚本中创建逻辑，以确定当两个游戏对象发生冲突时该做什么。正如我们在图 [3-22](#Fig22) 中看到的，我们想要创建一个新的“用户层”叫做“阻塞”。在用户第 8 层字段中键入“阻塞”。

选择层下拉菜单，然后选择“添加层”你应该会看到图层窗口如图 [3-22](#Fig22) 所示。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig22_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig22_HTML.jpg)

图 3-22

“层”窗口

现在再次选择 PlayerObject 以在检查器中查看其属性。从下拉菜单中选择我们刚刚创建的阻塞层(见图 [3-23](#Fig23) )将我们的 PlayerObject 添加到该层。选择 EnemyObject，并在检查器中将图层设置为“阻挡”。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig23_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig23_HTML.jpg)

图 3-23

从下拉菜单中选择阻挡层

稍后，我们将配置我们的游戏，以强制某些游戏对象不能通过阻挡层中的任何对象。例如，玩家将会在阻挡层中，任何墙、树或敌人也是如此。敌人不能穿过玩家，玩家也不能穿过任何墙壁、树木或敌人。

### 排序层

现在让我们看一个不同类型的层:排序层。排序层不同于常规层，因为它们允许我们告诉 Unity 引擎我们在屏幕上的各种 2D 精灵应该以什么顺序“渲染”或绘制。因为排序层与渲染相关，所以您总是会在渲染器组件中看到排序层下拉菜单。

为了更好地理解我们所说的精灵渲染的“顺序”，请看一下点击式冒险*树莓公园*图 [3-24](#Fig24) 中的截图。截图显示两个玩家角色站在一个房间里。我们可以在房间里看到各种各样的家具，如文件柜和桌子。在*树莓公园*的截图中，女侦探雷探员似乎正站在文件柜前。这个效果是在游戏引擎渲染文件柜之后，通过渲染代理人雷的精灵来完成的。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig24_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig24_HTML.jpg)

图 3-24

Thimbleweed Park 的截图，显示人物站在对象前面

Thimbleweed Park 使用自己专有的游戏引擎，而不是 Unity，但所有引擎都必须有某种逻辑来描述渲染像素的顺序。

在我们的 RPG 游戏中，我们将从上往下看，也就是所谓的“正交”视角。当我们谈到相机时，我们会更多地讨论这意味着什么，但现在我们知道我们希望 Unity 首先为地面绘制像素，然后是地面上的任何角色，如玩家或敌人，所以这些角色看起来像是在地面上行走。

我们将添加一个名为“角色”的分类层，我们将为我们的玩家和所有的敌人使用。

在检查器的精灵渲染器组件中，选择排序层下拉菜单，选择“添加排序层”，如图 [3-25](#Fig25) 所示。我们创建的排序层将在整个游戏中可用，即使我们是从 PlayerObject 的菜单中创建的。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig25_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig25_HTML.jpg)

图 3-25

添加排序层

添加一个名为“Characters”的排序层(图 [3-26](#Fig26) ，然后再次点击 PlayerObject 查看其检查器，并从排序层下拉菜单中选择我们新的 Characters 排序层，如图 [3-27](#Fig27) 所示。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig27_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig27_HTML.jpg)

图 3-27

在我们的 PlayerObject 中使用新的字符排序层

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig26_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig26_HTML.jpg)

图 3-26

添加一个名为 Characters 的新排序层

选择我们的 EnemyObject 并设置它的排序层为 Characters，因为我们希望敌人也能被渲染在地面瓷砖上。

## 简介:预设

Unity 允许你构建嵌入组件的游戏对象，然后用这个游戏对象创建一个叫做“预置”的东西。预设可以被认为是预先制作的模板，你可以从中创建或“实例化”已经制作好的游戏对象的新副本。这个资源有一个非常有用的特性，允许你通过改变预设模板来一次编辑所有的预设。另一方面，你可以选择改变一个单独的预置，让其余的和原来的一样。

例如，想象一下，如果你有一个玩家在酒馆里的场景。酒馆里有许多道具，如椅子、桌子和啤酒杯。如果你为所有这些道具创建了单独的游戏对象，它们中的每一个都可以独立编辑。如果您想要更改每个表的某个属性，例如，将表的颜色从浅色改为深色，您必须选择并编辑每个表，然后更改该属性。如果表对象是预置实例，你只需要改变单个对象——预置——的属性，然后点击按钮，将改变应用到从预置派生的所有实例。

我们将在构建游戏的过程中不断使用这种简单的预置技术。

从游戏对象中创建一个预置真的很容易。首先，在项目视图的资产文件夹下创建一个预置文件夹。然后从层次视图中选择我们的 PlayerObject，并简单地把它拖到我们的 Prefabs 文件夹中。

图 [3-28](#Fig28) 中的截图显示了我们将 PlayerObject 放入 Prefabs 文件夹后的预置。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig28_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig28_HTML.jpg)

图 3-28

通过拖动任何游戏对象到预设文件夹来创建一个预设

看一下图 [3-28](#Fig28) 中的层级视图。您会注意到 PlayerObject 文本是浅蓝色的。这表明 PlayerObject 是基于预设的。这也意味着接下来，如果你对玩家对象预设做了任何更改，并且你想将更改应用到预设的所有实例，你需要在项目视图中选择游戏对象时按下检查器中的应用按钮(见图 [3-29](#Fig29) )。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig29_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig29_HTML.jpg)

图 3-29

按下“应用”按钮，将对玩家对象所做的任何更改应用到预设的所有实例

您现在可以安全地从层次视图中删除 PlayerObject，因为我们现在有了一个预置的 PlayerObject，我们可以随时使用它来重新创建 PlayerObject。如果你想编辑预设的所有实例，只需将预设对象拖回层次视图并进行更改，然后按应用。

对 EnemyObject 执行相同的操作:将其拖动到 Prefabs 文件夹中，并从层次视图中删除原始的 EnemyObject。

现在是再次保存我们的场景的好时机，所以一定要这样做。

## 脚本:组件的逻辑

所以我们有玩家对象和敌人对象。让他们动起来。选择我们的 PlayerObject 预置，并将其拖入层次视图。您会注意到，检查器再次填充了 PlayerObject 的属性。

滚动到检查器的底部，然后按下“添加组件”按钮。输入单词， *script* ，选择“New Script”。将新脚本命名为“MovementController”，如图 [3-30](#Fig30) 所示。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig30_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig30_HTML.jpg)

图 3-30

将新脚本命名为:“MovementController”

在项目视图中创建一个名为“脚本”的新文件夹。新脚本将会在项目视图的顶层 Assets 文件夹中创建。将 MovementController 脚本拖到 Scripts 文件夹中，然后双击它以在 Visual Studio 中打开它。

是时候编写我们的第一个脚本了。Unity 中的脚本是用一种叫做 C#的语言编写的。一旦你在 Visual Studio 中打开了我们的 MovementController 脚本，它应该类似于图 [3-31](#Fig31) 。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig31_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig31_HTML.jpg)

图 3-31

Visual Studio 中的 MovementController 脚本

### 注意

直到最近，Unity 才允许开发人员用两种不同的语言编写脚本:C#和一种类似 JavaScript 的语言“UnityScript”。从 Unity 2017.2 测试版开始，Unity 开始了贬低 UnityScript 的过程，但你可能会在外面找到一些 UnityScript 样本。接下来，你应该只用 C#来为 Unity 写脚本。你可以在 Unity 的博客中了解更多关于弃用的原因:[https://blogs.unity3d.com](https://blogs.unity3d.com)。

让我们来看看典型的 Unity 脚本的结构。接下来的所有行都应该完全按照你看到的样子输入，并且 C#中的每一行都应该以分号结束。编程语言非常字面化，不喜欢省略分号、回车或额外的字母或数字。以//开头的行是注释，只是为了澄清而写的，您不必键入它们。C#中的注释可以用两个正斜杠://或用一个:/*后跟您的注释，并以:*/结束

```cs
// 1
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

// 2
public class MovementController : MonoBehaviour
{

// 3
    // Use this for initialization
    void Start()
    {

    }

// 4
    // Update is called once per frame
    void Update()
    {

    }
}

```

下面是前面每个部分的分类:

```cs
// 1

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

```

命名空间用于组织和控制 C#项目中的类的范围，以避免冲突，并使开发人员的生活更加轻松。使用的关键字**用于描述。NET Framework，并省去开发人员每次使用该命名空间中的方法时都必须键入完全限定名的麻烦。**

例如，如果我们包括系统命名空间，如下例所示:

```cs
using System;

```

而不必输入繁琐的:

```cs
System.Console.WriteLine("Greatest RPG Ever!");

```

我们可以简单地输入较短的版本:

```cs
Console.WriteLine("Greatest RPG Ever!");

```

这是可能的，因为:使用系统；声明阐明了该类文件中的代码将使用 System 命名空间。

C#中的命名空间也是可嵌套的。这意味着您可以在名称空间中引用名称空间，就像在系统中引用集合一样。这是这样写的:

```cs
using System.Collections;

```

UnityEngine 名称空间包含许多特定于 Unity 的类，其中一些我们已经在场景中使用过，比如 MonoBehaviour、GameObject、Rigidbody2D 和 BoxCollider2D。通过声明 UnityEngine 名称空间，我们可以在 C#脚本中引用和使用这些类。

```cs
// 2
public class MovementController : MonoBehaviour

```

对于作为组件附加到场景中游戏对象的类，它需要从 **UnityEngine** 类**monobehavior**继承。通过从 **MonoBehaviour** 继承，一个类可以访问诸如 Awake()、Start()、Update()、LateUpdate()和 OnCollisionEnter()之类的方法，并保证这些方法将在 Unity 事件函数执行周期的某个点被调用。

```cs
// 3
void Start()

```

父 **MonoBehaviour** 类提供的方法之一是 Start()。我们稍后将描述事件函数的执行周期，但是正如您从它的名字可以想象的那样，Start()函数是脚本执行时首先调用的方法之一。如果满足一些条件，则在第一次帧更新之前调用 Start()方法:

1.  该脚本必须从 MonoBehaviour 继承。我们的 MovementController 确实继承了 MonoBehaviour。

2.  该脚本必须在初始化时启用。默认情况下，脚本将被启用，但脚本在初始化时可能未被启用，这可能是一个错误源。

```cs
// 4
void Update()

```

Update()方法每帧调用一次，用于更新游戏行为。因为 Update()每帧调用一次，所以一个每秒 24 帧的游戏每秒将调用 Update() 24 次，但是更新调用之间的时间可能不同。如果您需要方法调用之间的时间一致，那么使用 FixedUpdate()方法。

既然我们已经熟悉了默认的 MonoBehaviour 脚本，请用下面的代码替换 MovementController 类:

```cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class MovementController : MonoBehaviour
{
    //1
    public float movementSpeed = 3.0f;

    // 2
    Vector2 movement = new Vector2();

    // 3
    Rigidbody2D rb2D;

    private void Start()
    {
        // 4
        rb2D = GetComponent<Rigidbody2D>();
    }

    private void Update()
    {
        // Keep this empty for now
    }

    // 5
    void FixedUpdate()
    {

        // 6
        movement.x = Input.GetAxisRaw(“Horizontal”);
        movement.y = Input.GetAxisRaw(“Vertical”);

       // 7
       movement.Normalize();

       // 8
       rb2D.velocity = movement * movementSpeed;

    }
}

// 1
public float movementSpeed = 3.0f;

```

声明一个公共浮动，我们将使用它来调整和设置角色的移动速度。通过将它声明为 public，我们允许这个变量 movementSpeed 在它所连接的游戏对象被选中时出现在检查器中。

看一下图 [3-32](#Fig32) 看看公共变量是如何出现在运动控制器(脚本)部分的检查器中的。Unity 会自动将公共变量的首字母大写，并在首个大写字母前添加一个空格。这意味着“运动速度”将在检查器中显示为“运动速度”。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig32_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig32_HTML.jpg)

图 3-32

公共变量 movementSpeed 以大写形式出现，并带有一个空格

```cs
// 2
Vector2 movement = new Vector2();

```

Vector2 是一种内置的数据结构，用于保存 2D 矢量或点。我们将使用它来表示玩家或敌方角色在 2D 空间中的位置或角色移动的方向。

```cs
// 3
Rigidbody2D rb2D;

```

声明一个变量来保存对 Rigidbody2D 的引用。

```cs
// 4
rb2D = GetComponent<Rigidbody2D>();

```

方法 GetComponent 接受一个类型的参数，并将返回附加到该类型的当前对象的组件(如果附加了一个的话)。我们调用 GetComponent <rigidbody2d>来获取我们在 Unity 编辑器中附加到 PlayerObject 的 Rigidbody2D 组件的引用。我们将使用这个组件来移动玩家。</rigidbody2d>

```cs
// 5
FixedUpdate()

```

正如我们在前面几页所讨论的，Unity 引擎以固定的时间间隔调用 FixedUpdate()。这与每帧调用一次的 Update()方法形成对比。在较慢的硬件设备上，游戏帧速率可能会降低，在这种情况下，Update()的调用频率可能会降低。

```cs
// 6
movement.x = Input.GetAxisRaw("Horizontal");
movement.y = Input.GetAxisRaw("Vertical");

```

Input 类为我们提供了几种捕捉用户输入的方法。我们使用 GetAxisRaw()方法捕获用户输入，并将这些值分配给 Vector2 结构的 *x* 和 *y* 值。GetAxisRaw()方法接受一个参数，该参数指定我们感兴趣的 2D 轴是水平的还是垂直的，并从 Unity 输入管理器中检索-1、0 或 1 并返回它。

“1”表示按下了右键或“d”(使用常见的 w、a、s、d 输入配置)，而“-1”表示按下了左键或“a”。“0”表示没有按下任何键。这个输入键映射可以通过 Unity 输入管理器配置，我们将在后面解释。

```cs
// 7
movement.Normalize();

```

这将使我们的向量“正常化”,并使玩家以相同的速度移动，无论他们是斜向移动、垂直移动还是水平移动。

```cs
// 8
rb2D.velocity = movement * movementSpeed;

```

将 movementSpeed 乘以运动向量将设置附加到 PlayerObject 的刚体 2D 的速度并移动它。

回到 Unity 编辑器，确保你在层次视图中看到我们的 PlayerObject。如果没有，将 PlayerObject 从 Prefabs 文件夹拖动到层次视图中。

还有最后一个非常重要的步骤:我们需要将脚本添加到 PlayerObject 中。

要将脚本添加到我们的 PlayerObject，请将 MovementController 脚本从 Scripts 文件夹拖到层次视图中的 PlayerObject 上，或者在选择 PlayerObject 时将其拖到检查器中。这就是我们如何在 Unity 编辑器中将脚本附加到对象上。当 MovementController 脚本附加到特定对象时，它可以访问 PlayerObject 中的其他组件。

现在按播放键。你应该看到我们的玩家角色在原地行走。按下键盘上的箭头键或 W、A、S、D，看着她四处移动。

恭喜你！你刚刚给曾经只是电子脉冲的东西注入了生命。你知道他们怎么说强大的力量会带来什么吗...

## 状态和动画

### 更多状态机

现在我们知道了如何在屏幕上移动我们的角色，我们将讨论如何基于当前玩家状态在动画之间切换。

转到“动画➤控制器”文件夹，双击 PlayerController 对象。您应该看到 Animator 窗口，显示我们之前设置的状态机。正如我们之前讨论过的，Unity 的动画状态机允许我们查看所有不同的玩家状态和他们相关的动画片段。

单击并拖动您的动画状态对象，直到它类似于图 [3-33](#Fig33) 中的屏幕，玩家空闲关闭到一边，玩家行走动画组合在一起。当排列它们时，不需要太精确，因为唯一真正重要的是动画状态对象之间的方向箭头。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig33_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig33_HTML.jpg)

图 3-33

Animator 窗口中动画的组织

在图 [3-33](#Fig33) 中，你可以看到玩家向东走的动画状态是橙色的。橙色表示这是这个动画的默认状态。选择然后右键单击“玩家空闲”动画状态，选择“设为图层默认状态”，如图 [3-34](#Fig34) 所示。颜色应该变成橙色。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig34_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig34_HTML.jpg)

图 3-34

右键单击并选择“设置为层默认状态”,将播放器空闲动画设置为默认动画

我们希望 player-idle 成为默认状态，因为当我们没有触摸方向键时，我们希望玩家在空闲状态下面朝南。这将看起来好像玩家角色正在等待用户。

现在选择并右键单击“任何状态”，然后选择“进行转换”将出现一条带箭头的线，连接到鼠标并围绕鼠标。点击“玩家向东走”来创建任意状态对象和玩家向东走之间的过渡。

如果你做的正确，它看起来应该如图 [3-35](#Fig35) 所示。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig35_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig35_HTML.jpg)

图 3-35

创建一个从任何状态到玩家东行的过渡

现在对其余的动画状态执行相同的操作:右键单击任意状态，创建过渡，并选择每个动画状态来创建过渡。正如我们前面提到的，当你想转换到一个状态时，使用“任何状态”，比如从任何其他状态“跳转”。

您应该创建总共五个白色过渡箭头，从任意状态指向所有四个玩家行走动画状态和玩家空闲动画状态。还应该有一个橙色的默认状态箭头，从进入动画状态指向玩家空闲动画状态，如图 [3-36](#Fig36) 所示。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig36_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig36_HTML.jpg)

图 3-36

创建从任何状态到所有动画状态的转换

### 动画参数

为了使用这些转换和状态，我们想要创建一个动画参数。动画参数是在动画控制器中定义的变量，由脚本用来控制动画状态机。

我们将使用我们在过渡和 MovementController 脚本中创建的动画参数来控制 PlayerObject，并让她在屏幕上走动。

选择 Animator 窗口左侧的参数选项卡(图 [3-37](#Fig37) )。按下加号并从下拉菜单中选择“Int”(图 [3-38](#Fig38) )。将创建的动画参数重命名为“AnimationState”(图 [3-39](#Fig39) )。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig39_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig39_HTML.jpg)

图 3-39

将动画参数命名为:AnimationState

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig38_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig38_HTML.jpg)

图 3-38

从下拉菜单中选择 Int

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig37_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig37_HTML.jpg)

图 3-37

动画窗口中的“参数”标签

我们将设置动画参数在每个过渡到一个特定的条件。如果在游戏过程中这个条件为真，那么动画师将转换到那个动画状态，相应的动画片段将会播放。因为此 Animator 组件附加到 PlayerObject，所以动画剪辑将显示在场景中变换组件的位置。我们使用一个脚本将这个动画参数条件设置为真，并触发状态转换。

选择将任何州连接到 player-walk-east 州的白色过渡线。在检查器中，更改设置，使其与图 [3-40](#Fig40) 相匹配。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig40_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig40_HTML.jpg)

图 3-40

在检查器中配置转场

我们希望取消选中诸如退出时间、固定持续时间和可以过渡到自我等框。确保将过渡持续时间(%)设置为 0，并将中断源设置为“当前状态，然后是下一个状态”

取消选中“退出时间”,因为我们希望在用户按下不同的键时中断动画。如果我们选择了退出时间，那么在下一个动画开始之前，动画必须播放到退出时间框中输入的百分比，这将导致玩家体验不佳。

在检查器的底部，您会看到一个标题为“条件”的区域点击右下角的加号，选择 AnimationState，Equals，输入 1(图 [3-41](#Fig41) )。我们刚刚创建了一个条件，它说:如果名为“AnimationState”的动画参数等于 1，那么进入这个动画状态并播放动画。这就是我们如何从将要编写的脚本中触发状态变化。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig41_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig41_HTML.jpg)

图 3-41

设置动画参数的条件:AnimationState

### 注意

很容易不小心将 AnimationState 下拉框中的“Greater”改为“Equals ”,所以要小心这一点。如果不将条件设置为 Equals，我们的转换将无法正常工作。

我们要做的下一件事是在脚本中将 AnimationState 参数设置为 1。回到 Visual Studio 和我们的 MovementController.cs 脚本。

将 MovementController 类替换为:

```cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class MovementController : MonoBehaviour
{
    public float movementSpeed = 3.0f;
    Vector2 movement = new Vector2();

// 1
    Animator animator;

// 2
    string animationState = "AnimationState";
    Rigidbody2D rb2D;

// 3
    enum CharStates
    {
        walkEast = 1,
        walkSouth = 2,
        walkWest = 3,
        walkNorth = 4,

        idleSouth = 5
    }

    private void Start()
    {
// 4
        animator = GetComponent<Animator>();
        rb2D = GetComponent<Rigidbody2D>();
    }

    private void Update()
    {

// 5
        UpdateState();
    }

    void FixedUpdate()
    {

// 6
        MoveCharacter();
    }

    private void MoveCharacter()
    {
        movement.x = Input.GetAxisRaw("Horizontal");
        movement.y = Input.GetAxisRaw("Vertical");

        movement.Normalize();
        rb2D.velocity = movement * movementSpeed;
    }

    private void UpdateState()
    {
// 7
        if (movement.x > 0)
        {
            animator.SetInteger(animationState, (int)CharStates.walkEast);
        }
        else if (movement.x < 0)
        {
            animator.SetInteger(animationState, (int)CharStates.walkWest);
        }
        else if (movement.y > 0)
        {
            animator.SetInteger(animationState, (int)CharStates.walkNorth);
        }
        else if (movement.y < 0)
        {
            animator.SetInteger(animationState, (int)CharStates.walkSouth);
        }
        else
        {
            animator.SetInteger(animationState, (int)CharStates.idleSouth);
        }
    }
}

// 1
Animator animator;

```

我们创建了一个名为“animator”的变量，稍后我们将使用它来存储一个对游戏对象中 Animator 组件的引用，这个脚本是附加到这个对象上的。

```cs
// 2
string animationState = "AnimationState";

```

将一个字符串直接输入到将要使用它的代码中称为“硬编码”值。当不可避免的输入错误发生时，这也是一个常见的错误来源，所以让我们通过只输入一次来避免这种可能性，然后在需要引用字符串时使用变量。

```cs
// 3
enum CharStates

```

数据类型“enum”用于声明一组枚举常数。每个枚举常数对应于一个基础类型值，如 int (integer)，您可以引用枚举来获取相应的值。

这里我们声明了一个名为 CharStates 的枚举，并使用它来映射角色的各种状态(向东走，向南走，等等)。)以及相应的 int。我们将很快使用这个 int 值来设置我们的动画状态。

```cs
// 4
animator = GetComponent<Animator>();

```

在这个脚本附加的游戏对象中获取一个动画组件的引用。我们希望保存这个组件引用，这样我们以后就可以通过这个变量快速访问它，而不必每次需要时都检索它。使用 GetComponent 是从脚本中访问其他组件的最常见方式。您甚至可以用它来访问其他脚本。

```cs
// 5
UpdateState();

```

调用我们编写的方法来更新动画状态机。我们将这种逻辑移到了一个单独的方法中，以保持代码库的整洁和易读性。单个方法中的代码越多，就越难阅读。越难阅读的代码越难调试、测试和维护。

```cs
// 6
MoveCharacter();

```

我们已经移动了代码，将播放器移动到另一个方法中，以保持代码的整洁和可读性。

```cs
// 7

```

这一系列 if-else-if 语句将决定我们对`Input.GetAxisRaw()`的调用是返回-1、0 还是 1，并相应地移动字符。

例如:

```cs
        if (movement.x > 0)
        {
            animator.SetInteger(animationState, (int)CharStates.walkEast);
        }

```

如果沿 *x* 轴的移动大于 0，则玩家按下向右键。

我们想告诉 Animator 对象应该将状态改为 walk-east，所以我们调用`SetInteger()`方法来设置我们之前创建的动画参数的值，并触发状态的转换。

`SetInteger()`接受两个参数:一个字符串和一个 int 值。第一个值是我们之前在 Unity 编辑器中创建的动画参数(图 [3-42](#Fig42) )

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig42_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig42_HTML.jpg)

图 3-42

我们从脚本中设置这个动画参数

我们在脚本中将这个动画参数的名称方便地存储在一个名为“animationState”的字符串中，并将它作为第一个参数传递给`SetInteger()`。

`SetInteger()`的第二个参数是为 AnimationState 设置的实际值。因为 CharStates 枚举中的每个值都对应一个 int 值，所以当我们键入:

```cs
CharStates.walkEast

```

我们实际上使用了 walkEast 在 enum 中对应的任何值。在这种情况下，walkEast 对应于 1。我们仍然需要通过将(int)写到变量的左边来将它显式地转换为一个 int。我们需要转换枚举的原因超出了本书的范围，但是与 C#语言在幕后实现的方式有关。

保存您的脚本并切换回 Unity 编辑器，这样我们就可以使用所有这些了。选择指向 player-walk-south 的白色过渡箭头，并在“条件”区域中单击加号。选择动画状态，等于，并输入值 2。这个值 2 对应于我们刚刚编写的脚本中枚举的值 2。

现在，为“玩家-向西走”、“玩家-向北走”和所有“玩家-空闲”状态转换箭头逐一选择每个白色转换箭头。通过 Inspector 窗口为它们添加一个条件，并从`CharStates`枚举中输入相应的值:

```cs
enum CharStates
    {
        walkEast = 1,
        walkSouth = 2,
        walkWest = 3,
        walkNorth = 4,

        idleSouth = 5
   }

```

在浏览每个过渡箭头时，请记住取消选中“退出时间”、“固定持续时间”、“可以过渡到自己”等框，并将过渡持续时间(%)设置为 0。

最后一件事，我保证！选择每个玩家行走动画状态对象并将速度调整为 0.6，将每个空闲动画调整为 0.25。这将使我们的球员动画看起来刚刚好。

你现在已经设置了我们游戏所需的大部分玩家动画。按下播放按钮，用箭头键或 W，A，S，d 在屏幕上移动我们的角色。

继续伸展你像素化的腿。

### 小费

如果您忘记了 C#中某个方法的确切参数，Visual Studio 将显示一个有用的弹出窗口，其中包含此信息(图 [3-43](#Fig43) )。您可以按下 return 键来自动完成方法调用。

![img/464283_1_En_3_Chapter/464283_1_En_3_Fig43_HTML.jpg](img/464283_1_En_3_Chapter/464283_1_En_3_Fig43_HTML.jpg)

图 3-43

Visual Studio 显示一个带有方法参数名称和类型的弹出窗口

## 摘要

在这一章中，我们已经介绍了很多制作 Unity 游戏所需的核心知识。我们讲述了 Unity 工作原理背后的一些设计哲学和计算机科学原理。我们介绍了 Unity 中的游戏是如何由场景组成的，场景中的所有东西都是游戏对象。我们了解了碰撞器和刚体组件如何一起工作来确定两个游戏对象何时碰撞，以及 Unity 的物理引擎应该如何处理交互。我们了解了标签是如何在游戏运行时从脚本中引用游戏对象(如 PlayerObject)的。我们添加到工具包中的另一个有用的工具是层，它用于将游戏对象组合在一起。然后，我们可以通过脚本将逻辑强加到这些层上。

我们在本章学到的最有用的概念之一是预置，我们认为它是预制的资源模板，我们用它来创建这些资源的新副本。例如，我们的游戏可能会在游戏过程中出现数百个敌人，甚至是同时出现(如果你真的想要杀死玩家)。我们创建了一个敌人预设，并从该预设实例化了敌人游戏对象的新副本，而不是创建数百个单独的敌人游戏对象。我们已经开始学习如何编写 Unity 脚本，我们将在本书中继续学习这些知识。我们甚至编写了第一个脚本，通过移动 PlayerObject 转换组件让玩家在屏幕上走动。我们的脚本还设置了 Animator 状态机用来控制玩家状态和动画剪辑之间的转换的动画参数。我们在这一章里讲了很多，但是我们才刚刚开始！