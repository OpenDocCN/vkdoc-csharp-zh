# 十、玩家和游戏状态类：第 2 部分

在这一章中，我们将通过观察游戏的大脑来继续回顾游戏的状态类，即`GameState`类。这节课复杂而漫长，深呼吸，做好心理准备。我们有艰巨的工作要做。我们开始吧。

## 课堂回顾:游戏状态

嗯，我们已经设法复习了整个游戏中几乎所有的职业，非常详细，有一些相当不错的演示场景。我们刚刚复习完游戏中最长、最重要的职业之一，我们还有一个同样复杂的职业要复习。`playerState`类通过轨迹交互更新，导致悬停赛车修改器，它还从用户输入接收一些信息。

所有这些数据都由`GameState`类和游戏的 HUD 屏幕组织、共享、存储和呈现。该类负责将活动的悬停赛车连接到游戏的 HUD，以便正确显示所有的修改器、状态字段和通知。这个类还负责管理不同的菜单屏幕和执行游戏状态。我们将遵循下面列出的审查步骤:

1.  列举

2.  静态/常量/只读类成员

3.  类别字段

4.  相关的方法大纲/类头

5.  支持方法详细信息

6.  主要方法详细信息

7.  示范

我们要看的第一个复习部分是枚举部分。

### 枚举:游戏状态

`GameState`类有两个枚举供我们细读。它们用于游戏状态管理和准备赛道。

```cs
public enum GameStateIndex {
   FIRST,
   NONE,
   MAIN_MENU_SCREEN,
   GAME_OVER_SCREEN,
   GAME_PAUSE_SCREEN,
   GAME_PLAY_SCREEN,
   GAME_EXIT_PROMPT
};

public enum GameDifficulty {
   LOW,
   MED,
   HIGH
};

Listing 10-1GameState Enumerations 1

```

列出的第一个枚举`GameStateIndex`，用于帮助管理游戏的当前状态。它也有助于改变状态。在这种情况下，游戏状态代表游戏中唯一的屏幕。例如，开始菜单是一种状态，而帮助菜单和实际游戏是其他游戏状态。请注意，有一个`NONE`状态、`FIRST`状态和每个菜单屏幕状态的条目。列出的下一个枚举是`GameDifficulty`枚举，用于帮助跟踪游戏的当前难度。在下一节中，我们将看看这个类的静态成员。

### 静态/常量/只读类成员:GameState

`GameState`类有一些我们需要查看的静态和只读类成员。让我们来看看。

```cs
private static bool FIRST_RUN = true;
public static bool ON_GUI_SHOW_CAR_DETAILS = false;
public static bool ON_GUI_SHOW_EXIT_BUTTON = false;
public static bool SHOW_WAYPOINT_OUTPUT = false;
public static readonly float START_GAME_SECONDS = 5.0f;

public static readonly float TRACK_HELP_SECONDS = 2.0f;

public static readonly int DEFAULT_TOTAL_LAPS = 10;

Listing 10-2PlayerState Static/Constants/Read-Only Class Members 1

```

`FIRST_RUN`字段是一个布尔标志，表示这是否是游戏的第一次运行。以下字段用于“main 13 演示”场景。如果`ON_GUI_SHOW_CAR_DETAILS`字段设置为真，屏幕上将显示大量玩家和游戏状态信息。下一个字段`ON_GUI_SHOW_EXIT_BUTTON`用于控制调试退出按钮的显示。接下来，`SHOW_WAYPOINT_OUTPUT`字段用于控制航路点调试输出。

`START_GAME_SECONDS`字段控制比赛开始前显示的秒数。类似地，`TRACK_HELP_SECONDS`字段保存显示帮助通知的秒数。最后，`DEFAULT_TOTAL_LAPS`字段用于保存每条赛道的默认圈数。静态/只读类成员审查到此结束。在下一个复习部分，我们将讨论该课程的剩余字段。

### 类别字段:游戏状态

`GameState`类是一个重要的中央集权和国家管理类，因此，它有大量的类字段供我们查看。我们将在这里详细讨论它们。我们将从回顾中省略类的内部变量，因为这些字段被用作局部方法变量。我们有很多材料要讲，所以慢慢来。如果你没有在一次阅读中吸收全部，不要沮丧。可能需要一点时间才能真正适应这门课。让我们看看第一组字段，好吗？

```cs
//***** Class Fields *****
public ArrayList players = null;
public PlayerState p0;
public PlayerState p1;
public PlayerState p2;
public PlayerState p3;
public PlayerState p4;
public PlayerState p5;
public PlayerState currentPlayer = null;

Listing 10-3GameState Class Fields 1

```

`players`字段是一个`ArrayList`实例，用于保存游戏活动玩家的一组`PlayerState`对象实例。这包括人类和人工智能控制的玩家。请注意，该游戏配置为支持六名玩家。最后一个条目是引用当前玩家的`PlayerState`的`currentPlayer`字段。当前玩家是其状态和摄像机插入游戏显示器的玩家。我们要研究的下一组变量是类字段和相关责任的随机分类。

```cs
//***** Internal Variables: Start *****
public int[] positions = null;
public bool sortingPositions = false;
public int currentIndex = 0;
public int player1Index = 0;
public LapTimeManager lapTimeManager = null;
public int totalLaps = DEFAULT_TOTAL_LAPS;
public int gameSettingsSet = 0;    //track type
public int gameSettingsSubSet = 0; //track difficulty
public bool debugOn = false;
public bool forceGameStart = false;
public bool scsMode = false;
private GUIStyle style1 = null;
private GUIStyle style2 = null;
public WaypointCompare wpc = new WaypointCompare();
public ArrayList waypointRoutes = null;

public ArrayList waypointData = null;
public AudioSource audioBgroundSound = null;
private AudioSource audioS = null;
private bool nightTime = false;
private bool player1AiOn = true;
private bool prepped = false;
private bool ready = false;
private bool startGame = false;
private float startGameTime = 0.0f;
public bool gameWon = false;
public bool gameRunning = false;
public bool gamePaused = false;

Listing 10-4GameState Class Fields 2

```

这个集合中列出的第一个字段`positions`是一个整数数组，用于存储悬停赛车的位置索引，并进行正确排序。通过这种方式，可以在索引零处找到比赛中的领先汽车。下一个字段是一个布尔标志，用于指示位置数组当前正在排序。接下来的两个字段看起来是多余的，但是仔细观察，我们会发现它们不是多余的。`currentIndex`字段表示可用玩家数组中当前活动玩家的数组索引。下一个字段`player1Index`，是玩家一的索引，默认为零。因此，虽然这两个字段看起来像是重复的，但请记住，当前玩家的索引可以改变，但玩家 1 的索引将始终为零。

集合中的下一个字段应该是熟悉的。它是`LapTimeManager`类的一个实例，用于管理存储在游戏首选项中的一圈时间。该字段被恰当地命名为`lapTimeManager`。`totalLaps`字段代表当前赛道配置的总圈数。该值根据赛道相关的`TrackScript`、比赛类型和比赛难度进行设置。接下来列出的两个字段，`gameSettingsSet`和`gameSettingSubSet`，是用于设置曲目类型和难度的类别字段。下一个字段`debugOn`用于打开`GameState`类的调试文本。该字段与我们之前讨论过的`ON_GUI_SHOW_CAR_DETAILS`静态类字段一起工作。

`forceGameState`字段是一个布尔标志，用于绕过某些正常的`GameState`类功能，并被大多数游戏演示场景使用。该值通常通过 Unity 编辑器的“检查器”面板设置，并保存为场景配置的一部分。`scsMode`字段用于帮助设置游戏，以便可以在不触发特定菜单屏幕(如游戏暂停菜单屏幕)的情况下拍摄游戏截图。`style1`和`style2`字段是 Unity 的`GUIStyle`类的实例，由类的`OnGUI`方法用来直接在游戏屏幕上显示调试信息。

`wc`类字段是`WaypointCompare`类的一个实例，用于对给定轨迹的路点数组进行排序。下一个字段是一个`ArrayList`实例，存储在当前轨迹上找到的不同的路点路线。我应该提一下，这个游戏，在它目前的状态下，不使用路点路线，所以这个领域不会得到太好的支持。下一个区域`waypointData`用于保存在航迹上发现的所有航路点条目。接下来的两个条目由班级的音频责任使用。第一个是`audioBgroundSound`，用于保存音轨的背景音乐。第二个条目`audioS`，用于保存菜单音效。当菜单屏幕接收到用户输入时，它播放声音效果来指示输入事件。很多情况下，菜单画面会要求游戏状态类播放菜单音效。

随后，接下来的五个类字段是布尔标志，用于指示游戏的当前状态。`nightTime`字段是由轨道的`TrackScript MonoBehaviour`和它的`headLightsOn`字段设置的布尔标志。下一个条目，`player1AiOn`，是一个布尔标志，指示玩家一辆车应该由 AI 控制。这在游戏第一次加载时就出现了,“街机”风格的人工智能竞赛开始了。`prepped`字段用于指示游戏已经通过初始化`players`数组中的所有`PlayerState`实例而被正确准备好。一旦这个标志被设置为 true，对类'`Prep`方法的调用将被转义。

`ready`布尔字段是表示游戏准备开始的标志。`startGame`字段用于指示比赛是否开始，并应启动倒计时定时器。下一个字段`startGameTime`，用于记录比赛开始的倒计时。该集合中的最后三个字段是`gameWon`、`gameRunning`和`gamePaused`布尔标志。`gameWon`区域表示当前玩家已经完成比赛。这并不一定意味着他们排在第一位。随后,`gameRunning`字段表明游戏正在运行，正如您所料。最后，`gamePaused`字段表示游戏正在运行，但已经暂停。

```cs
//***** Track Help Variables *****
public bool trackHelpAccelOn = false;
public float trackHelpAccelTime = 0.0f;
public bool trackHelpSlowOn = false;
public float trackHelpSlowTime = 0.0f;
public bool trackHelpTurnOn = false;
public float trackHelpTurnTime = 0.0f;

//***** Track Settings *****
public int raceTrack = 0;
public bool easyOn = false;
public int raceType = 0;
public int waypointWidthOverride = 6;
public int waypointZeroOverride = 1;
public bool trackHelpOn = false;
private TrackScript trackScript = null;
public GameDifficulty difficulty = GameDifficulty.LOW;
public GameStateIndex gameStateIndex = GameStateIndex.FIRST;

//***** Camera Variables *****
private GameObject blimpCamera = null;
public string sceneName = "";
public Camera gameCamera = null;
public Camera rearCamera = null;

Listing 10-5GameState Class Fields 3

```

前面列出了我们要查看的下一组类字段。该组中的第一组字段是“跟踪帮助变量”组。该组中的第一个字段`trackHelpAccelOn`和随后的条目`trackHelpAccelTime`用于打开帮助通知图像并跟踪其显示持续时间。类似地，下面列出的四个字段用于控制帮助减速和帮助转向通知，如果它们是由当前玩家触发的话。我们要看的下一组字段是“Track Settings”组。

“轨道设置”组从`raceTrack`字段开始。这个字段是我们当前正在比赛的赛道的数字表示。`easyOn`字段是一个布尔标志，指示当前比赛的难度设置是否为简单。随后的字段`raceType`用于指示当前比赛的模式。接下来的两个字段用于标准化轨迹的航路点的某些方面。`waypointWidthOverride`用于设置当前轨道上航路点的标准宽度。

以类似的方式，`waypointZeroOverride`域用于覆盖 Y 值为零的航路点标记的 Y 位置。`trackHelpOn`字段是一个布尔标志，用于控制音轨是否支持显示帮助通知。接下来的两个条目，`difficulty`和`gameStateIndex`，用于管理赛道的难度设置和游戏的状态。该组中要查看的最后一组字段是相机字段。`blimpCamera`字段是一个`GameObject`实例，用于引用游戏的飞艇摄像机功能。列表中的下一个字段`sceneName`是一个表示当前场景名称的字符串。最后，`gameCamera`和`rearCamera`类字段用于支持游戏的标准和后视摄像头。在结束本复习部分之前，我们还有一组课程字段要复习。

```cs
//***** Menu System Variables *****
private GameObject gamePauseMenu = null;
private GameObject gameStartMenu = null;
private GameObject gameOverMenu = null;
private GameObject gameExitMenu = null;
private GameObject gameHelpMenu = null;
public GameHUDNewScript hudNewScript = null;
public GameOverMenu gameOverMenuScript = null;

//***** Touch screen Variables *****
public bool accelOn = false;
public bool newTouch = false;
public bool touchScreen = false;

//***** Input Variables *****
private bool handleKeyA = false;
private bool handleKeyD = false;
private bool handleKey1 = false;
private bool handleKey2 = false;
private bool handleKey3 = false;
private bool handleKey4 = false;
private bool handleKey5 = false;
private bool handleKey6 = false;

Listing 10-6GameState Class Fields 4

```

该组中的第一组字段是“菜单系统”字段。有五个条目代表游戏支持的不同菜单屏幕。`hudNewScript`字段是对与游戏 HUD 相关联的脚本组件的引用。下一个字段`gameOverMenuScript`是对与菜单屏幕上的游戏相关联的脚本组件的引用。注意，在我们需要更细粒度控制的情况下，我们得到对`MonoBehaviour`实例的引用。在其他情况下，有一个对相关游戏对象的引用就足够了。

在这个组之后，我们有“触摸屏”字段。`accelOn`条目是一个布尔标志，表示触摸屏加速输入处于活动状态。`newTouch`字段指示新的触摸交互正在发生。该组中的最后一个条目`touchScreen`是一个布尔标志，表示触摸屏输入处于活动状态。我们要查看的最后一组字段是“输入”组。这一套不言自明。每个条目启用或禁用某些键盘键的输入。这就引出了“类字段回顾”部分的结论。在下一节中，我们将看看相关的方法大纲和类头回顾部分。

### 相关的方法大纲/类头:GameState

这个`GameState`类的方法大纲有一系列的方法供我们回顾。别担心，我们将在详细的回顾中省略简单的支持方法，以加快速度。我们仍然会在这里列出它们。由于它们很简单，我们就不详细介绍了。让我们开始吧。

```cs
//Main Methods
public void PauseGame();
public void UnPauseGame();
public void FindWaypoints();
public void SetCarDetails();
public void ResetGame();
public void SetCarDetailsByGameType(PlayerState player);

public void SetActiveCar(int j);
public void PrepGame();
public void OnApplicationPause(bool pauseStatus);
void Start();
void Update();

//Support Methods
private int GetOnGuiPosY(int idx, int rowHeight);
public void OnGUI();

//Support Methods Menu Is Showing
private bool AreMenusShowing();
public bool IsHelpMenuShowing();
public bool IsPauseMenuShowing();
public bool IsEndMenuShowing();
public bool IsStartMenuShowing();
public bool IsExitMenuShowing();
public bool IsTrackHelpOn();

//Support Methods Show/Hide Menu
public void HideHelpMenu();
public void ShowHelpMenu();
public void HidePauseMenu();
public void ShowPauseMenu();
public void HideExitMenu();
public void ShowExitMenu();
public void HideStartMenu();
public void ShowStartMenu();
public void HideEndMenu();
public void ShowEndMenu();

//Support Methods Misc. 1
public void PlayMenuSound();
public void PrintWaypoints();
public ArrayList GetWaypoints(int index);
public void ToggleDebugOn();
public void ToggleCurrentCarAi();
private bool PlayerStateIdxCheck(int idx);
public PlayerState GetPlayer1();
public PlayerState GetCurrentPlayer();
public PlayerState GetPlayer(int i);

//Support Methods Track Features On/Off

private void TurnOffArmorMarkers();
private void TurnOnArmorMarkers();
private void TurnOffGunMarkers();
private void TurnOnGunMarkers();
private void TurnOffHealthMarkers();
private void TurnOnHealthMarkers();
private void TurnOffInvincMarkers();
private void TurnOnInvincMarkers();
private void TurnOffHittableMarkers();
private void TurnOnHittableMarkers();
private void TurnOffOilDrumStackMarkers();
private void TurnOnOilDrumStackMarkers();
private void TurnOffFunBoxMarkers();
private void TurnOnFunBoxMarkers();

//Support Methods Misc. 2
private void AdjustTagActive(bool active, string tag);

public void LogLapTime(PlayerState p);
public void StartDemoScene();
public int GetPosition(int idx, int currentPosition);
public void SetPositions();
public int PlayerStateCompare(int i1, int i2);

Listing 10-7GameState Pertinent Method Outline/Class Headers 1

```

花点时间看看与这个类相关的方法。发挥你的想象力，试着想象这个类及其使用的方法。我们一会儿将回顾这些方法。在我们继续之前，让我们看看这个类的 import 语句和声明。

```cs
using System.Collections;
using UnityEngine;
using UnityEngine.SceneManagement;

public class GameState : MonoBehaviour {}

Listing 10-8GameState Pertinent Method Outline/Class Headers 2

```

在接下来的回顾部分，我们将讨论类的支持方法。

### 支持方法详细信息:游戏状态

我们要看的第一组支持方法简单而直接。我把方法列在这里给你看看。由于它们的简单性，我不会详细讨论它们。请确保您在继续之前回顾并理解了这些方法。

```cs
01 private int GetOnGuiPosY(int idx, int rowHeight) {
02    return (idx * rowHeight);
03 }

01 private bool AreMenusShowing() {
02    if (IsStartMenuShowing() == true || IsEndMenuShowing() == true || IsHelpMenuShowing() == true || IsExitMenuShowing() == true) {
03       return true;
04    } else {
05       return false;
06    }
07 }

01 public bool IsHelpMenuShowing() {
02    if (gameHelpMenu != null) {
03       return gameHelpMenu.activeSelf;
04    } else {
05       return false;
06    }

07 }

01 public bool IsPauseMenuShowing() {
02    if (gamePauseMenu != null) {
03       return gamePauseMenu.activeSelf;
04    } else {
05       return false;
06    }
07 }

01 public bool IsEndMenuShowing() {
02    if (gameOverMenu != null) {
03       return gameOverMenu.activeSelf;
04    } else {
05       return false;
06    }
07 }

01 public bool IsStartMenuShowing() {
02    if (gameStartMenu != null) {
03       return gameStartMenu.activeSelf;
04    } else {
05       return false;
06    }
07 }

01 public bool IsExitMenuShowing() {
02    if (gameExitMenu != null) {
03       return gameExitMenu.activeSelf;
04    } else {
05       return false;
06    }
07 }

01 public bool IsTrackHelpOn() {
02    return trackHelpOn;
03 }

01 public void HideHelpMenu() {
02    if (gameHelpMenu != null) {
03       gameHelpMenu.SetActive(false);
04       UnPauseGame();
05    }

06 }

01 public void ShowHelpMenu() {
02    if (gameHelpMenu != null) {
03       gameHelpMenu.SetActive(true);
04       PauseGame();
05    }
06 }

01 public void HidePauseMenu() {
02    if (gamePauseMenu != null) {
03       gamePauseMenu.SetActive(false);
04       UnPauseGame();
05    }
06 }

01 public void ShowPauseMenu() {
02    if (gamePauseMenu != null) {
03       gamePauseMenu.SetActive(true);
04       PauseGame();
05    }
06 }

01 public void HideExitMenu() {
02    if (gameExitMenu != null) {
03       gameExitMenu.SetActive(false);
04       UnPauseGame();
05    }
06 }

01 public void ShowExitMenu() {
02    if (gameExitMenu != null) {
03       gameExitMenu.SetActive(true);
04       PauseGame();
05    }
06 }

01 public void HideStartMenu() {
02    if (gameStartMenu != null) {

03       gameStartMenu.SetActive(false);
04    }
05 }

01 public void ShowStartMenu() {
02    if (gameStartMenu != null) {
03       gameStartMenu.SetActive(true);
04    }
05 }

01 public void HideEndMenu() {
02    if (gameOverMenu != null) {
03       gameOverMenu.SetActive(false);
04    }
05 }

01 public void ShowEndMenu() {
02    if (gameOverMenu != null) {
03       gameOverMenu.SetActive(true);
04    }
05 }

01 public void PlayMenuSound() {
02    if (audioS != null) {
03      audioS.Play();
04    }
05 }

01 public void ToggleDebugOn() {
02    if (debugOn == true) {
03       debugOn = false;
04    } else {
05       debugOn = true;
06    }
07 }

01 private bool PlayerStateIdxCheck(int idx) {
02    if (players != null && idx >= 0 && idx < players.Count) {
03       return true;
04    } else {
05       return false;
06    }
07 }

01 public PlayerState GetPlayer1() {
02    return (PlayerState)players[player1Index];
03 }

01 public PlayerState GetCurrentPlayer() {
02    return (PlayerState)players[currentIndex];
03 }

01 public PlayerState GetPlayer(int i) {
02    if (i >= 0 && i < players.Count) {
03       return (PlayerState)players[i];
04    } else {
05       return null;
06    }
07 }

01 private void TurnOffArmorMarkers() {
02    AdjustTagActive(false, "ArmorMarker");
03 }

01 private void TurnOnArmorMarkers() {
02    AdjustTagActive(true, "ArmorMarker");
03 }

01 private void TurnOffGunMarkers() {
02    AdjustTagActive(false, "GunMarker");
03 }

01 private void TurnOnGunMarkers() {
02    AdjustTagActive(true, "GunMarker");
03 }

01 private void TurnOffHealthMarkers() {
02    AdjustTagActive(false, "HealthMarker");
03 }

01 private void TurnOnHealthMarkers() {
02    AdjustTagActive(true, "HealthMarker");
03 }

01 private void TurnOffInvincMarkers() {
02    AdjustTagActive(false, "InvincibilityMarker");
03 }

01 private void TurnOnInvincMarkers() {
02    AdjustTagActive(true, "InvincibilityMarker");
03 }

01 private void TurnOffHittableMarkers() {
02    AdjustTagActive(false, "Hittable");
03 }

01 private void TurnOnHittableMarkers() {
02    AdjustTagActive(true, "Hittable");
03 }

01 private void TurnOffOilDrumStackMarkers() {
02    AdjustTagActive(false, "OilDrumStack");
03 }

01 private void TurnOnOilDrumStackMarkers() {
02    AdjustTagActive(true, "OilDrumStack");
03 }

01 private void TurnOffFunBoxMarkers() {
02    AdjustTagActive(false, "FullFunBox");
03 }

01 private void TurnOnFunBoxMarkers() {
02    AdjustTagActive(true, "FullFunBox");
03 }

01 public void StartDemoScene() {
02    PlayerPrefs.SetInt("GameStateIndex", 5);
03    PlayerPrefs.Save();
04    ResetGame();
05    SceneManager.LoadScene(SceneManager.GetActiveScene().name);
06 }

01 public int GetPosition(int idx, int currentPosition) {
02    int i = 0;
03    int l = 0;
04    l = positions.Length;
05
06    for (i = 0; i < l; i++) {
07       if (positions[i] == idx) {
08          return (i + 1);
09       }
10    }
11
12    return 6;
13 }

01 public void SetPositions() {
02    sortingPositions = true;
03    System.Array.Sort(positions, PlayerStateCompare);
04    sortingPositions = false;
05 }

Listing 10-9GameState Support Method Details 1

```

前面列出的类支持方法非常简单，所以我将它们留给您自己去回顾。在接下来的支持方法列表中，我们将回顾这些方法来解释它们是如何工作的。这些支持方法稍微复杂一点，所以它们值得更多的关注。我应该很快提到，我没有在主方法列表或支持方法列表中列出`OnGUI`方法。这是因为该方法相当长，除了将调试值打印到屏幕上之外，它没做什么。该方法的审查是可选的。我将把它留给你来判断。

```cs
01 public void PrintWaypoints() {
02    if (waypointData != null && waypointData.Count > 0) {
03       ArrayList data = (ArrayList)waypointData[0];
04       int l = data.Count;
05       WaypointCheck wc = null;
06       for (int j = 0; j < l; j++) {
07          wc = (WaypointCheck)data[j];
08          if (SHOW_WAYPOINT_OUTPUT) {
09             Utilities.wr(j + " Found waypoint: " + wc.waypointIndex + ", Center: " + wc.transform.position);
10          }
11       }

12    }
13 }

01 public ArrayList GetWaypoints(int index) {
02    if (waypointData == null) {
03       return null;
04    } else {
05       if (index >= 0 && index < waypointData.Count) {
06          return (ArrayList)waypointData[index];
07       } else {
08          return null;
09       }
10    }
11 }

01 public void ToggleCurrentCarAi() {
02    PlayerState player;
03    player = GetCurrentPlayer();
04
05    if (player1AiOn == true) {
06       player1AiOn = false;
07    } else {
08       player1AiOn = true;
09    }
10
11    if (player1AiOn == true) {
12       player.aiOn = true;
13       player.cm.aiOn = true;
14       player.fpsInput.aiOn = true;
15       player.mouseInput.aiOn = true;
16       player.offTrackSeconds = 5.0f;
17    } else {
18       player.aiOn = false;
19       player.cm.aiOn = false;
20       player.fpsInput.aiOn = false;
21       player.mouseInput.aiOn = false;
22       player.offTrackSeconds = 10.0f;
23    }
24
25    if (forceGameStart) {
26       player.offTrackSeconds = 10000.0f;
27       player.wrongDirectionSeconds = 10000.0f;
28    }
29 }

Listing 10-10GameState Support Method Details 2

```

前面列出了第一组更复杂的支持方法。我们有两个航路点方法和一个人工智能相关的方法要复习。列出的第一种方法`PrintWaypoints`用于列出所有与默认航路相关的航路点。如果在第 2 行定义并填充了`waypointData`字段，那么我们在该方法的第 3 行加载默认路线的路点。对于找到的数据中的每个航路点，我们打印出其设置的摘要，第 7-10 行。我们要回顾的下一个航路点是`GetWaypoints`方法。如果定义了`waypointData`字段，那么我们为给定的路线索引找到一组路点。如果未定义数据的索引，则该方法返回空值。这一套方法中我们要复习的最后一个方法是`ToggleCurrentAi`法。

这个方法用于切换当前玩家汽车的 AI 状态。注意，AI 标志随后被设置在与当前玩家相关联的所有输入类上。只有当`forceGameStart`布尔值被设置为真时，最后一位代码才会运行。我们设置了一些大的定时值，以防止偏离轨道和错误的方向修改器触发。还有几个支持方法让我们看看。我把它们列在这里。

```cs
01 private void AdjustTagActive(bool active, string tag) {
02    GameObject[] gos = GameObject.FindGameObjectsWithTag(tag);
03    int l = gos.Length;
04    for (int i = 0; i < l; i++) {
05       gos[i].SetActive(active);
06    }
07 }

01 public void LogLapTime(PlayerState p) {
02    string time = p.time;
03    int timeNum = p.timeNum;
04    int lap = p.currentLap;
05    int track = raceTrack;
06    int type = gameSettingsSet;
07    int diff = gameSettingsSubSet;
08
09    LapTime lt = new LapTime();
10    lt.time = time

;
11    lt.timeNum = timeNum;
12    lt.lap = lap;
13    lt.type = type;
14    lt.diff = diff;
15    lt.track = track;
16
17    lapTimeManager.AddEntry(lt);
18    lapTimeManager.CleanTimes();
19    lapTimeManager.FindBestLapTimeByLastEntry();
20    PlayerPrefs.SetString("LapTimes", lapTimeManager.Serialize());
21 }

01 public int PlayerStateCompare(int i1, int i2) {
02    if (!PlayerStateIdxCheck(i1) || !PlayerStateIdxCheck(i2)) {
03       return 0;
04    }
05
06    PlayerState obj1 = (PlayerState)players[i1];
07    PlayerState obj2 = (PlayerState)players[i2];
08
09    if (obj1.currentLap > obj2.currentLap) {
10       return -1;
11    } else if (obj1.currentLap < obj2.currentLap) {
12       return 1;
13    } else {
14       if (obj1.aiWaypointIndex > obj2.aiWaypointIndex) {
15          return -1;
16       } else if (obj1.aiWaypointIndex < obj2.aiWaypointIndex) {
17          return 1;
18       } else {
19          if (obj1.aiWaypointTime < obj2.aiWaypointTime) {
20             return 1;
21          } else if (obj1.aiWaypointTime > obj2.aiWaypointTime) {
22             return -1;
23          } else {
24             return 0;
25          }
26       }
27    }
28 }

Listing 10-11GameState Support Method Details 3

```

前面列出的最后一组支持方法是一个组合组。列出的第一种方法非常有用。`AdjustTagActive`方法用于定位所有具有指定标签的`GameObjects`。这些对象将它们的活动标志设置为第 5 行提供的参数值。下面列出的方法用于将一圈时间添加到玩家的圈时间日志中。在第 2-7 行，根据提供的`PlayerState`值、`p`和赛道的当前配置设置存储圈速所需的值。接下来，在第 9–15 行，创建了一个新的`LapTime`对象实例，并根据准备好的方法变量设置了对象的字段。单圈时间被添加到游戏的单圈时间管理器的第 17 行。第 18 行清除了分段时间，第 19 行的方法调用确定了最佳分段时间。最后，用第 20 行的`lapTimeManager`字段中新的序列化值更新玩家偏好。

我们将在本节中回顾的最后一个方法是`PlayerStateCompare`方法。这种方法用于比较两个玩家，以确定哪个玩家在当前比赛中处于哪个位置。首先，在第 2-4 行检查提供的玩家索引`i1`和`i2`的有效性。在第 9-27 行，两名选手在比赛中的顺序由当前圈决定，然后是当前路点索引，最后是最快圈速。这就是本复习部分的结论。接下来，我们将看看这个类的主要方法。

### 主要方法细节:GameState

`GameState`类有几个主要的方法让我们复习。让我们开始写代码吧！

```cs
01 public void PauseGame() {
02    gamePaused = true;
03    Time.timeScale = 0;
04
05    if (players != null) {
06       iPg = 0;
07       pPg = null;
08       lPg = players.Count;
09       for (iPg = 0; iPg < lPg; iPg++) {
10          pPg = (PlayerState)players[iPg];
11          if (pPg != null) {
12             pPg.PauseSound();
13          }
14       }
15    }
16
17    if (audioBgroundSound != null) {
18       audioBgroundSound.Stop();
19    }
20 }

01 public void UnPauseGame() {
02    gamePaused = false;
03    Time.timeScale = 1;
04
05    if (players != null) {
06       iUpg = 0;
07       pUpg = null;
08       lUpg = players.Count;
09       for (iUpg = 0; iUpg < lUpg; iUpg++) {
10          pUpg = (PlayerState)players[iUpg];
11          if (pUpg != null) {
12             pUpg.UnPauseSound();
13          }
14       }
15    }

16
17    if (audioBgroundSound != null) {
18       audioBgroundSound.Play();
19    }
20 }

01 public void FindWaypoints() {
02    GameObject[] list = GameObject.FindGameObjectsWithTag("Waypoint");
03    ArrayList routes = new ArrayList();
04    int l = list.Length;
05    WaypointCheck wc = null;
06    int i = 0;
07    int j = 0;
08
09    for (i = 0; i < l; i++) {
10       if (list[i].activeSelf == true) {
11          wc = (list[i].GetComponent<WaypointCheck>());
12          if (wc != null) {
13             if (routes.Contains(wc.waypointRoute + "") == false) {
14                routes.Add(wc.waypointRoute + "");
15             }
16          }
17       }
18    }
19
20    ArrayList waypoints = new ArrayList();
21    ArrayList row = new ArrayList();
22    l = routes.Count;
23
24    for (i = 0; i < l; i++) {
25       row.Clear();
26       int l2 = list.Length;
27       for (j = 0; j < l2; j++) {
28          if (list[j].activeSelf == true) {
29             if (waypointWidthOverride != -1) {
30                if (list[j].transform.localScale.z < 10) {
31                   list[j].transform.localScale.Set(list[j].transform.localScale.x, list[j].transform.localScale.y, waypointWidthOverride);
32                }
33             }
34
35             if (waypointZeroOverride != -1) {
36                if (list[j].transform.localPosition.y == 0) {
37                    list[j].transform.localScale.Set(list[j].transform.localScale.x, 1, waypointWidthOverride);
38                }
39             }

40
41             wc = (list[j].GetComponent<WaypointCheck>());
42             if (wc != null) {
43                if ((wc.waypointRoute + "") == (routes[i] + "")) {
44                   row.Add(wc);
45                }
46             }
47          }
48       }
49
50       object[] ar = row.ToArray();
51       System.Array.Sort(ar, wpc);
52       row = new ArrayList(ar);
53       l2 = row.Count;
54
55       for (j = 0; j < l2; j++) {
56          wc = (WaypointCheck)row[j];
57          wc.waypointIndex = j;
58       }
59
60       waypoints.Add(row);
61    }
62
63    waypointRoutes = routes;
64    waypointData = waypoints;
65 }

Listing 10-12GameState Main Method Details 1

```

我们要看的第一组主要方法包括游戏的暂停和取消暂停方法以及路点加载方法。让我们来看看！`PauseGame`方法用于在游戏窗口失去焦点时停止游戏。这可以在 Unity 编辑器中通过运行主游戏并在运行时切换到另一个应用程序来测试。注意第 2 行的`gamePaused`布尔标志被设置为真，并且`Time.timeScale`字段的值被设置为零。

这有停止游戏引擎的效果，第 3 行。如果定义了活动玩家的数组，则在第 6–8 行设置循环控制变量。循环遍历游戏的玩家，并暂停每个玩家的音频，第 9-14 行。随后，在第 17-19 行，背景音乐暂停。集合中列出的第二种方法是`UnPauseGame`方法。这个方法颠倒了游戏的暂停方法。仔细检查这个方法，注意时间刻度恢复为 1。列出的最后一种方法负责查找和准备所有的路点。所有带有“航路点”标签的 Unity `GameObjects`位于第 2 行。在第 3-7 行设置了临时路线`ArrayList`和一些回路控制变量。接下来，在第 9–18 行，我们遍历所有的路点，并将任何唯一的路点路线添加到路线数组中。在第 20–22 行，我们准备了一些方法变量。`row`变量用作航路点数据的临时保存器，而`waypoints`变量保存最终的航路点数据。

我们在第 24 行的已知路线上循环，变量`temp`在第 25 行被重置，一个新的长度变量在第 26 行被设置。然后在第 27 行，我们循环遍历已知航路点的列表。如果航路点是激活的，我们检查是否必须应用航路点宽度覆盖，第 29-33 行，和航路点零点覆盖，第 35-39 行。第 41 行设置了`WaypointCheck`脚本组件。如果该航路点是航路点组的成员，我们将其添加到`row`变量，第 42–46 行。在第 50–52 行，我们对找到的路点进行排序，并重置 row 变量。在第 53 行设置`l2`变量，在第 55-58 行重置航路航路点索引。在第 60 行，路线航点被添加到`waypoints`变量中。最后，在第 63-64 行，找到的航路点数据存储在类别字段`waypointRoutes`和`waypointData`中。

```cs
01 public void SetCarDetails() {
02    PlayerState player = null;
03    int i = 0;
04    int l = players.Count;
05
06    for (i = 0; i < l; i++) {
07       if (PlayerStateIdxCheck(i)) {
08          player = (PlayerState)players[i];
09          if (player != null) {
10             if (i == player1Index) {
11                gameCamera = player.camera;
12                player.camera.enabled = true;
13
14                rearCamera = player.rearCamera;
15                player.rearCamera.enabled = true;
16                player.audioListener.enabled = true;
17
18                if (player1AiOn == true) {
19                   player.aiOn = true;
20                   player.cm.aiOn = true;
21                   player.fpsInput.aiOn = true;
22                   player.mouseInput.aiOn = true;
23                } else {
24                   player.aiOn = false;
25                   player.cm.aiOn = false;
26                   player.fpsInput.aiOn = false;
27                   player.mouseInput.aiOn = false;
28                }
29             } else {
30                player.camera.enabled = false;
31                player.rearCamera.enabled = false;
32                player.audioListener.enabled = false;
33                player.aiOn = true;
34                player.cm.aiOn = true;
35                player.fpsInput.aiOn = true;
36                player.mouseInput.aiOn = true;
37             }
38             player.waypoints = GetWaypoints(0);
39          }
40       }
41    }
42 }

01 public void ResetGame() {
02    gamePaused = true;
03    Time.timeScale = 0;
04
05    prepped = false;
06    ready = false;
07    startGame = false;
08    startGameTime = 0.0f;
09    gameRunning = false;
10    gameWon = false;
11
12    Time.timeScale = 1;
13    gamePaused = false;
14 }

01 public void SetCarDetailsByGameType(PlayerState player) {
02    int idx = player.index;
03    player.player = GameObject.Find(Utilities.NAME_PLAYER_ROOT + idx);
04    player.player.transform.position = GameObject.Find(Utilities.NAME_START_ROOT + idx).transform.position;
05
06    player.maxSpeed = PlayerState.DEFAULT_MAX_SPEED;
07    player.gravity = PlayerState.DEFAULT_GRAVITY;
08
09    player.maxForwardSpeedSlow = 50;
10    player.maxSidewaysSpeedSlow = 12;
11    player.maxBackwardsSpeedSlow = 5;
12    player.maxGroundAccelerationSlow = 25;
13
14    player.maxForwardSpeedNorm = 200;
15    player.maxSidewaysSpeedNorm = 50;
16    player.maxBackwardsSpeedNorm = 20;
17    player.maxGroundAccelerationNorm = 100;
18
19    player.maxForwardSpeedBoost = 250;
20    player.maxSidewaysSpeedBoost = 60;
21    player.maxBackwardsSpeedBoost = 30;
22    player.maxGroundAccelerationBoost = 120;
23
24    if (idx != player1Index) {
25       if (difficulty == GameDifficulty.LOW) {
26          player.maxSpeed = PlayerState.DEFAULT_MAX_SPEED;
27          player.maxGroundAccelerationNorm += 5;
28       } else if (difficulty == GameDifficulty.MED) {
29          player.maxSpeed = PlayerState.DEFAULT_MAX_SPEED + 5;
30          player.maxForwardSpeedNorm += 10;
31          player.maxGroundAccelerationNorm += 10;
32       } else if (difficulty == GameDifficulty.HIGH) {
33          player.maxSpeed = PlayerState.DEFAULT_MAX_SPEED + 10;
34          player.maxForwardSpeedNorm += 15;
35          player.maxGroundAccelerationNorm += 40;
36          player.maxForwardSpeedBoost += 15;
37          player.maxGroundAccelerationBoost += 15;
38       }

39    } else if (idx == player1Index) {
40       player.maxSpeed += Random.Range(0, 12);
41       player.maxForwardSpeedNorm += Random.Range(0, 6);
42       player.maxGroundAccelerationNorm += Random.Range(0, 6);
43       player.maxForwardSpeedBoost += Random.Range(0, 6);
44       player.maxGroundAccelerationBoost += Random.Range(0, 6);
45    }
46 }

01 public void SetActiveCar(int j) {
02    if (debugOn == false) {
03       Utilities.wr("Method SetActiveCar says: debugOn is false, returning.");
04       return;
05    }
06
07    PlayerState player = null;
08    int l = players.Count;
09    for (int i = 0; i < l; i++) {
10       player = (PlayerState)players[i];
11       if (player != null && player.player != null) {
12          if (j == i) {
13             currentIndex = i;
14             currentPlayer = (PlayerState)players[currentIndex];
15             player.camera.enabled = true;
16             player.rearCamera.enabled = true;
17             player.audioListener.enabled = true;
18          } else {
19             player.camera.enabled = false;
20             player.rearCamera.enabled = false;
21             player.audioListener.enabled = false;
22          }

23       }
24    }
25 }

Listing 10-13GameState Main Method Details 2

```

这组主要方法中列出的第一个方法是`SetCarDetails`方法。这个方法用于将每辆车配置为 AI 或玩家控制的车。在第 2–4 行，该方法准备了一些局部变量，用于在活动玩家数组中循环。循环从第 6 行开始，如果`PlayerState`实例`player`不为空，那么我们在第 9–39 行处理这个玩家。关于这个代码块，第 10–28 行代码的第一个分支被应用到应该由玩家控制的汽车上。在第 11-165 行，悬停赛车被插入游戏的 HUD。如果这辆车应该是人工智能控制的，那么它在第 19-22 行被配置成这样。否则，第 24–27 行的代码会关闭这辆车的 AI。剩下的悬浮赛车都在 30-36 行被配置为人工智能控制。

列出的下一个主要方法是`ResetGame`方法。请注意该方法的第 2-3 行。请注意，游戏被标记为暂停，游戏的时间刻度被设置为零。在第 5–10 行，该方法重置键类字段。在第 12–13 行的方法结束时，游戏暂停标记被设置为 false，时间刻度返回到值 1。集合中列出的第三种方法是`SetCarDetailsByGameType`，它用于根据当前游戏类型为每个悬停参赛者准备正确的设置。第一行代码从第 2 行传入的`PlayerState`实例中获取玩家的索引。玩家的`GameObject`和`Transform`在 3、4 线得到强化。悬停赛车的最大速度、重力以及慢速、正常和加速速度设置在第 6-22 行。如果赛车的指数不是玩家一的指数，那么我们根据赛道的难度调整赛车的配置，第 25-38 行。

第 40–44 行的最后一个代码块为人类玩家配置汽车。这就把我们带到了这一组中的最后一个方法，即`SetActiveCar`方法。这个方法用于设置比赛中当前活跃的玩家。这不会使汽车受到人工智能或人类的控制，但它会将汽车连接到游戏的 HUD 中。要检查这个功能，在 Unity 编辑器中运行“Main13Demonstration”场景，并尝试按键盘上的数字键，数字 1 到 6。你会注意到，你可以使用这个功能切换到不同的汽车。回到代码，注意如果`debugOn`布尔字段被设置为 false，那么这个方法被转义。

如果没有，则在第 7–8 行准备循环控制变量。我们循环当前的一组玩家，如果定义了当前玩家，我们将它设置为游戏的当前玩家，游戏现在将显示汽车的摄像头、后视摄像头和飞艇摄像头，它们会相应地进行调整。在第 19–21 行，如果悬停赛车与指定的玩家索引不匹配，它将被设置为非活动模式。在`GameState`类中还有一些主要的方法需要复习。下一个我们将要讨论的是非常重要的`PrepGame`方法。这个方法被许多类调用，以确保游戏和它的玩家被正确配置。由于该方法的长度，我们将分块回顾它。让我们看一下该方法的第一个块。

```cs
001 public void PrepGame() {
002    if (prepped == true) {
003       return;
004    }
005    prepped = true;
006
007    //Prep waypoints and track script settings
008    FindWaypoints();
009    trackScript = GetComponent<TrackScript>();
010    totalLaps = trackScript.laps;
011    nightTime = trackScript.headLightsOn;
012    sceneName = trackScript.sceneName;
013
014    //Prep menu screens
015    if (hudNewScript == null) {
016       if (GameObject.Find("GameHUD") != null) {
017          hudNewScript = GameObject.Find("GameHUD").GetComponent<GameHUDNewScript>();
018       }

019    }
020
021    if (hudNewScript != null) {
022       hudNewScript.HideAll();
023    }
024
025    if (gameOverMenuScript == null) {
026       if (GameObject.Find("GameOverMenu") != null) {
027          gameOverMenuScript = GameObject.Find("GameOverMenu").GetComponent<GameOverMenu>();
028       }
029    }
030
031    if (gameOverMenuScript != null) {
032       gameOverMenuScript.HideWinImage();
033       gameOverMenuScript.ShowLoseImage();
034    }
035
036    if (audioBgroundSound == null) {
037       if (GameObject.Find("BgMusic") != null) {
038          audioBgroundSound = GameObject.Find("BgMusic").GetComponent<AudioSource>();
039       }
040    }
041
042    if (gamePauseMenu == null) {
043       gamePauseMenu = GameObject.Find("GamePauseMenu");
044       if (gamePauseMenu != null) {
045          gamePauseMenu.SetActive(false);
046       }
047    }
048
049    if (gameStartMenu == null) {
050       gameStartMenu = GameObject.Find("GameStartMenu");
051       if (gameStartMenu != null) {
052          gameStartMenu.SetActive(false);
053       }
054    }

055
056    if (gameOverMenu == null) {
057       gameOverMenu = GameObject.Find("GameOverMenu");
058       if (gameOverMenu != null) {
059          gameOverMenu.SetActive(false);
060       }
061    }
062
063    if (gameExitMenu == null) {
064       gameExitMenu = GameObject.Find("GameExitMenu");
065       if (gameExitMenu != null) {
066          gameExitMenu.SetActive(false);
067       }
068    }
069
070    if (gameHelpMenu == null) {
071       gameHelpMenu = GameObject.Find("GameHelpMenu");
072       if (gameHelpMenu != null) {
073          gameHelpMenu.SetActive(false);
074       }
075    }
076
077    //Prep player prefs default values
078    if (FIRST_RUN && gameStateIndex == GameStateIndex.FIRST) {
079       PlayerPrefs.DeleteKey("GameStateIndex");
080       if (PlayerPrefs.HasKey("EasyOn") == false && PlayerPrefs.HasKey("BattleOn") == false && PlayerPrefs.HasKey("ClassicOn") == false) {
081          PlayerPrefs.SetInt("EasyOn", 1);
082          PlayerPrefs.SetInt("BattleOn", 0);
083          PlayerPrefs.SetInt("ClassicOn", 0);
084       }
085
086       if (PlayerPrefs.HasKey("LowOn") == false && PlayerPrefs.HasKey("MedOn") == false && PlayerPrefs.HasKey("HighOn") == false) {
087          PlayerPrefs.SetInt("LowOn", 1);
088          PlayerPrefs.SetInt("MedOn", 0);
089          PlayerPrefs.SetInt("HighOn", 0);
090       }
091       PlayerPrefs.Save();
092    }
093
094    //Prep lap time manager
095    string tmpStr = PlayerPrefs.GetString("LapTimes", "");
096    lapTimeManager = new LapTimeManager();
097    if (tmpStr != null && tmpStr != "") {
098       Utilities.wr("Found lap times: " + tmpStr);
099       lapTimeManager.Deserialize(tmpStr);
100    }
101

Listing 10-14GameState Main Method Details 3

```

顾名思义，这种方法的主要目的是为比赛做准备。让我们一次一个地了解不同的职责。首先，如果已经调用了`PrepGame`方法，就对其进行转义，第 2–4 行。航路点被加载，任何`TrackScript`值被应用于第 8-12 行的准备航路点部分。对所有菜单系统游戏对象的引用配置在第 15–75 行。代码很简单。每个菜单屏幕游戏对象都是按名称加载的，如果有定义，随后会被停用。注意，在第 16–18 行，为`hudNewScript`字段创建了一个脚本组件引用。在第 27 行，同样的过程用于加载对`gameOverMenuScript`的引用。使用这些对象，我们可以调用类方法来调整菜单屏幕上的 HUD 和游戏的设置。

第 78–92 行的下一部分代码负责通过为比赛类型和难度设置一些默认值来准备玩家偏好。接下来，在第 95–100 行的代码块中，`lapTimeManager`被初始化，当前存储的分段时间(如果有的话)被反序列化并在第 99 行的`lapTimeManager`实例中激活。我们将在下面列出的下一个代码块中继续回顾这个方法。

```cs
102    //Prep difficulty
103    if (PlayerPrefs.HasKey("LowOn") == true && PlayerPrefs.GetInt("LowOn") == 1) {
104       difficulty = GameDifficulty.LOW;
105    } else if (PlayerPrefs.HasKey("MedOn") == true && PlayerPrefs.GetInt("MedOn") == 1) {
106       difficulty = GameDifficulty.MED;
107    } else if (PlayerPrefs.HasKey("HighOn") == true && PlayerPrefs.GetInt("HighOn") == 1) {
108       difficulty = GameDifficulty.HIGH;
109    }

110
111    //Prep track configuration
112    if (PlayerPrefs.HasKey("EasyOn") && PlayerPrefs.GetInt("EasyOn") == 1) {
113       gameSettingsSet = 0;
114       totalLaps = 2;
115       TurnOffArmorMarkers();
116       TurnOffGunMarkers();
117       TurnOffInvincMarkers();
118       TurnOffHealthMarkers();
119       TurnOffHittableMarkers();
120       if (difficulty == GameDifficulty.LOW) {
121          gameSettingsSubSet = 0;
122          TurnOffOilDrumStackMarkers();
123          TurnOffFunBoxMarkers();
124       } else if (difficulty == GameDifficulty.MED) {
125          gameSettingsSubSet = 1;
126          TurnOffOilDrumStackMarkers();
127          TurnOnFunBoxMarkers();
128       } else if (difficulty == GameDifficulty.HIGH) {
129          gameSettingsSubSet = 2;
130          TurnOnOilDrumStackMarkers();
131          TurnOnFunBoxMarkers();
132       }
133    } else if (PlayerPrefs.HasKey("BattleOn") && PlayerPrefs.GetInt("BattleOn") == 1) {
134       gameSettingsSet = 1;
135       totalLaps = trackScript.laps;
136       TurnOnArmorMarkers();
137       TurnOnGunMarkers();
138       TurnOnInvincMarkers();
139       TurnOnHealthMarkers();
140       TurnOnHittableMarkers();
141       if (difficulty == GameDifficulty.LOW) {
142          gameSettingsSubSet = 0;
143          TurnOffOilDrumStackMarkers();
144          TurnOffFunBoxMarkers();
145       } else if (difficulty == GameDifficulty.MED) {
146          gameSettingsSubSet = 1;
147          TurnOffOilDrumStackMarkers();
148          TurnOnFunBoxMarkers();
149       } else if (difficulty == GameDifficulty.HIGH) {
150          gameSettingsSubSet = 2;
151          TurnOnOilDrumStackMarkers();
152          TurnOnFunBoxMarkers();
153       }

154    } else if (PlayerPrefs.HasKey("ClassicOn") && PlayerPrefs.GetInt("ClassicOn") == 1) {
155       gameSettingsSet = 2;
156       totalLaps = 4;
157       TurnOffArmorMarkers();
158       TurnOffGunMarkers();
159       TurnOffInvincMarkers();
160       TurnOffHealthMarkers();
161       TurnOnHittableMarkers();
162       if (difficulty == GameDifficulty.LOW) {
163          gameSettingsSubSet = 0;
164          TurnOffOilDrumStackMarkers();
165          TurnOffFunBoxMarkers();
166       } else if (difficulty == GameDifficulty.MED) {
167          gameSettingsSubSet = 1;
168          TurnOffOilDrumStackMarkers();
169          TurnOnFunBoxMarkers();
170       } else if (difficulty == GameDifficulty.HIGH) {
171          gameSettingsSubSet = 2;
172          TurnOnOilDrumStackMarkers();
173          TurnOnFunBoxMarkers();
174       }
175    }
176
177    //Prep game state
178    if (!FIRST_RUN && PlayerPrefs.HasKey("GameStateIndex") == true) {
179       gsiTmp = PlayerPrefs.GetInt("GameStateIndex");
180       if (gsiTmp == 0) {
181          gameStateIndex = GameStateIndex.FIRST;
182       } else if (gsiTmp == 1) {
183          gameStateIndex = GameStateIndex.NONE;
184       } else if (gsiTmp == 2) {
185          gameStateIndex = GameStateIndex.MAIN_MENU_SCREEN;
186       } else if (gsiTmp == 3) {
187          gameStateIndex = GameStateIndex.GAME_OVER_SCREEN;
188       } else if (gsiTmp == 4) {
189          gameStateIndex = GameStateIndex.GAME_PAUSE_SCREEN;
190       } else if (gsiTmp == 5) {
191          gameStateIndex = GameStateIndex.GAME_PLAY_SCREEN;
192       } else if (gsiTmp == 6) {
193          gameStateIndex = GameStateIndex.MAIN_MENU_SCREEN;
194       }

195    }
196
197    if (gameStateIndex == GameStateIndex.NONE || gameStateIndex == GameStateIndex.FIRST) {
198       gameStateIndex = GameStateIndex.MAIN_MENU_SCREEN;
199    }
200
201    if (gameStateIndex == GameStateIndex.MAIN_MENU_SCREEN) {
202       player1AiOn = true;
203       ShowStartMenu();
204       HidePauseMenu();
205       HideEndMenu();
206    } else if (gameStateIndex == GameStateIndex.GAME_OVER_SCREEN) {
207       player1AiOn = true;
208       ShowStartMenu();
209       HidePauseMenu();
210       HideEndMenu();
211    } else if (gameStateIndex == GameStateIndex.GAME_PAUSE_SCREEN) {
212       ShowPauseMenu();
213    } else if (gameStateIndex == GameStateIndex.GAME_PLAY_SCREEN) {
214       HidePauseMenu();
215       HideEndMenu();
216       HideStartMenu();
217    }
218

Listing 10-15GameState Main Method Details 4

```

类别字段`difficulty`根据当前曲目难度的玩家偏好值进行设置。该值在方法行 112–175 的下一段代码中被广泛使用。Hover Racers 游戏能够调整赛道特性，以反映比赛类型和难度。这段代码非常直接。跟踪它，你会看到基于不同的轨道设置打开或关闭了哪些轨道功能。这就把我们带到了第 178–217 行代码的一个重要部分。这段代码负责通过隐藏或显示游戏的菜单屏幕来准备游戏状态。该方法中的下一个代码块如下所示。

```cs
219    //Prep blimp camera
220    if (blimpCamera == null) {
221       blimpCamera = GameObject.Find("BlimpCamera");
222    }
223
224    //Prep track settings
225    raceTrack = PlayerPrefs.GetInt("RaceTrack");
226    int tmp = PlayerPrefs.GetInt("EasyOn");
227    if (tmp == 0) {
228       easyOn = false;
229    } else {
230       easyOn = true;
231    }
232
233    raceType = PlayerPrefs.GetInt("RaceType");
234    Utilities.wr("RaceTrack: " + raceTrack);
235    Utilities.wr("EasyOn: " + easyOn);
236    Utilities.wr("RaceType: " + raceType);
237
238    if (PlayerPrefs.GetInt("RaceTrackHelp" + raceTrack) != 1) {
239       trackHelpOn = true;
240    } else {
241       trackHelpOn = false;
242    }
243
244    //Prep player positions
245    positions = new int[6];
246    positions[0] = 0;
247    positions[1] = 1;
248    positions[2] = 2;
249    positions[3] = 3;
250    positions[4] = 4;
251    positions[5] = 5;
252    players = new ArrayList();
253    players.AddRange(GameObject.Find("GameState").GetComponents<PlayerState>());
254
255    //Prep player states

256    int l = players.Count;
257    PlayerState player;
258    Transform t;
259    for (int i = 0; i < l; i++) {
260       Utilities.wr("Setting up player " + i);
261       player = (PlayerState)players[i];
262       if (player != null) {
263          player.index = i;
264          player.carType = i;
265          player.position = i;
266          SetCarDetailsByGameType(player); //sets the model and speeds
267
268          if (player.player != null) {
269             player.active = true;
270             player.controller = player.player.GetComponent<CharacterController>();
271             player.cm = player.player.GetComponent<CharacterMotor>();
272             player.camera = player.player.transform.Find("Main Camera").GetComponent<Camera>();
273             player.rearCamera = player.player.transform.Find("Rear Camera").GetComponent<Camera>();
274             player.audioListener = player.player.transform.Find("Main Camera").GetComponent<AudioListener>();
275             player.mouseInput = player.player.GetComponent<MouseLookNew>();
276             player.fpsInput = player.player.GetComponent<FPSInputController>();
277
278             t = player.player.transform.Find("Car");
279             if (t != null) {
280                player.gun = (GameObject)t.Find("Minigun_Head").gameObject;
281                player.gunBase = (GameObject)t.Find("Minigun_Base").gameObject;
282             }
283
284             player.lightHeadLight = (GameObject)player.player.transform.Find("HeadLight").gameObject;
285             if (player.lightHeadLight != null && nightTime == false) {
286                player.lightHeadLight.SetActive(false);
287             } else {
288                player.lightHeadLight.SetActive(true);
289             }

290
291             player.totalLaps = totalLaps;
292             player.currentLap = 0;
293             player.aiWaypointIndex = 0;
294             player.aiWaypointRoute = 0;
295             player.waypoints = GetWaypoints(player.aiWaypointRoute);
296             player.flame = (GameObject)player.player.transform.Find("Flame").gameObject;
297             player.gunExplosion = (GameObject)player.player.transform.Find("GunExplosion").gameObject;
298             //TODO //player.gunExplosionParticleSystem = player.gunExplosion.GetComponent<ParticleEmitter>();
299             player.gunHitSmoke = (GameObject)player.player.transform.Find("GunHitSmoke").gameObject;
300             //TODO //player.gunHitSmokeParticleSystem = player.gunHitSmoke.GetComponent<ParticleEmitter>();
301
302             if (player.gunOn == true) {
303                player.gun.SetActive(true);
304                player.gunBase.SetActive(true);
305             } else {
306                player.gun.SetActive(false);
307                player.gunBase.SetActive(false);
308             }
309
310             player.flame.SetActive(false);
311             player.gunExplosion.SetActive(false);
312             //TODO //player.gunExplosionParticleSystem.emit = false;
313             player.gunHitSmoke.SetActive(false);
314             //TODO //player.gunHitSmokeParticleSystem.emit = false;
315             player.LoadAudio();
316          } else {
317             Utilities.wr("Player model " + i + " is NULL. Deactivating...");
318             player.active = false;
319             player.prepped = false;
320          }
321       } else {
322          Utilities.wr("Player " + i + " is NULL. Removing...");
323          players.RemoveAt(i);
324          l--;
325       }
326
327       player.prepped = true;
328    }
329    SetCarDetails();
330
331    //Start game //line 324
332    ready = true;
333    FIRST_RUN = false;
334 }

Listing 10-16GameState Main Method Details 5

```

在前面列出的代码块的开头，在第 220–222 行配置了飞艇摄像机。第 225-242 行处理了更多的轨道设置，我们已经处理了所有的游戏准备工作。接下来，玩家位置数组被初始化为默认的六个悬浮赛车。玩家状态对象实例被加载到第 252 和 253 行的初始化玩家的`ArrayList`中。现在我们必须配置每个`PlayerState`对象。如果一切设置正确，我们将有六个`PlayerState`对象，每个玩家一个。

“准备玩家状态”标题下的下一部分代码可以说是最重要的。这个代码负责准备球员和他们的汽车的所有方面。局部变量设置在第 256 到 258 行，玩家数组从第 259 到 261 行开始迭代。玩家的索引、汽车类型和位置是在第 263–265 行设置的，它们的模型和速度值是通过调用`SetCarDetailsByGameType`方法配置的。

如果汽车的模型被成功加载，那么从 268 到 315 的代码就会执行。如果不是，则通过将`prepped`字段设置为假来停用数组条目。仔细查看这段代码，注意`PlayerState`类是如何准备好所有字段的；模型、摄像机和控制器都在这里设置。最后的设置是通过调用`SetCarDetails`方法来执行的，第 329 行。该方法负责设置主摄像机和后视摄像机、音频监听器以及 AI 或用户输入控件。在将`ready`字段设置为真并将`FIRST_RUN`字段设置为假之后，该方法返回。游戏现在可以运行了！

到目前为止，我们已经在本章中讲述了大量的代码，但是我们还没有脱离险境。我想讨论几个剩下的方法。下面列出了下一组要检查的方法。

```cs
01 public void OnApplicationPause(bool pauseStatus) {
02    if (AreMenusShowing()) {
03       if (pauseStatus == true) {
04          PauseGame();
05       } else {
06          UnPauseGame();
07       }
08    } else {
09       if (pauseStatus == true) {
10          if (gameStateIndex == GameStateIndex.GAME_PLAY_SCREEN) {
11             ShowPauseMenu();
12          } else {
13             PauseGame();
14          }
15       } else {
16          if (gameStateIndex == GameStateIndex.GAME_PLAY_SCREEN) {
17             HidePauseMenu();
18          } else {
19             UnPauseGame();
20          }
21       }
22    }
23 }

01 void Start() {
02    if (style1 == null) {
03       style1 = new GUIStyle();
04       style1.normal.textColor = Color.red;
05       style1.fontStyle = FontStyle.Bold;
06       style1.fontSize = 16;
07    }
08
09    if (style2 == null) {
10       style2 = new GUIStyle();
11       style2.normal.textColor = Color.black;
12       style2.fontStyle = FontStyle.Bold;
13       style2.fontSize = 16;
14    }

15
16    if (forceGameStart == true) {
17       if (SceneManager.GetActiveScene().name == "DemoCollideTrackHelp") {
18          PlayerPrefs.DeleteAll();
19          PlayerPrefs.Save();
20       } else if (SceneManager.GetActiveScene().name == "DemoCollideScript") {
21          PlayerPrefs.DeleteAll();
22          PlayerPrefs.SetInt("BattleOn", 1);
23          PlayerPrefs.SetInt("HighOn", 1);
24          PlayerPrefs.Save();
25       } else if (SceneManager.GetActiveScene().name == "DemoCarSensorScriptAutoPass") {
26          CarSensorScript.TRIGGER_SPEED_PASSING = 0.00f;
27       } else if (SceneManager.GetActiveScene().name == "DemoCarSensorScriptGunShot") {
28          PlayerPrefs.DeleteAll();
29          PlayerPrefs.SetInt("BattleOn", 1);
30          PlayerPrefs.SetInt("HighOn", 1);
31          PlayerPrefs.Save();
32       } else if (SceneManager.GetActiveScene().name == "DemoCameraFollowXz") {
33          GameStartMenu.TRACK_NAME_1 = "DemoCameraFollowXz";
34          GameStartMenu.TRACK_NAME_2 = "DemoCameraFollowXz";
35       } else if (SceneManager.GetActiveScene().name == "Main13Demonstration") {
36          GameState.ON_GUI_SHOW_CAR_DETAILS = true;
37          debugOn = true;
38          PlayerState.SHOW_AI_LOGIC = true;
39       }
40    }
41
42    audioS = GetComponent<AudioSource>();
43    if (audioS == null) {
44       Utilities.wrForce("GameState: audioS is null!");
45    }
46 }

Listing 10-17GameState Main Method Details 6

```

`OnApplicationPause`方法是一个 Unity 游戏引擎回调方法，在游戏失去焦点时触发。如果有菜单显示并且`pauseStatus`为真，那么我们想通过调用第 4 行的`PauseGame`方法暂停游戏。如果没有，我们想通过调用第 6 行的`UnPauseGame`方法来解除游戏暂停。但是，如果没有菜单显示，则执行第 9–21 行的代码。在这种情况下，如果`pauseStatus`为真，游戏在主游戏屏幕上，那么我们只显示暂停菜单屏幕，第 11 行。如果没有，那么我们暂停游戏。类似地，在第 16–20 行，如果`pauseStatus`参数为假并且游戏处于活动状态，我们调用`HidePauseMenu`方法。否则，我们取消游戏暂停，第 19 行。

这一组中的下一个方法是`Start`方法。这种方法的主要职责是为课堂准备一些东西。首先，该方法加载一些在`OnGUI`方法中使用的样式，以在屏幕上显示调试文本，第 2–14 行。接下来，在第 16 行，如果游戏被配置为演示场景，那么`forceGameStart`标志将为真。第 17–39 行的代码用于准备代码支持的不同演示场景。最后，在第 42–45 行，音轨的背景音乐被加载。

这个类中还有最后一个方法我们还没有介绍，那就是`Update`方法。尽管这是一个相当长的方法，但代码非常简单。这个方法更新游戏的 HUD 回想一下，`Update`方法运行每个游戏帧，以反映当前玩家在赛道上比赛时汽车的变化，体验不同的交互并触发不同的修改器。仔细阅读这个方法，确保在继续之前理解它是如何工作的。这就是我们对`GameState`课的总结。这意味着我们已经仔细检查了游戏中的每一个职业、领域和方法。

### 演示:游戏状态

演示`GameState`类最好的方法就是打开“Main13Demonstration”场景并播放。在街机演示模式运行时，使用数字键 1-6 在汽车之间跳跃，并注意 HUD 如何自动更新以显示当前所选悬停赛车的状态。另一个很好的示范可能是玩游戏，让你所有关于游戏如何运作的知识在你的脑海中流动，就像你在游戏中实际体验一样。

## 第二章结论

在这一章中，我们通过完成`GameState`代码回顾，看完了玩家和游戏状态类。这不是一个小壮举。这个类中有很多东西在进行，因为它是整个游戏的中心控制点。花点时间拍拍自己的背。这给我们带来了游戏的代码审查的结论。我们已经涵盖了第 2 章中概述的所有游戏规范，在文本的这一点上，你应该已经很好地理解了游戏对象、物理、碰撞和脚本组件如何相互作用来创建一个游戏。如果你第一次没有完全吸收，不要沮丧。发生了很多事情，你可能需要给自己更多的时间来真正掌握这一切。