# 十一、使其专业化

欢迎来到第十一章。如果您已经做到了这一步，那么您已经审查了大量的代码。我认为你已经赢得了你的军衔。在剩下的章节中，我们将不会回顾太多的代码，至少不会太长。相反，我们将密切关注 Unity 编辑器和游戏创作的各个方面，这些方面使你的游戏与众不同。这一章是关于使你的游戏专业化的特征、步骤和机制。我们将讨论以下主题以及如何在 Unity 中解决这些问题:

1.  构建设置

2.  输入映射

3.  用户界面/菜单系统

4.  数据持久性

5.  内存管理

6.  声音和音乐

7.  静态对象

8.  标签和层

9.  人工智能对手

10.  摄像机

11.  项目设置

这是一个相当多样的主题列表。其中一些，如果仔细研究，可以自己写满一整本书。我们要让事情变得轻松，把注意力集中在手头主题的重要的、一般的方面。我们要处理的第一个主题是构建设置。这是一个简洁的、特定于 Unity 的主题，非常适合我们的第一次讨论。就这样，让我们开始吧。

## 构建设置

Unity 构建设置用于选择目标平台、配置您的构建以及启动构建和测试过程。这是任何严肃的 Unity 项目的重要组成部分，因为它用于创建游戏的开发和生产版本。Unity 支持许多构建目标，但我们将关注最常见的目标，以及我认为对于迭代开发构建和生产构建质量最重要的设置。我将重点关注影响游戏开发过程效率和游戏本身性能的构建设置。我们将看看以下平台的一些选择构建设置:

1.  通用平台

2.  PC、Mac 和 Linux 桌面

3.  通用 Windows 平台(UWP)

4.  ios

5.  机器人

6.  web GL(web GL)

Unity 还支持其他构建目标，我们不会在这里讨论，但是这篇评论会让你对管理任何平台的构建设置有所了解和信心。

### 通用平台设置

通用平台设置是一组适用于所有平台的生成设置。

开发版本:此设置用于在项目的版本中启用脚本调试和探查器支持。你可能想知道为什么你会使用这个选项，当你可以在 Unity 编辑器中调试和分析你的游戏时。事实是，目标设备的行为可以而且将会与您的开发环境不同。在项目开发过程中，尽早开始在目标设备上测试游戏非常重要。

脚本调试:该选项仅在“开发构建”设置被激活且在 WebGL 平台上不可用时可用。如果希望调试脚本组件代码，请启用此选项。我个人在需要调试的时候会启用这样的选项。我尽量保持我的开发测试尽可能的纯净。

只构建脚本:对于拥有大量资产的项目来说，这是一个非常有用的特性。如果您的项目构建时间阻碍了您的测试迭代，那么尝试使用这个构建选项。为了使用此设置，您必须进行项目的完整构建。然而，一旦完成了这些，您将能够重建项目，只需要脚本，从而更快地解决代码问题。此设置要求启用“开发构建”设置。

压缩方法:压缩方法设置很重要。根据您的目标平台，您可以设置一些压缩选项。全部测试。找到最适合您的目标设备的版本。不要忽视这个设定。你的选择会对你的游戏加载时间产生显著的影响。

### PC、Mac 和 Linux 桌面设置

正如您可能已经猜到的，这类构建设置适用于桌面构建目标。

架构:macOS 上没有这个选项。它适用于 Windows 和 Linux。优化此设置以匹配目标设备的体系结构。再次，测试不同的设置，找到最适合你的游戏。

复制 PDB 文件:复制 PDB 文件选项仅在您的目标是 Windows 平台时可用。这是一个很有用的设置，可以将调试信息添加到游戏版本中。这可以让你在追踪开发过程中出现的顽固错误时获得优势。不用说，对于生产版本，应该关闭这个设置。

创建 Visual Studio 解决方案/创建 XCode 项目:此设置分别适用于 Windows 和 Mac。虽然您可能并不是在所有情况下都需要此功能，但是如果您需要对生成的项目进行更多的控制，此功能可能会有所帮助。如果您想要创建一个项目，并且该项目在编译后将生成您的最终产品，请使用它。

### 通用 Windows 平台(UWP)设置

本节介绍 UWP 构建设置。除了我们在这里讨论的选项之外，还有一些选项可用，所以我鼓励你看看 Unity 文档以获得更多信息。

架构:UWP 版本的这个构建设置有几个不同的目标供你选择。您可以指定 x86、x64、ARM 和 ARM64，但仅当与 Unity 的“构建和运行”选项一起使用时。这很可能是由于这个平台的普遍性。它很可能包含了之前在开发或生产版本中列出的所有架构的二进制文件。该选项允许您使用特定的架构进行测试、调试和评估。

生成类型:此设置用于控制如何根据 UWP 和 Visual Studio 生成您的项目。您可以选择 XAML、直接 3D 或仅可执行。如果您想在项目中使用 Windows XAML，您的性能会受到影响，但您可以在项目中 XAML 元素。对于大多数游戏来说，这可能是一个不常见的选择。直接 3D 选项提供最佳性能，并在基本应用程序窗口中呈现游戏。最后一个选项，仅可执行，是一个有趣的特性。此设置在不生成 Visual Studio 项目的预生成可执行文件中承载项目。使用这个选项来减少你的构建时间，这样你可以更快地迭代，更快地完成你的测试和调试。

构建配置:这个构建设置只适用于 Unity 的“构建和运行”特性。该设置的选项与 Unity 生成的 Visual Studio 项目中的选项相同。调试选项包括调试符号并启用 Unity Profiler。release 选项没有调试代码，但也启用了探查器。最后，主选项针对发布版本进行了全面优化。使用此构建设置来优化您的游戏并准备发布。

深度分析:该选项用于分析所有脚本代码，包括记录函数调用。使用此设置来查明游戏中的性能问题，但要小心；它使用大量的内存，可能无法像预期的那样处理非常复杂的脚本。

自动连接分析器:自动将分析器连接到游戏版本。此设置要求启用“开发构建”选项。

### iOS 设置

iOS 平台有许多构建设置与我们已经介绍过的平台重叠，所以我们在这里不再赘述。但是，我们将回顾一些特定于 iOS 的选项。

在 XCode 中运行:此选项仅在 macOS 上可用，用于指定用于运行结果项目的 XCode 版本。

以 XCode 身份运行:此选项允许您指定项目是以调试模式还是发布模式运行，从而帮助您调试 iOS 游戏。如果您需要调试代码并希望使用 XCode 来完成，请使用此功能。在开始设备测试之前，您还可以使用它来运行发布版本，以检查 XCode 中的功能。

Symlink Unity 库:该选项允许您引用 Unity 库，而不是将它们复制到项目中。使用这个特性可以减小 XCode 项目的大小，并且由于项目构建时间更短，可以帮助您更快地迭代。

### Android 设置

与 iOS 设置类似，Android build 设置与我们已经讨论过的选项部分重叠，因此我们在此不再赘述。我们将着重于帮助你优化和测试你的游戏的设置。

纹理压缩:在撰写本文时，Android 平台支持以下纹理压缩格式:DXT、PVRTC 等、ETC2 和 ASTC。默认设置是 ETC，但您应该了解目标设备的功能，并选择一个能为您提供最佳支持和效率平衡的设置。

ETC2 回退:这个设置我就不细说了。如果使用 ETC2 纹理压缩格式，请注意该选项。它可以帮助您的游戏在不支持 ETC2 和 OpenGL ES 3 的设备上更高效地运行。

运行设备:这个构建设置允许您指定目标附加的 Android 设备，然后您可以使用它来测试和调试您的构建。

### 网络光设置

WebGL 平台有许多构建设置与我们已经介绍过的选项重叠。您可以在为此平台配置构建设置时应用这些知识。

## 输入映射

在我看来，输入映射是职业游戏的一个重要方面。通过使用输入映射，您可以在输入和游戏之间创建一个抽象层。这允许您将相似的输入映射到一个输入标签。为什么我的游戏需要这个？好吧，如果你正在经历构建一个游戏的麻烦，为什么要把它的输入限制在一个或两个直接映射的输入。花时间改进和使用输入映射来无缝地支持多个输入。下面的屏幕截图演示了在 Hover Racers 游戏中使用的这种输入映射配置。

![img/520710_1_En_11_Chapter/520710_1_En_11_Fig1_HTML.png](img/520710_1_En_11_Chapter/520710_1_En_11_Fig1_HTML.png)

图 11-1

输入映射示例该图像描述了映射到输入标签的多个原始输入

正如您在前面列出的图像中看到的，我们已经将键盘输入和操纵杆输入映射到同一个标签“水平”现在，让我们看看一些输入代码，看看标签是如何使用的。

```cs
01 if (Input.GetAxis("Turn") < 0.0f) {
02    if (Input.GetAxis("Horizontal") < 0.0f) {
03       transform.Rotate(0, -1.75f, 0);
04    } else {
05       transform.Rotate(0, -1.25f, 0);
06    }
07 }
08
09 if (Input.GetAxis("Turn") > 0.0f) {
10    if (Input.GetAxis("Horizontal") > 0.0f) {
11       transform.Rotate(0, 1.75f, 0);
12    } else {
13       transform.Rotate(0, 1.25f, 0);
14    }
15 }

Listing 11-1Input Mapping in Use

```

请注意，在前面列出的代码中，无论输入源是什么，都会使用“水平”输入映射。玩家可以使用键盘、控制器或鼠标来使悬停赛车转弯；我们不在乎哪个。花点时间在你的游戏输入上努力吧！一个伟大的游戏可能会被糟糕的控制毁掉。相反，一个看起来不怎么样的游戏，如果控制正确，可能真的很有趣，会让人上瘾。

### 用户界面/菜单系统

菜单系统是另一个功能，如果它没有很好的实现，会影响你的游戏。用户习惯于在他们的游戏中使用相当不错的 UI。这是你在制作游戏时应该记住的事情。菜单系统应该简单直观。限制任何给定菜单屏幕上的选项和信息的数量，让你的玩家更容易理解正在发生的事情。

除了提供实际游戏中的菜单系统作为一个坚实的例子，我想谈谈 Unity UI 系统的两个方面，它们将帮助你更快地启动和运行。第一个是设置一个新的`Canvas`，第二个是设置一个带有一些按钮的`Panel`。我们还会将这些按钮连接到相关的脚本组件。打开主项目并创建一个名为“MyMenuSystemSample”的新场景打开场景，你会看到一个默认的，有点空白的“层次”面板。

右键单击“层级”面板，选择上下文菜单的“UI”部分，然后选择`Canvas`条目。您将看到层次结构的两个版本:一个`Canvas`和一个`EventSystem`对象。我们现在将关注于`Canvas`对象。选择它，并将您的注意力转向“检查器”面板。展开“画布”条目，并将“渲染模式”设置为“屏幕空间–覆盖”这将在屏幕上显示菜单，是你的菜单系统的一个好的起点。如果您想确保菜单图形尽可能清晰地缩放，请选中“像素完美”选项。确保“目标显示”设置为“显示 1”

![img/520710_1_En_11_Chapter/520710_1_En_11_Fig2_HTML.jpg](img/520710_1_En_11_Chapter/520710_1_En_11_Fig2_HTML.jpg)

图 11-2

Canvas Hierarchy 示例描述添加 Canvas 和 Panel 对象后的层次的图像片段

接下来，展开“Canvas Scaler”条目，并将“UI Scale Mode”设置为“Scale with Screen Size”值。我们将进行设置，使菜单屏幕居中，并随着游戏的屏幕大小上下缩放。“参考分辨率”条目应该与用于创建菜单屏幕资产的尺寸相匹配，特别是所使用的背景图像。在这种情况下，我们将“X”值设置为 640,“Y”值设置为 960。“屏幕匹配模式”应该设置为“匹配宽度或高度”，并且“匹配”选项的值应该为 0.5。这是宽度和高度的平衡。最后，“每单位像素”条目应该与原始菜单背景图像的像素密度相匹配。在这种情况下，将其设置为 326。

![img/520710_1_En_11_Chapter/520710_1_En_11_Fig3_HTML.png](img/520710_1_En_11_Chapter/520710_1_En_11_Fig3_HTML.png)

图 11-3

画布层次和设置示例描述完整演示场景层次并关注画布设置的屏幕截图

现在我们将向我们的`Canvas`添加一个`Panel`对象。在层级中选择`Canvas`对象，并右键单击。选择“UI”选项，然后选择“Panel”条目。您的`Canvas`对象现在将有一个`Panel`子对象。选择新的子对象，并将注意力放在“检查器”面板上。展开“矩形变换”条目，并将“宽度”和“高度”值分别设置为 460 和 240。这些是我们将使用的背景图像的自然尺寸。

我们希望我们的菜单场景保持居中，所以我们接下来将研究“锚”和“枢轴”选项。“X”和“Y”的“最小”和“最大”锚值应该设置为 0.5。这些值代表一个百分比，0.0 到 1.0 或 0%到 100%，如果你想这样想的话。现在将“X”和“Y”的“轴”值也设置为 0.5。这将把轴心点和锚点设置到菜单的中心。“旋转”、“PosY”、“PosX”和“PosZ”字段都应设置为零。

接下来让我们看看`Panel`对象在“检查器”面板中的“图像”条目。展开它并选择“源图像”选项，单击选择按钮，在弹出窗口中键入“菜单”并找到名为“MenuPanel_512x512”的条目在这一步之后，您可能需要重新设置“矩形变换”条目的“宽度”和“高度”值，所以一定要仔细检查它们。将“图像类型”选项设置为“切片”并选中“填充中心”复选框。

![img/520710_1_En_11_Chapter/520710_1_En_11_Fig4_HTML.png](img/520710_1_En_11_Chapter/520710_1_En_11_Fig4_HTML.png)

图 11-4

面板层次和设置示例显示面板对象的“矩形变换”和“图像”设置的屏幕截图

我们在这一部分要做的最后一件事是添加菜单屏幕特性、一些文本和两个按钮。然后我们将按钮连接到一个脚本，运行一些测试，然后就到此为止。

步骤 1:添加一个文本对象

*   从层级中选择`Panel`对象并右键单击。

*   选择“UI”选项，然后选择`Text`条目。一个新的`Text`对象将被添加为`Panel`对象的子对象。

*   选择它，然后注意“检查器”面板中的“矩形变换”部分。

步骤 2:配置新的文本对象

*   将“PosY”字段的值设为 60。

*   现在向下滚动到“文本”部分并展开它。将“文本”字段的值更改为“Hello World”将“字体样式”改为“粗体”，将“字体大小”改为 20。

*   在“段落”小节下，将“对齐”选项设置为“文本居中”。

步骤 3:添加两个按钮对象

*   遵循与添加`Text`对象到`Panel`相同的过程，除了这次添加两个`Button`对象。所有三个 UI 元素都应该是`Panel`的子对象。

步骤 4:配置按钮对象

*   将第一个按钮对象重命名为“ButtonOk”，将第二个按钮命名为“ButtonCancel”

*   选择`ButtonOk`对象，在“检查器”面板中展开“矩形变换”部分。将“PosX”字段的值设置为–90。对`ButtonCancel`对象做同样的事情，除了使用值 90。

简单的菜单屏幕正在形成。请注意，这两个按钮本质上是父对象。展开第一个按钮并选择`Text`子对象。将其“文本”值设置为“确定”对第二个按钮重复此步骤，只是将其“文本”值设置为“取消”

![img/520710_1_En_11_Chapter/520710_1_En_11_Fig5_HTML.jpg](img/520710_1_En_11_Chapter/520710_1_En_11_Fig5_HTML.jpg)

图 11-5

具有 UI 元素的面板层次示例描述添加了面板对象和 UI 元素的场景层次的图像片段

我们将向`Canvas`对象添加一个脚本组件。在层次中选择`Canvas`对象。现在，转到“项目”面板，搜索以下字符串，“DemoMenuSystemSample”。找到同名的脚本组件，并将其添加到`Canvas`对象中。接下来，右击`Canvas`对象并选择“属性...”入口。将产生的弹出窗口向旁边移动一点。选择`ButtonOk`对象，在“检查器”面板中展开“按钮”部分。

向下滚动到“点击时”部分，然后单击“+”按钮。将结果行条目的类型设置为“编辑器和运行时”将“Demo Menu System Simple”脚本组件从属性弹出菜单拖到“On Click”行条目的“Object”字段。选择“BtnOkClick”功能，将“无功能”的值更改为“DemoMenuSystemSample”。对“取消”按钮做同样的事情，只是这次选择“BtnCancelClick”功能。我们把所有东西都装好了。拿着它转一转，检查日志中哪个按钮被点击的指示。打开“DemoMenuSystemSample”场景可以找到这个简单屏幕的演示。

![img/520710_1_En_11_Chapter/520710_1_En_11_Fig7_HTML.png](img/520710_1_En_11_Chapter/520710_1_En_11_Fig7_HTML.png)

图 11-7

完成的 UI 层次示例描述完成的 UI 演示的层次和场景的屏幕截图

![img/520710_1_En_11_Chapter/520710_1_En_11_Fig6_HTML.png](img/520710_1_En_11_Chapter/520710_1_En_11_Fig6_HTML.png)

图 11-6

面板层次结构和设置示例描述 ButtonOk 对象配置的屏幕截图

### 数据持久性

我们在审查 Hover Racers 代码库时讨论了数据持久性。这是使用 Unity API`PlayerPrefs`类的数据持久性的简化形式。虽然它非常适合存储简单的数据，但对于复杂的信息，它可能不是最佳的解决方案。序列化技术，就像我们用来存储跟踪时间数据的那种，可能是一种选择，但你不应该把它用于大量数据或非常复杂的数据。在这些情况下，您应该探索数据文件的读写。

### 内存管理

既然你是用 C#，一种内存管理语言来编写你的 Unity 游戏，那么你就不用担心内存管理，对吗？错了。垃圾收集使用资源，垃圾收集器要做的工作越多，它破坏游戏流畅帧速率的机会就越大。确保跟踪每一帧运行的方法，并尽量减少悬挂对象的创建，这些对象在其他任何地方都不会被引用，并且在方法完成时会丢失。

在 Hover Racers 游戏中，我们使用私有类字段作为局部方法变量的替代，以避开垃圾收集器。然而，这种方法很快会变得很麻烦，不推荐用于更复杂的方法、类。当你编码的时候，记住内存管理，你已经完成了一半。通过剖析你的游戏，仔细检查 Unity 引擎的`Update`方法或其他频繁触发的方法(如碰撞回调方法)所涉及的方法和类，清理任何遗留问题。

### 声音和音乐

这似乎是显而易见的，但我还是要回顾一下。音效和音乐对任何游戏都非常重要，包括你的。如果您无法创建音频资源，请不要担心。包括 Unity store 在内，有很多地方可以让你接触到美妙的音乐和声音。一般来说，玩家的每一次交互，有时通过他们的角色，都应该引出某种声音效果。如果可以的话，你还应该找一个像样的背景音乐和环境声音。我知道这对于一个游戏版本来说是一个很大的挑战，但是如果你记住这一点，并且在开发过程中使用占位符，那么当需要润色和完善你的项目时，你将会处于一个很好的位置。

### 静态对象

如果你在 Unity 编辑器中选择任何`GameObject`并在“检查器”面板中检查该对象的配置，你会注意到面板右上角名为“静态”的标签旁边有一个小复选框。如果你游戏中的一个物体不移动，不与角色或 AI 对手交互，也不与其他物体交互，你应该将其标记为静态。这样做可以提高游戏的效率，因为静态对象会从某些运行时计算中逃逸出来。

### 标签和层

标签和层是在游戏中组织交互的重要功能。你可以找到他们的管理屏幕下的“编辑”➤“项目设置……”主菜单选项。在出现的设置窗口左侧选择“标签和层”条目。标签是您可以分配给一个或多个`GameObject`的参考名称。例如，游戏中所有的悬停赛车都有标签“玩家”标签帮助你识别特定的`GameObject`,并且可以帮助以编程方式将游戏对象连接到脚本字段。

Unity 中的层用于定义哪些`GameObject`可以相互交互。正如 Unity 文档中提到的，它们通常被`Camera`对象用来渲染场景的一部分，被灯光用来照亮场景的一部分。我们并没有真正在 Hover Racers 代码库中使用层。然而，如果你看看游戏屏幕右上方的飞艇摄像机，你可以想象一个场景，摄像机没有显示赛道的完整渲染，就像现在这样。例如，可以使用层对其进行配置，以仅显示某些对象，仅此而已。在游戏开发过程中，请记住这些特性。

### 人工智能对手

这是一个有点棘手的话题。首先，在这种情况下，AI 有点用词不当。目前，或许还有一段时间，游戏人工智能不是真正的人工智能或机器学习。就像某些物理计算可以被近似从而被简化一样，游戏人工智能意味着尽可能地模仿人类玩家，并且这样做看起来很聪明。在不太遥远的未来，每台像样的计算机都将拥有类似于今天 GPU 工作方式的专用 AI/ML 硬件，在某些情况下，它们已经存在。看看谷歌的 TPU 和苹果的 M1 芯片。

但是现在，我们将不得不接受近似和简化的游戏人工智能。这是一个很大的话题，很大程度上依赖于你正在制作的游戏类型。游戏人工智能实现的一个主要方面是模仿用户输入并管理这些输入来创建一个真实的人工智能玩家。考虑到这一点，您可能希望从实际的输入中抽象出输入处理，以便可以通过编程实现相同的功能。

当实现悬停赛车的人工智能，我们有简单的好处。盘旋赛车手有一个固定的，指定的，他们可以移动的地方，赛道。没有它，你将不得不使用像 A*或 Unity 的导航网格系统的寻路技术。此外，参赛者只能加速、减速或转弯。赛道的航路点系统告诉他们向哪个方向前进，赛道的中心点在哪里，转弯多少，以及何时减速。这就是我们在这场比赛中像样的人工智能对手所需要的一切。我建议在项目的早期就考虑和规划人工智能。

![img/520710_1_En_11_Chapter/520710_1_En_11_Fig8_HTML.png](img/520710_1_En_11_Chapter/520710_1_En_11_Fig8_HTML.png)

图 11-8

Hove Racer 人工智能逻辑示例一个截图，描述了人工智能对手的计算，决定向哪里移动以及转弯多少

### 摄像机

摄像机可以为你的游戏增添一份精彩。很多游戏使用两个或更多的摄像头来提供当前关卡的不同视角。你最喜欢的 FPS 上的导航 HUD 很可能是一个摄像机，它被设置为只能看到特定的对象层，这些对象层被用来描述给定关卡上玩家环境或位置的简化版本。用新的独特的方式给你的游戏添加摄像头真的可以让你的游戏脱颖而出。关于如何定位和调整相机大小的例子，请查看“Main13”或“Main14”场景，这是该项目的主要游戏场景。

### 项目绩效

最后但同样重要的是，还有项目设置。你的 Unity 项目涉及到很多设置，其中一些我们已经提到过了。有比我希望在这篇文章中解决的更多的问题。然而，我想花一点时间来讨论“质量”设置。您可以在主菜单的“编辑”条目下找到项目设置选项。可以从弹出窗口的左侧选择“质量”部分。

花点时间测试这些设置，以获得游戏质量和性能的正确平衡。您可以使用一些 Unity 性能监控工具来检查游戏的运行情况。我们要看的第一个工具是“游戏”面板的“统计”功能。打开主游戏场景，“Main13”或“Main14”，在 Unity 编辑器中运行游戏。请注意，在面板的右上角有一个“Stats”按钮。点击它，你应该会看到类似下面的截图。

![img/520710_1_En_11_Chapter/520710_1_En_11_Fig9_HTML.png](img/520710_1_En_11_Chapter/520710_1_En_11_Fig9_HTML.png)

图 11-9

描述场景统计对话框的截图

这个小弹出窗口有很多关于你的游戏的有用的高级信息，可以用来识别你的项目的问题。“为什么我的游戏只能以 30 FPS 的速度运行？”你问。问得好。要获得游戏性能的真实画面，请停止游戏，然后单击“统计”按钮旁边的“游戏时最大化”按钮。现在重新开始游戏，再次打开“统计”弹出窗口。此功能的一个示例如下。

![img/520710_1_En_11_Chapter/520710_1_En_11_Fig10_HTML.png](img/520710_1_En_11_Chapter/520710_1_En_11_Fig10_HTML.png)

图 11-10

Hove Racers 最大化统计数据示例一个截图，描述了在 Unity 编辑器中运行的主游戏，最大化，显示了统计数据弹出窗口

看看前面列出的图像中的帧速率。请注意，它在 1441 × 731 像素下以每秒 91 帧的速度运行。那还不算太寒酸。计划定期检查游戏的性能，尤其是在添加新功能和游戏机制之后。但是如果我在 Unity 编辑器中测试时发现性能问题，会发生什么呢？统计弹出窗口没有给我足够的信息来解决这个问题。不要害怕！Unity Profiler 可以提供帮助。可以在以下主菜单位置找到该分析器:“窗口”➤“分析”➤“分析器”让我们再次运行这个游戏，观察数据流入分析器的图表和摘要部分。看看下面的例子截图。

![img/520710_1_En_11_Chapter/520710_1_En_11_Fig11_HTML.png](img/520710_1_En_11_Chapter/520710_1_En_11_Fig11_HTML.png)

图 11-11

Hove Racers Profiler 示例描述 Unity profiler 的屏幕截图，其中包含 Hover Racer 游戏的运行数据

花点时间玩玩分析器。在左侧切换不同的指标，以查明是什么导致您的游戏行为不当。单击图表将在窗口的底部面板中显示详细信息。您可以访问关于垃圾收集器占用了多少时间、某些方法调用完成了多少时间等信息。分析器是一个强大的工具。知道如何使用它的开发者可以胜任并快速地解决他们游戏中的低效问题。成为那些开发者中的一员。

## 第二章结论

这就引出了本章的结论。在这一章中，我们看了一些主题，我觉得它们会帮助你把下一个 Unity 游戏做得更好。我们讨论了各种各样的主题，涉及到游戏效率和优化实现方面的问题。让我们在这里回顾一下这些主题。

构建设置:在这一部分，我们介绍了一些关键的构建设置，并指出了一些会影响游戏性能的有用选项。我们还讨论了许多选项，可以帮助你在一系列不同的平台上测试和调试你的游戏，随后列出。

1.  通用平台设置

2.  PC、Mac、Linux 桌面设置

3.  UWP 设置

4.  IOS 设置

5.  Android 设置

6.  网络光设置

输入映射:输入映射部分讨论了如何设置输入，以便输入映射特性能够对它们进行抽象。我们讨论并观察了应用于一个游戏的多个功能相同的输入是如何共享同一个标签的。这有效地创建了一个抽象层，允许您针对输入标签而不是直接针对输入源进行编码。

UI/菜单系统:在这一部分，我们讨论了一个坚固的 UI 如何增强你的游戏，并为你的玩家提供良好的体验。我们还逐步完成了构建一个简单的双按钮菜单屏幕的过程，附带了处理按钮单击事件的脚本，并提供了该场景的完整演示版本供您阅读。

数据持久性:我们花了一点时间讨论了数据持久性的主题，并提到了 Hover Racers 游戏使用的`PlayerPrefs`类。我们还简要讨论了使用序列化/反序列化技术来存储稍微复杂一些的数据。最后，我们建议对高度复杂和/或大量的数据使用数据文件。

内存管理:关于内存管理，我们提出了一些关于如何控制垃圾收集的想法，正如在所提供的游戏项目中实现的那样。我们还强调了了解并主动解决代码如何影响垃圾收集器的重要性。

声音和音乐:在这一部分，我们讨论了井...声音和音乐。我们建议尽可能为所有玩家交互、背景音乐和环境声音设置音效。我们还提到了在开发过程中使用占位符，允许您专注于游戏代码，同时让您可以在以后灵活地润色和完善您的游戏声音。

静态对象:静态对象部分提醒你尽可能花时间让游戏中的对象保持静态。当 Hover Racers 游戏项目在“Main13”和“Main14”场景中使用静态对象时，您可以查看该功能的使用情况。看一看。

标签和层:在这一节中，我们简要地谈到了标签和层，并讨论了如何在游戏中使用它们。Hover Racers 代码库经常使用标签来帮助以编程方式识别某些游戏对象。

人工智能对手:人工智能对手部分列出了一些关于游戏人工智能的一般想法，并谈到了应用于悬停赛车游戏的具体实现。

相机:在这一部分，我们讨论了相机以及如何使用它们来增强你的游戏。我们还提到了检查游戏的多摄像机设置是如何实现的。

项目设置:有大量的项目设置，要涵盖所有的设置需要相当多的时间和很多页的文字。我们所做的是把重点放在项目设置的“质量”部分，并把它作为 Unity 编辑器的统计弹出和剖析工具的一个延续。

我希望这一章为你提供了一些思考的素材。至少，当你开发下一个伟大的游戏或者改进当前的游戏时，你需要记住一些事情。在这篇文章的下一章，我们将看看如何添加一个新的赛道到悬停赛车游戏！