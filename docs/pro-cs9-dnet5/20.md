# 二十、文件 I/O 和对象序列化

当您创建桌面应用时，在用户会话之间保存信息的能力是很常见的。本章从的角度研究了几个与 I/O 相关的主题。NET 核心框架。首要任务是探索在`System.IO`名称空间中定义的核心类型，并学习如何以编程方式修改机器的目录和文件结构。下一个任务是探索读取和写入基于字符、基于二进制、基于字符串和基于内存的数据存储的各种方法。

在您学习了如何使用核心 I/O 类型操作文件和目录之后，您将研究相关的主题*对象序列化*。您可以使用对象序列化将对象的状态持久化并检索到任何从`System.IO.Stream`派生的类型。

Note

为了确保您可以运行本章中的每个示例，请以管理权限启动 Visual Studio(只需右击 Visual Studio 图标并选择“以管理员身份运行”)。如果不这样做，在访问计算机文件系统时可能会遇到运行时安全异常。

## 探索系统。IO 命名空间

在...的框架内。NET 核心中，`System.IO`命名空间是专用于基于文件(和基于内存)的输入和输出(I/O)服务的基类库区域。像任何名称空间一样，`System.IO`定义了一组类、接口、枚举、结构和委托，其中大部分可以在`mscorlib.dll`中找到。除了包含在`mscorlib.dll`中的类型之外，`System.dll`程序集还定义了`System.IO`名称空间的其他成员。

`System.IO`名称空间中的许多类型侧重于物理目录和文件的编程操作。但是，其他类型支持从字符串缓冲区以及原始内存位置读取数据和向其中写入数据。表 [20-1](#Tab1) 概述了核心(非抽象)类，提供了`System.IO`中功能的路线图。

表 20-1。

`System.IO`名称空间的主要成员

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

非抽象 I/O 类类型

 | 

生命的意义

 |
| --- | --- |
| `BinaryReader``BinaryWriter` | 这些类允许您以二进制值的形式存储和检索原始数据类型(整数、布尔值、字符串等等)。 |
| `BufferedStream` | 此类为字节流提供临时存储，您可以在以后提交给存储。 |
| `Directory``DirectoryInfo` | 您可以使用这些类来操作机器的目录结构。`Directory`类型使用*静态成员*公开功能，而`DirectoryInfo`类型从有效的*对象引用*公开类似的功能。 |
| `DriveInfo` | 该类提供关于给定机器使用的驱动器的详细信息。 |
| `File``FileInfo` | 您使用这些类来操作机器的一组文件。`File`类型使用*静态成员*公开功能，而`FileInfo`类型从有效的*对象引用*公开类似的功能。 |
| `FileStream` | 这个类为您提供了随机文件访问(例如，搜索功能),数据以字节流的形式表示。 |
| `FileSystemWatcher` | 这个类允许你监视指定目录中外部文件的修改。 |
| `MemoryStream` | 该类提供对存储在内存中而不是物理文件中的流数据的随机访问。 |
| `Path` | 这个类以平台无关的方式对包含文件或目录路径信息的`System.String`类型执行操作。 |
| `StreamWriter``StreamReader` | 您可以使用这些类将文本信息存储到(或从)文件中检索。这些类型不支持随机文件访问。 |
| `StringWriter``StringReader` | 像`StreamReader` / `StreamWriter`类一样，这些类也处理文本信息。然而，底层存储是一个字符串缓冲区，而不是一个物理文件。 |

除了这些具体的类类型，`System.IO`还定义了几个枚举，以及一组抽象类(例如，`Stream`、`TextReader`和`TextWriter`，它们为所有后代定义了一个共享的多态接口。在这一章中，你将会读到许多这种类型的内容。

## 目录(信息)和文件(信息)类型

提供四个类，允许你操作单个文件，以及与机器的目录结构交互。前两种类型，`Directory`和`File`，使用各种静态成员公开创建、删除、复制和移动操作。密切相关的`FileInfo`和`DirectoryInfo`类型公开了与实例级方法相似的功能(因此，必须用`new`关键字分配它们)。`Directory`和`File`类直接扩展`System.Object`，而`DirectoryInfo`和`FileInfo`从抽象的`FileSystemInfo`类型派生而来。

`FileInfo`和`DirectoryInfo`通常是获得文件或目录的完整细节(例如，创建时间或读/写能力)的更好选择，因为它们的成员倾向于返回强类型对象。相反，`Directory`和`File`类成员倾向于返回简单的字符串值，而不是强类型对象。然而，这只是一个指导方针；在许多情况下，你可以使用`File` / `FileInfo`或`Directory` / `DirectoryInfo`完成同样的工作。

### 抽象 FileSystemInfo 基类

`DirectoryInfo`和`FileInfo`类型从抽象的`FileSystemInfo`基类接收许多行为。在大多数情况下，您使用`FileSystemInfo`类的成员来发现一般特征(例如创建时间、各种属性等。)关于给定的文件或目录。表 [20-2](#Tab2) 列出了一些感兴趣的核心属性。

表 20-2。

`FileSystemInfo`属性

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

财产

 | 

生命的意义

 |
| --- | --- |
| `Attributes` | 获取或设置与当前文件关联的属性，这些属性由`FileAttributes`枚举表示(例如，文件或目录是只读的、加密的、隐藏的还是压缩的？) |
| `CreationTime` | 获取或设置当前文件或目录的创建时间 |
| `Exists` | 确定给定的文件或目录是否存在 |
| `Extension` | 检索文件的扩展名 |
| `FullName` | 获取目录或文件的完整路径 |
| `LastAccessTime` | 获取或设置上次访问当前文件或目录的时间 |
| `LastWriteTime` | 获取或设置上次写入当前文件或目录的时间 |
| `Name` | 获取当前文件或目录的名称 |

`FileSystemInfo`也定义了`Delete()`方法。这是通过派生类型从硬盘上删除给定的文件或目录来实现的。此外，您可以在获取属性信息之前调用`Refresh()`,以确保关于当前文件(或目录)的统计信息没有过时。

## 使用 DirectoryInfo 类型

您将研究的第一个可创建的以 I/O 为中心的类型是`DirectoryInfo`类。该类包含一组用于创建、移动、删除和枚举目录和子目录的成员。除了其基类(`FileSystemInfo`)提供的功能外，`DirectoryInfo`还提供表 [20-3](#Tab3) 中详细列出的关键成员。

表 20-3。

`DirectoryInfo`类型的主要成员

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

成员

 | 

生命的意义

 |
| --- | --- |
| `Create()``CreateSubdirectory()` | 给定路径名时，创建一个目录(或一组子目录) |
| `Delete()` | 删除目录及其所有内容 |
| `GetDirectories()` | 返回代表当前目录中所有子目录的`DirectoryInfo`对象数组 |
| `GetFiles()` | 检索代表给定目录中一组文件的一组`FileInfo`对象 |
| `MoveTo()` | 将目录及其内容移动到新路径 |
| `Parent` | 检索了此目录的父目录 |
| `Root` | 获取路径的根部分 |

通过指定一个特定的目录路径作为构造函数参数，开始使用`DirectoryInfo`类型。如果您想要访问当前工作目录(执行应用的目录)，请使用点(`.`)符号。以下是一些例子:

```cs
// Bind to the current working directory.
DirectoryInfo dir1 = new DirectoryInfo(".");
// Bind to C:\Windows,
// using a verbatim string.
DirectoryInfo dir2 = new DirectoryInfo(@"C:\Windows");

```

在第二个例子中，假设传递给构造函数(`C:\Windows`)的路径已经存在于物理机器上。然而，如果您试图与一个不存在的目录交互，就会抛出一个`System.IO.DirectoryNotFoundException`。因此，如果您指定了一个尚未创建的目录，您需要在继续之前调用`Create()`方法，如下所示:

```cs
// Bind to a nonexistent directory, then create it.
DirectoryInfo dir3 = new DirectoryInfo(@"C:\MyCode\Testing");
dir3.Create();

```

上例中使用的路径语法是以窗口为中心的。如果你在发展。NET 核心应用，您应该使用`Path.VolumeSeparatorChar`和`Path.DirectorySeparatorChar`构造，它们将基于平台产生适当的字符。将前面的代码更新为以下内容:

```cs
DirectoryInfo dir3 = new DirectoryInfo(
$@"C{Path.VolumeSeparatorChar}{Path.DirectorySeparatorChar}MyCode{Path.DirectorySeparatorChar}Testing");

```

在创建了一个`DirectoryInfo`对象之后，您可以使用从`FileSystemInfo`继承的任何属性来研究底层目录内容。要看到这一点，创建一个名为 DirectoryApp 的新控制台应用项目，并更新您的 C#文件以导入`System`和`System.IO`。用以下新的静态方法更新您的`Program`类，该方法创建一个映射到`C:\Windows`的新的`DirectoryInfo`对象(如果需要，调整您的路径)，它显示几个有趣的统计数据:

```cs
using System;
using System.IO;

Console.WriteLine("***** Fun with Directory(Info) *****\n");
ShowWindowsDirectoryInfo();
Console.ReadLine();

static void ShowWindowsDirectoryInfo()
{
  // Dump directory information. If you are not on Windows, plug in another directory
  DirectoryInfo dir = new DirectoryInfo($@"C{Path.VolumeSeparatorChar}{Path.DirectorySeparatorChar}Windows");
  Console.WriteLine("***** Directory Info *****");
  Console.WriteLine("FullName: {0}", dir.FullName);
  Console.WriteLine("Name: {0}", dir.Name);
  Console.WriteLine("Parent: {0}", dir.Parent);
  Console.WriteLine("Creation: {0}", dir.CreationTime);
  Console.WriteLine("Attributes: {0}", dir.Attributes);
  Console.WriteLine("Root: {0}", dir.Root);
  Console.WriteLine("**************************\n");
}

```

虽然您的输出可能会有所不同，但您应该会看到如下所示的内容:

```cs
***** Fun with Directory(Info) *****
***** Directory Info *****
FullName: C:\Windows
Name: Windows
Parent:
Creation: 3/19/2019 00:37:22
Attributes: Directory
Root: C:\
**************************

```

### 枚举 DirectoryInfo 类型的文件

除了获得现有目录的基本细节，您还可以扩展当前示例，使用一些`DirectoryInfo`类型的方法。首先，您可以利用`GetFiles()`方法获得位于`C:\Windows\Web\Wallpaper`目录中的所有`*.jpg`文件的信息。

Note

如果您不是在 Windows 机器上，修改此代码以读取您机器上某个目录下的文件。记住使用`Path.VolumeSeparatorChar`和`Path.DirectorySeparatorChar`值来使你的代码跨平台兼容。

`GetFiles()`方法返回一个由`FileInfo`对象组成的数组，每个对象公开一个特定文件的细节(你将在本章后面了解到`FileInfo`类型的全部细节)。在`Program`类中创建以下静态方法:

```cs
static void DisplayImageFiles()
{
  DirectoryInfo dir = new
    DirectoryInfo(@"C:\Windows\Web\Wallpaper");
  // Get all files with a *.jpg extension.
  FileInfo[] imageFiles =
    dir.GetFiles("*.jpg", SearchOption.AllDirectories);

  // How many were found?
  Console.WriteLine("Found {0} *.jpg files\n", imageFiles.Length);

  // Now print out info for each file.
  foreach (FileInfo f in imageFiles)
  {
    Console.WriteLine("***************************");
    Console.WriteLine("File name: {0}", f.Name);
    Console.WriteLine("File size: {0}", f.Length);
    Console.WriteLine("Creation: {0}", f.CreationTime);
    Console.WriteLine("Attributes: {0}", f.Attributes);
    Console.WriteLine("***************************\n");
  }
}

```

注意，当您调用`GetFiles()`时，您指定了一个搜索选项；这样做是为了在根目录的所有子目录中查找。运行应用后，您将看到所有符合搜索模式的文件的列表。

### 创建 DirectoryInfo 类型的子目录

您可以使用`DirectoryInfo.CreateSubdirectory()`方法以编程方式扩展目录结构。此方法可以在一次函数调用中创建一个子目录以及多个嵌套子目录。这个方法演示了如何做到这一点，用一些自定义子目录扩展了应用执行目录(用`.`表示)的目录结构:

```cs
static void ModifyAppDirectory()
{
  DirectoryInfo dir = new DirectoryInfo(".");

  // Create \MyFolder off application directory.
  dir.CreateSubdirectory("MyFolder");

  // Create \MyFolder2\Data off application directory.
  dir.CreateSubdirectory(
    $@"MyFolder2{Path.DirectorySeparatorChar}Data");
}

```

您不需要捕获`CreateSubdirectory()`方法的返回值，但是您应该知道，表示新创建的项目的`DirectoryInfo`对象在成功执行时被传递回来。考虑对先前方法的以下更新:

```cs
static void ModifyAppDirectory()
{
  DirectoryInfo dir = new DirectoryInfo(".");

  // Create \MyFolder off initial directory.
  dir.CreateSubdirectory("MyFolder");

  // Capture returned DirectoryInfo object.
  DirectoryInfo myDataFolder = dir.CreateSubdirectory(
    $@"MyFolder2{Path.DirectorySeparatorChar}Data");

  // Prints path to ..\MyFolder2\Data.
  Console.WriteLine("New Folder is: {0}", myDataFolder);
}

```

如果从顶级语句中调用此方法，并使用 Windows 资源管理器检查 Windows 目录，您将看到新的子目录存在并被考虑在内。

## 使用目录类型

你已经看到了`DirectoryInfo`型的作用；现在你已经准备好学习`Directory`类型了。在很大程度上，`Directory`的静态成员模仿了由`DirectoryInfo`定义的实例级成员所提供的功能。然而，回想一下，`Directory`的成员通常返回字符串数据，而不是强类型的`FileInfo` / `DirectoryInfo`对象。

现在让我们看看`Directory`类型的一些功能。这个最后的帮助器函数显示映射到当前计算机的所有驱动器的名称(使用`Directory.GetLogicalDrives()`方法),并使用静态的`Directory.Delete()`方法删除之前创建的`\MyFolder`和`\MyFolder2\Data`子目录。

```cs
static void FunWithDirectoryType()
{
  // List all drives on current computer.
  string[] drives = Directory.GetLogicalDrives();
  Console.WriteLine("Here are your drives:");
  foreach (string s in drives)
  {
    Console.WriteLine("--> {0} ", s);
  }

  // Delete what was created.
  Console.WriteLine("Press Enter to delete directories");
  Console.ReadLine();
  try
  {
    Directory.Delete("MyFolder");

    // The second parameter specifies whether you
    // wish to destroy any subdirectories.
    Directory.Delete("MyFolder2", true);
  }
  catch (IOException e)

  {
    Console.WriteLine(e.Message);
  }
}

```

## 使用 DriveInfo 类类型

`System.IO`名称空间提供了一个名为`DriveInfo`的类。像`Directory.GetLogicalDrives()`一样，静态`DriveInfo.GetDrives()`方法允许您发现机器驱动器的名称。然而，与`Directory.GetLogicalDrives()`不同的是，`DriveInfo`提供了许多其他细节(例如，驱动器类型、可用空间和卷标)。考虑在名为 DriveInfoApp 的新控制台应用项目中定义的以下`Program`类:

```cs
using System;
using System.IO;

// Get info regarding all drives.
DriveInfo[] myDrives = DriveInfo.GetDrives();
// Now print drive stats.
foreach(DriveInfo d in myDrives)
{
  Console.WriteLine("Name: {0}", d.Name);
  Console.WriteLine("Type: {0}", d.DriveType);

  // Check to see whether the drive is mounted.
  if(d.IsReady)
  {
    Console.WriteLine("Free space: {0}", d.TotalFreeSpace);
    Console.WriteLine("Format: {0}", d.DriveFormat);
    Console.WriteLine("Label: {0}", d.VolumeLabel);
  }
  Console.WriteLine();
}
Console.ReadLine();

```

以下是一些可能的输出:

```cs
***** Fun with DriveInfo *****
Name: C:\
Type: Fixed
Free space: 284131119104
Format: NTFS
Label: OS

Name: M:\
Type: Network
Free space: 4711871942656
Format: NTFS
Label: DigitalMedia

```

至此，您已经研究了`Directory`、`DirectoryInfo`和`DriveInfo`类的一些核心行为。接下来，您将学习如何创建、打开、关闭和销毁填充给定目录的文件。

## 使用 FileInfo 类

如前面的`DirectoryApp`示例所示，`FileInfo`类允许您获取硬盘上现有文件的详细信息(例如，创建时间、大小和文件属性),并帮助创建、复制、移动和销毁文件。除了由`FileSystemInfo`继承的功能集，你可以找到一些`FileInfo`类独有的核心成员，你可以在表 [20-4](#Tab4) 中看到描述。

表 20-4。

`FileInfo`核心成员

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

成员

 | 

生命的意义

 |
| --- | --- |
| `AppendText()` | 创建一个向文件追加文本的`StreamWriter`对象(稍后描述) |
| `CopyTo()` | 将现有文件复制到新文件中 |
| `Create()` | 创建一个新文件并返回一个`FileStream`对象(稍后描述)来与新创建的文件交互 |
| `CreateText()` | 创建一个写新文本文件的`StreamWriter`对象 |
| `Delete()` | 删除绑定了`FileInfo`实例的文件 |
| `Directory` | 获取父目录的实例 |
| `DirectoryName` | 获取父目录的完整路径 |
| `Length` | 获取当前文件的大小 |
| `MoveTo()` | 将指定文件移动到新位置，并提供指定新文件名的选项 |
| `Name` | 获取文件的名称 |
| `Open()` | 以各种读/写和共享权限打开文件 |
| `OpenRead()` | 创建一个只读的`FileStream`对象 |
| `OpenText()` | 创建一个从现有文本文件中读取的`StreamReader`对象(稍后描述) |
| `OpenWrite()` | 创建一个只写的`FileStream`对象 |

请注意，`FileInfo`类的大多数方法都返回一个特定的以 I/O 为中心的对象(例如，`FileStream`和`StreamWriter`)，该对象允许您开始以各种格式向相关文件读写数据。您将很快了解这些类型；然而，在您看到一个工作示例之前，您会发现检查使用`FileInfo`类类型获得文件句柄的各种方法是有帮助的。

### 文件信息。Create()方法

下一组示例都在一个名为 SimpleFileIO 的控制台应用中。创建文件句柄的一种方法是使用`FileInfo.Create()`方法，如下所示:

```cs
using System;
using System.IO;

Console.WriteLine("***** Simple IO with the File Type *****\n");
//Change to a folder on your machine that you have read/write access to, or run as administrator
var fileName = $@"C{Path.VolumeSeparatorChar}{Path.DirectorySeparatorChar}temp{Path.DirectorySeparatorChar}Test.dat";
// Make a new file on the C drive.
FileInfo f = new FileInfo(fileName);
FileStream fs = f.Create();

// Use the FileStream object...

// Close down file stream.
fs.Close();

```

Note

这些示例可能需要以管理员身份运行 Visual Studio，具体取决于您的用户权限和系统配置。

注意，`FileInfo.Create()`方法返回了一个`FileStream`对象，该对象公开了对底层文件的同步和异步写/读操作(稍后会有更多细节)。注意由`FileInfo.Create()`返回的`FileStream`对象授予所有用户完全的读/写权限。

还要注意，在使用完当前的`FileStream`对象后，必须确保关闭句柄来释放底层的非托管流资源。鉴于`FileStream`实现了`IDisposable`，你可以使用 C# `using`的作用域来允许编译器生成拆卸逻辑(详见第 [8 章](08.html))，如下所示:

```cs
var fileName = $@"C{Path.VolumeSeparatorChar}{Path.DirectorySeparatorChar}Test.dat";
...
//wrap the file stream in a using statement
// Defining a using scope for file I/O
FileInfo f1 = new FileInfo(fileName);
using (FileStream fs1 = f1.Create())
{
  // Use the FileStream object...
}
f1.Delete();

```

Note

本章中几乎所有的例子都包含了`using`语句。我本可以使用新的 using 声明语法，但在这次重写中没有这样做，以保持示例集中在我们正在检查的`System.IO`组件上。

### 文件信息。Open()方法

您可以使用`FileInfo.Open()`方法打开现有文件，也可以创建比使用`FileInfo.Create()`更精确的新文件。这是可行的，因为`Open()`通常采用几个参数来限定如何迭代您想要操作的文件。一旦对`Open()`的调用完成，就会返回一个`FileStream`对象。考虑以下逻辑:

```cs
var fileName = $@"C{Path.VolumeSeparatorChar}{Path.DirectorySeparatorChar}Test.dat";
...
// Make a new file via FileInfo.Open().
FileInfo f2 = new FileInfo(fileName);
using(FileStream fs2 = f2.Open(FileMode.OpenOrCreate,
  FileAccess.ReadWrite, FileShare.None))
{
  // Use the FileStream object...
}
f2.Delete();

```

这个版本的重载`Open()`方法需要三个参数。`Open()`方法的第一个参数指定了 I/O 请求的一般风格(例如，创建一个新文件，打开一个现有文件，并追加到一个文件中)，这可以使用`FileMode`枚举来指定(详细信息请参见表 [20-5](#Tab5) ，如下所示:

表 20-5。

`FileMode`枚举的成员

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

成员

 | 

生命的意义

 |
| --- | --- |
| `CreateNew` | 通知操作系统创建一个新文件。如果它已经存在，抛出一个`IOException`。 |
| `Create` | 通知操作系统创建一个新文件。如果它已经存在，它将被覆盖。 |
| `Open` | 打开现有文件。如果文件不存在，抛出一个`FileNotFoundException`。 |
| `OpenOrCreate` | 如果文件存在，则打开该文件；否则，将创建一个新文件。 |
| `Truncate` | 打开一个现有文件并将文件截断为 0 字节大小。 |
| `Append` | 打开一个文件，移动到文件末尾，并开始写操作(只能对只写流使用此标志)。如果文件不存在，将创建一个新文件。 |

```cs
public enum FileMode
{
  CreateNew,
  Create,
  Open,
  OpenOrCreate,
  Truncate,
  Append
}

```

使用`Open()`方法的第二个参数，一个来自`FileAccess`枚举的值，来确定底层流的读/写行为，如下所示:

```cs
public enum FileAccess
{
  Read,
  Write,
  ReadWrite
}

```

最后，`Open()`方法的第三个参数`FileShare`指定如何在其他文件处理程序之间共享文件。以下是核心名称:

```cs
public enum FileShare
{
  None,
  Read,
  Write,
  ReadWrite,
  Delete,
  Inheritable
}

```

### 文件信息。OpenRead()和 FileInfo。OpenWrite()方法

`FileInfo.Open()`方法允许您以灵活的方式获得文件句柄，但是`FileInfo`类也提供了名为`OpenRead()`和`OpenWrite()`的成员。正如您所想象的，这些方法返回一个正确配置的只读或只写的`FileStream`对象，而不需要提供各种枚举值。和`FileInfo.Create()`和`FileInfo.Open()`一样，`OpenRead()`和`OpenWrite()`返回一个`FileStream`对象。

注意，`OpenRead()`方法要求文件已经存在。下面的代码创建文件，然后关闭`FileStream`，这样它就可以被`OpenRead()`方法使用了:

```cs
f3.Create().Close();

```

以下是完整的示例:

```cs
var fileName = $@"C{Path.VolumeSeparatorChar}{Path.DirectorySeparatorChar}Test.dat";
...
// Get a FileStream object with read-only permissions.
FileInfo f3 = new FileInfo(fileName);
//File must exist before using OpenRead
f3.Create().Close();
using(FileStream readOnlyStream = f3.OpenRead())
{
  // Use the FileStream object...
}
f3.Delete();

// Now get a FileStream object with write-only permissions.
FileInfo f4 = new FileInfo(fileName);
using(FileStream writeOnlyStream = f4.OpenWrite())
{
  // Use the FileStream object...
}
f4.Delete();

```

### 文件信息。OpenText()方法

`FileInfo`类型的另一个开中心成员是`OpenText()`。与`Create()`、`Open()`、`OpenRead()`或`OpenWrite()`不同，`OpenText()`方法返回`StreamReader`类型的实例，而不是`FileStream`类型的实例。假设您在`C:`驱动器上有一个名为`boot.ini`的文件，下面的代码片段让您可以访问它的内容:

```cs
var fileName = $@"C{Path.VolumeSeparatorChar}{Path.DirectorySeparatorChar}Test.dat";
...
// Get a StreamReader object.
//If not on a Windows machine, change the file name accordingly
FileInfo f5 = new FileInfo(fileName);
//File must exist before using OpenText
f5.Create().Close();
using(StreamReader sreader = f5.OpenText())
{
  // Use the StreamReader object...
}
f5.Delete();

```

很快您就会看到，`StreamReader`类型提供了一种从底层文件读取字符数据的方法。

### 文件信息。CreateText()和 FileInfo。AppendText()方法

此时最后两个感兴趣的`FileInfo`方法是`CreateText()`和`AppendText()`。两者都返回一个`StreamWriter`对象，如下所示:

```cs
var fileName = $@"C{Path.VolumeSeparatorChar}{Path.DirectorySeparatorChar}Test.dat";
...
FileInfo f6 = new FileInfo(fileName);
using(StreamWriter swriter = f6.CreateText())
{
  // Use the StreamWriter object...
}
f6.Delete();
FileInfo f7 = new FileInfo(fileName);
using(StreamWriter swriterAppend = f7.AppendText())
{
  // Use the StreamWriter object...
}
f7.Delete();

```

正如您可能猜到的，`StreamWriter`类型提供了一种将字符数据写入底层文件的方法。

## 使用文件类型

`File`类型使用几个静态成员来提供与`FileInfo`类型几乎相同的功能。像`FileInfo`、`File`供给`AppendText()`、`Create()`、`CreateText()`、`Open()`、`OpenRead()`、`OpenWrite()`、`OpenText()`的方法。在许多情况下，您可以互换使用`File`和`FileInfo`类型。注意`OpenText()`和`OpenRead()`要求文件已经存在。要看到这一点，您可以通过使用`File`类型来简化前面的每个`FileStream`示例，如下所示:

```cs
var fileName = $@"C{Path.VolumeSeparatorChar}{Path.DirectorySeparatorChar}Test.dat";
...
//Using File instead of FileInfo
using (FileStream fs8 = File.Create(fileName))
{
  // Use the FileStream object...
}
File.Delete(fileName);
// Make a new file via FileInfo.Open().
using(FileStream fs9 =  File.Open(fileName,
  FileMode.OpenOrCreate, FileAccess.ReadWrite,
  FileShare.None))
{
  // Use the FileStream object...
}
// Get a FileStream object with read-only permissions.
using(FileStream readOnlyStream = File.OpenRead(fileName))
{}
File.Delete(fileName);
// Get a FileStream object with write-only permissions.
using(FileStream writeOnlyStream = File.OpenWrite(fileName))
{}
// Get a StreamReader object.
using(StreamReader sreader = File.OpenText(fileName))
{}
File.Delete(fileName);
// Get some StreamWriters.
using(StreamWriter swriter = File.CreateText(fileName))
{}
File.Delete(fileName);

using(StreamWriter swriterAppend =
  File.AppendText(fileName))
{}
File.Delete(fileName)

;

```

### 其他以文件为中心的成员

`File`类型还支持一些成员，如表 [20-6](#Tab6) 所示，可以大大简化读写文本数据的过程。

表 20-6。

文件类型的方法

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

方法

 | 

生命的意义

 |
| --- | --- |
| `ReadAllBytes()` | 打开指定的文件，以字节数组的形式返回二进制数据，然后关闭文件 |
| `ReadAllLines()` | 打开指定的文件，以字符串数组的形式返回字符数据，然后关闭文件 |
| `ReadAllText()` | 打开指定文件，返回字符数据作为`System.String`，然后关闭文件 |
| `WriteAllBytes()` | 打开指定的文件，写出字节数组，然后关闭文件 |
| `WriteAllLines()` | 打开指定文件，写出字符串数组，然后关闭文件 |
| `WriteAllText()` | 打开指定文件，写入指定字符串中的字符数据，然后关闭该文件 |

您可以使用这些`File`类型的方法，只用几行代码就可以读写成批的数据。更好的是，这些成员中的每一个都会自动关闭底层文件句柄。例如，下面的控制台程序(名为`SimpleFileIO`)将字符串数据持久化到`C:`驱动器上的一个新文件中(并将它读入内存中)，而不会产生任何麻烦(这个例子假设您已经导入了`System.IO`):

```cs
Console.WriteLine("***** Simple I/O with the File Type *****\n");
string[] myTasks = {
  "Fix bathroom sink", "Call Dave",
  "Call Mom and Dad", "Play Xbox One"};

// Write out all data to file on C drive.
File.WriteAllLines(@"tasks.txt", myTasks);

// Read it all back and print out.
foreach (string task in File.ReadAllLines(@"tasks.txt"))
{
  Console.WriteLine("TODO: {0}", task);
}
Console.ReadLine();
File.Delete("tasks.txt");

```

这里的教训是，当你想快速获得一个文件句柄时，`File`类型将为你节省一些击键。然而，首先创建一个`FileInfo`对象的一个好处是，您可以使用抽象的`FileSystemInfo`基类的成员来研究文件。

## 抽象流类

至此，您已经看到了许多获取`FileStream`、`StreamReader`和`StreamWriter`对象的方法，但是您还没有使用这些类型从文件中读取数据或将数据写入文件。为了理解如何做到这一点，你需要熟悉*流*的概念。在 I/O 操作的世界里，*流*代表了在源和目的地之间流动的数据块。流提供了一种与*字节序列*进行交互的通用方式，无论哪种设备(例如文件、网络连接或打印机)存储或显示相关的字节。

抽象`System.IO.Stream`类定义了几个成员，这些成员为与存储介质(例如，底层文件或存储位置)的同步和异步交互提供支持。

Note

流的概念不限于文件 I/O。NET 核心库提供了对网络、内存位置和其他以流为中心的抽象的流访问。

同样，`Stream`后代将数据表示为原始字节流；因此，直接处理原始流是相当神秘的。一些`Stream`派生的类型支持*寻找*，是指获取并调整流中当前位置的过程。表 [20-7](#Tab7) 通过描述`Stream`类的核心成员来帮助你理解它所提供的功能。

表 20-7。

摘要`Stream`成员

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

成员

 | 

生命的意义

 |
| --- | --- |
| `CanRead``CanWrite``CanSeek` | 确定当前流是否支持读取、查找和/或写入。 |
| `Close()` | 关闭当前流并释放与当前流关联的任何资源(如套接字和文件句柄)。在内部，这个方法是`Dispose()`方法的别名；因此，*关闭流*在功能上等同于*处置流*。 |
| `Flush()` | 用缓冲区的当前状态更新底层数据源或储存库，然后清除缓冲区。如果流没有实现缓冲区，则此方法不执行任何操作。 |
| `Length` | 以字节为单位返回流的长度。 |
| `Position` | 确定当前流中的位置。 |
| `Read()``ReadByte()``ReadAsync()` | 从当前流中读取一个字节序列(或单个字节),并将流中的当前位置提升所读取的字节数。 |
| `Seek()` | 设置当前流中的位置。 |
| `SetLength()` | 设置当前流的长度。 |
| `Write()``WriteByte()``WriteAsync()` | 将一个字节序列(或单个字节)写入当前流，并按写入的字节数提升流中的当前位置。 |

### 使用文件流

`FileStream`类以适合基于文件的流的方式为抽象`Stream`成员提供了一个实现。这是一条原始的河流；它只能读取或写入单个字节或字节数组。然而，你并不经常需要与`FileStream`类型的成员直接交互。相反，你可能会使用各种*流包装器*，这使得处理文本数据或.NETCore 类型。尽管如此，您会发现尝试一下`FileStream`类型的同步读/写功能是很有帮助的。

假设您有一个名为 FileStreamApp 的新控制台应用项目(并验证`System.IO`和`System.Text`已导入到您的初始 C#代码文件中)。你的目标是写一个简单的文本信息到一个名为`myMessage.dat`的新文件中。然而，鉴于`FileStream`只能对原始字节进行操作，您需要将`System.String`类型编码到相应的字节数组中。幸运的是，`System.Text`名称空间定义了一个名为`Encoding`的类型，它提供了将字符串编码和解码为字节数组的成员。

一旦编码完成，字节数组就用`FileStream.Write()`方法保存到文件中。要将字节读回内存，必须重置流的内部位置(使用`Position`属性)并调用`ReadByte()`方法。最后，向控制台显示原始字节数组和解码后的字符串。以下是完整的代码:

```cs
using System;
using System.IO;
using System.Text;

// Don't forget to import the System.Text and System.IO namespaces.
Console.WriteLine("***** Fun with FileStreams *****\n");

// Obtain a FileStream object.
using(FileStream fStream = File.Open("myMessage.dat",
  FileMode.Create))
{
  // Encode a string as an array of bytes.
  string msg = "Hello!";
  byte[] msgAsByteArray = Encoding.Default.GetBytes(msg);

  // Write byte[] to file.
  fStream.Write(msgAsByteArray, 0, msgAsByteArray.Length);

  // Reset internal position of stream.
  fStream.Position = 0;

  // Read the types from file and display to console.
  Console.Write("Your message as an array of bytes: ");
  byte[] bytesFromFile = new byte[msgAsByteArray.Length];
  for (int i = 0; i < msgAsByteArray.Length; i++)
  {
    bytesFromFile[i] = (byte)fStream.ReadByte();
    Console.Write(bytesFromFile[i]);
  }

  // Display decoded messages.
  Console.Write("\nDecoded Message: ");
  Console.WriteLine(Encoding.Default.GetString(bytesFromFile));
  Console.ReadLine();
}
File.Delete("myMessage.dat");

```

这个例子用数据填充文件，但是它也强调了直接使用`FileStream`类型的主要缺点:它要求对原始字节进行操作。其他`Stream`派生的类型以类似的方式操作。例如，如果你想将一个字节序列写入内存区域，你可以分配一个`MemoryStream`。

如前所述，`System.IO`名称空间提供了几个*读取器*和*写入器*类型，它们封装了使用`Stream`派生类型的细节。

## 使用 streamwriter 和 streamreader

当您需要读取或写入基于字符的数据(例如字符串)时，`StreamWriter`和`StreamReader`类非常有用。默认情况下，两者都使用 Unicode 字符；然而，您可以通过提供一个正确配置的`System.Text.Encoding`对象引用来改变这一点。为了简单起见，假设默认的 Unicode 编码符合要求。

`StreamReader`从一个名为`TextReader`的抽象类型派生而来，相关的`StringReader`类型也是如此(本章稍后讨论)。`TextReader`基类为这些后代中的每一个提供了一组有限的功能；具体来说，它提供了读取和查看字符流的能力。

`StreamWriter`类型(以及`StringWriter`，你将在本章后面研究)来自一个名为`TextWriter`的抽象基类。此类定义允许派生类型将文本数据写入给定字符流的成员。

为了帮助你理解`StreamWriter`和`StringWriter`类的核心编写能力，表 [20-8](#Tab8) 描述了抽象`TextWriter`基类的核心成员。

表 20-8。

TextWriter 的核心成员

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

成员

 | 

生命的意义

 |
| --- | --- |
| `Close()` | 此方法关闭编写器并释放所有关联的资源。在这个过程中，缓冲区被自动刷新(同样，这个成员在功能上等同于调用`Dispose()`方法)。 |
| `Flush()` | 此方法清除当前编写器的所有缓冲区，并将所有缓冲的数据写入基础设备；但是，它不会关闭编写器。 |
| `NewLine` | 此属性指示派生的 writer 类的换行符常量。Windows 操作系统的默认行结束符是回车，后面跟一个换行符(`\r\n`)。 |
| `Write()``WriteAsync()` | 这个重载方法将数据写入文本流，而不使用换行符常量。 |
| `WriteLine()``WriteLineAsync()` | 这个重载的方法用一个换行符常量将数据写入文本流。 |

Note

最后两个`TextWriter`类的成员可能你看起来很熟悉。如果您还记得，`System.Console`类型有`Write()`和`WriteLine()`成员，它们将文本数据推送到标准输出设备。实际上，`Console.In`属性包装了一个`TextReader`，而`Console.Out`属性包装了一个`TextWriter`。

派生的`StreamWriter`类为`Write()`、`Close()`和`Flush()`方法提供了适当的实现，并定义了额外的`AutoFlush`属性。当设置为`true`时，该属性强制`StreamWriter`在每次执行写操作时刷新所有数据。请注意，通过将`AutoFlush`设置为`false`，您可以获得更好的性能，前提是当您使用`StreamWriter`完成写入时，您总是调用`Close()`。

### 写入文本文件

要查看运行中的`StreamWriter`类型，创建一个名为 StreamWriterReaderApp 的新控制台应用项目，并导入`System.IO`和`System.Text`。下面的代码使用`File.CreateText()`方法在当前执行文件夹中创建一个名为`reminders.txt`的新文件。使用获得的`StreamWriter`对象，您可以向新文件添加一些文本数据。

```cs
using System;
using System.IO;
using System.Text;

Console.WriteLine("***** Fun with StreamWriter / StreamReader *****\n");

// Get a StreamWriter and write string data.
using(StreamWriter writer = File.CreateText("reminders.txt"))
{
  writer.WriteLine("Don't forget Mother's Day this year...");
  writer.WriteLine("Don't forget Father's Day this year...");
  writer.WriteLine("Don't forget these numbers:");
  for(int i = 0; i < 10; i++)
  {
    writer.Write(i + " ");
  }

  // Insert a new line.
  writer.Write(writer.NewLine);
}
Console.WriteLine("Created file and wrote some thoughts...");
Console.ReadLine();
//File.Delete("reminders.txt");

```

运行该程序后，您可以检查这个新文件的内容。您将在项目的根目录(Visual Studio 代码)或在`bin\Debug\net5.0`文件夹(Visual Studio)下找到该文件，因为您在调用`CreateText()`时没有指定绝对路径，并且文件位置默认为程序集的当前执行目录。

### 从文本文件中读取

接下来，您将学习通过使用相应的`StreamReader`类型以编程方式从文件中读取数据。回想一下，这个类源自抽象`TextReader`，它提供了表 [20-9](#Tab9) 中描述的功能。

表 20-9。

`TextReader`核心成员

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

成员

 | 

生命的意义

 |
| --- | --- |
| `Peek()` | 返回下一个可用字符(用整数表示)，而不改变读取器的位置。值`-1`表示您位于流的末尾。 |
| `Read()``ReadAsync()` | 从输入流中读取数据。 |
| `ReadBlock()``ReadBlockAsync()` | 从当前流中读取指定的最大字符数，并将数据写入缓冲区，从指定的索引处开始。 |
| `ReadLine()``ReadLineAsync()` | 从当前流中读取一行字符，并将数据作为字符串返回(`null`字符串表示 e of)。 |
| `ReadToEnd()``ReadToEndAsync()` | 读取从当前位置到流尾的所有字符，并将它们作为单个字符串返回。 |

如果您现在扩展当前的示例应用以使用一个`StreamReader`，您可以从`reminders.txt`文件中读入文本数据，如下所示:

```cs
Console.WriteLine("***** Fun with StreamWriter / StreamReader *****\n");
...
// Now read data from file.
Console.WriteLine("Here are your thoughts:\n");
using(StreamReader sr = File.OpenText("reminders.txt"))
{
  string input = null;
  while ((input = sr.ReadLine()) != null)
  {
    Console.WriteLine (input);
  }
}
Console.ReadLine();

```

运行程序后，你会看到`reminders.txt`中的字符数据显示到控制台上。

### 直接创建 StreamWriter/StreamReader 类型

使用`System.IO`中的类型的一个令人困惑的方面是，您经常可以使用不同的方法获得相同的结果。例如，您已经看到，您可以使用`CreateText()`方法获得带有`File`或`FileInfo`类型的`StreamWriter`。碰巧你可以用另一种方式处理`StreamWriter`和`StreamReader` s:直接创建它们。例如，您可以对当前应用进行如下改进:

```cs
Console.WriteLine("***** Fun with StreamWriter / StreamReader *****\n");

// Get a StreamWriter and write string data.
using(StreamWriter writer = new StreamWriter("reminders.txt"))
{
  ...
}

// Now read data from file.
using(StreamReader sr = new StreamReader("reminders.txt"))
{
  ...
}

```

虽然看到这么多看似相同的文件 I/O 方法会让人有点困惑，但请记住，这样做的结果是更大的灵活性。无论如何，现在您已经准备好检查`StringWriter`和`StringReader`类的作用，因为您已经看到了如何使用`StreamWriter`和`StreamReader`类型将字符数据移入和移出给定的文件。

## 使用 stringwriter 和 stringreader

您可以使用`StringWriter`和`StringReader`类型将文本信息视为内存中的字符流。当您想要将基于字符的信息追加到底层缓冲区时，这可能会很有帮助。下面的控制台应用项目(名为 StringReaderWriterApp)通过将一个字符串数据块写入一个`StringWriter`对象，而不是写入本地硬盘上的一个文件(不要忘记导入`System.IO`和`System.Text`)来说明这一点:

```cs
using System;
using System.IO;
using System.Text;

  Console.WriteLine("***** Fun with StringWriter / StringReader *****\n");

// Create a StringWriter and emit character data to memory.
using(StringWriter strWriter = new StringWriter())
{
  strWriter.WriteLine("Don't forget Mother's Day this year...");
  // Get a copy of the contents (stored in a string) and dump
  // to console.
  Console.WriteLine("Contents of StringWriter:\n{0}", strWriter);
}
Console.ReadLine();

```

`StringWriter`和`StreamWriter`都来源于同一个基类(`TextWriter`)，所以编写逻辑差不多。然而，考虑到`StringWriter`的性质，你也应该知道这个类允许你使用下面的`GetStringBuilder()`方法来提取一个`System.Text.StringBuilder`对象:

```cs
using (StringWriter strWriter = new StringWriter())
{
  strWriter.WriteLine("Don't forget Mother's Day this year...");
  Console.WriteLine("Contents of StringWriter:\n{0}", strWriter);

  // Get the internal StringBuilder.
  StringBuilder sb = strWriter.GetStringBuilder();
  sb.Insert(0, "Hey!! ");
  Console.WriteLine("-> {0}", sb.ToString());
  sb.Remove(0, "Hey!! ".Length);
  Console.WriteLine("-> {0}", sb.ToString());
}

```

当您想从字符数据流中读取数据时，您可以使用相应的`StringReader`类型，它(正如您所期望的)的功能与相关的`StreamReader`类相同。事实上，`StringReader`类只不过覆盖了继承的成员，从字符数据块中读取，而不是从文件中读取，如下所示:

```cs
using (StringWriter strWriter = new StringWriter())
{
  strWriter.WriteLine("Don't forget Mother's Day this year...");
  Console.WriteLine("Contents of StringWriter:\n{0}", strWriter);

  // Read data from the StringWriter.
  using (StringReader strReader = new StringReader(strWriter.ToString()))
  {
    string input = null;
    while ((input = strReader.ReadLine()) != null)
    {
      Console.WriteLine(input);
    }
  }
}

```

## 使用 binarywriter 和 binaryreader

您将在本节中检查的最后一组写入器/读取器是`BinaryReader`和`BinaryWriter`。两者都直接来源于`System.Object`。这些类型允许您以紧凑的二进制格式读写基础流中的离散数据类型。`BinaryWriter`类定义了一个高度重载的`Write()`方法，将数据类型放入底层流中。除了`Write()`成员之外，`BinaryWriter`还提供了额外的成员，允许您获取或设置`Stream`派生的类型；它还支持对数据的随机访问(见表 [20-10](#Tab10) )。

表 20-10。

`BinaryWriter`核心成员

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

成员

 | 

生命的意义

 |
| --- | --- |
| `BaseStream` | 这个只读属性提供对与`BinaryWriter`对象一起使用的基础流的访问。 |
| `Close()` | 此方法关闭二进制流。 |
| `Flush()` | 此方法刷新二进制流。 |
| `Seek()` | 此方法设置当前流中的位置。 |
| `Write()` | 此方法将一个值写入当前流。 |

`BinaryReader`类用表 [20-11](#Tab11) 中描述的成员补充了`BinaryWriter`提供的功能。

表 20-11。

`BinaryReader`核心成员

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

成员

 | 

生命的意义

 |
| --- | --- |
| `BaseStream` | 这个只读属性提供对与`BinaryReader`对象一起使用的基础流的访问。 |
| `Close()` | 此方法关闭二进制读取器。 |
| `PeekChar()` | 此方法返回下一个可用字符，而不提升在流中的位置。 |
| `Read()` | 此方法读取一组给定的字节或字符，并将它们存储在传入数组中。 |
| `ReadXXXX()` | `BinaryReader`类定义了许多从流中获取下一个类型的读取方法(例如，`ReadBoolean()`、`ReadByte()`和`ReadInt32()`)。 |

以下示例(一个名为 BinaryWriterReader 的控制台应用项目，使用了`System.IO`)将一些数据类型写入一个新的`*.dat`文件:

```cs
using System;
using System.IO;

Console.WriteLine("***** Fun with Binary Writers / Readers *****\n");

// Open a binary writer for a file.
FileInfo f = new FileInfo("BinFile.dat");
using(BinaryWriter bw = new BinaryWriter(f.OpenWrite()))
{
  // Print out the type of BaseStream.
  // (System.IO.FileStream in this case).
  Console.WriteLine("Base stream is: {0}", bw.BaseStream);

  // Create some data to save in the file.
  double aDouble = 1234.67;
  int anInt = 34567;
  string aString = "A, B, C";

  // Write the data.
  bw.Write(aDouble);
  bw.Write(anInt);
  bw.Write(aString);
}
Console.WriteLine("Done!");
Console.ReadLine();

```

注意从`FileInfo.OpenWrite()`返回的`FileStream`对象是如何传递给`BinaryWriter`类型的构造函数的。使用这种技术使得在写出数据之前*在*流中分层变得容易。请注意，`BinaryWriter`的构造函数接受任何从`Stream`派生的类型(例如，`FileStream`、`MemoryStream`或`BufferedStream`)。因此，将二进制数据写入内存就像提供一个有效的`MemoryStream`对象一样简单。

为了从`BinFile.dat`文件中读取数据，`BinaryReader`类型提供了几个选项。在这里，您调用各种以读取为中心的成员从文件流中提取每个数据块:

```cs
...
FileInfo f = new FileInfo("BinFile.dat");
...
// Read the binary data from the stream.
using(BinaryReader br = new BinaryReader(f.OpenRead()))
{
  Console.WriteLine(br.ReadDouble());
  Console.WriteLine(br.ReadInt32());
  Console.WriteLine(br.ReadString());
}
Console.ReadLine();

```

## 以编程方式监视文件

既然您对各种阅读器和编写器的使用有了更好的理解，那么您将会看到`FileSystemWatcher`类的作用。当您希望以编程方式监控(或“监视”)系统上的文件时，这种类型非常有用。具体来说，您可以指示`FileSystemWatcher`类型监视文件中由`System.IO.NotifyFilters`枚举指定的任何动作。

```cs
public enum NotifyFilters
{
  Attributes, CreationTime,
  DirectoryName, FileName,
  LastAccess, LastWrite,
  Security, Size
}

```

要开始使用`FileSystemWatcher`类型，您需要设置`Path`属性来指定包含您想要监控的文件的目录的名称(和位置),以及定义您想要监控的文件的文件扩展名的`Filter`属性。

此时，您可以选择处理`Changed`、`Created`和`Deleted`事件，所有这些事件都与`FileSystemEventHandler`委托协同工作。此委托可以调用与以下模式匹配的任何方法:

```cs
// The FileSystemEventHandler delegate must point
// to methods matching the following signature.
void MyNotificationHandler(object source, FileSystemEventArgs e)

```

您还可以使用`RenamedEventHandler`委托类型来处理`Renamed`事件，这可以调用匹配以下签名的方法:

```cs
// The RenamedEventHandler delegate must point
// to methods matching the following signature.
void MyRenamedHandler(object source, RenamedEventArgs e)

```

虽然您可以使用传统的委托/事件语法来处理每个事件，但我们将使用新的 lambda 表达式语法。

接下来，我们来看看看一个文件的过程。下面的控制台应用项目(名为 MyDirectoryWatcher，用一个`using`表示`System.IO`)监视`bin\debug\net5.0`目录中的`*.txt`文件，并在创建、删除、修改或重命名文件时打印消息:

```cs
using System;
using System.IO;

Console.WriteLine("***** The Amazing File Watcher App *****\n");
// Establish the path to the directory to watch.
FileSystemWatcher watcher = new FileSystemWatcher();
try
{
  watcher.Path = @".";
}
catch(ArgumentException ex)
{
  Console.WriteLine(ex.Message);
  return;
}
// Set up the things to be on the lookout for.
watcher.NotifyFilter = NotifyFilters.LastAccess
  | NotifyFilters.LastWrite
  | NotifyFilters.FileName
  | NotifyFilters.DirectoryName;

// Only watch text files.
watcher.Filter = "*.txt";

// Add event handlers.
// Specify what is done when a file is changed, created, or deleted.
watcher.Changed += (s, e) =>
  Console.WriteLine($"File: {e.FullPath} {e.ChangeType}!");
watcher.Created += (s, e) =>
  Console.WriteLine($"File: {e.FullPath} {e.ChangeType}!");
watcher.Deleted += (s, e) =>
  Console.WriteLine($"File: {e.FullPath} {e.ChangeType}!");
// Specify what is done when a file is renamed.
watcher.Renamed += (s, e) =>
  Console.WriteLine($"File: {e.OldFullPath} renamed to {e.FullPath}");
// Begin watching the directory.
watcher.EnableRaisingEvents = true;

// Wait for the user to quit the program.
Console.WriteLine(@"Press 'q' to quit app.");
// Raise some events.
using (var sw = File.CreateText("Test.txt"))
{
  sw.Write("This is some text");
}
File.Move("Test.txt","Test2.txt");
File.Delete("Test2.txt");

while(Console.Read()!='q');

```

当您运行这个程序时，最后几行将创建、更改、重命名，然后删除一个文本文件，并在此过程中引发事件。您还可以导航到`bin\debug\net5.0`目录，处理文件(扩展名为`*.txt`)并引发其他事件。

```cs
***** The Amazing File Watcher App *****
Press 'q' to quit app.
File: .\Test.txt Created!
File: .\Test.txt Changed!
File: .\Test.txt renamed to .\Test2.txt
File: .\Test2.txt Deleted!

```

这就结束了本章对。NET 核心平台。虽然您肯定会在许多应用中使用这些技术，但是您可能也会发现,*对象序列化*服务可以极大地简化您持久存储大量数据的方式。

## 了解对象序列化

术语*序列化*描述了将对象的状态持久化(并且可能转移)到流(例如，文件流或内存流)中的过程。持久化的数据序列包含了重构(或*反序列化*)对象的公共状态以备后用所需的所有必要信息。使用这项技术使得保存大量数据变得轻而易举。在许多情况下，使用序列化服务保存应用数据会比使用在`System.IO`名称空间中找到的读取器/写入器产生更少的代码。

例如，假设您想要创建一个基于 GUI 的桌面应用，为最终用户提供一种保存他们的首选项(例如，窗口颜色和字体大小)的方法。为此，您可以定义一个名为`UserPrefs`的类，它封装了大约 20 条字段数据。现在，如果你要使用一个`System.IO.BinaryWriter`类型，你需要手动保存`UserPrefs`对象*的每个字段*。同样，如果您要将数据从一个文件加载回内存，您将需要使用一个`System.IO.BinaryReader`和(再次)*手动*读入每个值来重新配置一个新的`UserPrefs`对象。

这都是可行的，但是您可以通过使用可扩展标记语言(XML)或 JavaScript 对象表示法(JSON)序列化来节省大量时间。每种格式都由名称-值对组成，允许在单个文本块中表示对象的公共状态，该文本块可跨平台和编程语言使用。这样做意味着您只需几行代码就可以保持对象的整个公共状态。

Note

本书前几版涉及的`BinaryFormatter`类型，安全风险较高，应立即停止使用( [`http://aka.ms/bnaryformatter`](http://aka.ms/bnaryformatter) )。更安全的替代方法包括对 XML/JSON 使用`BinaryReader`/`BinaryWriter`s。

。NET 核心对象序列化使得持久化对象变得容易；然而，幕后使用的流程相当复杂。例如，当对象被持久保存到流中时，所有相关联的公共数据(例如，基类数据和所包含的对象)也被自动序列化。因此，如果您试图持久化一个派生类，继承链上的所有公共数据都会随之而来。正如您将看到的，您使用一个对象图来表示一组相互关联的对象。

最后，要明白你可以将一个对象图持久化到*任何* `System.IO.Stream`派生的类型中。重要的是数据序列正确地表示了图形中对象的状态。

### 对象图的作用

如前所述。NET 运行库将考虑所有相关的对象，以确保在序列化对象时公共数据被正确地持久化。这组相关对象被称为*对象图*。对象图提供了一种简单的方法来记录一组项目如何相互引用。对象图是*而不是*表示 OOP *是-a* 或*有-a* 关系。相反，您可以将对象图中的箭头理解为“需要”或“依赖”

对象图中的每个对象都被赋予一个唯一的数值。请记住，分配给对象图中成员的数字是任意的，对外界没有实际意义。一旦给所有对象分配了一个数值，对象图就可以记录每个对象的依赖集。

例如，假设您已经创建了一组为一些汽车建模的类(当然)。你有一个名为`Car`的基类，而*有-a* `Radio`。另一个名为`JamesBondCar`的类扩展了`Car`的基本类型。图 [20-1](#Fig1) 显示了模拟这些关系的可能的对象图。

![img/340876_10_En_20_Chapter/340876_10_En_20_Fig1_HTML.jpg](img/340876_10_En_20_Chapter/340876_10_En_20_Fig1_HTML.jpg)

图 20-1。

一个简单的对象图

在读取对象图形时，连接箭头时可以使用短语*依赖于*或*指* *到*。因此，在图 [20-1](#Fig1) 中，你可以看到`Car`指的是`Radio`类(假定*有-a* 关系)。`JamesBondCar`指的是`Car`(给定*是-a* 关系)，也指的是`Radio`(它继承了这个受保护的成员变量)。

当然，CLR 不会在内存中绘制图片来表示相关对象的图形。相反，图 [20-1](#Fig1) 中记录的关系是由一个数学公式表示的，看起来像这样:

```cs
[Car 3, ref 2], [Radio 2], [JamesBondCar 1, ref 3, ref 2]

```

如果您解析这个公式，您可以看到对象 3(`Car`)依赖于对象 2(`Radio`)。对象 2，`Radio`，是一只孤独的狼，不需要任何人。最后，对象 1(`JamesBondCar`)依赖于对象 3，也依赖于对象 2。在任何情况下，当你序列化或者反序列化一个`JamesBondCar`的实例时，对象图确保`Radio`和`Car`类型也参与到这个过程中。

序列化过程的美妙之处在于，表示对象之间关系的图形是在幕后自动建立的。然而，正如你将在本章后面看到的，通过使用属性和接口定制序列化过程，你可以更多地参与给定对象图的构造。

### 创建示例类型和顶级语句

创建新的。NET 5 控制台应用命名为简单序列化。在这个项目中，添加一个名为`Radio.cs`的新类，并将代码更新为:

```cs
using System;
using System.Linq;
using System.Collections.Generic;
using System.Text.Json.Serialization;
using System.Xml;
using System.Xml.Serialization;

namespace SimpleSerialize
{
  public class Radio
  {
    public bool HasTweeters;
    public bool HasSubWoofers;
    public List<double> StationPresets;
    public string RadioId = "XF-552RR6";
    public override string ToString()
    {
      var presets = string.Join(",", StationPresets.Select(i => i.ToString()).ToList());
      return $"HasTweeters:{HasTweeters} HasSubWoofers:{HasSubWoofers} Station Presets:{presets}";
    }
  }
}

```

接下来，添加一个名为`Car.cs`的类，并更新代码以匹配清单:

```cs
using System;
using System.Text.Json.Serialization;
using System.Xml;
using System.Xml.Serialization;

namespace SimpleSerialize
{
  public class Car
  {
    public Radio TheRadio = new Radio();
    public bool IsHatchBack;
    public override string ToString()
      => $"IsHatchback:{IsHatchBack} Radio:{TheRadio.ToString()}";
  }
}

```

接下来，添加另一个名为`JamesBondCar.cs`的类，并对此类使用以下代码:

```cs
using System;
using System.Text.Json.Serialization;
using System.Xml;
using System.Xml.Serialization;

namespace SimpleSerialize
{
  public class JamesBondCar : Car
  {
    public bool CanFly;
    public bool CanSubmerge;
    public override string ToString()
      => $"CanFly:{CanFly}, CanSubmerge:{CanSubmerge} {base.ToString()}";
  }
}

```

最后一个类`Person.cs`，如下所示:

```cs
using System;
using System.Text.Json.Serialization;
using System.Xml;
using System.Xml.Serialization;

namespace SimpleSerialize
{
  public class Person
  {
    // A public field.
    public bool IsAlive = true;
    // A private field.
    private int PersonAge = 21;
    // Public property/private data.
    private string _fName = string.Empty;
    public string FirstName
    {
      get { return _fName; }
      set { _fName = value; }
    }
    public override string ToString() =>
    $"IsAlive:{IsAlive} FirstName:{FirstName} Age:{PersonAge} ";
  }
}

```

最后，将`Program.cs`类更新为以下起始代码:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Xml;
using System.Xml.Serialization;
using SimpleSerialize;

Console.WriteLine("***** Fun with Object Serialization *****\n");
// Make a JamesBondCar and set state.
JamesBondCar jbc = new()
{
  CanFly = true,
  CanSubmerge = false,
  TheRadio = new()
     {
       StationPresets = new() {89.3, 105.1, 97.1},
       HasTweeters = true
     }
};

Person p = new()
{
  FirstName = "James",
  IsAlive = true
};

```

现在，您已经准备好探索 XML 和 JSON 序列化了。

### 使用 XmlSerializer 进行序列化和反序列化

`System.Xml`名称空间提供了`System.Xml.Serialization.XmlSerializer`。您可以使用这个格式化程序将给定对象的*公共*状态作为纯 XML 持久化。注意，`XmlSerializer`要求您声明将被序列化(或反序列化)的类型。

#### 控制生成的 XML 数据

如果你有 XML 技术的背景，你会知道确保 XML 文档中的数据符合一组建立数据的*有效性*的规则通常是非常重要的。理解一个*有效的* XML 文档与 XML 元素的语法无关(例如，所有的开始元素必须有一个结束元素)。相反，有效文档符合商定的格式规则(例如，字段`X`必须表示为属性而不是子元素)，这些规则通常由 XML 模式或文档类型定义(DTD)文件定义。

默认情况下，`XmlSerializer`将所有公共字段/属性序列化为 XML 元素，而不是 XML 属性。如果您想控制`XmlSerializer`如何生成结果 XML 文档，您可以用任意数量的附加。来自`System.Xml.Serialization`命名空间的. NET 属性。表 [20-12](#Tab12) 记录了。NET 核心属性，这些属性影响 XML 数据如何编码为流。

表 20-12。

选择`System.Xml.Serialization`名称空间的属性

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

.NET 属性

 | 

生命的意义

 |
| --- | --- |
| `[XmlAttribute]` | 你可以用这个。NET 属性告诉`XmlSerializer`将数据序列化为 XML 属性(而不是子元素)。 |
| `[XmlElement]` | 该字段或属性将被序列化为您选择的 XML 元素。 |
| `[XmlEnum]` | 此属性提供枚举成员的元素名称。 |
| `[XmlRoot]` | 该属性控制如何构造根元素(名称空间和元素名称)。 |
| `[XmlText]` | 属性或字段将被序列化为 XML 文本(即根元素的开始标记和结束标记之间的内容)。 |
| `[XmlType]` | 该属性提供 XML 类型的名称和命名空间。 |

当然，您可以使用许多其他方法。NET Core 属性来控制`XmlSerializer`如何生成结果 XML 文档。要了解完整的细节，请在。NET Core SDK 文档。

Note

`XmlSerializer`要求对象图中的所有序列化类型都支持一个默认的构造函数(所以如果定义了自定义构造函数，一定要把它添加回来)。

#### 使用 XmlSerializer 序列化对象

考虑将以下局部函数添加到您的`Program.cs`类中:

```cs
static void SaveAsXmlFormat<T>(T objGraph, string fileName)
{
  //Must declare type in the constructor of the XmlSerializer
  XmlSerializer xmlFormat = new XmlSerializer(typeof(T));
  using (Stream fStream = new FileStream(fileName,
    FileMode.Create, FileAccess.Write, FileShare.None))
  {
    xmlFormat.Serialize(fStream, objGraph);
  }
}

```

将以下代码添加到顶级语句中:

```cs
  SaveAsXmlFormat(jbc, "CarData.xml");
  Console.WriteLine("=> Saved car in XML format!");

  SaveAsXmlFormat(p, "PersonData.xml");
  Console.WriteLine("=> Saved person in XML format!");

```

如果您查看新生成的`CarData.xml`文件，您会发现如下所示的 XML 数据:

```cs
<?xml version="1.0"?>
<JamesBondCar xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:="http://www.MyCompany.com">
  <TheRadio>
    <HasTweeters>true</HasTweeters>
    <HasSubWoofers>false</HasSubWoofers>
    <StationPresets>
      <double>89.3</double>
      <double>105.1</double>
      <double>97.1</double>
    </StationPresets>
    <RadioId>XF-552RR6</RadioId>
  </TheRadio>
  <IsHatchBack>false</IsHatchBack>
  <CanFly>true</CanFly>
  <CanSubmerge>false</CanSubmerge>
</JamesBondCar>

```

如果您想要指定一个自定义的 XML 名称空间来限定`JamesBondCar`并将`canFly`和`canSubmerge`值编码为 XML 属性，您可以通过修改 C#对`JamesBondCar`的定义来实现，如下所示:

```cs
[Serializable, XmlRoot(Namespace = "http://www.MyCompany.com")]
public class JamesBondCar : Car
{
  [XmlAttribute]
  public bool CanFly;
  [XmlAttribute]
  public bool CanSubmerge;
...
}

```

这产生了下面的 XML 文档(注意开始的`<JamesBondCar>`元素):

```cs
<?xml version="1.0"""?>
<JamesBondCar xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:xsd="http://www.w3.org/2001/XMLSchema"
  CanFly="true" CanSubmerge="false" xmlns:="http://www.MyCompany.com">
...
</JamesBondCar>

```

接下来，检查下面的`PersonData.xml`文件:

```cs
<?xml version="1.0"?>
<Person xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <IsAlive>true</IsAlive>
  <FirstName>James</FirstName>
</Person>

```

请注意`PersonAge`属性是如何没有被序列化到 XML 中的。这证实了 XML 序列化只序列化公共属性和字段。

#### 序列化对象集合

既然您已经看到了如何将单个对象持久化到流中，那么您就可以研究如何保存一组对象了。创建一个本地函数，初始化一个`JamesBondCars`列表，然后将它们序列化为 XML。

```cs
static void SaveListOfCarsAsXml()
{
  //Now persist a List<T> of JamesBondCars.
  List<JamesBondCar> myCars = new()
    {
      new JamesBondCar{CanFly = true, CanSubmerge = true},
      new JamesBondCar{CanFly = true, CanSubmerge = false},
      new JamesBondCar{CanFly = false, CanSubmerge = true},
      new JamesBondCar{CanFly = false, CanSubmerge = false},
    };

  using (Stream fStream = new FileStream("CarCollection.xml",
    FileMode.Create, FileAccess.Write, FileShare.None))
  {
    XmlSerializer xmlFormat = new XmlSerializer(typeof(List<JamesBondCar>));
    xmlFormat.Serialize(fStream, myCars);
  }
  Console.WriteLine("=> Saved list of cars!");
}

```

最后，添加下面一行来练习新函数:

```cs
SaveListOfCarsAsXml();

```

#### 反序列化对象和对象集合

XML 反序列化实际上与序列化对象(和对象集合)相反。考虑下面的局部函数，将 XML 反序列化回对象图。再次注意，要处理的类型必须传递给`XmlSerializer`的构造函数:

```cs
static T ReadAsXmlFormat<T>(string fileName)
{
  // Create a typed instance of the XmlSerializer
  XmlSerializer xmlFormat = new XmlSerializer(typeof(T));
  using (Stream fStream = new FileStream(fileName, FileMode.Open))
  {
    T obj = default;
    obj = (T)xmlFormat.Deserialize(fStream);
    return obj;
  }
}

```

将以下代码添加到顶级语句中，以将 XML 重新组成对象(或对象列表):

```cs
JamesBondCar savedCar = ReadAsXmlFormat<JamesBondCar>("CarData.xml");
Console.WriteLine("Original Car: {0}",savedCar.ToString());
Console.WriteLine("Read Car: {0}",savedCar.ToString());

List<JamesBondCar> savedCars = ReadAsXmlFormat<List<JamesBondCar>>("CarCollection.xml");

```

### 用系统进行序列化和反序列化。文本. Json

`System.Text.Json`名称空间提供了`System.Text.Json.JsonSerializer`。您可以使用这个格式化程序将给定对象的*公共*状态持久化为 JSON。

#### 控制生成的 JSON 数据

默认情况下，`JsonSerializer`使用与对象属性名称相同的名称(和大小写)将所有公共属性序列化为 JSON 名称-值对。您可以使用表 [20-13](#Tab13) 中列出的最常用属性来控制序列化过程的许多方面。

表 20-13。

选择`System.text.Json.Serialization`名称空间的属性

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

.NET 属性

 | 

生命的意义

 |
| --- | --- |
| `[JsonIgnore]` | 该属性将被忽略。 |
| `[JsonInclude]` | 将包括该成员。 |
| `[JsonPropertyName]` | 指定序列化/反序列化成员时要使用的属性名。这通常用于解决字符大小写问题。 |
| `[JsonConstructor]` | 指示将 JSON 反序列化回对象图时应该使用的构造函数。 |

#### 使用 JsonSerializer 序列化对象

`JsonSerializer`包含用于转换的静态`Serialize`方法。NET 核心对象(包括对象图)转换成公共属性的字符串表示形式。在 JavaScript 对象符号中，数据被表示为名称-值对。考虑将以下局部函数添加到您的`Program.cs`类中:

```cs
static void SaveAsJsonFormat<T>(T objGraph, string fileName)
{
  File.WriteAllText(fileName,System.Text.Json.JsonSerializer.Serialize(objGraph));
}

```

将以下代码添加到顶级语句中:

```cs
  SaveAsJsonFormat(jbc, "CarData.json");
  Console.WriteLine("=> Saved car in JSON format!");

  SaveAsJsonFormat(p, "PersonData.json");
  Console.WriteLine("=> Saved person in JSON format!");

```

当您检查创建的 JSON 文件时，您可能会惊讶地发现,`CarData.json`文件是空的(除了一对大括号),而`PersonData.json`文件只包含`Firstname`值。这是因为默认情况下`JsonSerializer`只写公共*属性*，不写公共字段。您将在下一节中更正这一点。

##### 包括字段

要将公共字段包含到生成的 JSON 中，有两种选择。另一种方法是使用`JsonSerializerOptions`类来指示`JsonSerializer`包含所有字段。第二种方法是通过向应该包含在 JSON 输出中的每个公共字段添加`[JsonInclude]`属性来更新您的类。注意，第一种方法(使用`JsonSerializationOptions`)将在对象图中包含*所有的*公共字段。要使用这种技术排除某些公共字段，必须对要排除的字段使用`JsonExclude`属性。

将 SaveAsJsonFormat 方法更新为以下内容:

```cs
static void SaveAsJsonFormat<T>(T objGraph, string fileName)
{
  var options = new JsonSerializerOptions
  {
    IncludeFields = true,
  };
  File.WriteAllText(fileName, System.Text.Json.JsonSerializer.Serialize(objGraph, options));
}

```

不使用`JsonSerializerOptions`，您可以通过将示例类中的所有公共字段更新为以下内容来获得相同的结果(注意，您可以将`Xml`属性留在类中，它们不会干扰`JsonSerializer`):

```cs
//Radio.cs
public class Radio
{
  [JsonInclude]
  public bool HasTweeters;
  [JsonInclude]
  public bool HasSubWoofers;
  [JsonInclude]
  public List<double> StationPresets;
  [JsonInclude]
  public string RadioId = "XF-552RR6";
...
}

//Car.cs
public class Car
{
  [JsonInclude]
  public Radio TheRadio = new Radio();
  [JsonInclude]
  public bool IsHatchBack;
...
}

//JamesBondCar.cs
public class JamesBondCar : Car
{
  [XmlAttribute]
  [JsonInclude]
  public bool CanFly;
  [XmlAttribute]
  [JsonInclude]
  public bool CanSubmerge;
...
}

//Person.cs
public class Person
{
  // A public field.
  [JsonInclude]
  public bool IsAlive = true;
...
}

```

现在，当您使用任何一种方法运行代码时，所有公共属性*和字段*都被写入文件。然而，当你检查内容时，你会看到 JSON 被写成*缩小了。* Minified 是一种删除所有无关紧要的空白和换行符的格式。这是默认格式，主要是因为 JSON 广泛用于 RESTful 服务，并且在通过 HTTP/HTTPS 在服务之间发送信息时减少了数据包的大小。

Note

序列化 JSON 的字段处理与反序列化 JSON 相同。如果您选择将选项设置为在序列化 JSON 时包含字段，那么在反序列化 JSON 时也必须包含该选项。

##### 漂亮印刷的 JSON

除了包含公共字段的选项，还可以指示`JsonSerializer`编写缩进的 JSON(并且是人类可读的)。将您的方法更新为以下内容:

```cs
static void SaveAsJsonFormat<T>(T objGraph, string fileName)
{
  var options = new JsonSerializerOptions
  {
    IncludeFields = true,
    WriteIndented = true
  };
  File.WriteAllText(fileName, System.Text.Json.JsonSerializer.Serialize(objGraph, options));
}

```

现在检查一下`CarData.json`文件，输出更加易读。

```cs
{
  "CanFly": true,
  "CanSubmerge": false,
  "TheRadio": {
    "HasTweeters": true,
    "HasSubWoofers": false,
    "StationPresets": [
      89.3,
      105.1,
      97.1
    ],
    "RadioId": "XF-552RR6"
  },
  "IsHatchBack": false
}

```

##### PascalCase 或 camelCase JSON

Pascal 大小写是一种格式，它使用大写的第一个字符以及名称的每个重要部分。以之前的 JSON 清单为例。`CanSubmerge`是帕斯卡大小写的例子。另一方面，camelCase 将第一个字符设置为小写(就像本节标题中的单词 *camelCase* )，然后名称的每个重要部分都以大写字母开头。上例的 camel case 版本是`canSubmerge`。

为什么这很重要？这很重要，因为大多数流行语言都是区分大小写的(比如 C#)。这意味着`CanSubmerge`和`canSubmerge`是两个不同的项目。正如你在本书中所看到的，在 C#中命名公共事物的公认标准(类、公共属性、函数等等。)就是用 Pascal 大小写。然而，大多数 JavaScript 框架更喜欢使用骆驼大小写。使用时，这可能会有问题。NET 和 C#与其他系统交互，例如通过在 RESTful 服务之间来回传递 JSON。

幸运的是，`JsonSerializer`可以定制来处理大多数情况，包括大小写差异。如果没有指定命名策略，`JsonSerializer`在序列化和反序列化 JSON 时将使用 Pascal 大小写。要将序列化过程更改为使用 camel 大小写，请将选项更新为以下内容:

```cs
static void SaveAsJsonFormat<T>(T objGraph, string fileName)
{
  JsonSerializerOptions options = new()
  {
    PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
    IncludeFields = true,
    WriteIndented = true,
  };
  File.WriteAllText(fileName, System.Text.Json.JsonSerializer.Serialize(objGraph, options));
}

```

现在，当您执行调用代码时，产生的 JSON 都是骆驼大小写的。

```cs
{
  "canFly": true,
  "canSubmerge": false,
  "theRadio": {
    "hasTweeters": true,
    "hasSubWoofers": false,
    "stationPresets": [
      89.3,
      105.1,
      97.1
    ],
    "radioId": "XF-552RR6"
  },
  "isHatchBack": false
}

```

当读取 JSON 时，默认情况下 C#是区分大小写的。外壳与`Deserialization`期间使用的`PropertyNamingPolicy`的设置相匹配。如果没有设置，则使用默认值(帕斯卡大小写)。通过将`PropertyNamingPolicy`设置为 camel case，那么所有传入的 JSON 都应该在 camel case 中。如果大小写不匹配，反序列化过程(很快会介绍)就会失败。

反序列化 JSON 时还有第三种选择，那就是大小写无关。通过将`PropertyNameCaseInsensitive`选项设置为 true，C#将反序列化`canSubmerge`和`CanSubmerge`。下面是设置选项的代码:

```cs
JsonSerializerOptions options = new()
{
  PropertyNameCaseInsensitive = true,
  IncludeFields = true
};

```

##### 用 JsonSerializer 处理数字

数字的默认处理是*严格*，这意味着数字将被序列化为数字(不带引号)和反序列化为数字(不带引号)。`JsonSerializerOptions`有一个`NumberHandling`属性，控制数字的读写。表 [20-14](#Tab14) 列出了`JsonNumberHandling`枚举中的可用值。

表 20-14。

JSON number 处理枚举值

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

枚举值

 | 

生命的意义

 |
| --- | --- |
| `Strict (0)` | 数字是从数字读出来的，写成数字。不允许报价，也不会生成报价。 |
| `AllowReadingFromString (1)` | 可以从数字或字符串标记中读取数字。 |
| `WriteAsString (2)` | 数字被写成 JSON 字符串(带引号)。 |
| `AllowNamedFloatingPointLiterals (4)` | 可以读取`Nan`、`Infinity`和`-Infinity`字符串标记，并且`Single`和`Double`值将作为它们对应的 JSON 字符串表示形式写入。 |

enum 有一个`flags`属性，允许其值的按位组合。例如，如果要读取字符串(和数字)并将数字写成字符串，可以使用以下选项设置:

```cs
JsonSerializerOptions options = new()
{
...
  NumberHandling = JsonNumberHandling.AllowReadingFromString & JsonNumberHandling.WriteAsString
};

```

通过这一更改，为`Car`类创建的 JSON 如下所示:

```cs
{
  "canFly": true,
  "canSubmerge": false,
  "theRadio": {
    "hasTweeters": true,
    "hasSubWoofers": false,
    "stationPresets": [
      "89.3",
      "105.1",
      "97.1"
    ],
    "radioId": "XF-552RR6"
  },
  "isHatchBack": false
}

```

##### 使用 JsonSerializerOption 的潜在性能问题

使用`JsonSerializerOption`时，最好创建一个实例，并在整个应用中重用它。记住这一点，将您的顶级语句和 JSON 方法更新如下:

```cs
JsonSerializerOptions options = new()
{
    PropertyNameCaseInsensitive = true,
    PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
    IncludeFields = true,
    WriteIndented = true,
    NumberHandling = JsonNumberHandling.AllowReadingFromString | JsonNumberHandling.WriteAsString
};
SaveAsJsonFormat(options, jbc, "CarData.json");
Console.WriteLine("=> Saved car in JSON format!");

SaveAsJsonFormat(options, p, "PersonData.json");
Console.WriteLine("=> Saved person in JSON format!");

static void SaveAsJsonFormat<T>(JsonSerializerOptions options, T objGraph, string fileName)
=> File.WriteAllText(fileName, System.Text.Json.JsonSerializer.Serialize(objGraph, options));

```

##### JsonSerializer 的 Web 默认值

构建 web 应用时，可以使用专门的构造函数来设置下列属性:

```cs
PropertyNameCaseInsensitive = true,
PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
NumberHandling = JsonNumberHandling.AllowReadingFromString

```

您仍然可以通过对象初始化来设置附加属性，如下所示:

```cs
JsonSerializerOptions options = new(JsonSerializerDefaults.Web)
{
  WriteIndented = true
};

```

#### 序列化对象集合

将一个对象集合序列化为 JSON 的过程与单个对象是一样的。将以下局部函数添加到顶级语句的末尾:

```cs
static void SaveListOfCarsAsJson(JsonSerializerOptions options, string fileName)
{
    //Now persist a List<T> of JamesBondCars.
    List<JamesBondCar> myCars = new()
    {
        new JamesBondCar { CanFly = true, CanSubmerge = true },
        new JamesBondCar { CanFly = true, CanSubmerge = false },
        new JamesBondCar { CanFly = false, CanSubmerge = true },
        new JamesBondCar { CanFly = false, CanSubmerge = false },
    };

    File.WriteAllText(fileName, System.Text.Json.JsonSerializer.Serialize(myCars, options));
    Console.WriteLine("=> Saved list of cars!");
}

```

最后，添加下面一行来练习新函数:

```cs
SaveListOfCarsAsJson(options, "CarCollection.json");

```

#### 反序列化对象和对象集合

就像 XML 反序列化一样，JSON 反序列化是序列化的反义词。以下函数将使用方法的泛型版本反序列化指定类型的 JSON:

```cs
static T ReadAsJsonFormat<T>(JsonSerializerOptions options, string fileName) =>
  System.Text.Json.JsonSerializer.Deserialize<T>(File.ReadAllText(fileName), options);

```

将以下代码添加到顶级语句中，以将 XML 重新组成对象(或对象列表):

```cs
JamesBondCar savedJsonCar = ReadAsJsonFormat<JamesBondCar>(options, "CarData.json");
Console.WriteLine("Read Car: {0}", savedJsonCar.ToString());

List<JamesBondCar> savedJsonCars = ReadAsJsonFormat<List<JamesBondCar>>(options, "CarCollection.json");
Console.WriteLine("Read Car: {0}", savedJsonCar.ToString());

```

## 摘要

你在本章开始时研究了`Directory(Info)`和`File(Info)`类型的使用。正如您所了解的，这些类允许您操作硬盘上的物理文件或目录。接下来，您研究了从抽象`Stream`类派生的几个类。假定`Stream`派生的类型在原始字节流上操作，`System.IO`命名空间提供了许多读取器/写入器类型(例如`StreamWriter`、`StringWriter`和`BinaryWriter`)，从而简化了这个过程。在这个过程中，您还了解了由`DriveType`提供的功能，学习了如何使用`FileSystemWatcher`类型来监控文件，并了解了如何以异步方式与流进行交互。

本章还向您介绍了对象序列化服务的主题。如您所见。NET Core platform 使用一个对象图来描述您希望保存到流中的相关对象的完整集合。然后，您处理了 XML 和 JSON 序列化和反序列化。