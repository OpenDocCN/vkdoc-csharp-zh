# 28.WPF 通知、验证、命令和 MVVM

本章将通过介绍支持模型-视图-视图模型(MVVM)模式的功能来结束您对 WPF 编程模型的研究。第一部分介绍了模型-视图-视图模型模式。接下来，您将了解 WPF 通知系统及其通过可观察模型和可观察集合实现的可观察模式。让 UI 中的数据准确地描述数据的当前状态可以自动显著改善用户体验，并减少在旧技术(如 WinForms)中实现相同结果所需的手动编码。

在可观察模式的基础上，您将研究向应用程序中添加验证的机制。验证是任何应用程序的一个重要部分——不仅让用户知道有什么地方出错了，还让他们知道什么地方出错了。为了通知用户错误是什么，您还将学习如何将验证合并到视图标记中。

接下来，您将更深入地研究 WPF 命令系统，并创建自定义命令来封装程序逻辑，就像您在第 [25](25.html) 章中使用内置命令一样。创建定制命令有几个优点，包括(但不限于)支持代码重用、逻辑封装和关注点分离。

最后，您将在一个示例 MVVM 应用程序中将所有这些结合在一起。

## 介绍模型-视图-视图模型

在深入研究 WPF 中的通知、验证和命令之前，最好理解一下本章的最终目标，即模型-视图-视图模型模式(MVVM)。MVVM 源自马丁·福勒的表示模型模式，它利用了本章中讨论的 XAML 特有的能力，使你的 WPF 开发更快更干净。名称本身描述了模式的主要组成部分:模型、视图、视图模型。

### 模型

*模型*是数据的对象表示。在 MVVM，模型在概念上与来自数据访问层(DAL)的模型相同。有时候是同一个物理班，但是这个没有要求。当你阅读这一章时，你将学会如何决定你是否可以使用你的 DAL 模型或者你是否需要创建新的模型。

模型通常通过数据注释和`INotifyDataErrorInfo`接口利用内置(或自定义)验证，并被配置为可观察的，以与 WPF 通知系统相结合。在本章的后面你会看到所有这些。

### 景色

*视图*是应用程序的 UI，它被设计得非常轻量级。想想免下车餐馆的菜单板。该板显示菜单项和价格，并且它有一个机制，以便用户可以与后端系统通信。然而，该电路板没有内置任何智能，除非它是专门的用户界面逻辑，例如在天黑时开灯。

应该怀着同样的目标发展 MVVM 观点。任何智能都应该内置到应用程序的其他地方。代码隐藏文件中唯一的代码(例如`MainWindow.xaml.cs`)应该与操作 UI 直接相关。它不应该基于业务规则或任何需要保留以备将来使用的东西。虽然这不是 MVVM 的主要目标，但是开发良好的 MVVM 应用程序通常只有很少的代码隐藏。

### 视图模型

在 WPF 和其他 XAML 技术中，*视图模型*有两个用途。

*   视图模型为视图所需的所有数据提供了一站式服务。这并不意味着视图模型负责获取实际数据；相反，它只是一种将数据从数据存储区移动到视图的传输机制。通常，视图和视图模型之间存在一对一的关联，但是存在架构差异，并且您的里程可能会有所不同。

*   第二项工作是充当视图的控制器。就像菜单板一样，视图模型接受用户的指示，并将该调用转发给相关代码，以确保采取正确的操作。这些代码通常以自定义命令的形式出现。

### 贫血模型或贫血视图模型

在 WPF 的早期，当开发人员仍然在研究如何最好地实现 MVVM 模式时，有关于在哪里实现验证和可观察模式的重要(有时是激烈的)讨论。一个阵营(贫血模型阵营)认为所有的都应该在视图模型中，因为将这些功能添加到模型中打破了关注点的分离。另一个阵营(贫血视图模型阵营)认为应该全部放在模型中，因为这样可以减少代码的重复。

真正的答案当然是视情况而定。当`INotifyPropertyChanged`、`IDataErrorInfo`和`INotifyDataErrorInfo`在模型类上实现时，这确保了相关代码接近代码的目标(正如你将在本章中看到的)，并且对于每个模型只实现一次。也就是说，有时候你的`view model`类本身也需要被开发成可观察的。最终，您需要确定什么对您的应用程序最有意义，而不会使您的代码过于复杂或牺牲 MVVM 的好处。

Note

有多种 MVVM 框架可用于 WPF，如 MVVMLite、Caliburn。Micro 和 Prism(尽管 Prism 不仅仅是一个 MVVM 框架)。本章讨论 MVVM 模式和 WPF 支持实现该模式的特性。读者朋友们，我让你们来研究不同的框架，并选择最符合你的应用需求的框架。

## WPF 约束通知系统

WinForms 绑定系统的一个显著缺点是缺少通知。如果视图中表示的数据是以编程方式更新的，则 UI 也必须以编程方式刷新，以使它们保持同步。这导致了对控件上的`Refresh()`的大量调用，为了安全起见，通常比绝对必要的调用更多。虽然包含太多对`Refresh()`的调用通常不是一个严重的性能问题，但是如果没有包含足够多的调用，用户的体验可能会受到负面影响。

内置于基于 XAML 的应用程序中的绑定系统纠正了这个问题，它使您能够将数据对象和集合作为可观察对象开发到通知系统中。每当一个属性的值在一个可观察的模型上改变或者集合在一个可观察的集合上改变(例如，项目被添加、删除或者重新排序)，一个事件被引发(或者`NotifyPropertyChanged`或者`NotifyCollectionChanged`)。绑定框架自动侦听这些事件的发生，并在它们触发时更新绑定的控件。更好的是，作为开发人员，您可以控制哪些属性会引发通知。听起来很完美，对吧？嗯，这不是*完全*完美。如果您全部手动完成，那么为可观察的模型设置这个过程会涉及到相当多的代码。幸运的是，有一个开源框架使它变得更简单，您很快就会看到这一点。

### 可观察模型和集合

在本节中，您将创建一个使用可观察模型和集合的应用程序。首先，创建一个名为 WpfNotifications 的新 WPF 应用程序。该应用程序将是一个主从表单，允许用户使用`ComboBox`选择特定的汽车，然后该汽车的详细信息将显示在下面的`TextBox`控件中。通过用以下标记替换默认网格来更新`MainWindow.xaml`:

```cs
<Grid IsSharedSizeScope="True" Margin="5,0,5,5">
  <Grid.RowDefinitions>
    <RowDefinition Height="Auto"/>
    <RowDefinition Height="Auto"/>
  </Grid.RowDefinitions>
  <Grid Grid.Row="0">
    <Grid.ColumnDefinitions>
      <ColumnDefinition Width="Auto"
        SharedSizeGroup="CarLabels"/>
      <ColumnDefinition Width="*"/>
    </Grid.ColumnDefinitions>
    <Label Grid.Column="0" Content="Vehicle"/>
    <ComboBox Name="cboCars"  Grid.Column="1"
      DisplayMemberPath="PetName" />
</Grid>
<Grid Grid.Row="1" Name="DetailsGrid">
  <Grid.ColumnDefinitions>
    <ColumnDefinition Width="Auto"
      SharedSizeGroup="CarLabels"/>
    <ColumnDefinition Width="*"/>
  </Grid.ColumnDefinitions>
  <Grid.RowDefinitions>
    <RowDefinition Height="Auto"/>
    <RowDefinition Height="Auto"/>
    <RowDefinition Height="Auto"/>
    <RowDefinition Height="Auto"/>
    <RowDefinition Height="Auto"/>
  </Grid.RowDefinitions>
  <Label Grid.Column="0" Grid.Row="0" Content="Id"/>
  <TextBox Grid.Column="1" Grid.Row="0" />
  <Label Grid.Column="0" Grid.Row="1" Content="Make"/>
  <TextBox Grid.Column="1" Grid.Row="1" />
  <Label Grid.Column="0" Grid.Row="2" Content="Color"/>
  <TextBox Grid.Column="1" Grid.Row="2" />
  <Label Grid.Column="0" Grid.Row="3" Content="Pet Name"/>
  <TextBox Grid.Column="1" Grid.Row="3" />
  <StackPanel Grid.Column="0" Grid.ColumnSpan="2" Grid.Row="4"
       HorizontalAlignment="Right" Orientation="Horizontal" Margin="0,5,0,5">
    <Button x:Name="btnAddCar" Content="Add Car" Margin="5,0,5,0" Padding="4, 2" />
    <Button x:Name="btnChangeColor" Content="Change Color" Margin="5,0,5,0"
       Padding="4, 2"/>
  </StackPanel>
  </Grid>
</Grid>

```

您的窗口将类似于图 [28-1](#Fig1) 。

![img/340876_10_En_28_Chapter/340876_10_En_28_Fig1_HTML.jpg](img/340876_10_En_28_Chapter/340876_10_En_28_Fig1_HTML.jpg)

图 28-1。

显示汽车详细信息的主-详细信息窗口

`Grid`控件上的`IsSharedSizeScope`标签设置子网格来共享维度。标有`SharedSizeGroup`的`ColumnDefinitions`将自动调整到相同的宽度，无需任何编程。在这个例子中，如果`Pet Name`标签变得更长，那么`Vehicle`列(在另一个`Grid`控件中)的大小将与之匹配，保持窗口的外观整洁。

接下来，在解决方案资源管理器中右键单击项目名称，选择添加➤新文件夹，并将文件夹命名为`Models`。在这个新文件夹中，创建一个名为`Car`的类。这里列出了初始类:

```cs
public class Car
{
  public int Id { get; set; }
  public string Make { get; set; }
  public string Color { get; set; }
  public string PetName { get; set; }
}

```

### 添加绑定和数据

下一步是为控件添加绑定语句。请记住，数据绑定语句围绕数据上下文，这可以在控件本身或父控件上设置。这里，您将在`DetailsGrid`上设置上下文，因此包含的每个控件都将继承该数据上下文。将`DataContext`设置为`ComboBox`的`SelectedItem`属性。将保存细节控件的`Grid`更新为以下内容:

```cs
<Grid Grid.Row="1" Name="DetailsGrid"
  DataContext="{Binding ElementName=cboCars, Path=SelectedItem}">

```

`DetailsGrid`中的文本框将显示所选汽车的个别属性。向`TextBox`控件添加适当的文本属性和相关绑定，如下所示:

```cs
<TextBox Grid.Column="1" Grid.Row="0" Text="{Binding Path=Id}" />
<TextBox Grid.Column="1" Grid.Row="1" Text="{Binding Path=Make}" />
<TextBox Grid.Column="1" Grid.Row="2" Text="{Binding Path=Color}" />
<TextBox Grid.Column="1" Grid.Row="3" Text="{Binding Path=PetName}" />

```

最后，将数据添加到`ComboBox`中。在`MainWindow.xaml.cs`中，创建一个新的`Car`记录列表，并将`ComboBox`的`ItemsSource`设置到列表中。此外，为`Notifications.Models`名称空间添加`using`语句。

```cs
using WpfNotifications.Models;
//omitted for brevity
public partial class MainWindow : Window
{
  readonly IList<Car> _cars = new List<Car>();
  public MainWindow()
  {
    InitializeComponent();
    _cars.Add(new Car {Id = 1, Color = "Blue", Make = "Chevy", PetName = "Kit"});
    _cars.Add(new Car {Id = 2, Color = "Red", Make = "Ford", PetName = "Red Rider"});
    cboCars.ItemsSource = _cars;
    }
}

```

运行应用程序。您将看到车辆选择器有两辆车可供选择。选择其中一个，文本框将自动填充车辆详细信息。更改其中一辆车的颜色，选择另一辆车，然后返回到您编辑的车辆。你会看到新的颜色确实仍然附着在车辆上。这没什么了不起的。在前面的例子中，您已经看到了 XAML 数据绑定的强大功能。

### 以编程方式更改车辆数据

虽然前面的例子像预期的那样工作，但是如果数据以编程方式改变，用户界面将*而不是*反映这些变化，除非你编写应用程序来刷新数据。为了演示这一点，为`btnChangeColor Button`添加一个事件处理程序，如下所示:

```cs
<Button x:Name="btnChangeColor" Content="Change Color" Margin="5,0,5,0"
    Padding="4, 2" Click="BtnChangeColor_OnClick"/>

```

在`BtnChangeColor_Click()`事件处理程序中，使用`ComboBox`的`SelectedItem`属性从汽车列表中定位选中的记录，并将颜色改为`Pink`。代码如下所示:

```cs
private void BtnChangeColor_OnClick(object sender, RoutedEventArgs e)
{
  _cars.First(x => x.Id == ((Car)cboCars.SelectedItem)?.Id).Color = "Pink";
}

```

运行应用程序，选择一辆车，然后单击“改变颜色”按钮。没有明显的变化。选择另一辆车，然后回到最初选择的车。现在您将看到更新后的值。这对用户来说不是一个好的体验！

现在给`btnAddCar`按钮添加一个事件处理程序，如下所示:

```cs
<Button x:Name="btnAddCar" Content="Add Car" Margin="5,0,5,0" Padding="4, 2"
  Click="BtnAddCar_OnClick" />

```

在`BtnAddCar_Click`事件处理程序中，向`Car`列表添加一条新记录。

```cs
private void BtnAddCar_Click(object sender, RoutedEventArgs e)
{
  var maxCount = _cars?.Max(x => x.Id) ?? 0;
  _cars?.Add(new Car { Id=++maxCount,Color="Yellow",Make="VW",PetName="Birdie"});
}

```

运行应用程序，点击 Add Car 按钮，检查`ComboBox`的内容。尽管您知道列表中有三辆汽车，但只显示了两辆！为了纠正这两个问题，您将把`Car`类转换成一个可观察的模型，并使用一个可观察的集合来保存所有的`Car`实例。

### 可观测模型

通过在您的`Car`模型类上实现`INotifyPropertyChanged`接口，解决了您的模型属性上的数据更改和不在 UI 中显示的问题。`INotifyPropertyChanged`界面包含一个单独的事件:`PropertyChangedEvent`。XAML 绑定引擎为实现`INotifyPropertyChanged`接口的类上的每个绑定属性监听该事件。界面如下所示:

```cs
public interface INotifyPropertyChanged
{
  event PropertyChangedEventHandler PropertyChanged;
}

```

将以下`using`语句添加到`Car.cs`类中:

```cs
using System.ComponentModel;
using System.Runtime.CompilerServices;

```

接下来，在类上实现`INotifyPropertyChanged`接口，如下所示:

```cs
public class Car : INotifyPropertyChanged
{
  //Omitted for brevity
  public event PropertyChangedEventHandler PropertyChanged;
}

```

`PropertyChanged`事件接受一个对象引用和一个`PropertyChangedEventArgs`类的新实例，如下例所示:

```cs
PropertyChanged?.Invoke(this,
  new PropertyChangedEventArgs("Model"));

```

第一个参数是引发事件的对象实例。`PropertyChangedEventArgs`构造函数接受一个字符串，该字符串表示属性已被更改，需要更新。当引发事件时，绑定引擎在该实例上查找绑定到命名属性的任何控件。如果将`String.Empty`传递给`PropertyChangedEventArgs`，那么实例的所有绑定属性都会更新。

您可以控制在自动更新中登记哪些属性。只有那些在 setter 中引发`PropertyChanged`事件的属性会被自动更新。这通常是模型类的所有属性，但是您可以根据应用程序的需求选择省略某些属性。一种常见的模式是创建一个帮助器方法(通常名为`OnPropertyChanged()`)来代表属性引发事件，而不是直接在 setter 中为每个登记的属性引发事件，通常是在模型的基类中。将以下方法和代码添加到`Car.cs`类中:

```cs
protected void OnPropertyChanged([CallerMemberName] string propertyName = "")
{
  PropertyChanged?.Invoke(this,
    new PropertyChangedEventArgs(propertyName));
}

```

接下来，更新`Car`类中的每个自动属性，使其拥有一个完整的 getter 和 setter 以及一个支持字段。当值改变时，调用`OnPropertyChanged()`帮助器方法。下面是更新后的`Id`属性:

```cs
private int _id;
public int Id
{
  get => _id;
  set
  {
    if (value == _id) return;
    _id = value;
    OnPropertyChanged();
  }
}

```

确保对该类中的所有属性执行相同的操作，然后再次运行该应用程序。选择一辆车并点击“改变颜色”按钮。您将立即看到 UI 中显示的更改。第一个问题解决！

#### 使用名称 of

C# 6 中增加的一个特性是`nameof`操作符，它提供传递给`nameof`方法的项目的字符串名称。您可以在 setters 中调用`OnPropertyChanged()`，就像这样:

```cs
public string Color
{
  get { return _color; }
  set
  {
    if (value == _color) return;
    _color = value;
    OnPropertyChanged(nameof(Color));
  }
}

```

注意，当您使用`nameof`方法时，您不必从`OnPropertyChanged()`中移除`CallerMemberName`属性(尽管它变得没有必要)。最后，是使用`nameof`方法还是`CallerMemberName`属性，这取决于个人的选择。

### 可观察的集合

下一个要解决的问题是当集合的内容改变时更新 UI。这是通过实现`INotifyCollectionChanged`接口来完成的。像`INotifyPropertyChanged`接口一样，这个接口公开了一个事件，即`CollectionChanged`事件。与`INotifyPropertyChanged`事件不同，手工实现这个接口不仅仅是调用 setter 中的一个方法。您需要创建一个完整的`List`实现，并在列表发生变化时引发`CollectionChanged`事件。

#### 使用 ObservableCollections 类

幸运的是，有一种比创建自己的集合类更简单的方法。`ObservableCollection<T>`类实现了`INotifyCollectionChanged`、`INotifyPropertyChanged`和`Collection<T>`，它是。NET 核心框架。没有额外的工作！为此，为`System.Collections.ObjectModel`添加一个`using`语句，然后将`_cars`的私有字段更新为:

```cs
private readonly IList<Car> _cars =
  new ObservableCollection<Car>();

```

再次运行应用程序，然后单击添加汽车按钮。您将看到新记录适当地出现。

#### 实现脏标志

可观测模型的另一个优点是跟踪状态变化的能力。使用 WPF 进行脏跟踪(当一个或多个对象的值发生变化时进行跟踪)相当简单。向`Car`类添加一个名为`IsChanged`的`bool`属性。确保像调用`Car`类中的其他属性一样调用`OnPropertyChanged()`。

```cs
private bool _isChanged;
public bool IsChanged {
  get => _isChanged;
  set
  {
    if (value == _isChanged) return;
    _isChanged = value;
    OnPropertyChanged();
  }
}

```

您需要在`OnPropertyChanged()`方法中将`IsChanged`属性设置为`true`。当`IsChanged`更新时，你还需要确保你没有将`IsChanged`设置为`true`，否则你将遇到堆栈溢出异常！将`OnPropertyChanged()`方法更新如下(使用前面讨论的`nameof`方法):

```cs
protected virtual void OnPropertyChanged(
  [CallerMemberName] string propertyName = "")
{
  if (propertyName != nameof(IsChanged))
  {
    IsChanged = true;
  }
  PropertyChanged?.Invoke(this,
    new PropertyChangedEventArgs(propertyName));
}

```

打开`MainWindow.xaml`并给`DetailsGrid`增加一个额外的`RowDefinition`。将以下内容添加到包含一个`Label`和一个`CheckBox`的`Grid`的末尾，绑定到`IsChanged`属性，如下所示:

```cs
<Label Grid.Column="0" Grid.Row="5" Content="Is Changed"/>
<CheckBox Grid.Column="1" Grid.Row="5" VerticalAlignment="Center"
    Margin="10,0,0,0" IsEnabled="False" IsChecked="{Binding Path=IsChanged}" />

```

如果您现在运行该应用程序，您会看到每一条记录都显示为已更改，即使您没有更改任何内容！这是因为对象创建会设置属性值，设置任何值都会调用`OnPropertyChanged()`。这将设置对象的`IsChanged`属性。要纠正这一点，将`IsChanged`属性设置为`false`，作为对象初始化代码中的最后一个属性。打开`MainWindow.xaml.cs`，将创建列表的代码改为如下:

```cs
_cars.Add(
    new Car {Id = 1, Color = "Blue", Make = "Chevy", PetName = "Kit", IsChanged = false});
_cars.Add(
    new Car {Id = 2, Color = "Red", Make = "Ford", PetName = "Red Rider", IsChanged = false});

```

再次运行应用程序，选择一辆车，然后单击“更改颜色”按钮。您将看到复选框和更新的颜色一起被选中。

#### 通过 UI 交互更新源代码

您可能会注意到，如果在用户界面中键入文本,“已更改”复选框实际上不会被选中，直到您退出正在编辑的控件。这是因为`TextBox`绑定上的`UpdateSourceTrigger`属性。`UpdateSourceTrigger`决定了什么事件(比如改变值、跳转等等)。)使用户界面更新基础数据。有四种选择，如表 [28-1](#Tab1) 所示。

表 28-1。

`UpdateSourceTrigger`值

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

成员

 | 

生命的意义

 |
| --- | --- |
| `Default` | 为控件设置默认值(例如，`TextBox`控件设置为`LostFocus`)。 |
| `Explicit` | 仅在调用`UpdateSource`方法时更新源对象。 |
| `LostFocus` | 当控件失去焦点时更新。这是`TextBox`控件的默认设置。 |
| `PropertyChanged` | 属性一改变就更新。这是`CheckBox`控件的默认设置。 |

`TextBox`的默认源触发器是`LostFocus`事件。通过将颜色`TextBox`的绑定更新为以下 XAML，将其更改为`PropertyChanged`:

```cs
<TextBox Grid.Column="1" Grid.Row="2" Text="{Binding Path=Color, UpdateSourceTrigger=PropertyChanged}" />

```

现在，当您运行应用程序并开始在颜色文本框中键入内容时，复选框会立即被选中。你可能会问为什么默认设置为`TextBox`控件的`LostFocus`。一个模型的任何确认(稍后介绍)都与`UpdateSourceTrigger`一起启动。对于`TextBox`，这可能会导致错误持续闪烁，直到用户输入正确的值。例如，如果验证规则不允许在一个`TextBox`中少于五个字符，错误将在每次击键时显示，直到用户输入五个或更多。在这些情况下，最好等待用户退出`TextBox`(在完成对文本的更改之后)来更新源代码。

### 包装通知和可观察项

对模型使用`INotifyPropertyChanged`和对列表使用`ObservableCollections`类可以通过保持数据和 UI 同步来改善用户体验。虽然这两个接口都不复杂，但它们确实需要更新您的代码。幸运的是，微软已经包含了`ObservableCollection`类来处理创建可观察集合的所有管道。同样幸运的是，Fody 项目的更新自动添加了`INotifyPropertyChanged`功能。有了这两个工具，没有理由不在您的 WPF 应用程序中实现 observables。

## WPF 验证

既然您已经实现了`INotifyPropertyChanged`并且正在使用`ObservableCollection`，那么是时候为您的应用程序添加验证了。应用程序需要验证用户输入，并在输入的数据不正确时向用户提供反馈。本节涵盖了现代 WPF 应用程序最常见的验证机制，但这些仍然只是 WPF 内置功能的一部分。

当数据绑定试图更新数据源时，会发生验证。除了内置验证(如属性 setter 中的异常)之外，您还可以创建自定义验证规则。如果*任何*验证规则(内置的或定制的)失败，那么`Validation`类(稍后将讨论)就会发挥作用。

Note

对于本章中的每一节，您可以继续使用上一节中的同一项目，也可以为每个新节创建一个项目副本。在本章的回购中，每个部分都是一个不同的项目。

### 更新验证示例的样本

在本章的 repo 中，新项目(复制自上一个例子)被称为 WpfValidations。如果您使用的是上一节中的同一个项目，那么在将本节中列出的示例中的代码复制到您的项目中时，您只需要记下名称空间的变化。

### 验证类

在向项目添加验证之前，理解`Validation`类很重要。该类是验证框架的一部分，它提供了可用于显示验证结果的方法和附加属性。在处理验证错误时，`Validation`类有三个常用的主要属性(如表 [28-2](#Tab2) 所示)。在本节的剩余部分，您将使用其中的每一项。

表 28-2。

`Validation`班的主要成员

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

成员

 | 

生命的意义

 |
| --- | --- |
| `HasError` | 附加的属性，指示验证规则在过程中的某个地方失败 |
| `Errors` | 所有活动`ValidationError`对象的集合 |
| `ErrorTemplate` | 当`HasError`设置为`true`时，变得可见并修饰绑定元素的控制模板 |

### 验证选项

如前所述，XAML 技术公司有几种将验证逻辑整合到应用程序中的机制。在接下来的小节中，您将研究三种最常用的验证选择。

#### 异常时通知

虽然不应该使用异常来实施业务逻辑，但是异常可能并且确实会发生，并且应该适当地处理它们。如果代码中没有处理它们，用户应该会收到问题的视觉反馈。WinForms 的一个重要变化是，默认情况下，WPF 绑定异常不会作为异常传播给用户。但是，它们是使用装饰器(位于控件顶部的可视层)以可视方式指示的。

为了测试这一点，运行应用程序，从`ComboBox`中选择一个记录，并清除`Id`值。因为`Id`属性被定义为`int`(不是`nullable int`)，所以需要一个数值。当您跳出`Id`字段时，绑定框架会向`Id`属性发送一个空字符串，由于空字符串不能转换为`int`，setter 中会抛出一个异常。通常，未处理的异常会向用户生成一个消息框，但在这种情况下，不会发生类似的情况。如果查看输出窗口的调试部分，您会看到以下内容:

```cs
System.Windows.Data Error: 7 : ConvertBack cannot convert value '' (type 'String'). BindingExpression:Path=Id; DataItem="Car" (HashCode=52579650); target element is 'TextBox' (Name=''); target property is 'Text' (type 'String') FormatException:'System.FormatException: Input string was not in a correct format.

```

异常的直观显示是控件周围的一个红色细框，如图 [28-2](#Fig2) 所示。

![img/340876_10_En_28_Chapter/340876_10_En_28_Fig2_HTML.jpg](img/340876_10_En_28_Chapter/340876_10_En_28_Fig2_HTML.jpg)

图 28-2。

默认错误模板

红框是`Validation`对象的`ErrorTemplate`属性，充当绑定控件的装饰器。虽然默认的错误装饰器显示确实有一个错误，但是没有任何迹象表明*什么*是错误的。好消息是`ErrorTemplate`是完全可定制的，你将在本章后面看到。

#### IDataErrorInfo

`IDataErrorInfo`接口为您向模型类添加定制验证提供了一种机制。这个接口直接添加到您的模型(或视图模型)类中，验证代码放在您的模型类中(最好是在分部类中)。这将验证代码集中在您的项目中，与 WinForms 项目形成鲜明对比，后者的验证通常在 UI 本身中完成。

这里显示的`IDataErrorInfo`接口包含两个属性:一个索引器和一个名为`Error`的字符串属性。注意，WPF 绑定引擎不使用`Error`属性。

```cs
public interface IDataErrorInfo
{
  string this[string columnName] { get; }
  string Error { get; }
}

```

您将很快添加`Car`分部类，但是首先您需要更新`Car.cs`类并将其标记为分部类。接下来，向`Models`目录添加另一个名为`CarPartial.cs`的文件。重命名该类`Car`，确保该类标记为`partial`，并添加`IDataErrorInfo`接口。最后，实现接口的 API。初始代码如下所示:

```cs
public partial class Car : IDataErrorInfo
{
  public string this[string columnName] => string.Empty;
  public string Error { get;}
}

```

对于选择加入到`IDataErrorInfo`接口的绑定控件，它必须将`ValidatesOnDataErrors`添加到绑定表达式中。将`Make`文本框的绑定表达式更新如下(并以同样的方式更新其余的绑定语句):

```cs
<TextBox Grid.Column="1" Grid.Row="1" Text="{Binding Path=Make, ValidatesOnDataErrors=True}" />

```

一旦对绑定语句进行了更新，模型上的索引器就会在每次引发`PropertyChanged`事件时被调用。事件的属性名被用作索引器中的`columnName`参数。如果索引器返回`string.Empty`，那么框架假设所有的验证都通过了，并且不存在错误情况。如果索引器返回除`string.Empty`之外的任何内容，则认为该对象实例的属性存在错误，并且绑定到该类的特定实例上正在验证的属性的每个控件都被认为有错误，`Validation`对象的`HasError`属性被设置为`true`，并且为受影响的控件激活`ErrorTemplate`装饰器。

接下来，您将向`CarPartial.cs`中的索引器添加一些简单的验证逻辑。验证规则很简单。

*   如果`Make`等于`ModelT`，设置误差等于`"Too Old"`。

*   如果`Make`等于`Chevy`，`Color`等于`Pink`，则设置误差等于`$"{Make}'s don't come in {Color}"`。

首先为每个属性添加一个`switch`语句。为了避免在`case`语句中使用神奇的字符串，您将再次使用`nameof`方法。如果代码没有通过`switch`语句，返回`string.Empty`。接下来，添加验证规则。在适当的`case`语句中，添加一个基于前面列出的规则的属性值检查。在`Make`属性的`case`语句中，首先检查以确保值不是`ModelT`。如果是，则返回错误。如果通过，下一行将调用一个 helper 方法，如果违反了第二条规则，它将返回一个错误，否则它将返回`string.Empty`。在针对`Color`属性的`case`语句中，也调用 helper 方法。代码如下:

```cs
public string this[string columnName]
{
  get
  {
    switch (columnName)
    {
      case nameof(Id):
        break;
      case nameof(Make):
        return Make == "ModelT"
          ? “Too Old”
          : CheckMakeAndColor();
      case nameof(Color):
        return CheckMakeAndColor();
      case nameof(PetName):
        break;
    }
    return string.Empty;
  }
}

internal string CheckMakeAndColor()
{
  if (Make == "Chevy" && Color == "Pink")
  {
    return $"{Make}'s don't come in {Color}";
  }
  return string.Empty;
}

```

运行应用程序，选择红色骑手车辆(福特)，并将品牌更改为 ModelT。一旦您跳出该字段，就会出现红色的错误装饰。现在从下拉列表中选择 Kit(这是一辆 Chevy ),并单击 Change Color 按钮将颜色更改为粉红色。红色错误装饰立即出现在颜色字段中，但不会出现在生成文本框中。现在，将 Make 更改为 Ford，跳出文本框，注意红色装饰符*没有*消失！

这是因为索引器仅在属性的`PropertyChanged`事件被触发时运行。正如在“WPP 绑定通知系统”一节中所讨论的，当源对象的属性改变时，`PropertyChanged`事件被触发，这或者通过代码(比如单击改变颜色按钮)或者通过用户交互(时间通过`UpdateSourceTrigger`来控制)来实现。当您改变颜色时，`Make`属性没有改变，所以事件没有为`Make`属性触发。因为事件没有触发，索引器没有被调用，所以对`Make`属性的验证没有运行。

有两种方法可以解决这个问题。第一个是通过传入`string.Empty`而不是字段名来更改`PropertyChangedEventArgs`以更新每个绑定属性。如前所述，这会导致绑定引擎更新该实例上的每个属性的*。像这样更新`Car.cs`类中的`OnPropertyChanged()`方法:*

```cs
protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = "")
{
  if (propertyName != nameof(IsChanged))
  {
    IsChanged = true;
  }
  //PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
  PropertyChanged?.Invoke(this,
    new PropertyChangedEventArgs(string.Empty));
}

```

现在，当您运行相同的测试时，您会看到当 Make 和 Color 文本框中的一个被更新时，它们都用错误模板进行了修饰。那么，为什么不总是以这种方式引发事件呢？很大程度上是性能问题。刷新一个对象的所有属性可能会降低性能。当然，不测试是无法知道的，你的里程可能(很可能)会有所不同。

另一个解决方案是当一个字段发生变化时，为其他依赖字段引发`PropertyChanged`事件。使用这种机制的缺点是，你(或其他支持你的应用程序的开发者)必须知道`Make`和`Color`属性是通过验证码联系在一起的。

#### INotifyDataErrorInfo

中引入的`INotifyDataErrorInfo`接口。NET 4.5 建立在`IDataErrorInfo`接口的基础上，并增加了额外的验证功能。当然，随着额外的功率而来的是额外的工作！与您必须特别选择的先前的验证技术相比，这是一个巨大的转变，`ValidatesOnNotifyDataErrors`绑定属性默认为`true`，因此将该属性添加到您的绑定语句是可选的。

`INotifyDataErrorInfo`接口非常小，但是确实需要大量的管道代码来使其有效，您很快就会看到这一点。界面如下所示:

```cs
public interface INotifyDataErrorInfo
{
  bool HasErrors { get; }
  event EventHandler<DataErrorsChangedEventArgs>
    ErrorsChanged;
  IEnumerable GetErrors(string propertyName);
}

```

绑定引擎使用`HasErrors`属性来确定实例的任何属性上是否有*任何*错误。如果使用 null 或空字符串调用`GetErrors()`方法的`propertyName`参数，它将返回实例中存在的所有错误。如果一个`propertyName`被传递到方法中，那么只返回特定属性的错误。`ErrorsChanged`事件(类似于`PropertyChanged`和`CollectionChanged`事件)通知绑定引擎更新当前错误列表的 UI。

##### 实现支持代码

在实现`INotifyDataErrorInfo`的时候，大部分代码通常会被推送到一个基础模型类中，所以只需要编写一次。从在`CarPartial.cs`类中用`INotifyDataErrorInfo`替换`IDataErrorInfo`开始，并添加接口成员(你可以把来自`IDataErrorInfo`的代码留在类中；您稍后将更新此内容)。

```cs
public partial class Car: INotifyDataErrorInfo, IDataErrorInfo
{
...
public IEnumerable GetErrors(string propertyName)
{
  throw new NotImplementedException();
}

public bool HasErrors { get; }
public event
  EventHandler<DataErrorsChangedEventArgs> ErrorsChanged;
}

```

接下来，添加一个`Dictionary<string,List<string>>`来保存按属性名分组的任何错误。您还需要为`System.Collections.Generic`添加一个`using`语句。两者都显示在这里:

```cs
using System.Collections.Generic;
private readonly Dictionary<string,List<string>> _errors
  = new Dictionary<string, List<string>>();

```

如果字典中有*任何*错误，`HasErrors`属性应该返回`true`。这很容易实现，如下所示:

```cs
public bool HasErrors => _errors.Any();

```

接下来，创建一个 helper 方法来引发`ErrorsChanged`事件(就像引发`PropertyChanged`事件一样),如下所示:

```cs
private void OnErrorsChanged(string propertyName)
{
  ErrorsChanged?.Invoke(this,
    new DataErrorsChangedEventArgs(propertyName));
}

```

如前所述，如果参数为空，那么`GetErrors()`方法应该返回字典中的所有错误。如果传入一个`propertyName`值，它将返回为该属性找到的任何错误。如果参数不匹配(或者属性没有任何错误)，那么该方法将返回 null。

```cs
public IEnumerable GetErrors(string propertyName)
{
  if (string.IsNullOrEmpty(propertyName))
  {
    return _errors.Values;
  }
  return _errors.ContainsKey(propertyName)
    ? _errors[propertyName]
    : null;
}

```

最后一组助手将为一个属性添加一个或多个错误，或者清除一个属性(或所有属性)的所有错误。每当字典改变时，记得调用`OnErrorsChanged()` helper 方法。

```cs
private void AddError(string propertyName, string error)
{
  AddErrors(propertyName, new List<string> { error });
}
private void AddErrors(
  string propertyName, IList<string> errors)
{
  if (errors == null || !errors.Any())
  {
    return;
  }
  var changed = false;
  if (!_errors.ContainsKey(propertyName))
  {
    _errors.Add(propertyName, new List<string>());
    changed = true;
  }
  foreach (var err in errors)
  {
    if (_errors[propertyName].Contains(err)) continue;
    _errors[propertyName].Add(err);
    changed = true;
  }
  if (changed)
  {
    OnErrorsChanged(propertyName);
  }
}
protected void ClearErrors(string propertyName = "")
{
  if (string.IsNullOrEmpty(propertyName))
  {
    _errors.Clear();
  }
  else
  {
    _errors.Remove(propertyName);
  }
  OnErrorsChanged(propertyName);
}

```

现在的问题是“这个代码是如何被激活的？”绑定引擎监听`ErrorsChanged`事件，如果绑定语句的错误集合发生变化，它将更新 UI。但是验证代码仍然需要一个触发器来执行。对此有两种机制，它们将在下面讨论。

##### 使用 INotifyDataErrorInfo 进行验证

检查错误的一个地方是属性设置器，如下例所示，简化为只检查`ModelT`验证:

```cs
public string Make
{
  get { return _make; }
  set
  {
    if (value == _make) return;
    _make = value;
    if (Make == "ModelT")
    {
      AddError(nameof(Make), "Too Old");
    }
    else
    {
      ClearErrors(nameof(Make));
    }
    OnPropertyChanged(nameof(Make));
    OnPropertyChanged(nameof(Color));
  }
}

```

这种方法的主要问题是，您必须将验证逻辑与属性设置器结合起来，这使得代码更难阅读和支持。

##### 将 idataerrorinfo 与 inotifydataerrorinfo 结合起来进行验证

在上一节中，您看到了可以将`IDataErrorInfo`添加到分部类中，这意味着您不必更新 setters。您还看到，当属性上的`PropertyChanged`被引发时，索引器会自动被调用。结合`IDataErrorInfo`和`INotifyDataErrorInfo`为您提供了来自`INotifyDataErrorInfo`的额外验证特性，以及`IDataErrorInfo`提供的与设置器的分离。

使用`IDataErrorInfo`的目的不是运行验证，而是确保每次在对象上引发`PropertyChanged`时，利用`INotifyDataErrorInfo`的验证代码都会被调用。因为没有使用`IDataErrorInfo`进行验证，所以总是从索引器返回`string.Empty`。将索引器和`CheckMakeAndColor()`帮助器方法更新为以下代码:

```cs
public string this[string columnName]
{
  get
  {
    ClearErrors(columnName);
    switch (columnName)
    {
      case nameof(Id):
        break;
      case nameof(Make):
        CheckMakeAndColor();
        if (Make == "ModelT")
        {
          AddError(nameof(Make), "Too Old");
          hasError = true;
        }
        break;
      case nameof(Color):
        CheckMakeAndColor();
        break;
      case nameof(PetName):
        break;
    }
    return string.Empty;
  }
}
internal bool CheckMakeAndColor()
{
  if (Make == "Chevy" && Color == "Pink")
  {
    AddError(nameof(Make), $"{Make}'s don't come in {Color}");
    AddError(nameof(Color),
      $"{Make}'s don't come in {Color}");
    return true;
  }
  return false;
}

```

运行应用程序，选择雪佛兰，并改变颜色为粉红色。除了品牌和型号文本框周围的红色装饰外，您还会看到整个网格周围的红色框装饰，其中包含了`Car`细节字段(如图 [28-3](#Fig3) 所示)。

![img/340876_10_En_28_Chapter/340876_10_En_28_Fig3_HTML.jpg](img/340876_10_En_28_Chapter/340876_10_En_28_Fig3_HTML.jpg)

图 28-3。

更新的错误装饰器

这是使用`INotifyDataErrorInfo`的另一个好处。除了有错误的控件之外，定义数据上下文的控件也用错误模板装饰。

##### 显示所有错误

`Validation`类上的`Errors`属性以`ValidationError`对象的形式返回特定对象上的所有验证错误。每个`ValidationError`对象都有一个`ErrorContent`属性，包含该属性的错误消息列表。这意味着您要显示的错误消息在列表中的这个列表中。为了正确显示它们，您需要创建一个保存显示数据的`ListBox`的`ListBox`。听起来有点递归，但是一旦看到就有道理了。

首先向`DetailsGrid`添加另一行，并确保`Window`的`Height`至少为 300。在最后一行添加一个`ListBox`，将`ItemsSource`绑定到`DetailsGrid`，使用`Validation.Errors`作为路径，如下所示:

```cs
<ListBox Grid.Row="6" Grid.Column="0" Grid.ColumnSpan="2"
    ItemsSource="{Binding ElementName=DetailsGrid, Path=(Validation.Errors)}">
</ListBox>

```

在`ListBox`中添加一个`DataTemplate`，在`DataTemplate`中添加一个与`ErrorContent`属性绑定的`ListBox`。在这种情况下，每个`ListBoxItem`的数据上下文是一个`ValidationError`对象，所以您不需要设置数据上下文，只需要设置路径。将绑定路径设置为`ErrorContent`，如下所示:

```cs
<ListBox.ItemTemplate>
  <DataTemplate>
    <ListBox ItemsSource="{Binding Path=ErrorContent}"/>
  </DataTemplate>
</ListBox.ItemTemplate>

```

运行应用程序，选择雪佛兰，并设置颜色为粉红色。您将看到图 [28-4](#Fig4) 中显示的错误。

![img/340876_10_En_28_Chapter/340876_10_En_28_Fig4_HTML.jpg](img/340876_10_En_28_Chapter/340876_10_En_28_Fig4_HTML.jpg)

图 28-4。

显示错误集合

这仅仅触及了验证和显示生成的错误的表面，但是它应该会让您在开发改善用户体验的信息丰富的 ui 的道路上走得很好。

##### 将支持代码移动到基类

正如您可能注意到的，现在在`CarPartial.cs`类中有很多代码。因为这个例子只有一个模型类，这并不可怕。但是，当您将模型添加到实际的应用程序中时，您不希望必须将所有的管道添加到模型的每个分部类中。最好的做法是将所有支持代码下推到一个基类。你现在就去做。

向名为`BaseEntity.cs`的`Models`文件夹添加一个新的类文件。增加`System.Collections`和`System.ComponentModel`的`using`语句。将该类公开，并添加`INotifyDataErrorInfo`接口，如下所示:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;

namespace Validations.Models
{
  public class BaseEntity : INotifyDataErrorInfo
}

```

将所有与`INofityDataErrorInfo`相关的代码从`CarPartial.cs`移到新的基类中。任何私有方法和变量都需要受到保护。接下来，从`CarPartial.cs`类中移除`INotifyDataErrorInfo`接口，并添加`BaseEntity`作为基类，如下所示:

```cs
public partial class Car : BaseEntity, IDataErrorInfo
{
 //removed for brevity
}

```

现在，您创建的任何额外的模型类都将继承所有的`INotifyDataErrorInfo`管道代码。

### 通过 WPF 利用数据注释

WPF 也可以利用数据注释进行 UI 验证。让我们给`Car`模型添加一些数据注释。

#### 向模型添加数据注释

打开`Car.cs`，为`System.ComponentModel.DataAnnotations`添加一条`using`语句。将`[Required]`和`[StringLength(50)]`属性添加到`Make`、`Color`和`PetName`中。`Required`属性添加了一个验证规则，即属性不能为空(当然，这对`Id`属性来说是多余的，因为它不是`nullable int`)。`StringLength(50)`属性增加了一条验证规则，即属性值不能超过 50 个字符。

#### 检查基于数据注释的验证错误

在 WPF 中，您必须以编程方式检查基于数据注释的验证错误。基于注释的验证的两个关键类是`ValidationContext`和`Validator`类。`ValidationContext`类提供了检查类验证错误的上下文。`Validator`类允许您在`ValidationContext`中检查对象的基于属性的错误。

打开`BaseEntity.cs`，添加以下`using`语句:

```cs
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;

```

接下来，创建一个名为`GetErrorsFromAnnotations()`的新方法。这个方法是通用的，接受一个字符串属性名和一个类型为`T`的值作为参数，并返回一个字符串数组。确保该方法被标记为受保护。签名如下所示:

```cs
protected string[] GetErrorsFromAnnotations<T>(
  string propertyName, T value)
{}

```

在该方法中，创建一个保存验证检查结果的`List<ValidationResult>`变量，并创建一个作用域为传递给该方法的属性名的`ValidationContext`。当你准备好这两个项目后，调用`Validate.TryValidateProperty`，它会返回一个`bool`。如果一切都通过(关于数据注释验证)，它返回`true`。如果不是，它返回`false`并用错误填充`List<ValidationResult>`。完整的代码如下所示:

```cs
protected string[] GetErrorsFromAnnotations<T>(
  string propertyName, T value)
{
  var results = new List<ValidationResult>();
  var vc = new ValidationContext(this, null, null)
    { MemberName = propertyName };
  var isValid = Validator.TryValidateProperty(
    value, vc, results);
  return (isValid)
    ? null
    : Array.ConvertAll(
        results.ToArray(), o => o.ErrorMessage);
}

```

现在您可以更新`CarPartial.cs`中的索引器方法，根据数据注释检查任何错误。如果发现任何错误，将它们添加到支持`INotifyDataErrorInfo`的错误集合中。这使我们能够清理错误处理。在索引器方法的开始，清除列的错误。然后处理验证，最后是实体的定制逻辑。更新后的索引器代码如下所示:

```cs
public string this[string columnName]
{
  get
  {
    ClearErrors(columnName);
    var errorsFromAnnotations =
      GetErrorsFromAnnotations(columnName,
        typeof(Car)
        .GetProperty(columnName)?.GetValue(this,null));
    if (errorsFromAnnotations != null)
    {
      AddErrors(columnName, errorsFromAnnotations);
    }
    switch (columnName)
    {
      case nameof(Id):
        break;
      case nameof(Make):
        CheckMakeAndColor();
        if (Make == "ModelT")
        {
          AddError(nameof(Make), "Too Old");
        }
        break;
      case nameof(Color):
        CheckMakeAndColor();
        break;
      case nameof(PetName):
        break;
    }
    return string.Empty;
  }
}

```

运行应用程序，选择其中一辆车，并为颜色添加超过 50 个字符的文本。当超过 50 个字符的阈值时，`StringLength`数据注释会创建一个验证错误，并报告给用户，如图 [28-5](#Fig5) 所示。

![img/340876_10_En_28_Chapter/340876_10_En_28_Fig5_HTML.jpg](img/340876_10_En_28_Chapter/340876_10_En_28_Fig5_HTML.jpg)

图 28-5。

验证所需的数据注释

### 自定义错误模板

最后一个主题是创建一个在控件出错时应用的样式，并更新`ErrorTemplate`以显示更有意义的错误信息。正如你在第 27 章中学到的，控件可以通过样式和控件模板来定制。

首先在目标类型为`TextBox`的`MainWindow.xaml`的`Windows.Resources`部分添加一个新样式。接下来，当`Validation.HasError`属性被设置为`true`时，在设置属性的样式上添加一个触发器。要设置的属性和值是`Background` ( `Pink`)、`Foreground` ( `Black`)和`Tooltip`到`ErrorContent`。`Background`和`Foreground`设置器并不新鲜，但是设置`ToolTip`的语法需要一些解释。绑定指向应用该样式的控件，在本例中是`TextBox`。该路径是`Validation.Errors`集合的第一个`ErrorContent`值。标记如下所示:

```cs
<Window.Resources>
  <Style TargetType="{x:Type TextBox}">
    <Style.Triggers>
      <Trigger Property="Validation.HasError" Value="true">
        <Setter Property="Background" Value="Pink" />
        <Setter Property="Foreground" Value="Black" />
        <Setter Property="ToolTip"
            Value="{Binding RelativeSource={RelativeSource Self},
            Path=(Validation.Errors)[0].ErrorContent}"/>
      </Trigger>
    </Style.Triggers>
  </Style>
</Window.Resources>

```

运行应用程序并创建一个错误条件。结果将类似于图 [28-6](#Fig6) ，并带有显示错误信息的工具提示。

![img/340876_10_En_28_Chapter/340876_10_En_28_Fig6_HTML.jpg](img/340876_10_En_28_Chapter/340876_10_En_28_Fig6_HTML.jpg)

图 28-6。

显示自定义错误模板

以前的样式改变了任何有错误条件的`TextBox`的外观。接下来，您将创建一个定制的控件模板来更新`Validation`类的`ErrorTemplate`以显示一个红色的感叹号，并为感叹号设置工具提示。`ErrorTemplate`是一个*装饰器*，它位于控件的顶部。当刚刚创建的样式更新控件本身时，`ErrorTemplate`将位于控件之上。

在刚刚创建的样式中，在`Style.Triggers`结束标记之后立即放置一个 setter。您将创建一个控制模板，它由一个`TextBlock`(显示感叹号)和一个`BorderBrush`组成，包围包含错误的`TextBox`。在 XAML 有一个特殊的标签，这个标签上装饰着名为`AdornedElementPlaceholder`的`ErrorTemplate`。通过向该控件添加名称，可以访问与该控件相关联的错误。在这个例子中，您想要访问`Validation.Errors`属性，这样您就可以获得`ErrorContent`(就像您在`Style.Trigger`中所做的那样)。以下是 setter 的完整标记:

```cs
<Setter Property="Validation.ErrorTemplate">
  <Setter.Value>
    <ControlTemplate>
      <DockPanel LastChildFill="True">
        <TextBlock Foreground="Red" FontSize="20" Text="!"
          ToolTip="{Binding ElementName=controlWithError,
          Path=AdornedElement.(Validation.Errors)[0].ErrorContent}"/>
        <Border BorderBrush="Red" BorderThickness="1">
          <AdornedElementPlaceholder Name="controlWithError" />
        </Border>
      </DockPanel>
    </ControlTemplate>
  </Setter.Value>
</Setter>

```

运行应用程序并创建一个错误条件。结果将类似于图 [28-7](#Fig7) 。

![img/340876_10_En_28_Chapter/340876_10_En_28_Fig7_HTML.jpg](img/340876_10_En_28_Chapter/340876_10_En_28_Fig7_HTML.jpg)

图 28-7。

显示自定义错误模板

### 完成验证

这就完成了您对 WPF 验证方法的了解。当然，你还可以做更多的事情。有关更多信息，请参考 WPF 文档。

## 创建自定义命令

与验证部分一样，您可以继续在同一个项目中工作，或者创建一个新项目并将所有代码复制到其中。我将创建一个名为 WpfCommands 的新项目。如果您正在使用同一个项目，请务必注意本节代码示例中的名称空间，并根据需要进行调整。

正如你在第 [25](25.html) 章中了解到的，命令是 WPF 不可或缺的一部分。命令可以挂接到 WPF 控件(比如`Button`和`MenuItem`控件)来处理用户事件，比如`Click()`事件。不是直接创建事件处理程序并将代码直接添加到代码隐藏文件中，而是在 click 事件触发时执行命令的`Execute()`方法。`CanExecute()`方法用于根据自定义代码启用或禁用控件。除了您在第 [25](25.html) 章中使用的内置命令之外，您还可以通过实现`ICommand`接口来创建自己的定制命令。通过使用命令而不是事件处理程序，您获得了封装应用程序代码以及基于业务逻辑自动启用和禁用控件的好处。

### 实现 ICommand 接口

作为对第 [25 章](25.html)的快速回顾，`ICommand`界面如下所示:

```cs
public interface ICommand
{
  event EventHandler CanExecuteChanged;
  bool CanExecute(object parameter);
  void Execute(object parameter);
}

```

### 添加 ChangeColorCommand 命令

从改变颜色按钮开始，`Button`控件的事件处理程序将被替换为命令。首先在项目中添加一个新文件夹(名为`Cmds`)。添加一个名为`ChangeColorCommand.cs`的新类。公开类，实现`ICommand`接口。添加下面的`using`语句(第一个可能会有所不同，这取决于您是否为这个示例创建了一个新项目):

```cs
using WpfCommands.Models;
using System.Windows.Input;

```

您的类应该是这样的:

```cs
public class ChangeColorCommand : ICommand
{
  public bool CanExecute(object parameter)
  {
    throw new NotImplementedException();
  }
  public void Execute(object parameter)
  {
    throw new NotImplementedException();
  }
  public event EventHandler CanExecuteChanged;
}

```

如果`CanExecute()`方法返回`true`，任何绑定控件都将被启用，如果它返回`false`，它们将被禁用。如果一个控件被启用(因为`CanExecute()`返回`true`)并被点击，那么`Execute()`方法将被触发。传递给这两个方法的参数来自基于绑定语句上设置的`CommandParameter`属性的 UI。`CanExecuteChanged`事件绑定到绑定和通知系统，通知 UI`CanExecute()`方法的结果已经改变(很像`PropertyChanged`事件)。

在本例中，只有当参数不为空并且类型为`Car`时，更改颜色按钮才起作用。将`CanExecute()`方法更新如下:

```cs
public bool CanExecute(object parameter)
  => (parameter as Car) != null;

```

`Execute()`方法参数的值与`CanExecute()`方法的值相同。由于`Execute()`方法只能在对象类型为`Car`时执行，参数必须转换为`Car`类型并更新颜色，如下所示:

```cs
public void Execute(object parameter)
{
  ((Car)parameter).Color="Pink";
}

```

#### 将命令附加到 CommandManager

命令类的最后一个更新是在命令管理器中键入命令。当`Window`第一次加载，然后当命令管理器指示它重新执行时，`CanExecute()`方法触发。每个命令类都必须选择加入命令管理器。这是通过更新关于`CanExecuteChanged`事件的代码来完成的，如下所示:

```cs
public event EventHandler CanExecuteChanged
{
  add => CommandManager.RequerySuggested += value;
  remove => CommandManager.RequerySuggested -= value;
}

```

#### 更新 MainWindow.xaml.cs

下一个变化是创建这个类的一个实例，`Button`可以访问它。现在，您将把它放在`MainWindow`的代码隐藏文件中(在本章的后面，您将把它移到一个`view model`)。打开`MainWindow.xaml.cs`并删除改变颜色按钮的`Click`事件处理程序。将下面的`using`语句添加到文件的顶部(同样，命名空间可能会根据您是仍在使用同一个项目还是开始了一个新项目而有所不同):

```cs
using WpfCommands.Cmds;
using System.Windows.Input;

```

接下来，添加一个名为`ChangeColorCmd`的公共属性，类型为`ICommand`，带有一个支持字段。在属性的表达式体中，返回支持属性(如果支持字段为空，确保实例化一个新的`ChangeColorCommand`实例)。

```cs
private ICommand _changeColorCommand = null;
public ICommand ChangeColorCmd
  => _changeColorCommand ??= new ChangeColorCommand());

```

#### 更新 MainWindow.xaml

正如你在第 [25](25.html) 章中看到的，WPF 中的可点击控件(像`Button`控件)有一个`Command`属性，允许你给控件分配一个命令对象。首先，将代码隐藏中实例化的命令连接到`btnChangeColor`按钮。因为命令的属性在`MainWindow`类上，所以使用`RelativeSourceMode`绑定语法来访问包含`Button`的`Window`，如下所示:

```cs
Command="{Binding Path=ChangeColorCmd,
  RelativeSource={RelativeSource Mode=FindAncestor, AncestorType={x:Type Window}}}"

```

`Button`仍然需要发送一个`Car`对象作为`CanExecute()`和`Execute()`方法的参数。这是通过`CommandParameter`房产转让的。您将此设置为`cboCars ComboBox`的`SelectedItem`，如下所示:

```cs
CommandParameter="{Binding ElementName=cboCars, Path=SelectedItem}"

```

按钮的完整标记如下所示:

```cs
<Button x:Name="btnChangeColor" Content="Change Color" Margin="5,0,5,0"
    Padding="4, 2" Command="{Binding Path=ChangeColorCmd,
        RelativeSource={RelativeSource Mode=FindAncestor, AncestorType={x:Type Window}}}"
    CommandParameter="{Binding ElementName=cboCars, Path=SelectedItem}"/>

```

#### 测试应用程序

运行应用程序。你会看到变色命令是*而不是*被激活，如图 [28-8](#Fig8) 所示，因为没有选择车辆。

![img/340876_10_En_28_Chapter/340876_10_En_28_Fig8_HTML.jpg](img/340876_10_En_28_Chapter/340876_10_En_28_Fig8_HTML.jpg)

图 28-8。

未选择任何内容的窗口

现在，选择一辆车；该按钮将被启用，点击它将改变颜色，正如所料！

### 创建 commandbars 类

如果对`AddCarCommand.cs`继续使用这种模式，将会有代码在类之间重复。这是一个好迹象，表明基类可以提供帮助。在`Cmds`文件夹中创建一个名为`CommandBase.cs`的新类，并为`System.Windows.Input`名称空间添加一个`using`。将类设置为 public 并实现`ICommand`接口。将类和`Execute()`和`CanExecute()`方法改为抽象。最后，添加来自`ChangeColorCommand`类的更新后的`CanExecuteChanged`事件。下面列出了完整的实现:

```cs
using System;
using System.Windows.Input;

namespace WpfCommands.Cmds
{
  public abstract class CommandBase : ICommand
  {
    public abstract bool CanExecute(object parameter);
    public abstract void Execute(object parameter);
    public event EventHandler CanExecuteChanged
    {
      add => CommandManager.RequerySuggested += value;
      remove => CommandManager.RequerySuggested -= value;
    }
  }
}

```

### 添加 AddCarCommand 类

将名为`AddCarCommand.cs`的新类添加到`Cmds`文件夹中。将该类公开，并添加`CommandBase`作为基类。将以下`using`语句添加到文件的顶部:

```cs
using System.Collections.ObjectModel;
using System.Linq;
using WpfCommands.Models;

```

该参数应该是一个`ObservableCollection<Car>`，所以在`CanExecute()`方法中检查以确保这一点。如果是，那么`Execute()`方法应该添加一辆额外的汽车，就像`Click`事件处理程序一样。

```cs
public class AddCarCommand :CommandBase
{
  public override bool CanExecute(object parameter)
    => parameter is ObservableCollection<Car>;
  public override void Execute(object parameter)
  {
    if (parameter is not ObservableCollection<Car> cars)
    {
      return;
    }
    var maxCount = cars.Max(x => x.Id);
    cars.Add(new Car
    {
      Id = ++maxCount,
      Color = "Yellow",
      Make = "VW",
      PetName = "Birdie"
    });
  }
}

```

#### 更新 MainWindow.xaml.cs

添加一个名为`AddCarCmd`的公共属性，类型为`ICommand`，带有一个支持字段。在属性的表达式体中，返回支持属性(如果支持字段为空，确保实例化一个新的`AddCarCommand`实例)。

```cs
private ICommand _addCarCommand = null;
public ICommand AddCarCmd
  => _addCarCommand ??= new AddCarCommand());

```

#### 更新 MainWindow.xaml

更新 XAML 以删除`Click`属性，并添加`Command`和`CommandParameter`属性。`AddCarCommand`将从`cboCars`组合框中接收汽车列表。整个按钮的 XAML 如下:

```cs
<Button x:Name="btnAddCar" Content="Add Car" Margin="5,0,5,0" Padding="4, 2"
  Command="{Binding Path=AddCarCmd,
      RelativeSource={RelativeSource Mode=FindAncestor, AncestorType={x:Type Window}}}"
   CommandParameter="{Binding ElementName=cboCars, Path=ItemsSource}"/>

```

有了这些，您现在可以使用独立类中包含的可重用代码添加汽车和更新汽车的颜色。

#### 正在更新 ChangeColorCommand

最后一步是更新`ChangeColorCommand`以继承`CommandBase`。将`ICommand`改为`CommandBase`，在两个方法中添加`override`关键字，删除`CanExecuteChanged`代码。真的就这么简单！下面列出了新代码:

```cs
public class ChangeColorCommand : CommandBase
{
  public override bool CanExecute(object parameter)
    => parameter is Car;
  public override void Execute(object parameter)
  {
    ((Car)parameter).Color = "Pink";
  }
}

```

### 中继命令

在 WPF，命令模式的另一个实现是`RelayCommand`。该模式使用委托来实现`ICommand`接口，而不是为每个命令创建一个新的类。这是一个轻量级的实现，因为每个命令都没有自己的类。`RelayCommand`通常在执行命令不需要重用的时候使用。

#### 创建基本继电器命令

通常在两个类中实现。当`CanExecute()`和`Execute()`方法不需要任何参数时，使用基类`RelayCommand`，当需要参数时，使用`RelayCommand<T>`。您将从基本的`RelayCommand`类开始，它利用了`CommandBase`类。将名为`RelayCommand.cs`的新类添加到`Cmds`文件夹中。将该类公开，并添加`CommandBase`作为基类。添加两个类级变量来保存`Execute()`和`CanExecute()`委托。

```cs
private readonly Action _execute;
private readonly Func<bool> _canExecute;

```

创建三个构造函数。第一个是默认构造函数(`RelayCommand<T>`-派生类需要)，第二个是带`Action`参数的构造函数，第三个是带`Action`参数和`Func`参数的构造函数，如下所示:

```cs
public RelayCommand(){}
public RelayCommand(Action execute) : this(execute, null) { }
public RelayCommand(Action execute, Func<bool> canExecute)
{
  _execute = execute
    ?? throw new ArgumentNullException(nameof(execute));
  _canExecute = canExecute;
}

```

最后，实现`CanExecute()`和`Execute()`覆盖。如果`Func`为空，则`CanExecute()`返回`true`；或者如果不为空，则执行并返回`true`。`Execute()`执行`Action`参数。

```cs
public override bool CanExecute(object parameter)
  => _canExecute == null || _canExecute();
public override void Execute(object parameter) { _execute(); }

```

#### 创建继电器命令

将名为`RelayCommandT.cs`的新类添加到`Cmds`文件夹中。这个类几乎是基类的翻版，只是委托都带有一个参数。使该类成为公共的和通用的，并添加`RelayCommand`作为基类，如下所示:

```cs
public class RelayCommand<T> : RelayCommand

```

添加两个类级变量来保存`Execute()`和`CanExecute()`委托:

```cs
private readonly Action<T> _execute;
private readonly Func<T, bool> _canExecute;

```

创建两个构造函数。第一个带一个`Action<T>`参数，第二个带一个`Action<T>`参数和一个`Func<T,bool>`参数，如下所示:

```cs
public RelayCommand(Action<T> execute):this(execute, null) {}
public RelayCommand(
  Action<T> execute, Func<T, bool> canExecute)
{
  _execute = execute
    ?? throw new ArgumentNullException(nameof(execute));
  _canExecute = canExecute;
}

```

最后，实现`CanExecute()`和`Execute()`覆盖。如果`Func`为空，则`CanExecute()`返回 true 或者，如果不为空，它执行并返回`true`。`Execute()`执行`Action`参数。

```cs
public override bool CanExecute(object parameter)
  => _canExecute == null || _canExecute((T)parameter);
public override void Execute(object parameter)
  { _execute((T)parameter); }

```

#### 更新 MainWindow.xaml.cs

当您使用`RelayCommand` s 时，在构造新命令时，需要指定委托的所有方法。这并不意味着代码需要存在于代码隐藏中(如此处所示)；它只需要可以从代码隐藏中访问。它可以存在于另一个类(甚至另一个程序集)中，提供创建自定义命令类的代码封装优势。

添加一个类型为`RelayCommand<Car>`的新私有变量和一个名为`DeleteCarCmd`的公共属性，如下所示:

```cs
private RelayCommand<Car> _deleteCarCommand = null;
public RelayCommand<Car> DeleteCarCmd
  => _deleteCarCommand ??=
     new RelayCommand<Car>(DeleteCar,CanDeleteCar));

```

还必须创建`DeleteCar()`和`CanDeleteCar()`方法，如下所示:

```cs
private bool CanDeleteCar(Car car) => car != null;
private void DeleteCar(Car car)
{
  _cars.Remove(car);
}

```

注意方法中的强类型——这是使用`RelayCommand<T>`的好处之一。

#### 添加和实现删除汽车按钮

最后一步是添加按钮，并分配`Command`和`CommandParameter`绑定。添加以下标记:

```cs
<Button x:Name="btnDeleteCar" Content="Delete Car" Margin="5,0,5,0" Padding="4, 2"
  Command="{Binding Path=DeleteCarCmd,
      RelativeSource={RelativeSource Mode=FindAncestor, AncestorType={x:Type Window}}}"
  CommandParameter="{Binding ElementName=cboCars, Path=SelectedItem}"/>

```

现在，当您运行应用程序时，您可以测试只有在下拉列表中选择了一辆汽车时，Delete Car 按钮才被启用，并且单击该按钮确实会从汽车列表中删除该汽车。

### 包装命令

你在 WPF 司令部的短暂旅程到此结束。通过将事件处理从代码隐藏文件中移出并放到单独的命令类中，您可以获得代码封装、重用和提高可维护性的好处。如果您不需要那么多的关注点分离，您可以使用轻量级的`RelayCommand`实现。目标是提高可维护性和代码质量，因此选择最适合您的方法。

## 将代码和数据迁移到视图模型

正如在“WPF 验证”一节中一样，您可以继续在同一个项目中工作，或者您可以创建一个新的项目并复制所有的代码。我将创建一个名为 WpfViewModel 的新项目。如果您正在使用同一个项目，请务必注意本节代码示例中的名称空间，并根据需要进行调整。

在您的项目中创建一个名为`ViewModels`的新文件夹，并将名为`MainWindowViewModel.cs`的新类添加到该文件夹中。添加以下命名空间并将该类设为公共类:

```cs
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Windows.Input;
using WpfViewModel.Cmds;
using WpfViewModel.Models;

```

Note

一个流行的惯例是根据视图模型支持的窗口来命名视图模型。我通常遵循这一惯例，并将在本章中这样做。然而，像任何模式或惯例一样，这不是一条规则，你会发现关于这一点有各种各样的观点。

### 移动 MainWindow.xaml.cs 代码

代码隐藏文件中的几乎所有代码都将被移动到视图模型中。最后，只有几行代码，包括对`InitializeComponent()`的调用和将窗口的数据上下文设置为视图模型的代码。

创建一个名为`Cars`的`IList<Car>`类型的公共属性，如下所示:

```cs
public IList<Car> Cars { get; } =
  new ObservableCollection<Car>();

```

创建一个默认的构造函数，从`MainWindow.xaml.cs`文件中移走所有的汽车创建代码，更新列表变量名。您也可以从`MainWindow.xaml.cs`中删除`_cars`变量。以下是视图模型构造函数:

```cs
public MainWindowViewModel()
{
  Cars.Add(
    new Car { Id = 1, Color = "Blue", Make = "Chevy", PetName = "Kit", IsChanged = false });
  Cars.Add(
    new Car { Id = 2, Color = "Red", Make = "Ford", PetName = "Red Rider", IsChanged = false });
}

```

接下来，将所有与命令相关的代码从窗口代码隐藏文件移动到视图模型，更新对`Cars`的变量引用`_cars`。下面是更改后的代码:

```cs
//rest omitted for brevity
private void DeleteCar(Car car)
{
  Cars.Remove(car);
}

```

### 更新主窗口代码和标记

从`MainWindow.xaml.cs`文件中删除了大部分代码。删除为组合框分配`ItemsSource`的行，只留下对`InitializeComponent`的调用。它现在应该是这样的:

```cs
public MainWindow()
{
    InitializeComponent();
}

```

将下面的`using`语句添加到文件的顶部:

```cs
using WpfViewModel.ViewModels;

```

接下来，创建一个强类型属性来保存视图模型的实例。

```cs
public MainWindowViewModel ViewModel { get; set; }
  = new MainWindowViewModel();

```

最后，在 XAML 的窗口声明中添加一个`DataContext`属性。

```cs
DataContext="{Binding ViewModel, RelativeSource={RelativeSource Self}}"

```

### 更新控件标记

既然`Window`的`DataContext`被设置为视图模型，控件的 XAML 绑定需要更新。从组合框开始，通过添加一个`ItemsSource`来更新标记。

```cs
<ComboBox Name="cboCars" Grid.Column="1" DisplayMemberPath="PetName" ItemsSource="{Binding Cars}" />

```

这是因为`Window`的数据上下文是`MainWindowViewModel`，而`Cars`是视图模型的公共属性。回想一下，绑定调用沿着元素树向上走，直到找到数据上下文。接下来，您需要更新`Button`控件的绑定。这很简单；由于绑定已经设置到窗口级别，您只需要更新绑定语句，从`DataContext`属性开始，如下所示:

```cs
<Button x:Name="btnAddCar" Content="Add Car" Margin="5,0,5,0" Padding="4, 2"
    Command="{Binding Path=DataContext.AddCarCmd,
        RelativeSource={RelativeSource Mode=FindAncestor, AncestorType={x:Type Window}}}"
    CommandParameter="{Binding ElementName=cboCars, Path=ItemsSource}"/>
<Button x:Name="btnDeleteCar" Content="Delete Car" Margin="5,0,5,0" Padding="4, 2"
    Command="{Binding Path=DataContext.DeleteCarCmd,
        RelativeSource={RelativeSource Mode=FindAncestor, AncestorType={x:Type Window}}}"
    CommandParameter="{Binding ElementName=cboCars, Path=SelectedItem}" />
<Button x:Name="btnChangeColor" Content="Change Color" Margin="5,0,5,0" Padding="4, 2"
    Command="{Binding Path=DataContext.ChangeColorCmd,
        RelativeSource={RelativeSource Mode=FindAncestor, AncestorType={x:Type Window}}}"
    CommandParameter="{Binding ElementName=cboCars, Path=SelectedItem}"/>

```

### 包装视图模型

信不信由你，你刚刚完成了你的第一份 MVVM WPF 申请。您可能会想，“这不是真正的应用程序。数据呢？本例中的数据是硬编码的。你是对的。不是真正的 app 是 demoware。然而，这就是 MVVM 模式的美妙之处。视图不知道数据来自哪里；它只是绑定到视图模型上的一个属性。您可以交换视图模型实现，也许使用一个硬编码数据的版本用于测试，一个命中数据库的版本用于生产。

还有很多可以讨论的地方，包括各种开源框架、视图模型定位器模式，以及关于如何最好地实现该模式的许多不同观点。这就是软件设计模式的美妙之处——通常有许多正确的方法来实现它，然后您只需要根据您的业务和技术需求找到最佳方式。

## 更新自动 Lot。MVVM 的 Dal

如果你想为 MVVM 更新`AutoLot.Dal`，你必须将我们为`Car`类所做的更改应用到自动 Lot 中的所有实体。Dal.Models 项目，包括`BaseEntity`。

## 摘要

本章研究了支持模型-视图-视图模型模式的 WPF 主题。您已经开始学习如何在绑定管理器中将模型类和集合绑定到通知系统中。您实现了`INotifyPropertyChanged`并使用了`ObservableCollections`类来保持 UI 与绑定数据的同步。

接下来，使用`IDataErrorInfo`和`INotifyDataErrorInfo`向模型添加验证代码，并检查数据注释错误。然后，您在 UI 中显示任何验证错误，以便用户知道问题是什么以及如何修复它，并且您创建了一个样式和自定义控件模板来以有意义的方式呈现错误。

最后，您通过添加一个视图模型将所有这些放在一起，并且您清理了 UI 标记和代码隐藏文件以增加关注点的分离。