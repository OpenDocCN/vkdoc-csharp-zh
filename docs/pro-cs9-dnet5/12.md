# 12.委托、事件和 Lambda 表达式

到本文的这一点为止，你开发的大多数应用程序都将不同的代码作为顶级语句添加到了`Program.cs`中，这些语句以某种方式将请求*发送到给定对象的*。然而，许多应用程序要求一个对象能够使用回调机制将*传递回*创建它的实体。虽然回调机制可以在任何应用程序中使用，但它们对于图形用户界面尤其重要，因为控件(如按钮)需要在正确的情况下(单击按钮时、鼠标进入按钮表面时等)调用外部方法。).

在下面。NET 核心平台中，*委托*类型是在应用程序中定义和响应回调的首选方式。本质上。NET Core 委托类型是一个类型安全的对象，它“指向”一个方法或一组以后可以调用的方法。然而，与传统的 C++函数指针不同，委托是具有多播内置支持的类。

Note

在的早期版本中。NET 中，用`BeginInvoke()` / `EndInvoke()`委托公开的异步方法调用。虽然这些仍由编译器生成，但在下不受支持。NET 核心。这是因为代理使用的`IAsyncResult()` / `BeginInvoke()`模式已经被基于任务的异步模式所取代。有关异步执行的更多信息，请参见第 [15 章](15.html)。

在本章中，你将学习如何创建和操作委托类型，然后你将研究 C# `event`关键字，它简化了使用委托类型的过程。在此过程中，您还将研究 C#的几个以委托为中心和以事件为中心的语言特性，包括匿名方法和方法组转换。

我通过检查λ表达式来结束这一章。使用 C# lambda 运算符(`=>`)，您可以在任何需要强类型委托的地方指定代码语句块(以及传递给这些代码语句的参数)。正如您将看到的，lambda 表达式只不过是一个伪装的匿名方法，并提供了一种简化的委托处理方法。此外，相同的操作(截至。NET Framework 4.6 及更高版本)可用于使用简洁的语法实现单语句方法或属性。

## 了解委托类型

在正式定义代表之前，让我们先了解一下情况。历史上，Windows API 经常使用 C 风格的函数指针来创建被称为*回调函数*的实体，或者简称为*回调*。使用回调，程序员能够配置一个函数来报告(回调)应用程序中的另一个函数。通过这种方法，Windows 开发人员能够处理按钮点击、鼠标移动、菜单选择以及内存中两个实体之间的一般双向通信。

在。NET 和。NET 核心框架中，回调是使用*委托*以类型安全和面向对象的方式完成的。委托是一个类型安全的对象，它指向应用程序中的另一个方法(或者可能是一列方法)，以后可以调用该方法。具体来说，代理维护三条重要的信息。

*   它调用的方法的*地址*

*   该方法的*参数*(如果有)

*   该方法的*返回类型*(如果有)

Note

。NET 核心委托可以指向静态方法或实例方法。

在委托对象被创建并被赋予必要的信息后，它可以在运行时动态地调用它所指向的方法。

### 在 C#中定义委托类型

当你想在 C#中创建一个委托类型时，你可以使用`delegate`关键字。您的委托类型的名称可以是您想要的任何名称。但是，您必须定义委托以匹配它将指向的方法的签名。例如，下面的委托类型(名为`BinaryOp`)可以指向任何返回一个整数并接受两个整数作为输入参数的方法(在本章的稍后部分，您将自己构建并使用这个委托，所以暂时不要着急):

```
// This delegate can point to any method,
// taking two integers and returning an integer.
public delegate int BinaryOp(int x, int y);

```

当 C#编译器处理委托类型时，它会自动生成一个从`System.MulticastDelegate`派生的密封类。这个类(与它的基类`System.Delegate`一起)为委托提供了必要的基础结构，以保存稍后要调用的方法列表。例如，如果您使用`ildasm.exe`来检查`BinaryOp`委托，您会发现如下所示的细节(如果您想自己检查，您将马上构建这个完整的示例):

```
//     -------------------------------------------------------
//     TypDefName: SimpleDelegate.BinaryOp
//     Extends   : System.MulticastDelegate
//     Method #1
//     -------------------------------------------------------
//             MethodName: .ctor
//             ReturnType: Void
//             2 Arguments
//                     Argument #1:  Object
//                     Argument #2:  I
//     Method #2
//     -------------------------------------------------------
//             MethodName: Invoke
//             ReturnType: I4
//             2 Arguments
//                     Argument #1:  I4
//                     Argument #2:  I4
//             2 Parameters
//                     (1) ParamToken : Name : x flags: [none]
//                     (2) ParamToken : Name : y flags: [none] //
//     Method #3
//     -------------------------------------------------------
//             MethodName: BeginInvoke
//             ReturnType: Class System.IAsyncResult
//             4 Arguments
//                     Argument #1:  I4
//                     Argument #2:  I4
//                     Argument #3:  Class System.AsyncCallback
//                     Argument #4:  Object
//             4 Parameters
//                     (1) ParamToken : Name : x flags: [none]
//                     (2) ParamToken : Name : y flags: [none]
//                     (3) ParamToken : Name : callback flags: [none]
//                     (4) ParamToken : Name : object flags: [none]
//
//     Method #4
//     -------------------------------------------------------
//             MethodName: EndInvoke
//             ReturnType: I4 (int32)
//             1 Arguments
//                     Argument #1:  Class System.IAsyncResult
//             1 Parameters
//                     (1) ParamToken : Name : result flags: [none]

```

如您所见，编译器生成的`BinaryOp`类定义了三个公共方法。`Invoke()`是中的关键方法。NET Core，因为它用于以一种*同步*的方式调用由委托对象维护的每个方法，这意味着调用者必须等待调用完成后才能继续它的方式。奇怪的是，同步`Invoke()`方法可能不需要从 C#代码中显式调用。正如您马上会看到的，当您使用适当的 C#语法时，`Invoke()`会在幕后被调用。

Note

虽然生成了`BeginInvoke()`和`EndInvoke()`，但是在下运行代码时不支持它们。NET 核心。这可能会令人沮丧，因为如果使用它们，您将不会收到编译器错误，而是运行时错误。

现在，编译器到底是如何知道如何定义`Invoke()`方法的呢？为了理解这个过程，下面是编译器生成的`BinaryOp`类类型的关键(粗斜体标记了由定义的委托类型指定的项目):

```
sealed class BinaryOp : System.MulticastDelegate
{
  public int Invoke(int x, int y);
...
}

```

首先，注意为`Invoke()`方法定义的参数和返回类型与`BinaryOp`委托的定义完全匹配。

让我们看另一个例子。假设您已经定义了一个委托类型，它可以指向任何返回一个`string`并接收三个`System.Boolean`输入参数的方法。

```
public delegate string MyDelegate (bool a, bool b, bool c);

```

这一次，编译器生成的类分解如下:

```
sealed class MyDelegate : System.MulticastDelegate
{
  public string Invoke(bool a, bool b, bool c);
...
}

```

委托还可以“指向”包含任意数量的`out`或`ref`参数(以及标有`params`关键字的数组参数)的方法。例如，假设以下委托类型:

```
public delegate string MyOtherDelegate(
  out bool a, ref bool b, int c);

```

`Invoke()`方法的签名看起来就像你所期望的那样。

总的来说，C#委托类型定义会产生一个密封类，其中包含一个编译器生成的方法，该方法的参数和返回类型基于委托的声明。以下伪代码近似于基本模式:

```
// This is only pseudo-code!
public sealed class DelegateName : System.MulticastDelegate
{
  public delegateReturnValue Invoke(allDelegateInputRefAndOutParams);
}

```

### 系统。多播代理和系统。委托基类

因此，当您使用 C# `delegate`关键字构建类型时，您是在间接声明一个从`System.MulticastDelegate`派生的类类型。该类为后代提供对列表的访问，该列表包含由委托对象维护的方法的地址，以及与调用列表交互的几个附加方法(和几个重载运算符)。以下是`System.MulticastDelegate`的一些精选成员:

```
public abstract class MulticastDelegate : Delegate
{
  // Returns the list of methods "pointed to."
  public sealed override Delegate[] GetInvocationList();

  // Overloaded operators.
  public static bool operator ==
    (MulticastDelegate d1, MulticastDelegate d2);
  public static bool operator !=
    (MulticastDelegate d1, MulticastDelegate d2);

  // Used internally to manage the list of methods maintained by the delegate.
  private IntPtr _invocationCount;
  private object _invocationList;
}

```

`System.MulticastDelegate`从其父类`System.Delegate`获得附加功能。下面是类定义的部分快照:

```
public abstract class Delegate : ICloneable, ISerializable
{
  // Methods to interact with the list of functions.
  public static Delegate Combine(params Delegate[] delegates);
  public static Delegate Combine(Delegate a, Delegate b);
  public static Delegate Remove(
    Delegate source, Delegate value);
  public static Delegate RemoveAll(
    Delegate source, Delegate value);

  // Overloaded operators.
  public static bool operator ==(Delegate d1, Delegate d2);
  public static bool operator !=(Delegate d1, Delegate d2);

  // Properties that expose the delegate target.
  public MethodInfo Method { get; }
  public object Target { get; }
}

```

现在，要明白你永远不能在你的代码中直接从这些基类派生(这样做是一个编译器错误)。然而，当您使用`delegate`关键字时，您已经间接地创建了一个“is-a”`MulticastDelegate`类。表 [12-1](#Tab1) 记录了所有委托类型共有的核心成员。

表 12-1。

选择*System.MulticastDelegate/System.Delegate*的成员

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

成员

 | 

生命的意义

 |
| --- | --- |
| `Method` | 该属性返回一个代表由委托维护的静态方法的细节的`System.Reflection.MethodInfo`对象。 |
| `Target` | 如果要调用的方法是在对象级定义的(而不是静态方法)，`Target`返回一个对象，该对象表示由委托维护的方法。如果从`Target`返回的值等于`null`，那么要调用的方法是一个静态成员。 |
| `Combine()` | 此静态方法将方法添加到由委托维护的列表中。在 C#中，您使用重载的`+=`操作符作为一种简写符号来触发这个方法。 |
| `GetInvocationList()` | 这个方法返回一个由`System.Delegate`对象组成的数组，每个对象代表一个可能被调用的方法。 |
| `Remove()` `/``RemoveAll()` | 这些静态方法从委托的调用列表中移除一个方法(或所有方法)。在 C#中，可以使用重载的`-=`运算符间接调用`Remove()`方法。 |

## 最简单的委托示例

当然，第一次遇到委托时，可能会引起一些混乱。因此，开始吧，让我们看一个简单的控制台应用程序(名为 SimpleDelegate ),它使用了您之前见过的`BinaryOp`委托类型。下面是完整的代码，并附有分析:

```
//SimpleMath.cs
namespace SimpleDelegate
{
  // This class contains methods BinaryOp will
  // point to.
  public class SimpleMath
  {
    public static int Add(int x, int y) => x + y;
    public static int Subtract(int x, int y) => x - y;
  }
}

//Program.cs
using System;
using SimpleDelegate;

Console.WriteLine("***** Simple Delegate Example *****\n");

// Create a BinaryOp delegate object that
// "points to" SimpleMath.Add().
BinaryOp b = new BinaryOp(SimpleMath.Add);

// Invoke Add() method indirectly using delegate object.
Console.WriteLine("10 + 10 is {0}", b(10, 10));
Console.ReadLine();

//Additional type definitions must be placed at the end of the
// top-level statements
// This delegate can point to any method,
// taking two integers and returning an integer.
public delegate int BinaryOp(int x, int y);

```

Note

回想一下第 [3 章](03.html)中的内容，额外的类型声明(在这个例子中是`BinaryOp`委托)必须跟在*所有的*顶级语句之后。

再次注意`BinaryOp`委托类型声明的格式；它指定`BinaryOp`委托对象可以指向任何一个接受两个整数并返回一个整数的方法(所指向的方法的实际名称是不相关的)。这里，您已经创建了一个名为`SimpleMath`的类，它定义了两个静态方法，这两个方法与`BinaryOp`委托定义的模式相匹配。

当您想要将目标方法分配给给定的委托对象时，只需将方法的名称传递给委托的构造函数。

```
// Create a BinaryOp delegate object that
// "points to" SimpleMath.Add().
BinaryOp b = new BinaryOp(SimpleMath.Add);

```

此时，您可以使用类似于直接函数调用的语法来调用所指向的成员。

```
// Invoke() is really called here!
Console.WriteLine("10 + 10 is {0}", b(10, 10));

```

在幕后，运行时在您的`MulticastDelegate`派生类上调用编译器生成的`Invoke()`方法。如果您在`ildasm.exe`中打开您的程序集，并在`Main()`方法中检查 CIL 代码，您可以自己验证这一点。

```
.method private hidebysig static void Main(string[] args) cil managed
{
...
  callvirt   instance int32 BinaryOp::Invoke(int32, int32)
}

```

C#不要求你在代码库中显式调用`Invoke()`。因为`BinaryOp`可以指向带两个参数的方法，下面的代码语句也是允许的:

```
Console.WriteLine("10 + 10 is {0}", b.Invoke(10, 10));

```

回想一下。NET 核心委托是*类型安全的*。因此，如果您试图创建一个指向与模式不匹配的方法的委托对象，就会收到一个编译时错误。举例来说，假设`SimpleMath`类现在定义了一个名为`SquareNumber()`的附加方法，它接受一个整数作为输入。

```
public class SimpleMath
{
  public static int SquareNumber(int a) => a * a;
}

```

鉴于`BinaryOp`委托只能将*指向*接受两个整数并返回一个整数的方法，下面的代码是非法的，不会被编译:

```
// Compiler error! Method does not match delegate pattern!
BinaryOp b2 = new BinaryOp(SimpleMath.SquareNumber);

```

### 调查委托对象

让我们通过在`Program`类中创建一个静态方法(名为`DisplayDelegateInfo()`)来增加当前示例的趣味。该方法将打印出由委托对象维护的方法的名称，以及定义该方法的类的名称。为此，您将迭代由`GetInvocationList()`返回的`System.Delegate`数组，调用每个对象的`Target`和`Method`属性。

```
static void DisplayDelegateInfo(Delegate delObj)
{
  // Print the names of each member in the
  // delegate's invocation list.
  foreach (Delegate d in delObj.GetInvocationList())
  {
    Console.WriteLine("Method Name: {0}", d.Method);
    Console.WriteLine("Type Name: {0}", d.Target);
  }
}

```

假设您已经更新了您的`Main()`方法来调用这个新的帮助器方法，如下所示:

```
BinaryOp b = new BinaryOp(SimpleMath.Add);
DisplayDelegateInfo(b);

```

您会发现如下所示的输出:

```
***** Simple Delegate Example *****
Method Name: Int32 Add(Int32, Int32)
Type Name:
10 + 10 is 20

```

注意，当调用`Target`属性时，目标类(`SimpleMath`)的名称当前显示为*而不是*。原因是您的`BinaryOp`委托指向一个*静态方法*，因此没有对象可以引用！然而，如果您将`Add()`和`Subtract()`方法更新为非静态的(只需删除`static`关键字)，您可以创建一个`SimpleMath`类的实例，并使用对象引用指定要调用的方法。

```
using System;
using SimpleDelegate;

Console.WriteLine("***** Simple Delegate Example *****\n");

// Delegates can also point to instance methods as well.
SimpleMath m = new SimpleMath();
BinaryOp b = new BinaryOp(m.Add);

// Show information about this object.
DisplayDelegateInfo(b);

Console.WriteLine("10 + 10 is {0}", b(10, 10));
Console.ReadLine();

```

在这种情况下，您会发现如下所示的输出:

```
***** Simple Delegate Example *****
Method Name: Int32 Add(Int32, Int32)
Type Name: SimpleDelegate.SimpleMath
10 + 10 is 20

```

## 使用委托发送对象状态通知

显然，前面的 SimpleDelegate 示例本质上纯粹是说明性的，因为没有令人信服的理由来定义一个简单地将两个数相加的委托。为了更真实地使用委托类型，让我们使用委托来定义一个`Car`类，它可以通知外部实体它当前的引擎状态。为此，您将采取以下步骤:

1.  定义将用于向呼叫者发送通知的新委托类型。

2.  在`Car`类中声明这个委托的成员变量。

3.  在`Car`上创建一个助手函数，允许调用者指定要回调的方法。

4.  实现`Accelerate()`方法以在正确的情况下调用委托的调用列表。

首先，创建一个名为 CarDelegate 的新控制台应用程序项目。现在，定义一个新的`Car`类，最初如下所示:

```
using System;
using System.Linq;

namespace CarDelegate
{
  public class Car
  {
    // Internal state data.
    public int CurrentSpeed { get; set; }
    public int MaxSpeed { get; set; } = 100;
    public string PetName { get; set; }

    // Is the car alive or dead?
    private bool _carIsDead;

    // Class constructors.
    public Car() {}
    public Car(string name, int maxSp, int currSp)
    {
      CurrentSpeed = currSp;
      MaxSpeed = maxSp;
      PetName = name;
    }
  }
}

```

现在，考虑以下更新，这些更新解决了前三点:

```
public class Car
{
  ...
  // 1) Define a delegate type.
  public delegate void CarEngineHandler(string msgForCaller);

  // 2) Define a member variable of this delegate.
  private CarEngineHandler _listOfHandlers;

  // 3) Add registration function for the caller.
  public void RegisterWithCarEngine(CarEngineHandler methodToCall)
  {
    _listOfHandlers = methodToCall;
  }
}

```

请注意，在这个例子中，您直接在`Car`类的范围内定义了委托类型，这当然不是必需的，但确实有助于强化委托自然地与这个类一起工作的思想。委托类型`CarEngineHandler`可以指向任何将单个`string`作为输入并将`void`作为返回值的方法。

接下来，请注意，您声明了一个委托类型的私有成员变量(名为`_listOfHandlers`)和一个助手函数(名为`RegisterWithCarEngine()`)，该函数允许调用者将一个方法分配给委托的调用列表。

Note

严格地说，您可以将您的委托成员变量定义为 public，从而避免创建额外的注册方法。但是，通过将委托成员变量定义为 private，您可以实施封装服务并提供更类型安全的解决方案。在本章的后面，当你查看 C# `event`关键字时，你将再次讨论公共委托成员变量的风险。

此时，您需要创建`Accelerate()`方法。回想一下，这里的要点是允许一个`Car`对象向任何订阅的侦听器发送与引擎相关的消息。以下是最新消息:

```
// 4) Implement the Accelerate() method to invoke the delegate's

//    invocation list under the correct circumstances.
public void Accelerate(int delta)
{
  // If this car is "dead," send dead message.
  if (_carIsDead)
  {
    _listOfHandlers?.Invoke("Sorry, this car is dead...");
  }
  else
  {
    CurrentSpeed += delta;
    // Is this car "almost dead"?
    if (10 == (MaxSpeed - CurrentSpeed))
    {
      _listOfHandlers?.Invoke("Careful buddy! Gonna blow!");
    }
    if (CurrentSpeed >= MaxSpeed)
    {
      _carIsDead = true;
    }
    else
    {
      Console.WriteLine("CurrentSpeed = {0}", CurrentSpeed);
    }
  }
}

```

请注意，在尝试调用由`listOfHandlers`成员变量维护的方法时，您使用了空传播语法。原因是调用者的工作是通过调用`RegisterWithCarEngine()` helper 方法来分配这些对象。如果调用者没有调用这个方法，而你试图调用委托的调用列表，你将在运行时触发一个`NullReferenceException`。现在您已经有了委托基础设施，观察对`Program`类的更新，如下所示:

```
using System;
using CarDelegate;

Console.WriteLine("** Delegates as event enablers **\n");

// First, make a Car object.
Car c1 = new Car("SlugBug", 100, 10);

// Now, tell the car which method to call
// when it wants to send us messages.
c1.RegisterWithCarEngine(
  new Car.CarEngineHandler(OnCarEngineEvent));

// Speed up (this will trigger the events).
Console.WriteLine("***** Speeding up *****");
for (int i = 0; i < 6; i++)
{
  c1.Accelerate(20);
}
Console.ReadLine();

// This is the target for incoming events.
static void OnCarEngineEvent(string msg)
{
  Console.WriteLine("\n*** Message From Car Object ***");
  Console.WriteLine("=> {0}", msg);
  Console.WriteLine("********************\n");
}

```

代码从简单地创建一个新的`Car`对象开始。既然您对引擎事件感兴趣，那么下一步就是调用您的定制注册函数`RegisterWithCarEngine()`。回想一下，这个方法期望被传递一个嵌套的`CarEngineHandler`委托的实例，和任何委托一样，您指定一个“指向的方法”作为构造函数参数。本例中的技巧是，所讨论的方法位于`Program`类中！再次注意，`OnCarEngineEvent()`方法与相关委托完全匹配，因为它接受一个`string`作为输入并返回`void`。考虑当前示例的输出:

```
***** Delegates as event enablers *****
***** Speeding up *****
CurrentSpeed = 30
CurrentSpeed = 50
CurrentSpeed = 70

***** Message From Car Object *****
=> Careful buddy! Gonna blow!
***********************************
CurrentSpeed = 90
***** Message From Car Object *****
=> Sorry, this car is dead...
***********************************

```

### 启用多播

回想一下。网络核心代表具有内置的*组播*能力。换句话说，委托对象可以维护要调用的方法列表，而不仅仅是单个方法。当你想给一个委托对象添加多个方法时，你只需使用重载的`+=`操作符，而不是直接赋值。要在`Car`类上启用多播，您可以更新`RegisterWithCarEngine()`方法，如下所示:

```
public class Car
{
  // Now with multicasting support!
  // Note we are now using the += operator, not
  // the assignment operator (=).
  public void RegisterWithCarEngine(
    CarEngineHandler methodToCall)
  {
    _listOfHandlers += methodToCall;
  }
...
}

```

当您在委托对象上使用`+=`操作符时，编译器将其解析为对静态`Delegate.Combine()`方法的调用。事实上，你可以直接给`Delegate.Combine()`打电话；然而，`+=`操作符提供了一个更简单的选择。不需要修改您当前的`RegisterWithCarEngine()`方法，但是这里有一个使用`Delegate.Combine()`而不是`+=`操作符的例子:

```
public void RegisterWithCarEngine( CarEngineHandler methodToCall )
{
  if (_listOfHandlers == null)
  {
    _listOfHandlers = methodToCall;
  }
  else
  {
    _listOfHandlers =
      Delegate.Combine(_listOfHandlers, methodToCall)
        as CarEngineHandler;
  }
}

```

无论如何，调用者现在可以为同一个回调通知注册多个目标。这里，第二个处理程序以大写形式打印传入的消息，只是为了显示:

```
Console.WriteLine("***** Delegates as event enablers *****\n");

// First, make a Car object.
Car c1 = new Car("SlugBug", 100, 10);

// Register multiple targets for the notifications.
c1.RegisterWithCarEngine(
  new Car.CarEngineHandler(OnCarEngineEvent));
c1.RegisterWithCarEngine(
  new Car.CarEngineHandler(OnCarEngineEvent2));

// Speed up (this will trigger the events).
Console.WriteLine("***** Speeding up *****");
for (int i = 0; i < 6; i++)
{
  c1.Accelerate(20);
}
Console.ReadLine();

// We now have TWO methods that will be called by the Car
// when sending notifications.
static void OnCarEngineEvent(string msg)
{
  Console.WriteLine("\n*** Message From Car Object ***");
  Console.WriteLine("=> {0}", msg);
  Console.WriteLine("*********************************\n");
}

static void OnCarEngineEvent2(string msg)
{
  Console.WriteLine("=> {0}", msg.ToUpper());
}

```

### 从委托的调用列表中删除目标

`Delegate`类还定义了一个静态的`Remove()`方法，允许调用者从委托对象的调用列表中动态删除一个方法。这使得允许调用者在运行时“取消订阅”给定的通知变得简单。虽然您可以在代码中直接调用`Delegate.Remove()`，但是 C#开发人员可以使用`-=`操作符作为一种方便的简写符号。让我们给`Car`类添加一个新方法，它允许调用者从调用列表中删除一个方法。

```
public class Car
{
...
  public void UnRegisterWithCarEngine(CarEngineHandler methodToCall)
  {
    _listOfHandlers -= methodToCall;
  }
}

```

使用当前对`Car`类的更新，您可以通过更新调用代码来停止在第二个处理程序上接收引擎通知，如下所示:

```
Console.WriteLine("***** Delegates as event enablers *****\n");

// First, make a Car object.
Car c1 = new Car("SlugBug", 100, 10);
c1.RegisterWithCarEngine(
  new Car.CarEngineHandler(OnCarEngineEvent));

// This time, hold onto the delegate object,
// so we can unregister later.
Car.CarEngineHandler handler2 =
  new Car.CarEngineHandler(OnCarEngineEvent2);
c1.RegisterWithCarEngine(handler2);

// Speed up (this will trigger the events).
Console.WriteLine("***** Speeding up *****");
for (int i = 0; i < 6; i++)
{
  c1.Accelerate(20);
}

// Unregister from the second handler.
c1.UnRegisterWithCarEngine(handler2);

// We won't see the "uppercase" message anymore!
Console.WriteLine("***** Speeding up *****");
for (int i = 0; i < 6; i++)
{
  c1.Accelerate(20);
}

Console.ReadLine();

```

这段代码中的一个不同之处是，这次您创建了一个`Car.CarEngineHandler`对象，并将其存储在一个局部变量中，这样您就可以在以后使用该对象来注销通知。因此，第二次加速`Car`对象时，您将不再看到输入消息数据的大写版本，因为您已经从委托的调用列表中删除了这个目标。

### 方法组转换语法

在前面的 CarDelegate 示例中，您显式创建了`Car.CarEngineHandler` delegate 对象的实例，以便向引擎通知注册和注销。

```
Console.WriteLine("***** Delegates as event enablers *****\n");

Car c1 = new Car("SlugBug", 100, 10);
c1.RegisterWithCarEngine(new Car.CarEngineHandler(OnCarEngineEvent));

Car.CarEngineHandler handler2 =
  new Car.CarEngineHandler(OnCarEngineEvent2);
c1.RegisterWithCarEngine(handler2);
...

```

可以肯定的是，如果您需要调用`MulticastDelegate`或`Delegate`的任何继承成员，手动创建一个委托变量是最简单的方法。然而，在大多数情况下，您并不真正需要抓住委托对象不放。相反，您通常只需要使用委托对象将方法名作为构造函数参数传入。

作为一种简化，C#提供了一种称为*方法组转换*的快捷方式。当调用以委托作为参数的方法时，此功能允许您提供直接的方法名，而不是委托对象。

Note

正如你将在本章后面看到的，你也可以使用方法组转换语法来简化你注册 C#事件的方式。

举例来说，考虑下面对`Program`类的更新，该类使用方法组转换来注册和注销引擎通知:

```
...
Console.WriteLine("***** Method Group Conversion *****\n");
Car c2 = new Car();

// Register the simple method name.
c2.RegisterWithCarEngine(OnCarEngineEvent);

Console.WriteLine("***** Speeding up *****");
for (int i = 0; i < 6; i++)
{
  c2.Accelerate(20);
}

// Unregister the simple method name.
c2.UnRegisterWithCarEngine(OnCarEngineEvent);

// No more notifications!
for (int i = 0; i < 6; i++)
{
  c2.Accelerate(20);
}

Console.ReadLine();

```

请注意，您不是直接分配相关的委托对象，而是简单地指定一个与委托的预期签名相匹配的方法(在本例中，该方法返回`void`并接受一个`string`)。要明白 C#编译器仍然在确保类型安全。因此，如果`OnCarEngineEvent()`方法没有接受`string`并返回`void`，就会出现编译器错误。

## 了解泛型委托

在第 10 章中，我提到 C#允许你定义通用的委托类型。例如，假设您想要定义一个委托类型，它可以调用任何返回`void`并接收单个参数的方法。如果所讨论的参数可能不同，您可以使用类型参数对此进行建模。为了说明这一点，请考虑名为 GenericDelegate 的新控制台应用程序项目中的以下代码:

```
Console.WriteLine("***** Generic Delegates *****\n");

// Register targets.
MyGenericDelegate<string> strTarget =
  new MyGenericDelegate<string>(StringTarget);
strTarget("Some string data");

//Using the method group conversion syntax
MyGenericDelegate<int> intTarget = IntTarget;
intTarget(9);
Console.ReadLine();

static void StringTarget(string arg)
{
  Console.WriteLine("arg in uppercase is: {0}", arg.ToUpper());
}

static void IntTarget(int arg)
{
  Console.WriteLine("++arg is: {0}", ++arg);
}
  // This generic delegate can represent any method
  // returning void and taking a single parameter of type T.
  public delegate void MyGenericDelegate<T>(T arg);

```

注意，`MyGenericDelegate<T>`定义了一个类型参数，它表示传递给委托目标的参数。创建此类型的实例时，需要指定类型参数的值，以及委托将调用的方法的名称。因此，如果您指定了一个字符串类型，您将向目标方法发送一个字符串值。

```
// Create an instance of MyGenericDelegate<T>
// with string as the type parameter.
MyGenericDelegate<string> strTarget = StringTarget;
strTarget("Some string data");

```

给定`strTarget`对象的格式，`StringTarget()`方法现在必须将单个字符串作为参数。

```
static void StringTarget(string arg)
{
  Console.WriteLine(
    "arg in uppercase is: {0}", arg.ToUpper());
}

```

### 通用动作<>和功能<>委托

在本章的过程中，你已经看到了当你想在你的应用程序中使用委托来启用回调时，你通常遵循如下所示的步骤:

1.  定义与所指向方法的格式相匹配的自定义委托。

2.  创建自定义委托的实例，将方法名作为构造函数参数传入。

3.  通过调用委托对象上的`Invoke()`来间接调用该方法。

当您采用这种方法时，您通常会得到几个自定义委托，这些委托可能永远不会在当前任务之外使用(例如，`MyGenericDelegate<T>`、`CarEngineHandler`等)。).虽然您确实需要为您的项目定制一个唯一命名的委托类型，但是其他时候委托类型的确切名称*是不相关的。在许多情况下，您只是希望“某个委托”接受一组参数，并可能有一个不同于`void`的返回值。在这些情况下，您可以使用框架内置的`Action<>`和`Func<>`委托类型。为了说明它们的用途，创建一个名为 ActionAndFuncDelegates 的新控制台应用程序项目。*

泛型`Action<>`委托是在`System`名称空间中定义的，您可以使用这个泛型委托来“指向”一个最多占用 *16 个参数*的方法(这应该足够了！)并返回`void`。现在回想一下，因为`Action<>`是一个泛型委托，所以您还需要指定每个参数的底层类型。

更新您的`Program`类来定义一个新的静态方法，它接受三个(或更多)唯一的参数。这里有一个例子:

```
// This is a target for the Action<> delegate.
static void DisplayMessage(string msg, ConsoleColor txtColor, int printCount)
{
  // Set color of console text.
  ConsoleColor previous = Console.ForegroundColor;
  Console.ForegroundColor = txtColor;

  for (int i = 0; i < printCount; i++)
  {
    Console.WriteLine(msg);
  }

  // Restore color.
  Console.ForegroundColor = previous;
}

```

现在，您可以使用现成的`Action<>`委托，而不是手动构建一个自定义委托来将程序流传递给`DisplayMessage()`方法，如下所示:

```
Console.WriteLine("***** Fun with Action and Func *****");

// Use the Action<> delegate to point to DisplayMessage.
Action<string, ConsoleColor, int> actionTarget =
  DisplayMessage;
actionTarget("Action Message!", ConsoleColor.Yellow, 5);

Console.ReadLine();

```

如您所见，使用`Action<>`委托可以省去定义定制委托类型的麻烦。然而，回想一下，`Action<>`委托类型只能指向采用`void`返回值的方法。如果您想指向一个确实有返回值的方法(并且不想麻烦自己编写自定义委托)，您可以使用`Func<>`。

通用的`Func<>`委托可以指向(像`Action<>`)最多接受 16 个参数和一个自定义返回值的方法。为了举例说明，将下面的新方法添加到`Program`类中:

```
// Target for the Func<> delegate.
static int Add(int x, int y)
{
  return x + y;
}

```

在本章的前面，我让你构建一个定制的`BinaryOp`委托来“指向”加减法。然而，您可以使用一个总共有三个类型参数的版本的`Func<>`来简化您的工作。要知道`Func<>`的 *final* 类型参数是*总是*方法的返回值。为了巩固这一点，假设`Program`类还定义了以下方法:

```
static string SumToString(int x, int y)
{
  return (x + y).ToString();
}

```

现在，调用代码可以调用这些方法中的每一个，如下所示:

```
Func<int, int, int> funcTarget = Add;
int result = funcTarget.Invoke(40, 40);
Console.WriteLine("40 + 40 = {0}", result);

Func<int, int, string> funcTarget2 = SumToString;
string sum = funcTarget2(90, 300);
Console.WriteLine(sum);

```

在任何情况下，考虑到`Action<>`和`Func<>`可以让您省去手动定义自定义委托的步骤，您可能想知道是否应该一直使用它们。与编程的许多方面一样，答案是“视情况而定”在许多情况下，`Action<>`和`Func<>`将是首选的行动方案(没有双关语)。但是，如果您需要一个具有自定义名称的委托，并且您认为它有助于更好地捕获您的问题域，那么构建自定义委托就像一条代码语句一样简单。在阅读本文的剩余部分时，您将会看到这两种方法。

Note

许多重要的。NET 核心 API 大量使用了`Action<>`和`Func<>`委托，包括并行编程框架和 LINQ(等等)。

这就结束了我们对委托类型的初步了解。接下来，让我们继续讨论 C# `event`关键字的相关主题。

## 了解 C#事件

委托是有趣的构造，因为它们使内存中的对象能够进行双向对话。然而，在 raw 中使用委托可能需要创建一些样板代码(定义委托、声明必要的成员变量、创建自定义注册和注销方法以保留封装，等等)。).

此外，当您使用 raw 中的委托作为应用程序的回调机制时，如果您没有将类的委托成员变量定义为 private，调用方将可以直接访问委托对象。在这种情况下，调用者可以将变量重新分配给一个新的委托对象(有效地删除当前要调用的函数列表)，更糟糕的是，调用者可以直接调用委托的调用列表。为了演示这个问题，创建一个名为 PublicDelegateProblem 的新控制台应用程序，并添加对前面 CarDelegate 示例中的`Car`类的以下修改(和简化):

```
namespace PublicDelegateproblem
{
  public class Car
  {
    public delegate void CarEngineHandler(string msgForCaller);

    // Now a public member!
    public CarEngineHandler ListOfHandlers;

    // Just fire out the Exploded notification.
    public void Accelerate(int delta)
    {
      if (ListOfHandlers != null)
      {
        ListOfHandlers("Sorry, this car is dead...");
      }
    }
  }
}

```

请注意，您不再拥有用自定义注册方法封装的私有委托成员变量。因为这些成员确实是公共的，所以调用者可以直接访问`listOfHandlers`成员变量，并将该类型重新分配给新的`CarEngineHandler`对象，并在需要时调用委托。

```
using System;
using PublicDelegateProblem;

Console.WriteLine("***** Agh! No Encapsulation! *****\n");
// Make a Car.
Car myCar = new Car();
// We have direct access to the delegate!
myCar.ListOfHandlers = CallWhenExploded;
myCar.Accelerate(10);

// We can now assign to a whole new object...
// confusing at best.
myCar.ListOfHandlers = CallHereToo;
myCar.Accelerate(10);

// The caller can also directly invoke the delegate!
myCar.ListOfHandlers.Invoke("hee, hee, hee...");
Console.ReadLine();

static void CallWhenExploded(string msg)
{
  Console.WriteLine(msg);
}

static void CallHereToo(string msg)
{
  Console.WriteLine(msg);
}

```

公开公共委托成员会破坏封装，这不仅会导致代码难以维护(和调试),还会使您的应用程序面临潜在的安全风险！以下是当前示例的输出:

```
***** Agh! No Encapsulation! *****
Sorry, this car is dead...
Sorry, this car is dead...
hee, hee, hee...

```

显然，您不希望让其他应用程序有权更改委托所指向的内容，或者在未经您允许的情况下调用成员。鉴于此，通常的做法是声明私有委托成员变量。

### C#事件关键字

作为一种快捷方式，C#提供了`event`关键字，这样您就不必构建自定义方法来向委托的调用列表添加或移除方法。当编译器处理`event`关键字时，会自动为您提供注册和注销方法，以及您的委托类型所需的任何成员变量。这些委托成员变量*总是*声明为私有的，因此，它们不会直接从触发事件的对象中暴露出来。当然，`event`关键字可以用来简化定制类向外部对象发送通知的方式。

定义事件是一个两步过程。首先，您需要定义一个委托类型(或者重用一个现有的类型),它将保存事件触发时要调用的方法列表。接下来，根据相关的委托类型声明一个事件(使用 C# `event`关键字)。

为了说明`event`关键字，创建一个名为 CarEvents 的新控制台应用程序。在这个`Car`类的迭代中，您将定义两个名为`AboutToBlow`和`Exploded`的事件。这些事件与一个名为`CarEngineHandler`的委托类型相关联。下面是对`Car`类的初始更新:

```
using System;

namespace CarEvents
{
  public class Car
  {
...
    // This delegate works in conjunction with the
    // Car's events.
    public delegate void CarEngineHandler(string msgForCaller);

    // This car can send these events.
    public event CarEngineHandler Exploded;
    public event CarEngineHandler AboutToBlow;
 ...
  }
}

```

向调用者发送事件非常简单，只需按名称指定事件，以及相关委托定义的任何必需参数。为了确保调用者确实注册了事件，在调用委托的方法集之前，您需要对照一个`null`值来检查事件。考虑到这几点，下面是`Car`的`Accelerate()`方法的新迭代:

```
public void Accelerate(int delta)
{
  // If the car is dead, fire Exploded event.
  if (_carIsDead)
  {
    Exploded?.Invoke("Sorry, this car is dead...");
  }
  else
  {
    CurrentSpeed += delta;

    // Almost dead?
    if (10 == MaxSpeed - CurrentSpeed)
    {
      AboutToBlow?.Invoke("Careful buddy! Gonna blow!");
    }

    // Still OK!
    if (CurrentSpeed >= MaxSpeed)
    {
      _carIsDead = true;
    }
    else
    {
      Console.WriteLine("CurrentSpeed = {0}", CurrentSpeed);
    }
  }
}

```

至此，您已经配置了 car 来发送两个定制事件，而不必定义定制注册函数或声明委托成员变量。您将很快看到这种新汽车的用法，但首先让我们更详细地检查一下事件架构。

### 幕后事件

当编译器处理 C# `event`关键字时，它会生成两个隐藏方法，一个有一个`add_`前缀，另一个有一个`remove_`前缀。每个前缀后跟 C#事件的名称。例如，`Exploded`事件产生了两个名为`add_Exploded()`和`remove_Exploded()`的隐藏方法。如果您要查看`add_AboutToBlow()`后面的 CIL 指令，您会发现对`Delegate.Combine()`方法的调用。考虑部分 CIL 码:

```
.method public hidebysig specialname instance void  add_AboutToBlow(
  class [System.Runtime]System.EventHandler`1<class CarEvents.CarEventArgs> 'value') cil managed
  {
...
    IL_000b: call class [System.Runtime]System.Delegate [System.Runtime]System.Delegate::Combine(class [System.Runtime]System.Delegate, class [System.Runtime]System.Delegate)
...
  } // end of method Car::add_AboutToBlow

```

正如您所料，`remove_AboutToBlow()`将代表您调用`Delegate.Remove()`。

```
.method public hidebysig specialname instance void  remove_AboutToBlow (
  class [System.Runtime]System.EventHandler`1<class CarEvents.CarEventArgs> 'value') cil managed
  {
...
    IL_000b:  call class [System.Runtime]System.Delegate [System.Runtime]System.Delegate::Remove(class [System.Runtime]System.Delegate, class [System.Runtime]System.Delegate)
...
}

```

最后，代表事件本身的 CIL 代码使用`.addon`和`.removeon`指令来映射要调用的正确的`add_XXX()`和`remove_XXX()`方法的名称。

```
.event class [System.Runtime]System.EventHandler`1<class CarEvents.CarEventArgs> AboutToBlow
{
  .addon instance void CarEvents.Car::add_AboutToBlow(
    class [System.Runtime]System.EventHandler`1<class CarEvents.CarEventArgs>)
  .removeon instance void CarEvents.Car::remove_AboutToBlow(
    class [System.Runtime]System.EventHandler`1<class CarEvents.CarEventArgs>)
} // end of event Car::AboutToBlow

```

既然您已经理解了如何构建一个可以发送 C#事件的类(并且意识到事件只不过是一个节省键入时间的工具)，下一个大问题就是如何在调用者端监听传入的事件。

### 监听传入事件

C#事件还简化了注册调用方事件处理程序的操作。调用者不必指定定制的助手方法，而是直接使用`+=`和`-=`操作符(这将在后台触发正确的`add_XXX()`或`remove_XXX()`方法)。当您想要注册某个事件时，请遵循此处显示的模式:

```
// NameOfObject.NameOfEvent +=
//    new RelatedDelegate(functionToCall);
//
Car.CarEngineHandler d =
  new Car.CarEngineHandler(CarExplodedEventHandler);
myCar.Exploded += d;

```

当您想要从事件源分离时，使用`-=`操作符，使用以下模式:

```
// NameOfObject.NameOfEvent -=
//  new RelatedDelegate(functionToCall);
//
myCar.Exploded -= d;

```

请注意，您也可以对事件使用方法组转换语法:

```
Car.CarEngineHandler d = CarExplodedEventHandler;
myCar.Exploded += d;

```

给定这些非常可预测的模式，下面是重构后的`calling code`，现在使用 C#事件注册语法:

```
Console.WriteLine("***** Fun with Events *****\n");
Car c1 = new Car("SlugBug", 100, 10);

// Register event handlers.
c1.AboutToBlow += CarIsAlmostDoomed;
c1.AboutToBlow += CarAboutToBlow;

Car.CarEngineHandler d = CarExploded;
c1.Exploded += d;

Console.WriteLine("***** Speeding up *****");
for (int i = 0; i < 6; i++)
{
  c1.Accelerate(20);
}

// Remove CarExploded method
// from invocation list.
c1.Exploded -= d;

Console.WriteLine("\n***** Speeding up *****");
for (int i = 0; i < 6; i++)
{
  c1.Accelerate(20);
}
Console.ReadLine();

static void CarAboutToBlow(string msg)
{
  Console.WriteLine(msg);
}

static void CarIsAlmostDoomed(string msg)
{
  Console.WriteLine("=> Critical Message from Car: {0}", msg);
}

static void CarExploded(string msg)
{
  Console.WriteLine(msg);
}

```

### 使用 Visual Studio 简化事件注册

Visual Studio 帮助注册事件处理程序。当您在事件注册期间应用`+=`语法时，您会发现显示了一个智能感知窗口，邀请您点击 Tab 键来自动完成关联的委托实例(参见图 [12-1](#Fig1) ，它是使用*方法组转换语法*捕获的。

![../images/340876_10_En_12_Chapter/340876_10_En_12_Fig1_HTML.jpg](../images/340876_10_En_12_Chapter/340876_10_En_12_Fig1_HTML.jpg)

图 12-1。

委托选择智能感知

点击 Tab 键后，IDE 会自动生成新方法，如图 [12-2](#Fig2) 所示。

![../images/340876_10_En_12_Chapter/340876_10_En_12_Fig2_HTML.jpg](../images/340876_10_En_12_Chapter/340876_10_En_12_Fig2_HTML.jpg)

图 12-2。

委托目标格式智能感知

注意存根代码是委托目标的正确格式(注意这个方法已经被声明为静态的，因为事件是在静态方法中注册的)。

```
static void NewCar_AboutToBlow(string msg)
{
  throw new NotImplementedException();
}

```

所有人都可以使用智能感知。NET 核心事件、自定义事件和基类库中的所有事件。这个 IDE 特性可以节省大量的时间，因为它使您不必搜索帮助系统来确定事件要使用的正确委托以及委托目标方法的格式。

### 创建自定义事件参数

说实话，你可以对当前的`Car`类做最后一个增强，它反映了微软推荐的事件模式。当你开始研究基类库中给定类型发送的事件时，你会发现底层委托的第一个参数是一个`System.Object`，而第二个参数是`System.EventArgs`的后代。

`System.Object`参数表示对发送事件的对象的引用(比如`Car`)，而第二个参数表示关于当前事件的信息。`System.EventArgs`基类表示不发送任何自定义信息的事件。

```
public class EventArgs
{
  public static readonly EventArgs Empty;
  public EventArgs();
}

```

对于简单的事件，可以直接传递一个`EventArgs`的实例。然而，当您想要传递自定义数据时，您应该构建一个从`EventArgs`派生的合适的类。对于这个例子，假设您有一个名为`CarEventArgs`的类，它维护一个表示发送给接收者的消息的字符串。

```
using System;

namespace CarEvents
{
  public class CarEventArgs : EventArgs
  {
    public readonly string msg;
    public CarEventArgs(string message)
    {
      msg = message;
    }
  }
}

```

这样，您现在可以如下更新`CarEngineHandler`委托类型定义(事件将保持不变):

```
public class Car
{
  public delegate void CarEngineHandler(object sender, CarEventArgs e);
...
}

```

这里，当从`Accelerate()`方法中触发事件时，您现在需要提供一个对当前`Car`(通过`this`关键字)的引用和一个`CarEventArgs`类型的实例。例如，考虑以下部分更新:

```
public void Accelerate(int delta)
{
  // If the car is dead, fire Exploded event.
  if (carIsDead)
  {
    Exploded?.Invoke(this, new CarEventArgs("Sorry, this car is dead..."));
  }
...
}

```

在调用者端，您需要做的就是更新您的事件处理程序来接收传入的参数并通过只读字段获取消息。这里有一个例子:

```
static void CarAboutToBlow(object sender, CarEventArgs e)
{
  Console.WriteLine($"{sender} says: {e.msg}");
}

```

如果接收者想要与发送事件的对象交互，可以显式地强制转换`System.Object`。从这个引用中，您可以利用发送事件通知的对象的任何公共成员。

```
static void CarAboutToBlow(object sender, CarEventArgs e)
{
  // Just to be safe, perform a
  // runtime check before casting.
  if (sender is Car c)
  {
    Console.WriteLine(
      $"Critical Message from {c.PetName}: {e.msg}");
  }
}

```

### 通用 EventHandler <t>委托</t>

鉴于如此多的自定义委托将一个`object`作为第一个参数，将一个`EventArgs`后代作为第二个参数，您可以通过使用通用的`EventHandler<T>`类型来进一步简化前面的示例，其中`T`是您的自定义`EventArgs`类型。考虑下面对`Car`类型的更新(注意您不再需要定义自定义委托类型):

```
public class Car
{
...
  public event EventHandler<CarEventArgs> Exploded;
  public event EventHandler<CarEventArgs> AboutToBlow;
}

```

然后，调用代码可以在之前指定了`CarEventHandler`的任何地方使用`EventHandler<CarEventArgs>`(或者，再次使用方法组转换)。

```
Console.WriteLine("***** Prim and Proper Events *****\n");

// Make a car as usual.
Car c1 = new Car("SlugBug", 100, 10);

// Register event handlers.
c1.AboutToBlow += CarIsAlmostDoomed;
c1.AboutToBlow += CarAboutToBlow;

EventHandler<CarEventArgs> d = CarExploded;
c1.Exploded += d;
...

```

太好了。至此，您已经看到了在 C#语言中使用委托和事件的核心方面。虽然您可以使用这些信息来满足所有的回调需求，但是在本章结束时，您将会看到一些最终的简化，特别是匿名方法和 lambda 表达式。

## 了解 C#匿名方法

正如您所看到的，当调用者想要监听传入事件时，它必须在一个类(或结构)中定义一个自定义方法，该方法与相关委托的签名相匹配。这里有一个例子:

```
SomeType t = new SomeType();

// Assume "SomeDelegate" can point to methods taking no
// args and returning void.
t.SomeEvent += new SomeDelegate(MyEventHandler);

// Typically only called by the SomeDelegate object.
static void MyEventHandler()
{
  // Do something when event is fired.
}

```

然而，仔细想想，像`MyEventHandler()`这样的方法很少会被程序中除了调用委托之外的任何部分调用。就生产效率而言，手动定义一个由委托对象调用的单独方法有点麻烦(尽管这绝不是一个阻碍)。

为了解决这一点，可以在事件注册时将事件直接关联到代码语句块。形式上，这样的代码被称为*匿名方法*。为了说明语法，首先创建一个名为 AnonymousMethods 的新控制台应用程序，并将 CarEvents 项目中的`Car.cs`和`CarEventArgs.cs`类复制到新项目中(确保将它们的名称空间更改为`AnonymousMethods`)。更新`Program.cs`文件的代码以匹配下面的代码，它使用匿名方法处理从`Car`类发送的事件，而不是专门命名的事件处理程序:

```
using System;
using AnonymousMethods;

Console.WriteLine("***** Anonymous Methods *****\n");
Car c1 = new Car("SlugBug", 100, 10);

// Register event handlers as anonymous methods.
c1.AboutToBlow += delegate
{
  Console.WriteLine("Eek! Going too fast!");
};

c1.AboutToBlow += delegate(object sender, CarEventArgs e)
{
  Console.WriteLine("Message from Car: {0}", e.msg);
};

c1.Exploded += delegate(object sender, CarEventArgs e)
{
  Console.WriteLine("Fatal Message from Car: {0}", e.msg);
};

// This will eventually trigger the events.
for (int i = 0; i < 6; i++)
{
  c1.Accelerate(20);
}
Console.ReadLine();

```

Note

匿名方法的最后一个花括号必须以分号结束。如果不这样做，就会出现编译错误。

再次注意，调用代码不再需要定义特定的静态事件处理程序，比如`CarAboutToBlow()`或`CarExploded()`。相反，在调用者使用`+=`语法处理事件时，未命名(又名匿名)方法被内联定义。匿名方法的基本语法与以下伪代码相匹配:

```
SomeType t = new SomeType();
t.SomeEvent += delegate (optionallySpecifiedDelegateArgs)
{ /* statements */ };

```

当处理前一个代码示例中的第一个`AboutToBlow`事件时，请注意，您没有指定从委托传递的参数。

```
c1.AboutToBlow += delegate
{
  Console.WriteLine("Eek! Going too fast!");
};

```

严格地说，您不需要接收特定事件发送的传入参数。但是，如果您想要利用可能的传入参数，您将需要指定由委托类型原型化的参数(如第二个对`AboutToBlow`和`Exploded`事件的处理所示)。这里有一个例子:

```
c1.AboutToBlow += delegate(object sender, CarEventArgs e)
{
  Console.WriteLine("Critical Message from Car: {0}", e.msg);
};

```

### 访问局部变量

匿名方法很有趣，因为它们可以访问定义它们的方法的局部变量。从形式上讲，这样的变量被称为匿名方法的外部变量。关于匿名方法范围和定义方法范围之间的交互，应该提到以下要点:

*   匿名方法不能访问定义方法的`ref`或`out`参数。

*   匿名方法中的局部变量不能与外部方法中的局部变量同名。

*   匿名方法可以访问外部类范围内的实例变量(或静态变量，视情况而定)。

*   匿名方法可以声明与外部类成员变量同名的局部变量(局部变量具有不同的范围并隐藏外部类成员变量)。

假设您的顶级语句定义了一个名为`aboutToBlowCounter`的局部整数。在处理`AboutToBlow`事件的匿名方法中，您将使这个计数器加 1，并在语句完成之前打印出计数。

```
Console.WriteLine("***** Anonymous Methods *****\n");
int aboutToBlowCounter = 0;

// Make a car as usual.
Car c1 = new Car("SlugBug", 100, 10);

// Register event handlers as anonymous methods.
c1.AboutToBlow += delegate
{
  aboutToBlowCounter++;
  Console.WriteLine("Eek! Going too fast!");
};

c1.AboutToBlow += delegate(object sender, CarEventArgs e)
{
  aboutToBlowCounter++;
  Console.WriteLine("Critical Message from Car: {0}", e.msg);
};
...
// This will eventually trigger the events.
for (int i = 0; i < 6; i++)
{
  c1.Accelerate(20);
}

Console.WriteLine("AboutToBlow event was fired {0} times.",
  aboutToBlowCounter);
Console.ReadLine();

```

运行更新后的代码后，您会发现最后的`Console.WriteLine()`报告了`AboutToBlow`事件被触发了两次。

### 使用静态和匿名方法(新 9.0)

前面的例子演示了匿名方法与方法本身范围之外声明的变量进行交互。虽然这可能是您想要的，但它破坏了封装，并可能在您的程序中引入意想不到的副作用。回想一下第 [4](04.html) 章，通过将局部函数设置为静态，可以将它们从包含代码中分离出来，如下例所示:

```
static int AddWrapperWithStatic(int x, int y)
{
  //Do some validation here
  return Add(x,y);
  static int Add(int x, int y)
  {
    return x + y;
  }
}

```

C# 9.0 中新增的匿名方法也可以标记为静态，以保持封装性，并确保该方法不会给包含它的代码带来任何副作用。例如，请参见此处更新的匿名方法:

```
c1.AboutToBlow += static delegate
{
  //This causes a compile error because it is marked static
  aboutToBlowCounter++;
  Console.WriteLine("Eek! Going too fast!");
};

```

由于匿名方法试图访问在其范围之外声明的变量，上述代码将无法编译。

### 用匿名方法丢弃(新 9.0)

在第 3 章中介绍的丢弃，已经在 C# 9.0 中更新，作为匿名方法的输入参数，带有一个 catch。因为下划线(`_`)在以前版本的 C#中是一个合法的变量标识符，所以必须有两个或更多与匿名方法一起使用的丢弃才会被视为丢弃。

例如，下面的代码为一个接受两个整数并返回另一个整数的`Func`创建了一个委托。该实现忽略任何传入的变量，并返回 42:

```
Console.WriteLine("******** Discards with Anonymous Methods ********");

Func<int,int,int> constant = delegate (int _, int _) {return 42;};
Console.WriteLine("constant(3,4)={0}",constant(3,4));

```

## 理解 Lambda 表达式

以此来结束您对。NET 核心事件架构，您将研究 C# *lambda 表达式*。正如刚才所解释的，C#支持“内联”处理事件的能力，方法是使用匿名方法将一组代码语句直接分配给一个事件，而不是构建一个由底层委托调用的独立方法。Lambda 表达式只不过是一种简洁的方式来创作匿名方法，并最终简化您使用。NET 核心委托类型。

要为 lambda 表达式的检查做准备，请创建一个名为 lambda expressions 的新控制台应用程序项目。首先，考虑泛型`List<T>`类的`FindAll()`方法。当您需要从集合中提取项目的子集时，可以调用此方法，其原型如下:

```
// Method of the System.Collections.Generic.List<T>
public List<T> FindAll(Predicate<T> match)

```

正如您所看到的，这个方法返回了一个新的代表数据子集的`List<T>`。还要注意的是，`FindAll()`的唯一参数是一个类型为`System.Predicate<T>`的泛型委托。这个委托类型可以指向任何返回一个`bool`的方法，并将一个类型参数作为唯一的输入参数。

```
// This delegate is used by FindAll() method
// to extract out the subset.
public delegate bool Predicate<T>(T obj);

```

当你调用`FindAll()`时，`List<T>`中的每一项都被传递给`Predicate<T>`对象所指向的方法。所述方法的实现将执行一些计算，以查看传入的数据是否匹配必要的标准，并将返回`true`或`false`。如果这个方法返回`true`，这个条目将被添加到新的代表子集的`List<T>`中(明白了吗？).

在您看到 lambda 表达式如何简化使用`FindAll()`之前，让我们直接使用委托对象，用手写符号来解决这个问题。在您的`Program`类型中添加一个与`System.Predicate<T>`类型交互的方法(名为`TraditionalDelegateSyntax()`),以发现整数的`List<T>`中的偶数。

```
using System;
using System.Collections.Generic;
using LambdaExpressions;

Console.WriteLine("***** Fun with Lambdas *****\n");
TraditionalDelegateSyntax();
Console.ReadLine();

static void TraditionalDelegateSyntax()
{
  // Make a list of integers.
  List<int> list = new List<int>();
  list.AddRange(new int[] { 20, 1, 4, 8, 9, 44 });

  // Call FindAll() using traditional delegate syntax.
  Predicate<int> callback = IsEvenNumber;
  List<int> evenNumbers = list.FindAll(callback);

  Console.WriteLine("Here are your even numbers:");
  foreach (int evenNumber in evenNumbers)
  {
    Console.Write("{0}\t", evenNumber);
  }
  Console.WriteLine();
}

// Target for the Predicate<> delegate.
static bool IsEvenNumber(int i)
{
  // Is it an even number?
  return (i % 2) == 0;
}

```

这里，您有一个方法(`IsEvenNumber()`)，它通过 C#模操作符`%`监督测试传入的整数参数，以查看它是偶数还是奇数。如果您执行您的应用程序，您会发现数字 20、4、8 和 44 打印到控制台。

虽然这种使用委托的传统方法如预期的那样工作，但是只有在有限的情况下才会调用`IsEvenNumber()`方法——特别是当您调用`FindAll()`时，这会给您留下一个完整方法定义的包袱。虽然您可以将它作为一个局部函数，但是如果您使用匿名方法，您的代码将会清理得相当干净。考虑下面这个`Program`类的新方法:

```
static void AnonymousMethodSyntax()
{
  // Make a list of integers.
  List<int> list = new List<int>();
  list.AddRange(new int[] { 20, 1, 4, 8, 9, 44 });

  // Now, use an anonymous method.
  List<int> evenNumbers =
    list.FindAll(delegate(int i) { return (i % 2) == 0; } );

  Console.WriteLine("Here are your even numbers:");
  foreach (int evenNumber in evenNumbers)
  {
    Console.Write("{0}\t", evenNumber);
  }
  Console.WriteLine();
}

```

在这种情况下，您可以匿名内联一个方法，而不是直接创建一个`Predicate<T>`委托对象，然后创作一个独立的方法。虽然这是朝着正确方向迈出的一步，但是仍然需要使用关键字`delegate`(或者强类型的`Predicate<T>`)，并且必须确保参数列表是完全匹配的。

```
List<int> evenNumbers = list.FindAll(
  delegate(int i)
  {
    return (i % 2) == 0;
  }
);

```

*λ表达式*可以用来进一步简化对`FindAll()`的调用。当您使用 lambda 语法时，根本没有任何底层委托对象的痕迹。考虑下面对`Program`类的新方法:

```
static void LambdaExpressionSyntax()
{
  // Make a list of integers.
  List<int> list = new List<int>();
  list.AddRange(new int[] { 20, 1, 4, 8, 9, 44 });

  // Now, use a C# lambda expression.
  List<int> evenNumbers = list.FindAll(i => (i % 2) == 0);

  Console.WriteLine("Here are your even numbers:");
  foreach (int evenNumber in evenNumbers)
  {
    Console.Write("{0}\t", evenNumber);
  }
  Console.WriteLine();
}

```

在这种情况下，请注意传递给`FindAll()`方法的代码语句，它实际上是一个 lambda 表达式。在这个例子的迭代中，没有任何关于`Predicate<T>`委托(或者`delegate`关键字)的痕迹。您所指定的只是 lambda 表达式。

```
i => (i % 2) == 0

```

在我分解这个语法之前，首先要理解 lambda 表达式可以用在任何使用匿名方法或强类型委托的地方(通常击键次数少得多)。在幕后，C#编译器利用`Predicate<T>`委托类型(可以使用`ildasm.exe`或`reflector.exe`来验证)将表达式翻译成标准的匿名方法。具体来说，下面的代码语句:

```
// This lambda expression...
List<int> evenNumbers = list.FindAll(i => (i % 2) == 0);

```

被编译成如下近似的 C#代码:

```
// ...becomes this anonymous method.
List<int> evenNumbers = list.FindAll(delegate (int i)
{
  return (i % 2) == 0;
});

```

### 剖析 Lambda 表达式

lambda 表达式是这样编写的:首先定义一个参数列表，然后是`=>`标记(在 *lambda 演算*中找到的 lambda 运算符的 C#标记)，然后是一组将处理这些参数的语句(或单个语句)。从高层次来看，lambda 表达式可以理解为:

```
ArgumentsToProcess => StatementsToProcessThem

```

在`LambdaExpressionSyntax()`方法中，事情是这样分解的:

```
// "i" is our parameter list.
// "(i % 2) == 0" is our statement set to process "i".
List<int> evenNumbers = list.FindAll(i => (i % 2) == 0);

```

lambda 表达式的参数可以显式或隐式类型化。目前，代表`i`参数(整数)的底层数据类型是隐式确定的。编译器可以根据 lambda 表达式和底层委托的上下文判断出`i`是一个整数。但是，也可以通过将数据类型和变量名放在一对括号中来显式定义表达式中每个参数的类型，如下所示:

```
// Now, explicitly state the parameter type.
List<int> evenNumbers = list.FindAll((int i) => (i % 2) == 0);

```

正如你所看到的，如果一个 lambda 表达式只有一个隐式类型的参数，那么圆括号可以从参数列表中省略。如果你想在 lambda 参数的使用上保持一致，你可以*总是*将参数列表放在括号内，留给你这个表达式:

```
List<int> evenNumbers = list.FindAll((i) => (i % 2) == 0);

```

最后，请注意，当前表达式没有用括号括起来(当然，您已经将 modulo 语句括起来，以确保它在相等测试之前首先执行)。Lambda 表达式允许语句包装如下:

```
// Now, wrap the expression as well.
List<int> evenNumbers = list.FindAll((i) => ((i % 2) == 0));

```

既然您已经看到了构建 lambda 表达式的各种方法，那么您如何以人类友好的方式阅读这个 lambda 语句呢？抛开原始的数学，下面的解释符合这个要求:

```
// My list of parameters (in this case, a single integer named i)
// will be processed by the expression (i % 2) == 0.
List<int> evenNumbers = list.FindAll((i) => ((i % 2) == 0));

```

### 处理多条语句中的参数

第一个 lambda 表达式是一个最终计算为布尔值的语句。然而，如您所知，许多委托目标必须执行几个代码语句。出于这个原因，C#允许您通过使用标准花括号指定代码块来构建包含多个语句的 lambda 表达式。考虑以下对`LambdaExpressionSyntax()`方法的示例更新:

```
static void LambdaExpressionSyntax()
{
  // Make a list of integers.
  List<int> list = new List<int>();
  list.AddRange(new int[] { 20, 1, 4, 8, 9, 44 });

  // Now process each argument within a group of
  // code statements.
  List<int> evenNumbers = list.FindAll((i) =>
  {
    Console.WriteLine("value of i is currently: {0}", i);
    bool isEven = ((i % 2) == 0);
    return isEven;
  });

  Console.WriteLine("Here are your even numbers:");
  foreach (int evenNumber in evenNumbers)
  {
    Console.Write("{0}\t", evenNumber);
  }
  Console.WriteLine();
}

```

在这种情况下，参数列表(同样是一个名为`i`的整数)由一组代码语句处理。除了对`Console.WriteLine()`的调用，为了增加可读性，modulo 语句被分成了两个代码语句。假设您在本节中看到的每个方法都是从顶级语句中调用的:

```
Console.WriteLine("***** Fun with Lambdas *****\n");
TraditionalDelegateSyntax();
AnonymousMethodSyntax();
Console.WriteLine();
LambdaExpressionSyntax();
Console.ReadLine();

```

您会发现以下输出:

```
***** Fun with Lambdas *****
Here are your even numbers:
20      4       8       44
Here are your even numbers:
20      4       8       44
value of i is currently: 20
value of i is currently: 1
value of i is currently: 4
value of i is currently: 8
value of i is currently: 9
value of i is currently: 44
Here are your even numbers:
20      4       8       44

```

### 具有多个(或零个)参数的 Lambda 表达式

到目前为止，你在本章中看到的 lambda 表达式只处理了一个参数。然而，这不是必需的，因为 lambda 表达式可以处理多个参数(或者一个都不处理)。为了说明多参数的第一种情况，添加下面的`SimpleMath`类型实例:

```
public class SimpleMath
{
  public delegate void MathMessage(string msg, int result);
  private MathMessage _mmDelegate;

  public void SetMathHandler(MathMessage target)
  {
    _mmDelegate = target;
  }

  public void Add(int x, int y)
  {
    _mmDelegate?.Invoke("Adding has completed!", x + y);
  }
}

```

请注意，`MathMessage`委托类型需要两个参数。为了将它们表示为 lambda 表达式，可以将`Main()`方法编写如下:

```
// Register with delegate as a lambda expression.
SimpleMath m = new SimpleMath();
m.SetMathHandler((msg, result) =>
  {Console.WriteLine("Message: {0}, Result: {1}", msg, result);});

// This will execute the lambda expression.
m.Add(10, 10);
Console.ReadLine();

```

这里，您利用了类型推断，因为为了简单起见，这两个参数没有被强类型化。但是，您可以调用`SetMathHandler()`，如下所示:

```
m.SetMathHandler((string msg, int result) =>
  {Console.WriteLine("Message: {0}, Result: {1}", msg, result);});

```

最后，如果使用 lambda 表达式与不带任何参数的委托进行交互，可以通过提供一对空括号作为参数来实现。因此，假设您已经定义了以下委托类型:

```
public delegate string VerySimpleDelegate();

```

您可以按如下方式处理调用的结果:

```
// Prints "Enjoy your string!" to the console.
VerySimpleDelegate d = new VerySimpleDelegate( () => {return "Enjoy your string!";} );
Console.WriteLine(d());

```

使用新的表达式语法，前一行可以写成这样:

```
VerySimpleDelegate d2 =
  new VerySimpleDelegate(() => "Enjoy your string!");

```

也可以简化为:

```
VerySimpleDelegate d3 = () => "Enjoy your string!";

```

### 在 Lambda 表达式中使用 static(新 9.0)

因为 lambda 表达式是委托的简写，所以可以理解 lambda 也支持`static`关键字(在 C# 9.0 中)和丢弃(在下一节讨论)。将以下内容添加到顶级语句中:

```
var outerVariable = 0;

Func<int, int, bool> DoWork = (x,y) =>
{
  outerVariable++;
  return true;
};
DoWork(3,4);
Console.WriteLine("Outer variable now = {0}", outerVariable);

```

执行此代码时，它会输出以下内容:

```
***** Fun with Lambdas *****

Outer variable now = 1

```

如果将 lambda 更新为 static，将会收到一个编译错误，因为表达式试图更新外部作用域中声明的变量。

```
var outerVariable = 0;

Func<int, int, bool> DoWork = static (x,y) =>
{
 //Compile error since it’s accessing an outer variable
  //outerVariable++;
  return true;
};

```

### 用 Lambda 表达式丢弃(新 9.0)

与委托(和 C# 9.0)一样，如果不需要输入变量，lambda 表达式的输入变量可以用丢弃来替换。与委托的情况相同。因为下划线(_)在以前版本的 C#中是合法的变量标识符，所以它们必须在 lambda 表达式中被丢弃两次或更多次。

```
var outerVariable = 0;

Func<int, int, bool> DoWork = (x,y) =>
{
  outerVariable++;
  return true;
};
DoWork(_,_);
Console.WriteLine("Outer variable now = {0}", outerVariable);

```

### 使用 lambda 表达式改进汽车事件示例

考虑到 lambda 表达式的全部原因是提供一种干净、简洁的方式来定义一个匿名方法(从而间接地简化委托的工作)，让我们改进本章前面创建的`CarEventArgs`项目。下面是该项目的`Program`类的简化版本，它利用 lambda 表达式语法(而不是原始委托)来挂钩从`Car`对象发送的每个事件:

```
using System;
using CarEventsWithLambdas;

Console.WriteLine("***** More Fun with Lambdas *****\n");

// Make a car as usual.
Car c1 = new Car("SlugBug", 100, 10);

// Hook into events with lambdas!
c1.AboutToBlow += (sender, e)
  => { Console.WriteLine(e.msg);};
c1.Exploded += (sender, e) => { Console.WriteLine(e.msg); };

// Speed up (this will generate the events).
Console.WriteLine("\n***** Speeding up *****");
for (int i = 0; i < 6; i++)
{
  c1.Accelerate(20);
}
Console.ReadLine();

```

### Lambdas 和 Expression-body 成员(更新 7.0)

既然您已经理解了 lambda 表达式及其工作原理，那么显而易见的是表达式体成员是如何工作的。正如第 4 章提到的，从 C# 6 开始，允许使用`=>`操作符来简化成员实现。具体来说，如果您有一个方法或属性(除了自定义运算符或转换例程之外；参见第 [11 章](11.html))在实现中只包含一行代码，您不需要通过花括号定义作用域。相反，您可以利用 lambda 运算符并编写一个表达式体成员。在 C# 7 中，你也可以对类构造器、终结器(在第 [9](09.html) 章中讨论)以及属性成员的`get`和`set`访问器使用这种语法。

但是，请注意，这种新的简化语法可以在任何地方使用，即使您的代码与委托或事件无关。因此，例如，如果您要构建一个简单的类来添加两个数字，您可以编写以下代码:

```
class SimpleMath
{
  public int Add(int x, int y)
  {
    return x + y;
  }

  public void PrintSum(int x, int y)
  {
    Console.WriteLine(x + y);
  }
}

```

或者，您现在可以编写如下代码:

```
class SimpleMath
{
  public int Add(int x, int y) =>  x + y;
  public void PrintSum(int x, int y) => Console.WriteLine(x + y);
}

```

理想情况下，在这一点上，您可以看到 lambda 表达式的整体作用，并理解它们如何提供一种“函数方式”来处理匿名方法和委托类型。尽管 lambda 运算符(`=>`)可能需要一点时间来适应，但请记住，lambda 表达式可以分解为以下简单的等式:

```
ArgumentsToProcess =>
{
  //StatementsToProcessThem
}

```

或者，如果使用`=>`操作符来实现单行类型成员，它将是这样的:

```
TypeMember => SingleCodeStatement

```

值得指出的是，LINQ 编程模型也大量使用 lambda 表达式来帮助简化您的编码工作。你将从第 13 章开始研究 LINQ。

## 摘要

在本章中，您研究了多个对象参与双向对话的几种方式。首先，您查看了 C# `delegate`关键字，该关键字用于间接构造从`System.MulticastDelegate`派生的类。如您所见，委托对象在被告知调用方法时会维护该方法。

然后研究了 C# `event`关键字，当它与委托类型结合使用时，可以简化将事件通知发送给等待调用方的过程。如生成的 CIL 所示。NET 事件模型映射到`System.Delegate` / `System.MulticastDelegate`类型的隐藏调用。在这种情况下，C# `event`关键字完全是可选的，因为它只是为您节省了一些键入时间。同样，您已经看到 C# 6.0 空条件操作符简化了您如何安全地向任何感兴趣的一方触发事件。

本章还探讨了 C#语言的一个特性，称为匿名方法。使用这种语法结构，您可以将代码语句块直接关联到给定的事件。正如您所看到的，匿名方法可以忽略事件发送的参数，并可以访问定义方法的“外部变量”。您还研究了使用*方法组转换*注册事件的简化方法。

最后，通过查看 C# *lambda 操作符*、`=>`来总结一下。如图所示，这种语法是创作匿名方法的一种很好的速记符号，其中可以将一堆参数传递给一组语句进行处理。中的任何方法。NET 核心平台可以用一个相关的 lambda 表达式来代替，这通常会大大简化你的代码库。