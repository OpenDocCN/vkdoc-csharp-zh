# 十五、多线程、并行和异步编程

没有人喜欢使用在执行过程中反应迟钝的应用。此外，没有人喜欢在一个应用中启动一个任务(可能是通过点击一个工具栏项启动的),这个任务会阻止程序的其他部分尽可能地响应。在发布之前。网(和。NET Core)，构建能够执行多项任务的应用通常需要编写使用 Windows 线程 API 的复杂 C++代码。谢天谢地。NET/。NET Core platform 为您提供了多种方法来构建软件，这些软件可以在独特的执行路径上执行复杂的操作，而棘手的问题却少得多。

本章首先定义了“多线程应用”的整体性质接下来，将向您介绍从开始提供的原始线程名称空间。NET 1.0，具体是`System.Threading`。在这里，你将考察众多类型(`Thread`、`ThreadStart`等)。)允许您显式地创建额外的执行线程并同步您的共享资源，这有助于确保多个线程能够以非易失的方式共享数据。

本章的其余部分将研究三种最新的技术。NET 核心开发人员可以使用来构建多线程软件，特别是任务并行库(TPL)、并行 LINQ (PLINQ)以及相对较新的(从 C# 6 开始)C#固有异步关键字(`async`和`await`)。正如您将看到的，这些特性可以极大地简化您构建响应性多线程软件应用的方式。

## 进程/AppDomain/上下文/线程关系

在第 [14](14.html) 章中，*线程*被定义为可执行应用中的执行路径。虽然很多人。NET 核心应用可以过着快乐而高效的单线程生活，程序集的主线程(当应用的入口点执行时由运行时产生)可以随时创建执行的辅助线程来执行额外的工作单元。通过创建额外的线程，您可以构建响应速度更快(但不一定在单核机器上执行得更快)的应用。

名称空间`System.Threading`是随。NET 1.0 并提供了一种构建多线程应用的方法。`Thread`类可能是核心类型，因为它代表一个给定的线程。如果您想以编程方式获取对当前执行给定成员的线程的引用，只需调用静态的`Thread.CurrentThread`属性，如下所示:

```cs
static void ExtractExecutingThread()
{
  // Get the thread currently
  // executing this method.
  Thread currThread = Thread.CurrentThread;
}

```

回想一下。NET 核心，只有一个 AppDomain。即使不能创建额外的 AppDomain，一个应用的 AppDomain 在任何给定时间都可以有许多线程在其中执行。要获取对托管应用的 AppDomain 的引用，请调用静态的`Thread.GetDomain()`方法，如下所示:

```cs
static void ExtractAppDomainHostingThread()
{
  // Obtain the AppDomain hosting the current thread.
  AppDomain ad = Thread.GetDomain();
}

```

单个线程也可以在任何给定的时间被移动到一个执行上下文中，并且可以在。NET 核心运行时。当您想要获得一个线程正在其中执行的当前执行上下文时，使用静态的`Thread.CurrentThread.ExecutionContext`属性，如下所示:

```cs
static void ExtractCurrentThreadExecutionContext()
{
  // Obtain the execution context under which the
  // current thread is operating.
  ExecutionContext ctx =
    Thread.CurrentThread.ExecutionContext;
}

```

再说一遍。NET Core Runtime 监督将线程移入(和移出)执行上下文。作为一名. NET 核心开发人员，您通常可以幸福地保持不知道给定线程的结束位置。然而，您应该知道获得底层原语的各种方法。

### 并发的问题

多线程编程的众多“乐趣”(也就是痛苦的方面)之一是，您几乎无法控制底层操作系统或运行时如何使用它的线程。例如，如果您创建了一个新的执行线程的代码块，您不能保证该线程立即执行。相反，这些代码只指示操作系统/运行时尽快执行线程(通常是在线程调度程序开始执行时)。

此外，鉴于线程可以根据运行时的需要在应用和上下文边界之间移动，您必须注意应用的哪些方面是*线程易变的*(例如，受多线程访问的影响)，哪些操作是*原子的*(线程易变的操作是危险的！).

为了说明这个问题，假设一个线程正在调用一个特定对象的方法。现在假设线程调度器指示该线程暂停其活动，以允许另一个线程访问同一对象的同一方法。

如果原始线程没有完成其操作，则第二个传入线程可能正在查看处于部分修改状态的对象。在这一点上，第二个线程基本上是在读取假数据，这肯定会让位于极其奇怪(并且难以发现)的错误，这些错误甚至更难复制和调试。

另一方面，原子操作在多线程环境中总是安全的。可悲的是，在美国几乎没有什么行动。NET 核心基本类库，保证是原子的。甚至给成员变量赋值的行为也不是原子的！除非。NET 核心文档明确指出操作是原子性的，您必须假设它是线程易变的，并采取预防措施。

### 线程同步的作用

在这一点上，应该清楚多线程程序本身是非常不稳定的，因为许多线程可以同时(或多或少)在共享资源上操作。为了保护应用的资源免受可能的损坏。NET 核心开发人员必须使用任意数量的线程原语(比如锁、监视器和`[Synchronization]`属性或语言关键字支持)来控制执行线程之间的访问。

虽然。NET Core 平台并不能使构建健壮的多线程应用的困难完全消失，这个过程已经大大简化了。使用在`System.Threading`名称空间、任务并行库以及 C# `async`和`await`语言关键字中定义的类型，您可以以最少的麻烦和麻烦处理多线程。

在深入到`System.Threading`名称空间、TPL、C# `async`和`await`关键字之前，您将首先检查。NET 核心委托类型可用于以异步方式调用方法。虽然可以肯定的是。NET 4.6 新的 C# `async`和`await`关键字为异步委托提供了一个更简单的替代方法，知道如何使用这种方法与代码交互仍然很重要(相信我，生产中有大量代码使用异步委托)。

## 系统。线程命名空间

在下面。NET 和。NET 核心平台中，`System.Threading`命名空间提供了支持直接构建多线程应用的类型。除了提供允许您与. NET 核心运行时线程交互的类型之外，此命名空间还定义了允许访问。NET Core 运行时维护的线程池，一个简单的(非基于 GUI 的)`Timer`类，以及许多用于提供对共享资源的同步访问的类型。表 [15-1](#Tab1) 列出了这个名称空间的一些重要成员。(请务必查阅。NET Core SDK 文档以获得完整的详细信息。)

表 15-1。

系统的核心类型。线程命名空间

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

类型

 | 

生命的意义

 |
| --- | --- |
| `Interlocked` | 这种类型为由多个线程共享的变量提供原子操作。 |
| `Monitor` | 这种类型使用锁和等待/信号来提供线程对象的同步。C# `lock`关键字使用了一个`Monitor`对象。 |
| `Mutex` | 这个同步原语可用于应用域边界之间的同步。 |
| `ParameterizedThreadStart` | 此委托允许线程调用接受任意数量参数的方法。 |
| `Semaphore` | 这种类型允许您限制可以并发访问资源的线程数量。 |
| `Thread` | 此类型表示在中执行的线程。NET 核心运行时。使用这种类型，您可以在原始 AppDomain 中生成额外的线程。 |
| `ThreadPool` | 此类型允许您与。NET 核心运行时——给定进程中维护的线程池。 |
| `ThreadPriority` | 该枚举表示线程的优先级(`Highest`、`Normal`等)。). |
| `ThreadStart` | 此委托用于指定给定线程要调用的方法。与`ParameterizedThreadStart`委托不同，`ThreadStart`的目标必须总是有相同的原型。 |
| `ThreadState` | 该枚举指定了线程可能采用的有效状态(`Running`、`Aborted`等)。). |
| `Timer` | 这种类型提供了一种以指定间隔执行方法的机制。 |
| `TimerCallback` | 该委托类型与`Timer`类型一起使用。 |

## 系统。线程.线程类

在`System.Threading`名称空间的所有类型中，最原始的是`Thread`。此类表示 AppDomain 中给定执行路径周围的面向对象包装。此类型还定义了几个方法(静态和实例级)，允许您在当前 AppDomain 中创建新线程，以及挂起、停止和销毁线程。考虑表 [15-2](#Tab2) 中的关键静态成员列表。

表 15-2。

线程类型的关键静态成员

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

静态构件

 | 

生命的意义

 |
| --- | --- |
| `ExecutionContext` | 此只读属性返回与执行的逻辑线程相关的信息，包括安全性、调用、同步、本地化和事务上下文。 |
| `CurrentThread` | 此只读属性返回对当前运行线程的引用。 |
| `Sleep()` | 此方法将当前线程挂起一段指定的时间。 |

`Thread`类还支持几个实例级成员，其中一些如表 [15-3](#Tab3) 所示。

表 15-3。

选择线程类型的实例级成员

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

实例级成员

 | 

生命的意义

 |
| --- | --- |
| `IsAlive` | 返回一个 Boolean 值，指示该线程是否已启动(尚未终止或中止)。 |
| `IsBackground` | 获取或设置一个值，该值指示此线程是否为“后台线程”(稍后将提供更多详细信息)。 |
| `Name` | 允许您建立线程的友好文本名称。 |
| `Priority` | 获取或设置线程的优先级，可以从`ThreadPriority`枚举中为其赋值。 |
| `ThreadState` | 获取该线程的状态，可以从`ThreadState`枚举中为其赋值。 |
| `Abort()` | 指示。NET Core 运行时尽快终止线程。 |
| `Interrupt()` | 从合适的等待周期中断(例如唤醒)当前线程。 |
| `Join()` | 阻塞调用线程，直到指定的线程(调用`Join()`的线程)退出。 |
| `Resume()` | 恢复先前挂起的线程。 |
| `Start()` | 指示。NET 核心运行时尽快执行线程。 |
| `Suspend()` | 挂起线程。如果线程已经被挂起，调用`Suspend()`没有任何效果。 |

Note

中止或挂起一个活动线程通常被认为是一个坏主意。当您这样做时，线程在受到干扰或终止时有可能会“泄漏”其工作负载(尽管可能性很小)。

### 获取当前执行线程的统计信息

回想一下，可执行程序集的入口点(即顶级语句或`Main()`方法)运行在执行的主线程上。为了说明`Thread`类型的基本用法，假设您有一个名为 ThreadStats 的新控制台应用项目。如您所知，静态的`Thread.CurrentThread`属性检索一个代表当前执行线程的`Thread`对象。一旦获得了当前线程，就可以打印出各种统计数据，如下所示:

```cs
// Be sure to import the System.Threading namespace.
using System;
using System.Threading;
Console.WriteLine("***** Primary Thread stats *****\n");

// Obtain and name the current thread.
Thread primaryThread = Thread.CurrentThread;
primaryThread.Name = "ThePrimaryThread";

// Print out some stats about this thread.
Console.WriteLine("ID of current thread: {0}",
  primaryThread.ManagedThreadId);
Console.WriteLine("Thread Name: {0}",
  primaryThread.Name);
Console.WriteLine("Has thread started?: {0}",
  primaryThread.IsAlive);
Console.WriteLine("Priority Level: {0}",
  primaryThread.Priority);
Console.WriteLine("Thread State: {0}",
  primaryThread.ThreadState);
Console.ReadLine();

```

以下是当前输出:

```cs
***** Primary Thread stats *****
ID of current thread: 1
Thread Name: ThePrimaryThread
Has thread started?: True
Priority Level: Normal
Thread State: Running

```

### 名称属性

注意，`Thread`类支持一个名为`Name`的属性。如果不设置这个值，`Name`将返回一个空的`string`。然而，一旦你给一个给定的`Thread`对象分配了一个友好的字符串名字，你就可以大大简化你的调试工作。如果您使用的是 Visual Studio，则可以在调试会话期间访问“线程”窗口(在程序运行时选择“调试➤ Windows ➤线程”)。从图 [15-1](#Fig1) 可以看出，可以快速识别出想要诊断的线程。

![img/340876_10_En_15_Chapter/340876_10_En_15_Fig1_HTML.jpg](img/340876_10_En_15_Chapter/340876_10_En_15_Fig1_HTML.jpg)

图 15-1。

使用 Visual Studio 调试线程

### 优先属性

接下来，请注意，`Thread`类型定义了一个名为`Priority`的属性。默认情况下，所有线程的优先级都是`Normal`。然而，你可以在线程生命周期的任何时候使用`Priority`属性和相关的`System.Threading.ThreadPriority`枚举来改变它，就像这样:

```cs
public enum ThreadPriority
{
  Lowest,
  BelowNormal,
  Normal, // Default value.
  AboveNormal,
  Highest
}

```

如果你要给一个线程的优先级指定一个不同于默认值(`ThreadPriority.Normal`)的值，要知道你不能直接控制线程调度器何时在线程间切换。线程的优先级为。NET 核心运行时关于线程活动的重要性。因此，具有值`ThreadPriority.Highest`的线程不一定保证被给予最高优先级。

同样，如果线程调度器全神贯注于给定的任务(例如，同步对象、切换线程或移动线程)，则优先级很可能会相应地改变。然而，所有的事情都是平等的。NET Core Runtime 将读取这些值，并指示线程调度程序如何最好地分配时间片。具有相同线程优先级的每个线程应该获得相同的时间来执行它们的工作。

在大多数情况下，您很少(如果有的话)需要直接改变线程的优先级。理论上，可以提高一组线程的优先级，从而阻止优先级较低的线程在它们需要的级别上执行(所以要小心)。

## 手动创建辅助线程

当您想要以编程方式创建额外的线程来执行某个工作单元时，请在使用`System.Threading`名称空间的类型时遵循这个可预测的过程:

1.  创建一个方法作为新线程的入口点。

2.  创建一个新的`ParameterizedThreadStart`(或`ThreadStart`)委托，将步骤 1 中定义的方法的地址传递给构造函数。

3.  创建一个`Thread`对象，将`ParameterizedThreadStart/ThreadStart`委托作为构造函数参数传递。

4.  建立任何初始线程特征(名称、优先级等。).

5.  调用`Thread.Start()`方法。这将尽快在步骤 2 中创建的委托所引用的方法处启动线程。

如步骤 2 所述，您可以使用两种不同的委托类型来“指向”辅助线程将执行的方法。委托可以指向任何不带参数且不返回任何内容的方法。当方法被设计为只在后台运行而不需要进一步交互时，此委托会很有帮助。

`ThreadStart`的限制是不能传入参数进行处理。然而，`ParameterizedThreadStart`委托类型允许类型为`System.Object`的单个参数。鉴于任何东西都可以表示为一个`System.Object`，您可以通过一个定制的类或结构传入任意数量的参数。但是，请注意，`ThreadStart`和`ParameterizedThreadStart`委托只能指向返回`void`的方法。

### 使用 ThreadStart 委托

为了说明构建多线程应用的过程(以及演示这样做的有用性)，假设您有一个名为 SimpleMultiThreadApp 的控制台应用项目，该项目允许最终用户选择应用是使用单个主线程来执行其任务，还是使用两个单独的执行线程来分担其工作负载。

假设您已经导入了`System.Threading`名称空间，您的第一步是定义一个方法来执行(可能的)辅助线程的工作。为了将重点放在构建多线程程序的机制上，该方法将简单地在控制台窗口中打印出一系列数字，每次大约暂停两秒钟。下面是`Printer`类的完整定义:

```cs
using System;
using System.Threading;

namespace SimpleMultiThreadApp
{
  public class Printer
  {
    public void PrintNumbers()
    {
      // Display Thread info.
      Console.WriteLine("-> {0} is executing PrintNumbers()",
        Thread.CurrentThread.Name);

      // Print out numbers.
      Console.Write("Your numbers: ");
      for(int i = 0; i < 10; i++)
      {
        Console.Write("{0}, ", i);
        Thread.Sleep(2000);
      }
      Console.WriteLine();
    }
  }
}

```

现在，在`Program.cs`中，您将添加顶级语句，首先提示用户确定是使用一个还是两个线程来执行应用的工作。如果用户请求单个线程，您只需在主线程中调用`PrintNumbers()`方法。但是，如果用户指定了两个线程，您将创建一个指向`PrintNumbers()`的`ThreadStart`委托，将这个委托对象传递给一个新的`Thread`对象的构造函数，并调用`Start()`来通知。此线程已准备好进行处理。下面是完整的实现:

```cs
using System;
using System.Threading;
using SimpleMultiThreadApp;

Console.WriteLine("***** The Amazing Thread App *****\n");
Console.Write("Do you want [1] or [2] threads? ");
string threadCount = Console.ReadLine();

// Name the current thread.
Thread primaryThread = Thread.CurrentThread;
primaryThread.Name = "Primary";

// Display Thread info.
Console.WriteLine("-> {0} is executing Main()",
Thread.CurrentThread.Name);

// Make worker class.
Printer p = new Printer();

switch(threadCount)
{
  case "2":
    // Now make the thread.
    Thread backgroundThread =
      new Thread(new ThreadStart(p.PrintNumbers));
    backgroundThread.Name = "Secondary";
    backgroundThread.Start();
    break;
  case "1":
    p.PrintNumbers();
    break;
  default:
    Console.WriteLine("I don't know what you want...you get 1 thread.");
    goto case "1";
}
// Do some additional work.
Console.WriteLine("This is on the main thread, and we are finished.");
Console.ReadLine();

```

现在，如果您用单线程运行这个程序，您会发现最终的消息框不会显示消息，直到整个数字序列打印到控制台。由于在打印每个数字后，您会明显地暂停大约两秒钟，这将导致不太好的最终用户体验。但是，如果您选择两个线程，消息框会立即显示，因为有一个唯一的`Thread`对象负责将数字打印到控制台。

### 使用 ParameterizedThreadStart 委托

回想一下，`ThreadStart`委托只能指向返回`void`且不带参数的方法。虽然在某些情况下这可能符合要求，但是如果您想将数据传递给在辅助线程上执行的方法，您将需要使用`ParameterizedThreadStart`委托类型。举例来说，创建一个名为 AddWithThreads 的新控制台应用项目，并导入`System.Threading`名称空间。现在，假设`ParameterizedThreadStart`可以指向任何带`System.Object`参数的方法，您将创建一个包含要添加的数字的自定义类型，如下所示:

```cs
namespace AddWithThreads
{
  class AddParams
  {
    public int a, b;

    public AddParams(int numb1, int numb2)
    {
      a = numb1;
      b = numb2;
    }
  }
}

```

接下来，在`Program`类中创建一个方法，该方法将接受一个`AddParams`参数并打印所涉及的两个数字的和，如下所示:

```cs
void Add(object data)
{
  if (data is AddParams ap)
  {
    Console.WriteLine("ID of thread in Add(): {0}",
      Thread.CurrentThread.ManagedThreadId);

    Console.WriteLine("{0} + {1} is {2}",
      ap.a, ap.b, ap.a + ap.b);
  }
}

```

`Program.cs`中的代码很简单。简单地使用`ParameterizedThreadStart`而不是`ThreadStart`，就像这样:

```cs
using System;
using System.Threading;
using AddWithThreads;

Console.WriteLine("***** Adding with Thread objects *****");
Console.WriteLine("ID of thread in Main(): {0}",
  Thread.CurrentThread.ManagedThreadId);

// Make an AddParams object to pass to the secondary thread.
AddParams ap = new AddParams(10, 10);
Thread t = new Thread(new ParameterizedThreadStart(Add));
t.Start(ap);

// Force a wait to let other thread finish.
Thread.Sleep(5);
Console.ReadLine();

```

### AutoResetEvent 类

在前面的几个例子中，没有一种明确的方法来知道辅助线程何时完成了它的工作。在最后一个例子中，`Sleep`在任意时间被调用，以让另一个线程完成。一种简单且线程安全的强制线程等待另一个线程完成的方法是使用`AutoResetEvent`类。在需要等待的线程中，创建这个类的一个实例，并将`false`传递给构造函数，以表示您还没有得到通知。然后，在你愿意等待的点上，调用`WaitOne()`方法。下面是对`Program.cs`类的更新，它将使用静态级别的`AutoResetEvent`成员变量来做这件事:

```cs
AutoResetEvent _waitHandle = new AutoResetEvent(false);

Console.WriteLine("***** Adding with Thread objects *****");
Console.WriteLine("ID of thread in Main(): {0}",
  Thread.CurrentThread.ManagedThreadId);
AddParams ap = new AddParams(10, 10);
Thread t = new Thread(new ParameterizedThreadStart(Add));
t.Start(ap);

// Wait here until you are notified!
_waitHandle.WaitOne();
Console.WriteLine("Other thread is done!");

Console.ReadLine();
...

```

当另一个线程完成其工作负载时，它将在同一个`AutoResetEvent`类型的实例上调用`Set()`方法。

```cs
void Add(object data)
{
  if (data is AddParams ap)
  {
    Console.WriteLine("ID of thread in Add(): {0}",
      Thread.CurrentThread.ManagedThreadId);

    Console.WriteLine("{0} + {1} is {2}",
      ap.a, ap.b, ap.a + ap.b);

    // Tell other thread we are done.
    _waitHandle.Set();
  }
}

```

### 前台线程和后台线程

既然您已经看到了如何使用`System.Threading`名称空间以编程方式创建新的执行线程，那么让我们来正式区分前台线程和后台线程:

*   *前台线程*可以阻止当前应用终止。那个。在所有前台线程结束之前，NET Core Runtime 不会关闭应用(也就是说，卸载宿主 AppDomain)。

*   后台线程(有时称为*后台线程*)被。NET 核心运行时作为可消耗的执行路径，可以在任何时间点被忽略(即使它们当前正在某个工作单元上工作)。因此，如果所有前台线程都已终止，当应用域卸载时，所有后台线程都会自动终止。

值得注意的是，前台和后台线程与主线程和工作线程是不同的。默认情况下，通过`Thread.Start()`方法创建的每个线程都自动成为前台线程。同样，这意味着 AppDomain 不会卸载，直到所有执行线程都完成了它们的工作单元。在大多数情况下，这正是您需要的行为。

然而，为了便于讨论，假设您想要在一个应该作为后台线程的辅助线程上调用`Printer.PrintNumbers()`。同样，这意味着由`Thread`类型(通过`ThreadStart`或`ParameterizedThreadStart`委托)指向的方法应该能够在所有前台线程完成它们的工作后安全地暂停。配置这样一个线程就像将`IsBackground`属性设置为`true`一样简单，就像这样:

```cs
Console.WriteLine("***** Background Threads *****\n");
Printer p = new Printer();
Thread bgroundThread =
  new Thread(new ThreadStart(p.PrintNumbers));

// This is now a background thread.
bgroundThread.IsBackground = true;
bgroundThread.Start();

```

注意这个`code`是*而不是*调用`Console.ReadLine()`来强制控制台保持可见直到你按下回车键。因此，当您运行应用时，它会立即关闭，因为`Thread`对象已经被配置为后台线程。假设进入应用的入口点(这里显示的顶级语句或`Main()`方法)触发主*前台*线程的创建，一旦入口点中的逻辑完成，AppDomain 就会在辅助线程完成其工作之前卸载。

但是，如果您注释掉设置`IsBackground`属性的行，您会发现每个数字都会打印到控制台，因为所有前台线程都必须在 AppDomain 从宿主进程中卸载之前完成它们的工作。

在很大程度上，当相关的工作线程正在执行程序的主任务完成后不再需要的非关键任务时，配置线程作为后台类型运行会很有帮助。例如，您可以构建一个应用，每隔几分钟就向电子邮件服务器发送一次新邮件，更新当前天气状况，或者执行一些其他非关键任务。

## 并发性的问题

当您构建多线程应用时，您的程序需要确保任何共享数据都受到保护，以防大量线程更改其值。假设 AppDomain 中的所有线程都可以并发访问应用的共享数据，想象一下如果多个线程访问同一点数据会发生什么。由于线程调度器会强制线程随机暂停它们的工作，如果线程 A 在完全完成工作之前就被踢出去了呢？线程 B 现在正在读取不稳定的数据。

为了说明并发性问题，让我们构建另一个名为 MultiThreadedPrinting 的控制台应用项目。这个应用将再次使用之前创建的`Printer`类，但是这次`PrintNumbers()`方法将强制当前线程暂停一段随机生成的时间。

```cs
using System;
using System.Threading;

namespace MultiThreadedPrinting
{
  public class Printer
  {
    public void PrintNumbers()
    {
      // Display Thread info.
      Console.WriteLine("-> {0} is executing PrintNumbers()",
        Thread.CurrentThread.Name);

      // Print out numbers.
      for (int i = 0; i < 10; i++)
      {
        // Put thread to sleep for a random amount of time.
        Random r = new Random();
        Thread.Sleep(1000 * r.Next(5));
        Console.Write("{0}, ", i);
      }
      Console.WriteLine();
    }
  }
}

```

调用代码负责创建一个由十个(唯一命名的)`Thread`对象组成的数组，每个对象调用`Printer`对象的*同一个实例*，如下所示:

```cs
using System;
using System.Threading;
using MultiThreadedPrinting;

Console.WriteLine("*****Synchronizing Threads *****\n");

Printer p = new Printer();

// Make 10 threads that are all pointing to the same
// method on the same object.
Thread[] threads = new Thread[10];
for (int i = 0; i < 10; i++)
{
  threads[i] = new Thread(new ThreadStart(p.PrintNumbers))
  {
    Name = $"Worker thread #{i}"
  };
}
// Now start each one.
foreach (Thread t in threads)
{
  t.Start();
}
Console.ReadLine();

```

在查看一些测试运行之前，让我们回顾一下这个问题。这个 AppDomain 中的主线程通过产生十个辅助工作线程而开始存在。每个工作线程被告知在*同一个* `Printer`实例上调用`PrintNumbers()`方法。假设您没有采取任何预防措施来锁定该对象的共享资源(控制台)，那么在`PrintNumbers()`方法能够打印完整的结果之前，当前线程很有可能会被踢出去。因为您不知道这种情况何时(或是否)会发生，所以您肯定会得到不可预测的结果。例如，您可能会发现如下所示的输出:

```cs
*****Synchronizing Threads *****
-> Worker thread #3 is executing PrintNumbers()
-> Worker thread #0 is executing PrintNumbers()
-> Worker thread #1 is executing PrintNumbers()
-> Worker thread #2 is executing PrintNumbers()
-> Worker thread #4 is executing PrintNumbers()
-> Worker thread #5 is executing PrintNumbers()
-> Worker thread #6 is executing PrintNumbers()
-> Worker thread #7 is executing PrintNumbers()
-> Worker thread #8 is executing PrintNumbers()
-> Worker thread #9 is executing PrintNumbers()
0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 2, 3, 1, 2, 2, 2, 1, 2, 1, 1, 2, 2, 3, 3, 4, 3, 3, 2, 2, 3, 4, 3, 4, 5, 4, 5, 4, 4, 3, 6, 7, 2, 3, 4, 4, 4, 5, 6, 5, 3, 5, 8, 9,
6, 7, 4, 5, 6, 6, 5, 5, 5, 8, 5, 6, 7, 8, 7, 7, 6, 6, 6, 8, 9,
8, 7, 7, 7, 7, 9,
6, 8, 9,
8, 9,
9, 9,

8, 8, 7, 8, 9,
9,
9,

```

现在再运行几次应用并检查输出。很可能每次都不一样。

Note

如果您无法生成不可预测的输出，那么将线程数量从 10 增加到 100(例如),或者在您的程序中引入另一个对`Thread.Sleep()`的调用。最终，您会遇到并发问题。

这里显然存在一些问题。当每个线程告诉`Printer`打印数字数据时，线程调度器很高兴地在后台交换线程。结果是输出不一致。您需要的是一种以编程方式强制同步访问共享资源的方法。正如您所猜测的，`System.Threading`名称空间提供了几种以同步为中心的类型。C#编程语言还为多线程应用中同步共享数据的任务提供了一个关键字。

### 使用 C# lock 关键字进行同步

第一个可以用来同步访问共享资源的技术是 C# `lock`关键字。该关键字允许您定义必须在线程间同步的语句范围。通过这样做，传入线程不能中断当前线程，从而阻止它完成工作。`lock`关键字要求您指定一个*令牌*(一个对象引用)，线程必须获得这个令牌才能进入锁范围。当您试图锁定一个*私有*实例级方法时，您可以简单地传入一个对当前类型的引用，如下所示:

```cs
private void SomePrivateMethod()
{
  // Use the current object as the thread token.
  lock(this)
  {
    // All code within this scope is thread safe.
  }
}

```

然而，如果您要锁定一个*公共*成员中的一段代码，那么声明一个私有`object`成员变量作为锁标记会更安全(也是最佳实践),如下所示:

```cs
public class Printer
{
  // Lock token.
  private object threadLock = new object();

  public void PrintNumbers()
  {
    // Use the lock token.
    lock (threadLock)
    {
      ...
    }
  }
}

```

在任何情况下，如果您检查`PrintNumbers()`方法，您可以看到线程竞争访问的共享资源是控制台窗口。在锁定范围内确定所有与`Console`类型的交互的范围，如下所示:

```cs
public void PrintNumbers()
{
  // Use the private object lock token.
  lock (threadLock)
  {
    // Display Thread info.
    Console.WriteLine("-> {0} is executing PrintNumbers()",
      Thread.CurrentThread.Name);
    // Print out numbers.
    Console.Write("Your numbers: ");
    for (int i = 0; i < 10; i++)
    {
      Random r = new Random();
      Thread.Sleep(1000 * r.Next(5));
      Console.Write("{0}, ", i);
    }
    Console.WriteLine();
  }
}

```

当这样做时，您已经有效地设计了一个方法，该方法将允许当前线程完成其任务。一旦线程进入锁范围，其他线程就无法访问锁令牌(在这种情况下，是对当前对象的引用)，直到在锁范围退出后释放锁。因此，如果线程 A 已经获得锁令牌，其他线程就不能进入*任何使用相同锁令牌的范围*，直到线程 A 放弃锁令牌。

Note

如果您试图锁定静态方法中的代码，只需声明一个私有静态对象成员变量作为锁标记。

如果您现在运行应用，您可以看到每个线程都有足够的机会来完成它的任务。

```cs
*****Synchronizing Threads *****
-> Worker thread #0 is executing PrintNumbers()
Your numbers: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
-> Worker thread #1 is executing PrintNumbers()
Your numbers: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
-> Worker thread #3 is executing PrintNumbers()
Your numbers: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
-> Worker thread #2 is executing PrintNumbers()
Your numbers: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
-> Worker thread #4 is executing PrintNumbers()
Your numbers: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
-> Worker thread #5 is executing PrintNumbers()
Your numbers: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
-> Worker thread #7 is executing PrintNumbers()
Your numbers: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
-> Worker thread #6 is executing PrintNumbers()
Your numbers: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
-> Worker thread #8 is executing PrintNumbers()
Your numbers: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
-> Worker thread #9 is executing PrintNumbers()
Your numbers: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,

```

### 使用系统进行同步。线程。监视器类型

C# `lock`语句是使用`System.Threading.Monitor`类的简写符号。一旦被 C#编译器处理，锁的作用域就解析为如下内容(可以使用`ildasm.exe`来验证):

```cs
public void PrintNumbers()
{
  Monitor.Enter(threadLock);
  try
  {
    // Display Thread info.
    Console.WriteLine("-> {0} is executing PrintNumbers()",
      Thread.CurrentThread.Name);

    // Print out numbers.
    Console.Write("Your numbers: ");
    for (int i = 0; i < 10; i++)
    {
      Random r = new Random();
      Thread.Sleep(1000 * r.Next(5));
      Console.Write("{0}, ", i);
    }
    Console.WriteLine();
  }
  finally
  {
    Monitor.Exit(threadLock);
  }
}

```

首先，请注意，`Monitor.Enter()`方法是您指定为`lock`关键字参数的线程令牌的最终接收者。接下来，锁范围内的所有代码都被包装在一个`try`块中。相应的`finally`块确保线程令牌被释放(通过`Monitor.Exit()`方法)，不管任何可能的运行时异常。如果您要修改多线程打印程序以直接使用`Monitor`类型(如上所示)，您会发现输出是相同的。

现在，鉴于`lock`关键字似乎比显式使用`System.Threading.Monitor`类型需要更少的代码，您可能想知道直接使用`Monitor`类型的好处。简单的答案是控制。如果使用`Monitor`类型，可以指示活动线程等待一段时间(通过静态`Monitor.Wait()`方法)，在当前线程完成时通知等待线程(通过静态`Monitor.Pulse()`和`Monitor.PulseAll()`方法)，等等。

如您所料，在大多数情况下，C# `lock`关键字将符合要求。但是，如果您对检查`Monitor`类的其他成员感兴趣，请参考。NET 核心文档。

### 使用系统进行同步。螺纹.互锁型

尽管这总是令人难以置信，但直到你看到底层的 CIL 代码，赋值和简单的算术运算才是原子的 T4。出于这个原因，`System.Threading`名称空间提供了一种类型，允许您以比`Monitor`类型更少的开销原子地操作单点数据。`Interlocked`类定义了表 [15-4](#Tab4) 中所示的关键静态成员。

表 15-4。

选择*系统的静态成员。穿线.互锁*型

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

成员

 | 

生命的意义

 |
| --- | --- |
| `CompareExchange()` | 安全地测试两个值是否相等，如果相等，将其中一个值与第三个值交换 |
| `Decrement()` | 安全地将值递减 1 |
| `Exchange()` | 安全地交换两个值 |
| `Increment()` | 安全地将值递增 1 |

虽然从一开始看起来不像，但是在多线程环境中原子地改变单个值的过程是很常见的。假设您有代码来增加一个名为`intVal`的整数成员变量。而不是编写如下的同步代码:

```cs
int intVal = 5;
object myLockToken = new();
lock(myLockToken)
{
  intVal++;
}

```

你可以通过静态的`Interlocked.Increment()`方法来简化你的代码。只需通过引用传递要递增的变量。请注意，`Increment()`方法不仅调整传入参数的值，还返回新值。

```cs
intVal = Interlocked.Increment(ref intVal);

```

除了`Increment()`和`Decrement()`之外，`Interlocked`类型允许你原子地分配数字和对象数据。例如，如果您想将成员变量的值赋给值`83`，您可以避免使用显式的`lock`语句(或显式的`Monitor`逻辑),而使用`Interlocked.Exchange()`方法，如下所示:

```cs
Interlocked.Exchange(ref myInt, 83);

```

最后，如果您想测试两个值是否相等，并以线程安全的方式改变比较点，您可以如下利用`Interlocked.CompareExchange()`方法:

```cs
public void CompareAndExchange()
{
  // If the value of i is currently 83, change i to 99.
  Interlocked.CompareExchange(ref i, 99, 83);
}

```

## 用定时器回调编程

许多应用需要在固定的时间间隔内调用特定的方法。例如，您可能有一个应用需要通过给定的助手函数在状态栏上显示当前时间。作为另一个例子，您可能希望让您的应用偶尔调用一个 helper 函数来执行非关键的后台任务，比如检查新的电子邮件。对于这样的情况，您可以将`System.Threading.Timer`类型与名为`TimerCallback`的相关委托结合使用。

举例来说，假设您有一个控制台应用项目(TimerApp ),它将每秒打印一次当前时间，直到用户按下一个键来终止应用。第一个明显的步骤是编写将由`Timer`类型调用的方法(确保将`System.Threading`导入到您的代码文件中)。

```cs
using System;
using System.Threading;

Console.WriteLine("***** Working with Timer type *****\n");
Console.ReadLine();

static void PrintTime(object state)
{
  Console.WriteLine("Time is: {0}",
    DateTime.Now.ToLongTimeString());
}

```

注意，`PrintTime()`方法有一个类型为`System.Object`的单一参数，并返回`void`。这不是可选的，因为`TimerCallback`委托只能调用匹配这个签名的方法。传递到您的`TimerCallback`委托的目标中的值可以是任何类型的对象(在电子邮件示例中，该参数可能表示在该过程中要与之交互的 Microsoft Exchange 服务器的名称)。还要注意，假设这个参数确实是一个`System.Object`，那么您可以使用一个`System.Array`或者定制的类/结构来传递多个参数。

下一步是配置一个`TimerCallback`委托的实例，并将其传递给`Timer`对象。除了配置一个`TimerCallback`委托之外，`Timer`构造函数还允许您指定传递给委托目标的可选参数信息(定义为一个`System.Object`)、轮询方法的时间间隔以及在进行第一次调用之前等待的时间(以毫秒为单位)。这里有一个例子:

```cs
Console.WriteLine("***** Working with Timer type *****\n");

// Create the delegate for the Timer type.
TimerCallback timeCB = new TimerCallback(PrintTime);

// Establish timer settings.
Timer t = new Timer(
  timeCB,     // The TimerCallback delegate object.
  null,       // Any info to pass into the called method (null for no info).
  0,          // Amount of time to wait before starting (in milliseconds).
  1000);      // Interval of time between calls (in milliseconds).

Console.WriteLine("Hit Enter key to terminate...");
Console.ReadLine();

```

在这种情况下，`PrintTime()`方法将大约每秒被调用一次，并且不会向该方法传递任何附加信息。以下是输出:

```cs
***** Working with Timer type *****
Hit key to terminate...
Time is: 6:51:48 PM
Time is: 6:51:49 PM
Time is: 6:51:50 PM
Time is: 6:51:51 PM
Time is: 6:51:52 PM
Press any key to continue . . .

```

如果您确实想发送一些信息供委托目标使用，只需用适当的信息替换第二个构造函数参数的`null`值，如下所示:

```cs
// Establish timer settings.
Timer t = new Timer(timeCB, "Hello From C# 9.0", 0, 1000);

```

然后，您可以按如下方式获取传入数据:

```cs
static void PrintTime(object state)
{
  Console.WriteLine("Time is: {0}, Param is: {1}",
    DateTime.Now.ToLongTimeString(), state.ToString());
}

```

### 使用独立丢弃(新 7.0)

在前面的示例中，`Timer`变量没有在任何执行路径中使用，因此可以用 discard 替换它，如下所示:

```cs
  var _ = new Timer(
    timeCB,  // The TimerCallback delegate object.
    null,    // Any info to pass into the called method
             // (null for no info).
    0,       // Amount of time to wait before starting
             //(in milliseconds).
    1000);   // Interval of time between calls
             //(in milliseconds).

```

## 了解线程池

你将在本章研究的下一个以线程为中心的主题是运行时线程池的角色。启动一个新线程是有成本的，所以为了提高效率，线程池会保留已创建的(但不活动的)线程，直到需要为止。为了允许您与这个等待线程池进行交互，`System.Threading`名称空间提供了`ThreadPool`类类型。

如果您想让一个方法调用在池中排队由一个工作线程处理，您可以使用`ThreadPool.QueueUserWorkItem()`方法。这个方法已经被重载，允许你为自定义状态数据指定一个可选的`System.Object`以及一个`WaitCallback`委托的实例。

```cs
public static class ThreadPool
{
  ...
  public static bool QueueUserWorkItem(WaitCallback callBack);
  public static bool QueueUserWorkItem(WaitCallback callBack,
                                      object state);
}

```

`WaitCallback`委托可以指向任何将`System.Object`作为其唯一参数(代表可选的状态数据)并且不返回任何内容的方法。请注意，如果在调用`QueueUserWorkItem()`时没有提供`System.Object`。NET Core 运行时自动传递空值。来说明供。NET 核心运行时线程池，思考下面的程序(在一个名为 ThreadPoolApp 的控制台应用中)，它再次使用了`Printer`类型。然而，在这种情况下，您不是手动创建一个`Thread`对象的数组；相反，您是在将池中的成员分配给`PrintNumbers()`方法。

```cs
using System;
using System.Threading;
using ThreadPoolApp;

Console.WriteLine("***** Fun with the .NET Core Runtime Thread Pool *****\n");

Console.WriteLine("Main thread started. ThreadID = {0}",
  Thread.CurrentThread.ManagedThreadId);

Printer p = new Printer();

WaitCallback workItem = new WaitCallback(PrintTheNumbers);

// Queue the method ten times.
for (int i = 0; i < 10; i++)
{
  ThreadPool.QueueUserWorkItem(workItem, p);
}
Console.WriteLine("All tasks queued");
Console.ReadLine();

static void PrintTheNumbers(object state)
{
  Printer task = (Printer)state;
  task.PrintNumbers();
}

```

此时，您可能想知道使用。NET 核心运行时维护线程池，而不是显式创建`Thread`对象。考虑利用线程池的这些好处:

*   线程池通过最小化必须创建、启动和停止的线程数量来有效地管理线程。

*   通过使用线程池，您可以专注于您的业务问题，而不是应用的线程基础设施。

但是，在某些情况下，最好使用手动线程管理。这里有一个例子:

*   如果需要前台线程或者必须设置线程优先级。池线程是*总是*具有默认优先级的后台线程(`ThreadPriority.Normal`)。

*   如果你需要一个有固定身份的线程来中止它，挂起它，或者通过名字发现它。

这就完成了对`System.Threading`名称空间的研究。可以肯定的是，在创建多线程应用时，理解本章到目前为止介绍的主题(尤其是在您研究并发性问题的过程中)是非常有价值的。有了这个基础，现在将注意力转向中引入的几个新的以线程为中心的主题。NET 4.0 并延续到。NET 核心。首先，您将研究另一个线程模型任务并行库的作用。

## 使用任务并行库的并行编程

在本章的这一点上，您已经检查了允许您构建多线程软件的`System.Threading`名称空间对象。从发布。在. NET 4.0 中，微软引入了一种新的多线程应用开发方法，该方法使用一个名为*任务并行库* (TPL)的并行编程库。使用`System.Threading.Tasks`的类型，您可以构建细粒度的、可伸缩的并行代码，而不必直接使用线程或线程池。

然而，这并不是说当你使用 TPL 时，你不会使用`System.Threading`的类型。这两个线程工具包可以非常自然地一起工作。尤其是因为`System.Threading`名称空间仍然提供了您之前检查过的大多数同步原语(`Monitor`、`Interlocked`等)。).然而，你很可能会发现你更喜欢使用 TPL 而不是原来的`System.Threading`名称空间，因为同样的任务可以用更直接的方式来执行。

### 系统。线程.任务命名空间

统称起来，`System.Threading.Tasks`的类型被称为*任务并行库*。TPL 将使用运行时线程池，在可用的 CPU 之间动态地自动分配应用的工作负载。TPL 处理工作的划分、线程调度、状态管理和其他底层细节。结果是，您可以最大限度地发挥。NET 核心应用，同时避免了许多直接使用线程的复杂性。

### 并行类的作用

第三方物流的一个关键类别是`System.Threading.Tasks.Parallel`。这个类包含的方法允许你以并行的方式迭代一组数据(特别是一个实现了`IEnumerable<T>`的对象)，主要是通过两个主要的静态方法`Parallel.For()`和`Parallel.ForEach()`，每个方法都定义了许多重载版本。

这些方法允许您创作将以并行方式处理的代码语句体。从概念上讲，这些语句与您在普通循环结构中编写的逻辑是相同的(通过`for`或`foreach` C#关键字)。好处是`Parallel`类将代表您从线程池中提取线程(并管理并发性)。

这两种方法都要求您指定一个兼容`IEnumerable`或`IEnumerable<T>`的容器，该容器保存您需要以并行方式处理的数据。容器可以是一个简单的数组、一个非泛型集合(比如`ArrayList`)、一个泛型集合(比如`List<T>`)或者一个 LINQ 查询的结果。

此外，您将需要使用`System.Func<T>`和`System.Action<T>`委托来指定将被调用来处理数据的目标方法。你已经遇到了第 [13 章](13.html)中的`Func<T>`代表，在你调查 LINQ 地对象期间。回想一下，`Func<T>`表示一个可以有给定返回值和不同数量参数的方法。`Action<T>`委托类似于`Func<T>`，因为它允许你指向一个带一些参数的方法。但是，`Action<T>`指定了一个只能返回`void`的方法。

虽然您可以调用`Parallel.For()`和`Parallel.ForEach()`方法并传递强类型的`Func<T>`或`Action<T>`委托对象，但是您可以通过使用合适的 C#匿名方法或 lambda 表达式来简化您的编程。

### 并行类的数据并行性

使用 TPL 的第一种方法是执行*数据并行*。简单地说，这个术语指的是使用`Parallel.For()`或`Parallel.ForEach()`方法以并行方式迭代数组或集合的任务。假设您需要执行一些劳动密集型的文件 I/O 操作。具体来说，你需要将大量的`*.jpg`文件加载到内存中，翻转过来，将修改后的图像数据保存到新的位置。

在这个示例中，您将看到如何使用图形用户界面执行相同的整体任务，因此您可以检查“匿名委托”的使用，以允许辅助线程更新主用户界面线程(也称为 UI 线程)。

Note

当您构建多线程图形用户界面(GUI)应用时，辅助线程永远不能直接访问用户界面控件。原因是控件(按钮、文本框、标签、进度条等。)与创建它们的线程有线程关联。在下面的例子中，我将说明一种允许辅助线程以线程安全的方式访问 UI 项的方法。当您检查 C# `async`和`await`关键字时，您会看到一个更简化的方法。

举例来说，创建一个新的 WPF应用(模板缩写为 WPF 应用。NET Core))命名为 DataParallelismWithForEach。要使用 CLI 创建项目并将其添加到本章的解决方案中，请输入以下命令:

```cs
dotnet new wpf -lang c# -n DataParallelismWithForEach -o .\DataParallelismWithForEach -f net5.0
dotnet sln .\Chapter15_AllProjects.sln add .\DataParallelismWithForEach

```

Note

Windows Presentation Foundation(WPF)仅适用于此版本的 Windows。NET 核心，将在第[24](24.html)—[28](28.html)章节中详细介绍。如果你没有和 WPF 一起工作过，这里列出了你在这个例子中需要的所有东西。如果您更愿意跟随一个完整的解决方案，您可以在`Chapter` [`15`](15.html) 文件夹中找到 DataParallelismWithForEach。WPF 开发使用 Visual Studio 代码，尽管没有设计器支持。为了获得更丰富的开发体验，我建议您使用 Visual Studio 2019 来获得本章中的 WPF 示例。

在解决方案资源管理器中双击`MainWindow.xaml`文件，并用以下内容替换 XAML:

```cs
<Window x:Class="DataParallelismWithForEach.MainWindow"
        xmlns:="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"

        xmlns:local="clr-namespace:DataParallelismWithForEach"
        mc:Ignorable="d"
        Title="Fun with TPL" Height="400" Width="800">
  <Grid>
    <Grid.RowDefinitions>
      <RowDefinition Height="Auto"/>
      <RowDefinition Height="*"/>
      <RowDefinition Height="Auto"/>
    </Grid.RowDefinitions>
    <Label Grid.Row="0" Grid.Column="0">
      Feel free to type here while the images are processed...
    </Label>
    <TextBox Grid.Row="1" Grid.Column="0"  Margin="10,10,10,10"/>
    <Grid Grid.Row="2" Grid.Column="0">
      <Grid.ColumnDefinitions>
        <ColumnDefinition Width="Auto"/>
        <ColumnDefinition Width="*"/>
        <ColumnDefinition Width="Auto"/>
      </Grid.ColumnDefinitions>
            <Button Name="cmdCancel" Grid.Row="0" Grid.Column="0" Margin="10,10,0,10" Click="cmdCancel_Click">
                Cancel
            </Button>
            <Button Name="cmdProcess" Grid.Row="0" Grid.Column="2" Margin="0,10,10,10"
                         Click="cmdProcess_Click">
                Click to Flip Your Images!
            </Button>
    </Grid>
  </Grid>
</Window>

```

同样，不要担心标记意味着什么或者它是如何工作的；你很快就会有很多时间和 WPF 在一起。应用的 GUI 由多行`TextBox`和单个`Button`(名为`cmdProcess`)组成。文本区域的目的是允许您在后台执行工作时输入数据，从而说明并行任务的非阻塞性质。

对于这个例子，需要一个额外的 NuGet 包(`System.Drawing.Common`)。若要将它添加到项目中，请在 Visual Studio 的命令行(与解决方案文件位于同一目录中)或包管理器控制台中输入以下行(全部在一行中):

```cs
dotnet add DataParallelismWithForEach package System.Drawing.Common

```

打开`MainWindow.xaml.cs`文件(在 Visual Studio 中双击它——您可能需要通过`MainWindow.xaml`展开节点),并将以下`using`语句添加到文件的顶部:

```cs
// Be sure you have these namespaces! (System.Threading.Tasks should already be there from the default template)
using System;
using System.Drawing;
using System.Threading.Tasks;
using System.Threading;
using System.Windows;
using System.IO;

```

Note

您应该更新传递到下面的`Directory.GetFiles()`方法调用中的字符串，以指向您的计算机上有一些图像文件的路径(比如家庭照片的个人文件夹)。为了方便起见，我在`Solution`目录中包含了一些示例图像(Windows 操作系统附带的)。

```cs
public partial class MainWindow : Window
{
  public MainWindow()
  {
    InitializeComponent();
  }

  private void cmdCancel_Click(object sender, EventArgs e)
  {
    // This will be updated shortly
  }

  private void cmdProcess_Click(object sender, EventArgs e)
  {
    ProcessFiles();
    this.Title = "Processing Complete";
  }

  private void ProcessFiles()
  {
    // Load up all *.jpg files, and make a new folder for the
    //   modified data.
    //Get the directory path where the file is executing
    //For VS 2019 debugging, the current directory will be <projectdirectory>\bin\debug\net5.0-windows
    //For VS Code or “dotnet run”, the current directory will be <projectdirectory>
    var basePath = Directory.GetCurrentDirectory();
    var pictureDirectory =
      Path.Combine(basePath, "TestPictures");
    var outputDirectory =
      Path.Combine(basePath, "ModifiedPictures");
    //Clear out any existing files
    if (Directory.Exists(outputDirectory))
    {
      Directory.Delete(outputDirectory, true);
    }
    Directory.CreateDirectory(outputDirectory);
    string[] files = Directory.GetFiles(pictureDirectory,
       "*.jpg", SearchOption.AllDirectories);

    // Process the image data in a blocking manner.
    foreach (string currentFile in files)
    {
      string filename =
        System.IO.Path.GetFileName(currentFile);
      // Print out the ID of the thread processing the current image.
       this.Title = $"Processing {filename} on thread {Thread.CurrentThread.ManagedThreadId}";
      using (Bitmap bitmap = new Bitmap(currentFile))
      {
        bitmap.RotateFlip(RotateFlipType.Rotate180FlipNone);
        bitmap.Save(System.IO.Path.Combine(
          outputDirectory, filename));
      }
    }
  }
}

```

Note

如果您收到一条错误消息，指出`Path`是`System.IO.Path`和`System.Windows.Shapes.Path`之间的不明确引用，请删除`System.Windows.Shapes`的`using`，或者将`System.IO`添加到`Path` : `System.IO.Path.Combine(...)`。

请注意，`ProcessFiles()`方法将旋转指定目录下的每个`*.jpg`文件。目前，所有的工作都发生在可执行文件的主线程上。因此，如果单击该按钮，程序将显示为挂起。此外，窗口的标题还将报告同一个主线程正在处理文件，因为我们只有一个执行线程。

为了在尽可能多的 CPU 上处理文件，您可以重写当前的`foreach`循环来使用`Parallel.ForEach()`。回想一下，这个方法已经被重载了无数次；然而，在最简单的形式中，您必须指定包含要处理的项目的与`IEnumerable<T>`兼容的对象(那将是`files`字符串数组)和一个指向将执行工作的方法的`Action<T>`委托。

下面是相关的更新，使用 C# lambda 操作符代替文字`Action<T>`委托对象。请注意，您目前正在*注释掉*显示执行当前图像文件的线程 ID 的代码行。见下一节找出原因。

```cs
// Process the image data in a parallel manner!
Parallel.ForEach(files, currentFile =>
  {
    string filename = Path.GetFileName(currentFile);

      // This code statement is now a problem! See next section.
      // this.Title = $"Processing {filename} on thread
      //      {Thread.CurrentThread.ManagedThreadId}"
      // Thread.CurrentThread.ManagedThreadId);

    using (Bitmap bitmap = new Bitmap(currentFile))
    {
      bitmap.RotateFlip(RotateFlipType.Rotate180FlipNone);
      bitmap.Save(Path.Combine(outputDirectory, filename));
    }
  }
);

```

### 访问辅助线程上的 UI 元素

您会注意到，我已经注释掉了用当前执行线程的 ID 更新主窗口标题的前一行代码。如前所述，GUI 控件与创建它们的线程有“线程亲缘关系”。如果辅助线程试图访问它们没有直接创建的控件，那么在调试软件时，您肯定会遇到运行时错误。另一方面，如果您要*运行*应用(通过 Ctrl+F5)，您可能永远不会发现原始代码有任何问题。

Note

让我重申前面的观点:当您调试多线程应用时，您有时可以捕捉到当辅助线程“接触”在主线程上创建的控件时出现的错误。然而，通常当您运行应用时，应用可能看起来运行正常(或者可能立即出错)。除非您采取预防措施(接下来将讨论)，否则在这种情况下，您的应用有可能引发运行时错误。

允许这些辅助线程以线程安全的方式访问控件的一种方法是另一种以委托为中心的技术，特别是一种*匿名委托*。WPF 中的`Control`父类定义了一个`Dispatcher`对象，它管理一个线程的工作项。这个对象有一个名为`Invoke()`的方法，它接受一个`System.Delegate`作为输入。当您处于涉及辅助线程的编码上下文中时，可以调用此方法，以提供线程安全的方式来更新给定控件的 UI。现在，虽然您可以直接编写所有需要的委托代码，但大多数开发人员使用表达式语法作为简单的替代方法。以下是对先前注释掉的代码语句内容的相关更新:

```cs
// Eek! This will not work anymore!
//this.Title = $"Processing {filename} on thread {Thread.CurrentThread.ManagedThreadId}";

// Invoke on the Form object, to allow secondary threads to access controls
// in a thread-safe manner.
Dispatcher?.Invoke(() =>
{
  this.Title = $"Processing {filename}";
});
using (Bitmap bitmap = new Bitmap(currentFile))
{
  bitmap.RotateFlip(RotateFlipType.Rotate180FlipNone);
  bitmap.Save(Path.Combine(outputDirectory, filename));
}

```

现在，如果您运行这个程序，TPL 将会使用尽可能多的 CPU 将工作负载分配给线程池中的多个线程。然而，由于`Title`总是从主线程更新，所以`Title`更新代码不再显示当前线程，并且如果您在文本框中键入内容，直到所有图像都被处理完，您将看不到任何内容！原因是主 UI 线程仍然被阻塞，等待所有其他线程完成它们的任务。

### 任务类

`Task`类允许您轻松地调用辅助线程上的方法，并且可以作为使用异步委托的简单替代方法。更新`Button`控件的`Click`处理程序，如下所示:

```cs
private void cmdProcess_Click(object sender, EventArgs e)
{
  // Start a new "task" to process the files.
  Task.Factory.StartNew(() => ProcessFiles());
  //Can also be written this way
  //Task.Factory.StartNew(ProcessFiles);

}

```

`Task`的`Factory`属性返回一个`TaskFactory`对象。当您调用它的`StartNew()`方法时，您传入一个`Action<T>`委托(这里，用一个合适的 lambda 表达式隐藏起来)，该委托指向要以异步方式调用的方法。通过这个小小的更新，您会发现窗口的标题将显示线程池中的哪个线程正在处理给定的文件，更好的是，文本区域能够接收输入，因为 UI 线程不再被阻塞。

### 处理取消请求

您可以对当前示例进行的一个改进是，通过第二个(恰当命名的)Cancel 按钮，为用户提供一种停止处理图像数据的方法。幸运的是，`Parallel.For()`和`Parallel.ForEach()`方法都支持使用*取消令牌*进行取消。当您调用`Parallel`上的方法时，您可以传入一个`ParallelOptions`对象，该对象又包含一个`CancellationTokenSource`对象。

首先，在名为`_cancelToken`的`CancellationTokenSource`类型的`Form`派生类中定义以下新的私有成员变量:

```cs
public partial class MainWindow :Window
{
  // New Window-level variable.
  private CancellationTokenSource _cancelToken = new CancellationTokenSource();
...
}

```

将取消按钮`Click`事件更新为以下代码:

```cs
private void cmdCancel_Click(object sender, EventArgs e)
{
  // This will be used to tell all the worker threads to stop!
  _cancelToken.Cancel();
}

```

现在，真正的修改需要发生在`ProcessFiles()`方法中。考虑最终的实现:

```cs
private void ProcessFiles()
{
  // Use ParallelOptions instance to store the CancellationToken.
  ParallelOptions parOpts = new ParallelOptions();
  parOpts.CancellationToken = _cancelToken.Token;
  parOpts.MaxDegreeOfParallelism = System.Environment.ProcessorCount;

  // Load up all *.jpg files, and make a new folder for the modified data.
  string[] files = Directory.GetFiles(@".\TestPictures", "*.jpg", SearchOption.AllDirectories);
  string outputDirectory = @".\ModifiedPictures";
  Directory.CreateDirectory(outputDirectory);

  try
  {
    // Process the image data in a parallel manner!
    Parallel.ForEach(files, parOpts, currentFile =>
    {
      parOpts
         .CancellationToken.ThrowIfCancellationRequested();

      string filename = Path.GetFileName(currentFile);
      Dispatcher?.Invoke(() =>
      {
        this.Title =
          $"Processing {filename} on thread {Thread.CurrentThread.ManagedThreadId}";
      });
      using (Bitmap bitmap = new Bitmap(currentFile))
      {
        bitmap.RotateFlip(RotateFlipType.Rotate180FlipNone);
        bitmap.Save(Path.Combine(outputDirectory, filename));
      }
    });
    Dispatcher?.Invoke(()=>this.Title = "Done!");
  }
  catch (OperationCanceledException ex)
  {
    Dispatcher?.Invoke(()=>this.Title = ex.Message);
  }
}

```

注意，这个方法是通过配置一个`ParallelOptions`对象开始的，设置`CancellationToken`属性来使用`CancellationTokenSource`令牌。还要注意，当您调用`Parallel.ForEach()`方法时，您将把`ParallelOptions`对象作为第二个参数传入。

在循环逻辑的范围内，您调用令牌上的`ThrowIfCancellationRequested()`,这将确保如果用户单击 Cancel 按钮，所有线程都将停止，并且您将通过运行时异常得到通知。当您捕捉到`OperationCanceledException`错误时，您将把主窗口的文本设置为错误消息。

### 使用并行类的任务并行性

除了数据并行性之外，TPL 还可以使用`Parallel.Invoke()`方法轻松地启动任意数量的异步任务。这种方法比使用来自`System.Threading`的成员更简单；然而，如果您需要对任务的执行方式有更多的控制，您可以放弃使用`Parallel.Invoke()`而直接使用`Task`类，就像您在前面的例子中所做的那样。

为了说明任务并行性，创建一个名为 MyEBookReader 的新控制台应用，并确保在`Program.cs`的顶部导入了`System.Threading`、`System.Text`、`System.Threading.Tasks`、`System.Linq`和`System.Net`名称空间(这个示例是对。NET 核心文档)。在这里，您将从 Project Gutenberg ( [`www.gutenberg.org`](http://www.gutenberg.org) )获取一个公开可用的电子书，然后并行执行一组冗长的任务。

这本书是用`GetBook()`方法下载的，如下所示:

```cs
using System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Net;
using System.Text;

string _theEBook = "";
GetBook();
Console.WriteLine("Downloading book...");
Console.ReadLine();

void GetBook()
{
  WebClient wc = new WebClient();
  wc.DownloadStringCompleted += (s, eArgs) =>
  {
    _theEBook = eArgs.Result;
    Console.WriteLine("Download complete.");
    GetStats();
  };

  // The Project Gutenberg EBook of A Tale of Two Cities, by Charles Dickens
  // You might have to run it twice if you’ve never visited the site before, since the first
  // time you visit there is a message box that pops up, and breaks this code.
  wc.DownloadStringAsync(new Uri("http://www.gutenberg.org/files/98/98-8.txt"));
}

```

`WebClient`类是`System.Net`的成员。此类提供向 URI 标识的资源发送数据和从该资源接收数据的方法。事实证明，这些方法中有很多都有异步版本，比如`DownloadStringAsync()`。此方法将从。NET 核心运行时自动线程池。当`WebClient`完成获取数据时，它将触发`DownloadStringCompleted`事件，这里使用 C# lambda 表达式处理该事件。如果您要调用该方法的同步版本(`DownloadString()`)，那么在下载完成之前，不会显示“正在下载”的消息。

接下来，实现`GetStats()`方法来提取包含在`theEBook`变量中的单个单词，然后将字符串数组传递给几个辅助函数进行处理，如下所示:

```cs
void GetStats()
{
  // Get the words from the ebook.
  string[] words = _theEBook.Split(new char[]
    { ' ', '\u000A', ',', '.', ';', ':', '-', '?', '/' },
    StringSplitOptions.RemoveEmptyEntries);

  // Now, find the ten most common words.
  string[] tenMostCommon = FindTenMostCommon(words);

  // Get the longest word.
  string longestWord = FindLongestWord(words);

  // Now that all tasks are complete, build a string to show all stats.
  StringBuilder bookStats = new StringBuilder("Ten Most Common Words are:\n");
  foreach (string s in tenMostCommon)
  {
    bookStats.AppendLine(s);
  }

  bookStats.AppendFormat("Longest word is: {0}", longestWord);
  bookStats.AppendLine();
  Console.WriteLine(bookStats.ToString(), "Book info");
}

```

`FindTenMostCommon()`方法使用 LINQ 查询来获得在`string`数组中最常出现的`string`对象的列表，而`FindLongestWord()`则定位最长的单词。

```cs
string[] FindTenMostCommon(string[] words)
{
    var frequencyOrder = from word in words
                         where word.Length > 6
                         group word by word into g
                         orderby g.Count() descending
                         select g.Key;
    string[] commonWords = (frequencyOrder.Take(10)).ToArray();
    return commonWords;
}
string FindLongestWord(string[] words)
{
    return (from w in words orderby w.Length descending select w).FirstOrDefault();
}

```

如果您要运行这个项目，根据您的机器的 CPU 数量和整体处理器速度，执行所有任务可能会花费大量的时间。最终，您应该会看到如下所示的输出:

```cs
Downloading book...
Download complete.
Ten Most Common Words are:
Defarge
himself
Manette
through
nothing
business
another
looking
prisoner
Cruncher
Longest word is: undistinguishable

```

通过并行调用`FindTenMostCommon()`和`FindLongestWord()`方法，可以帮助确保您的应用使用主机上所有可用的 CPU。为此，将您的`GetStats()`方法修改如下:

```cs
void GetStats()
{
  // Get the words from the ebook.
  string[] words = _theEBook.Split(
    new char[] { ' ', '\u000A', ',', '.', ';', ':', '-', '?', '/' },
    StringSplitOptions.RemoveEmptyEntries);
  string[] tenMostCommon = null;
  string longestWord = string.Empty;

  Parallel.Invoke(
    () =>
    {
      // Now, find the ten most common words.
      tenMostCommon = FindTenMostCommon(words);
    },
    () =>
    {
      // Get the longest word.
      longestWord = FindLongestWord(words);
    });

  // Now that all tasks are complete, build a string to show all stats.
  ...
}

```

`Parallel.Invoke()`方法需要一个`Action<>`委托的参数数组，这是您使用 lambda 表达式间接提供的。同样，虽然输出是相同的，但好处是 TPL 现在将使用机器上所有可能的处理器来尽可能并行地调用每个方法。

## 并行 LINQ 查询(PLINQ)

总结一下您对 TPL 的看法，要知道还有另一种方法可以将并行任务合并到您的。NET 核心应用。如果您愿意，可以使用一组扩展方法来构造一个并行执行其工作负载的 LINQ 查询(如果可能的话)。相应地，设计为并行运行的 LINQ 查询被称为 *PLINQ 查询*。

像使用`Parallel`类创作的并行代码一样，如果需要，PLINQ 可以选择忽略您并行处理集合的请求。PLINQ 框架已经在许多方面进行了优化，包括确定一个查询实际上是否会以同步方式执行得更快。

在运行时，PLINQ 分析查询的整体结构，如果查询可能受益于并行化，它将并发运行。但是，如果并行化查询会损害性能，PLINQ 只会按顺序运行查询。如果 PLINQ 可以在潜在昂贵的并行算法或便宜的顺序算法之间进行选择，默认情况下它会选择顺序算法。

必要的扩展方法可以在名称空间`System.Linq`的`ParallelEnumerable`类中找到。表 [15-5](#Tab5) 记录了一些有用的 PLINQ 扩展。

表 15-5。

选择 ParallelEnumerable 类的成员

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

成员

 | 

生命的意义

 |
| --- | --- |
| `AsParallel()` | 指定查询的其余部分应该并行化(如果可能) |
| `WithCancellation()` | 指定 PLINQ 应定期监视所提供的取消令牌的状态，并在收到请求时取消执行 |
| `WithDegreeOfParallelism()` | 指定 PLINQ 用于并行查询的最大处理器数量 |
| `ForAll()` | 支持并行处理结果，而无需先合并回消费者线程，这是使用`foreach`关键字枚举 LINQ 结果时的情况 |

要查看 PLINQ 的运行情况，创建一个名为 plinqdataprocessingwithcassignation 的控制台应用，并导入`System.Linq`、`System.Threading`和`System.Threading.Tasks`名称空间(如果还没有的话)。当处理开始时，程序将触发一个新的`Task`，它执行一个 LINQ 查询，该查询调查一个大的整数数组，只查找`x % 3 == 0`为`true`的项目。下面是一个*不平行的*版本的查询:

```cs
using System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

Console.WriteLine("Start any key to start processing");
Console.ReadKey();

Console.WriteLine("Processing");
Task.Factory.StartNew(ProcessIntData);
Console.ReadLine();

void ProcessIntData()
{
  // Get a very large array of integers.
  int[] source = Enumerable.Range(1, 10_000_000).ToArray();
  // Find the numbers where num % 3 == 0 is true, returned
  // in descending order.
  int[] modThreeIsZero = (
    from num in source
    where num % 3 == 0
    orderby num descending
    select num).ToArray();
  Console.WriteLine($"Found { modThreeIsZero.Count()} numbers that match query!");
}

```

### 选择加入 PLINQ 查询

如果您想要通知 TPL 并行执行这个查询(如果可能的话)，您将想要使用`AsParallel()`扩展方法，如下所示:

```cs
int[] modThreeIsZero = (
  from num in source.AsParallel()
  where num % 3 == 0
  orderby num descending select num).ToArray();

```

请注意，LINQ 查询的整体格式与您在前面章节中看到的完全相同。然而，通过包含对`AsParallel()`的调用，TPL 将试图将工作负载传递给任何可用的 CPU。

### 取消 PLINQ 查询

也可以使用`CancellationTokenSource`对象通知 PLINQ 查询在正确的条件下停止处理(通常是因为用户干预)。声明一个名为`_cancelToken`的类级`CancellationTokenSource`对象，并更新顶级语句方法以接受用户输入。以下是相关的代码更新:

```cs
CancellationTokenSource _cancelToken =
  new CancellationTokenSource();

do
{
  Console.WriteLine("Start any key to start processing");
  Console.ReadKey();
  Console.WriteLine("Processing");
  Task.Factory.StartNew(ProcessIntData);
  Console.Write("Enter Q to quit: ");
  string answer = Console.ReadLine();
  // Does user want to quit?
  if (answer.Equals("Q",
    StringComparison.OrdinalIgnoreCase))
  {
    _cancelToken.Cancel();
    break;
  }
}
while (true);

Console.ReadLine();

```

现在，通过链接`WithCancellation()`扩展方法并传入令牌，通知 PLINQ 查询它应该注意一个传入的取消请求。此外，您将希望将这个 PLINQ 查询包装在一个适当的`try` / `catch`范围内，并处理可能的异常。下面是`ProcessIntData()`方法的最终版本:

```cs
void ProcessIntData()
{
  // Get a very large array of integers.
  int[] source = Enumerable.Range(1, 10_000_000).ToArray();
  // Find the numbers where num % 3 == 0 is true, returned
  // in descending order.
  int[] modThreeIsZero = null;
  try
  {
    modThreeIsZero = (from num in source.AsParallel().WithCancellation(_cancelToken.Token)
            where num % 3 == 0
            orderby num descending
            select num).ToArray();
    Console.WriteLine();
    Console.WriteLine($"Found {modThreeIsZero.Count()} numbers that match query!");
  }
  catch (OperationCanceledException ex)
  {
    Console.WriteLine(ex.Message);
  }
}

```

当运行这个程序时，您会想要点击 Q 并快速输入以查看来自取消令牌的消息。在我的开发机器上，在它自己完成之前，我有大约一秒钟的时间退出。

## 用 async/await 进行异步调用

在这一章(相当长)中，我已经介绍了很多材料。可以肯定的是，构建、调试和理解复杂的多线程应用在任何框架中都具有挑战性。虽然 TPL、PLINQ 和 delegate 类型可以在某种程度上简化事情(特别是与其他平台和语言相比)，但开发人员仍然需要了解各种高级技术的来龙去脉。

自从发布以来。NET 4.5 中，C#编程语言已经更新了两个新的关键字，进一步简化了创作异步代码的过程。与本章中的所有例子相比，当你使用新的`async`和`await`关键字时，编译器将使用`System.Threading`和`System.Threading.Tasks`名称空间的众多成员为你生成大量线程代码。

### 首先看看 C# async 和 await 关键字(更新 7.1，9.0)

C#的关键字`async`用于限定方法、lambda 表达式或匿名方法应该以异步方式自动*调用*。是的，这是真的。只需用`async`修饰符标记一个方法。NET 核心运行时将创建一个新的执行线程来处理手头的任务。此外，当您调用一个`async`方法时，`await`关键字将*自动*暂停当前线程的任何进一步活动，直到任务完成，让调用线程自由地继续。

举例来说，创建一个名为 FunWithCSharpAsync 的控制台应用，并将`System.Threading`、`System.Threading.Tasks`和`System.Collections.Generic`名称空间导入到`Program.cs`中。添加一个名为`DoWork()`的方法，强制调用线程等待五秒钟。到目前为止，故事是这样的:

```cs
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

Console.WriteLine(" Fun With Async ===>");
Console.WriteLine(DoWork());
Console.WriteLine("Completed");
Console.ReadLine();

static string DoWork()
{
  Thread.Sleep(5_000);
  return "Done with work!";
}

```

现在，考虑到你在这一章中的工作，你知道如果你要运行这个程序，你需要等待五秒钟，然后其他事情才会发生。如果这是一个图形应用，整个屏幕将被锁定，直到工作完成。

如果你要使用本章中介绍的任何一种技术来提高程序的响应能力，你将有大量的工作要做。然而自从。NET 4.5，您可以编写以下 C#代码库:

```cs
...
string message = await DoWorkAsync();
Console.WriteLine(message);
...

static string DoWork()
{
  Thread.Sleep(5_000);
  return "Done with work!";
}
static async Task<string> DoWorkAsync()
{
  return await Task.Run(() =>
  {
    Thread.Sleep(5_000);
    return "Done with work!";
  });
}

```

如果您使用一个`Main()`方法作为入口点(而不是顶级语句)，您需要将该方法标记为`async`，这是在 C# 7.1 中引入的。

```cs
static async Task Main(string[] args)
{
...
string message = await DoWorkAsync();
Console.WriteLine(message);
...
}

```

Note

从 C# 7.1 开始，可以用`async`来修饰`Main()`方法。在 C# 9.0 中，顶层语句是隐式的`async`。

注意在命名将以异步方式调用的方法之前的`await`关键字*。这一点很重要:如果你用`async`关键字修饰一个方法，但是没有至少一个内部的`await`为中心的方法调用，你实际上已经构建了一个同步方法调用(事实上，你将得到一个关于这个效果的编译器警告)。*

现在，请注意，您需要使用来自`System.Threading.Tasks`名称空间的`Task`类来重构您的`Main()`(如果您正在使用`Main()`)和`DoWork()`方法(后者被添加为`DoWorkAsync()`)。基本上，不是直接返回一个特定的返回值(在当前的例子中是一个`string`对象)，而是返回一个`Task<T>`对象，其中泛型类型参数`T`是底层的实际返回值(到目前为止？).如果方法没有返回值(就像在`Main()`方法中一样)，那么就用 `Task`代替任务<t>。</t>

`DoWorkAsync()`的实现现在直接返回一个`Task<T>`对象，这个对象就是`Task.Run()`的返回值。`Run()`方法接受一个`Func<>`或`Action<>`委托，正如您在本文中所知，您可以通过使用 lambda 表达式来简化您的生活。基本上你的新版`DoWorkAsync()`本质上是在说下面的话:

> *当你调用我的时候，我会运行一个新的任务。这个任务将导致调用线程睡眠五秒钟，当它完成时，它给我一个字符串返回值。我将把这个字符串放到一个新的 Task < string >对象中，并将其返回给调用者。*

将`DoWorkAsync()`的这个新实现翻译成更自然(诗意)的语言后，您对`await`标记的真正作用有了一些了解。这个关键字将总是修改返回一个`Task`对象的方法。当逻辑流到达`await`标记时，调用线程在这个方法中被挂起，直到调用完成。如果您要运行这个版本的应用，您会发现`Completed`消息显示在`Done with work!`消息之前。如果这是一个图形应用，当`DoWorkAsync()`方法执行时，用户可以继续使用 UI。

### 同步上下文和异步/等待

`SynchronizationContext`的官方定义是一个基类，提供无同步的自由线程上下文。虽然最初的定义不是很有描述性，但官方文档继续说:

> *由该类实现的同步模型的目的是允许公共语言运行库的内部异步/同步操作在不同的同步模型下正常运行。*

这一陈述，以及您对多线程的了解，阐明了这个问题。回想一下，GUI 应用(WinForms，WPF)不允许辅助线程直接访问控件，但必须委托该访问。我们已经看到了 WPF 例子中的`Dispatcher`对象。对于不使用 WPF 的控制台应用，没有这种限制。这些是提到的不同的同步模型。记住这一点，让我们更深入地了解一下`SynchronizationContext`。

`SynchonizationContext`是一种提供虚拟 post 方法的类型，它接受一个要异步执行的委托。这为框架提供了适当处理异步请求的模式(为 WPF/WinForms 分派，为非 GUI 应用直接执行，等等)。).它提供了一种方法来将一个工作单元排队到一个上下文中，并对未完成的`async`操作进行计数。

正如我们前面讨论的，当一个委托被排队异步运行时，它被安排在一个单独的线程上运行。这个细节由。NET 核心运行时。这通常是使用。NET 核心运行时托管线程池，但可以用自定义实现重写。

虽然这种管道工作可以通过代码手动管理，但是`async` / `await`模式完成了大部分繁重的工作。当等待一个`async`方法时，它利用目标框架的`SynchronizationContext`和`TaskScheduler`实现。例如，如果您在一个 WPF 应用中使用`async` / `await`，WPF 框架会管理委托的分派，并在等待的任务完成时回调状态机，以便安全地更新控件。

### ConfigureAwait 的作用

现在您对`SynchronizationContext`有了更好的理解，是时候介绍一下`ConfigureAwait()`方法的作用了。默认情况下，等待`Task`将导致同步上下文被利用。当开发 GUI 应用(WinForms，WPF)时，这是您想要的行为。但是，如果您正在编写非 GUI 应用代码，在不需要时对原始上下文进行排队的开销可能会导致应用中的性能问题。

要了解这一点，请将您的顶级语句更新为以下内容:

```cs
Console.WriteLine(" Fun With Async ===>");
//Console.WriteLine(DoWork());
string message = await DoWorkAsync();
Console.WriteLine(message);

string message1 = await DoWorkAsync().ConfigureAwait(false);
Console.WriteLine(message1);

```

原始代码块使用框架提供的`SynchronizationContext`(在本例中，是。NET 核心运行时)。相当于调用`ConfigureAwait(true)`。第二个例子忽略了当前的上下文和调度程序。

的指导。NET 核心团队建议在开发应用代码时(WinForms、WPF 等。)保留默认行为。如果你正在编写非应用代码(如库代码)，那么使用`ConfigureAwait(false)`。一个例外是 ASP.NET 核心(在第 9 部分中讨论)。ASP.NET 核心不创建自定义`SynchronizationContext`；因此，`ConfigureAwait(false)`在使用其他框架时不提供这种好处。

### 异步方法的命名约定

当然，你注意到了从`DoWork()`到`DoWorkAsync()`的名称变化，但是为什么会发生变化呢？假设新版本的方法仍被命名为`DoWork()`；但是，调用代码是这样实现的:

```cs
//Oops! No await keyword here!
string message = DoWork();

```

注意你确实用`async`关键字标记了方法，但是你忽略了在`DoWork()`方法调用之前使用`await`关键字作为修饰。此时，您将遇到编译器错误，因为`DoWork()`的返回值是一个`Task`对象，您试图将它直接赋给一个字符串变量。记住，`await`标记提取包含在`Task`对象中的内部返回值。因为您没有使用这个标记，所以您有一个类型不匹配。

Note

一个“可适应的”方法只是一个返回`Task`或`Task<T>`的方法。

鉴于返回`Task`对象的方法现在可以通过`async`和`await`标记以非阻塞的方式调用，微软建议(作为最佳实践)任何返回`Task`的方法都用`Async`后缀标记。通过这种方式，知道命名约定的开发人员会收到一个视觉提示，如果他们打算在异步上下文中调用该方法，则需要使用`await`关键字。

Note

GUI 控件的事件处理程序(如按钮`Click`处理程序)以及 MVC 风格应用中使用`async` / `await`关键字的动作方法不遵循这种命名约定(按照约定，请原谅冗余！).

### Void 异步方法

目前，您的`DoWorkAsync()`方法正在返回一个`Task`，它包含调用者的“真实数据”，这些数据将通过`await`关键字透明地获得。但是，如果要构建一个返回 void 的异步方法呢？如何实现这一点取决于该方法是否需要等待(就像在“一劳永逸”的场景中一样)。

#### 适用的 Void 异步方法

如果你的`async`方法需要是可适应的，你使用非泛型`Task`类并省略任何`return`语句，就像这样:

```cs
static async Task MethodReturningTaskOfVoidAsync()
{
  await Task.Run(() => { /* Do some work here... */
                         Thread.Sleep(4_000);
                       });
  Console.WriteLine("Void method completed");
}

```

这个方法的调用者将使用关键字`await`,如下所示:

```cs
await MethodReturningVoidAsync();
Console.WriteLine("Void method complete");

```

#### “一劳永逸”的 Void 异步方法

如果你的方法需要是`async`但不需要是可实现的，而是用于“一劳永逸”的情况，添加带有`void`的`async`关键字，而不是`Task`返回类型。这通常用于日志记录之类的情况，在这种情况下，您不希望日志记录工作延迟其余的代码。

```cs
static async void MethodReturningVoidAsync()
{
  await Task.Run(() => { /* Do some work here... */
                         Thread.Sleep(4_000);
                       });
  Console.WriteLine("Fire and forget void method completed");
}

```

这个方法的调用者将*而不是*这样使用`await`关键字:

```cs
MethodReturningVoidAsync();
Console.WriteLine("Void method complete");

```

### 具有多个等待的异步方法

一个`async`方法在其实现中拥有多个 await 上下文是完全允许的。下面是完全可以接受的代码:

```cs
static async Task MultipleAwaits()
{
    await Task.Run(() => { Thread.Sleep(2_000); });
    Console.WriteLine("Done with first task!");

    await Task.Run(() => { Thread.Sleep(2_000); });
    Console.WriteLine("Done with second task!");

    await Task.Run(() => { Thread.Sleep(2_000); });
    Console.WriteLine("Done with third task!");
}

```

同样，这里的每个任务都只是暂停当前线程一段时间；然而，任何工作单元都可以由这些任务来表示(调用 web 服务、读取数据库等。).

另一种选择是不等待每个任务，而是一起等待它们。这是一个更可能的场景，其中有三件事(检查邮件、更新服务器、下载文件)必须成批完成，但可以并行完成。下面是使用`Task.WhenAll()`方法更新的代码:

```cs
static async Task MultipleAwaits()
{
  var task1 = Task.Run(() =>
  {
    Thread.Sleep(2_000);
    Console.WriteLine("Done with first task!");
  });

  var task2=Task.Run(() =>
  {
    Thread.Sleep(1_000);
    Console.WriteLine("Done with second task!");
  });

  var task3 = Task.Run(() =>
  {
    Thread.Sleep(1_000);
    Console.WriteLine("Done with third task!");
  });
  await Task.WhenAll(task1,task2,task3);
}

```

当您现在运行程序时，您会看到这三个任务按照最短的`Sleep`时间的顺序启动。

```cs
Fun With Async ===>
Done with work!
Void method completed
Done with second task!
Done with third task!
Done with first task!
Completed

```

还有一个`WhenAny()`，它返回完成的任务。为了演示`WhenAny()`，将`MultipleAwaits`的最后一行改为:

```cs
await Task.WhenAny(task1,task2,task3);

```

当您这样做时，输出更改为:

```cs
Fun With Async ===>
Done with work!
Void method completed
Done with second task!
Completed
Done with third task!
Done with first task!

```

### 从非异步方法调用异步方法

前面的每个例子都使用了`async`关键字在`async`方法执行时将线程返回给调用代码。在 review 中，您只能在标记为`async`的方法中使用`await`关键字。如果您不能(或者不想)标记一个方法`async`该怎么办？

幸运的是，还有其他方法可以调用异步方法。如果您只是不使用`await`关键字，那么该方法中的代码会继续通过`async`方法，而不会返回给调用者。如果您需要等待您的`async`方法完成(当您使用`await`关键字时就会发生这种情况)，有两种方法。

第一种是简单地使用`Task<T>`上的`Result`属性或者`Task` / `Task<T>`方法上的`Wait`。(记住异步时返回值的方法必须返回`Task<T>`，无返回值的方法在`async`时返回`Task`)。如果该方法失败，则返回一个`AggregateException`。

您也可以调用`GetAwaiter().GetResult()`，它完成与`async`方法中的`await`关键字相同的事情，并以与`aync` / `await`相同的方式传播异常。然而，这些方法在文档中被标记为“不供外部使用”，这意味着它们可能会在将来的某个时候改变或消失。`GetAwaiter().GetResult()`方法对有返回值的方法和没有返回值的方法都有效。

Note

在`Task<T>`上使用`Result`还是`GetAwaiter().GetResult()`取决于你自己，大多数开发者基于异常处理来决定。如果你的方法返回`Task`，你必须使用`GetAwaiter().GetResult()`或者`Wait()`。

例如，您可以像这样调用`DoWorkAsync()`方法:

```cs
Console.WriteLine(DoWorkAsync().Result);
Console.WriteLine(DoWorkAsync().GetAwaiter().GetResult());

```

要暂停执行，直到一个`async`方法返回一个`void`返回类型，只需在`Task`上调用`Wait()`，就像这样:

```cs
MethodReturningVoidAsync().Wait();

```

### 等待捕获并最终阻塞

C# 6 引入了在`catch`和`finally`块中放置 await 调用的能力。方法本身必须是`async`才能做到这一点。下面的代码示例演示了该功能:

```cs
static async Task<string> MethodWithTryCatch()
{
  try
  {
    //Do some work
    return "Hello";
  }
  catch (Exception ex)
  {
    await LogTheErrors();
    throw;
  }
  finally
  {
    await DoMagicCleanUp();
  }
}

```

### 通用异步返回类型(新 7.0)

在 C# 7 之前，`async`方法的唯一返回选项是`Task`、`Task<T>`和`void`。C# 7 支持额外的返回类型，如果它们遵循`async`模式的话。一个具体的例子就是`ValueTask`。要了解这一点，请创建如下代码:

```cs
static async ValueTask<int> ReturnAnInt()
{
  await Task.Delay(1_000);
  return 5;
}

```

同样的规则也适用于`ValueTask`和`Task`，因为`ValueTask`只是值类型的一个`Task`，而不是强制在堆上分配一个对象。

### 本地函数(新 7.0)

局部函数在第 4 章[中介绍，在第 8 章](04.html)[中使用迭代器。它们也有利于`async`方法。为了证明好处，你需要首先看到问题。添加一个名为`MethodWithProblems()`的新方法，并添加以下代码:](08.html)

```cs
static async Task MethodWithProblems(int firstParam, int secondParam)
{
  Console.WriteLine("Enter");
  await Task.Run(() =>
  {
    //Call long running method
    Thread.Sleep(4_000);
    Console.WriteLine("First Complete");
    //Call another long running method that fails because
    //the second parameter is out of range
    Console.WriteLine("Something bad happened");
  });
}

```

场景是第二个长时间运行的任务由于无效的输入数据而失败。您可以(也应该)将检查添加到方法的开头，但是由于整个方法是异步的，因此无法保证检查将在何时执行。在调用代码继续运行之前，最好立即进行检查。在下面的更新中，检查以同步方式完成，然后私有函数异步执行:

```cs
static async Task MethodWithProblemsFixed(int firstParam, int secondParam)
{
  Console.WriteLine("Enter");
  if (secondParam < 0)
  {
    Console.WriteLine("Bad data");
    return;
  }

  await actualImplementation();

  async Task actualImplementation()
  {
    await Task.Run(() =>
    {
      //Call long running method
      Thread.Sleep(4_000);
      Console.WriteLine("First Complete");
      //Call another long running method that fails because
      //the second parameter is out of range
      Console.WriteLine("Something bad happened");
    });
  }
}

```

### 取消异步/等待操作

使用`async` / `await`模式也可以取消，比使用`Parallel.ForEach`模式简单得多。为了演示，我们将使用本章前面的同一个 WPF 项目。您可以重用该项目或添加一个新的 WPF 应用(。NET Core)添加到解决方案中，并通过执行以下 CLI 命令将`System.Drawing.Common`包添加到项目中:

```cs
dotnet new wpf -lang c# -n PictureHandlerWithAsyncAwait -o .\PictureHandlerWithAsyncAwait -f net5.0
dotnet sln .\Chapter15_AllProjects.sln add .\PictureHandlerWithAsyncAwait
dotnet add PictureHandlerWithAsyncAwait package System.Drawing.Common

```

如果您使用的是 Visual Studio，可以在解决方案资源管理器中右键单击解决方案名称，选择“添加➤项目”，并将其命名为`PictureHandlerWithAsyncAwait`。确保通过右键单击新项目名称并选择 Set as StartUp Project 将新项目设置为启动项目。添加`System.Drawing.Common` NuGet 包。

```cs
dotnet add PictureHandlerWithAsyncAwait package System.Drawing.Common

```

替换 XAML 以匹配之前的 WPF 项目，除了将标题更改为`Picture Handler with Async/Await`。

在`MainWindow.xaml.cs`文件中，确保以下`using`语句到位:

```cs
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Drawing;

```

接下来，为`CancellationToken`添加一个类级变量，并添加 Cancel 按钮事件处理程序:

```cs
private CancellationTokenSource _cancelToken = null;
private void cmdCancel_Click(object sender, EventArgs e)
{
  _cancelToken.Cancel();
}

```

过程和前面的例子一样:获取图片目录，创建输出目录，获取图片文件，旋转，保存到新目录。代替使用`Parallel.ForEach()`，这个新版本将使用`async`方法来完成工作，并且方法签名接受一个`CancellationToken`作为参数。输入以下代码:

```cs
private async void cmdProcess_Click(object sender, EventArgs e)
{
  _cancelToken = new CancellationTokenSource();
  var basePath = Directory.GetCurrentDirectory();
  var pictureDirectory =
    Path.Combine(basePath, "TestPictures");
  var outputDirectory =
    Path.Combine(basePath, "ModifiedPictures");
  //Clear out any existing files
  if (Directory.Exists(outputDirectory))
  {
    Directory.Delete(outputDirectory, true);
  }
  Directory.CreateDirectory(outputDirectory);
  string[] files = Directory.GetFiles(
    pictureDirectory, "*.jpg", SearchOption.AllDirectories);
  try
  {
    foreach(string file in files)
    {
      try
      {
        await ProcessFile(
         file, outputDirectory,_cancelToken.Token);
      }
      catch (OperationCanceledException ex)
      {
        Console.WriteLine(ex);
        throw;
      }
    }
  }
  catch (OperationCanceledException ex)
  {
    Console.WriteLine(ex);
    throw;
  }
  catch (Exception ex)
  {
    Console.WriteLine(ex);
    throw;
  }
  _cancelToken = null;
  this.Title = "Processing complete";
}

```

在初始设置之后，代码遍历文件，并为每个文件异步调用`ProcessFile()`。对`ProcessFile()`的调用被包装在一个`try` / `catch`块中，`CancellationToken`被传递给`ProcessFile()`方法。如果在`CancellationTokenSource`上执行`Cancel()`(比如当用户点击取消按钮时)，就会抛出`OperationCanceledException`。

Note

`try` / `catch`代码可以在调用链中的任何地方(您很快就会看到)。是将它放在第一次调用中还是放在异步方法本身中，这纯粹是偏好和应用需求的问题。

要添加的最后一个方法是`ProcessFile()`方法。

```cs
private async Task ProcessFile(string currentFile,
  string outputDirectory, CancellationToken token)
{
  string filename = Path.GetFileName(currentFile);
  using (Bitmap bitmap = new Bitmap(currentFile))
  {
    try
    {
      await Task.Run(() =>
      {
        Dispatcher?.Invoke(() =>
        {
          this.Title = $"Processing {filename}";
        });
        bitmap.RotateFlip(RotateFlipType.Rotate180FlipNone);
        bitmap.Save(Path.Combine(outputDirectory, filename));
      }
      ,token);
    }
    catch (OperationCanceledException ex)
    {
      Console.WriteLine(ex);
      throw;
    }
  }
}

```

这个方法使用了`Task.Run`命令的另一个重载，将`CancellationToken`作为一个参数。这个`Task.Run`命令被封装在一个`try` / `catch`块中(就像调用代码一样)，以防用户点击取消按钮。

### 异步流(新 8.0)

C# 8.0 中的新特性，流(在第 [20](20.html) 章中讨论)可以异步创建和使用。返回异步流的方法

*   是用`async`修饰符声明的

*   返回一个`IAsyncEnumerable<T>`

*   包含用于返回异步流中连续元素的`yield return`语句(在第 [8 章](08.html)中介绍)

举以下例子:

```cs
public static async IAsyncEnumerable<int> GenerateSequence()
{
  for (int i = 0; i < 20; i++)
  {
    await Task.Delay(100);
    yield return i;
  }
}

```

该方法被声明为`async`，返回一个`IAsyncEnumerable<int>`，并使用`yield return`从序列中返回整数。若要调用此方法，请将以下内容添加到调用代码中:

```cs
await foreach (var number in GenerateSequence())
{
  Console.WriteLine(number);
}

```

### 异步包装并等待

这一节包含了很多例子；这一部分的要点如下:

*   方法(以及 lambda 表达式或匿名方法)可以用`async`关键字标记，以使方法能够以非阻塞方式工作。

*   标有`async`关键字的方法(以及 lambda 表达式或匿名方法)将同步运行，直到遇到`await`关键字。

*   一个`async`方法可以有多个`await`上下文。

*   当遇到`await`表达式时，调用线程被挂起，直到等待的任务完成。同时，控制权将返回给方法的调用方。

*   关键字`await`将从视图中隐藏返回的`Task`对象，看起来像是直接返回底层返回值。没有返回值的方法简单地返回`void`。

*   参数检查和其他错误处理应该在方法的主要部分完成，实际的`async`部分被移到私有函数中。

*   对于堆栈变量，`ValueTask`比`Task`对象更有效，这可能会导致装箱和取消装箱。

*   作为命名约定，异步调用的方法应该用后缀`Async`标记。

## 摘要

本章从检查`System.Threading`名称空间的角色开始。正如您所了解的，当应用创建额外的执行线程时，结果是相关程序可以同时(看起来)执行许多任务。您还研究了几种保护线程敏感的代码块的方式，以确保共享资源不会变成不可用的伪数据单元。

然后，本章研究了一些新的模型，用于处理。NET 4.0，特别是任务并行库和 PLINQ。我总结了一下`async`和`await`关键字的作用。正如你所看到的，这些关键字在后台使用了许多类型的 TPL 框架；然而，编译器为您完成了创建复杂线程和同步代码的大部分工作。