# 六、理解继承和多态

第 5 章研究了 OOP 的第一个支柱:封装。那时，您学习了如何用构造函数和各种成员(字段、属性、方法、常量和只读字段)构建一个定义良好的类类型。本章将关注 OOP 的其余两个支柱:继承和多态。

首先，您将学习如何使用*继承*构建相关类的家族。正如您将看到的，这种形式的代码重用允许您在父类中定义公共功能，这些功能可以被子类利用，也可能被子类修改。在这个过程中，您将学习如何使用虚拟和抽象成员建立一个进入类层次结构的*多态接口*，以及显式转换的角色。

本章将通过研究。NET 基础类库:`System.Object`。

## 理解继承的基本机制

回想一下第 5 章中的内容，继承是 OOP 的一个方面，有助于代码重用。具体来说，代码重用有两种风格:继承(“is-a”关系)和包容/委托模型(“has-a”关系)。让我们从检查“是-a”关系的经典继承模型开始这一章。

当您在类之间建立“is-a”关系时，您正在构建两个或更多类类型之间的依赖关系。经典继承背后的基本思想是，可以使用现有的类作为起点来创建新的类。从一个简单的例子开始，创建一个名为`BasicInheritance.`的新控制台应用项目。现在假设您已经设计了一个名为`Car`的类，它模拟了汽车的一些基本细节。

```cs
namespace BasicInheritance
{
  // A simple base class.
  class Car
  {
    public readonly int MaxSpeed;
    private int _currSpeed;

    public Car(int max)
    {
      MaxSpeed = max;
    }
    public Car()
    {
      MaxSpeed = 55;
    }
    public int Speed
    {
      get { return _currSpeed; }
      set
      {
        _currSpeed = value;
        if (_currSpeed > MaxSpeed)
        {
          _currSpeed = MaxSpeed;
        }
      }
    }
  }
}

```

注意，`Car`类使用封装服务来控制对私有`currSpeed`字段的访问，该字段使用一个名为`Speed`的公共属性。此时，你可以锻炼你的`Car`类型如下:

```cs
using System;
using BasicInheritance;

Console.WriteLine("***** Basic Inheritance *****\n");
// Make a Car object, set max speed and current speed.
Car myCar = new Car(80) {Speed = 50};

// Print current speed.
Console.WriteLine("My car is going {0} MPH", myCar.Speed);
Console.ReadLine();

```

### 指定现有类的父类

现在假设您想要构建一个名为`MiniVan`的新类。像基本的`Car`一样，您希望定义`MiniVan`类来支持最大速度、当前速度和名为`Speed`的属性的数据，以允许对象用户修改对象的状态。显然，`Car`和`MiniVan`类是相关的；其实可以这么说，a`MiniVan`*就是-a* 型的`Car`。“is-a”关系(正式名称为*经典继承*)允许您构建扩展现有类功能的新类定义。

将作为新类基础的现有类被称为*基类*、*超类*或*父类*。基类的作用是为扩展它的类定义所有公共数据和成员。扩展类被正式称为*派生*或*子类*。在 C# 中，在类定义上使用冒号操作符来建立类之间的“is-a”关系。假设您已经编写了以下新的`MiniVan`类:

```cs
namespace BasicInheritance
{
  // MiniVan "is-a" Car.
  sealed class MiniVan : Car
  {
  }
}

```

目前，这个新类还没有定义任何成员。那么，从`Car`基类扩展`MiniVan`你得到了什么？简单地说，`MiniVan`对象现在可以访问父类中定义的每个公共成员。

Note

尽管构造函数通常被定义为公共的，但派生类从不继承父类的构造函数。构造函数仅用于构造定义它们的类，尽管派生类可以通过构造函数链调用它们。这将很快涉及到。

给定这两个类类型之间的关系，您现在可以像这样使用`MiniVan`类:

```cs
Console.WriteLine("***** Basic Inheritance *****\n");
.
// Now make a MiniVan object.
MiniVan myVan = new MiniVan {Speed = 10};
Console.WriteLine("My van is going {0} MPH", myVan.Speed);
Console.ReadLine();

```

同样，请注意，尽管您没有向`MiniVan`类添加任何成员，但是您可以直接访问父类的公共`Speed`属性，因此可以重用代码。这比创建一个与`Car`有相同成员的`MiniVan`类，比如一个`Speed`属性，要好得多。如果您确实在这两个类之间复制了代码，那么您现在需要维护两个代码体，这无疑是对您时间的浪费。

永远记住，继承保持封装；因此，下面的代码会导致编译器错误，因为私有成员永远不能从对象引用中访问:

```cs
Console.WriteLine("***** Basic Inheritance *****\n");
...
// Make a MiniVan object.
MiniVan myVan = new MiniVan();
myVan.Speed = 10;
Console.WriteLine("My van is going {0} MPH",
  myVan.Speed);

// Error! Can't access private members!
myVan._currSpeed = 55;
Console.ReadLine();

```

与此相关，如果`MiniVan`定义了自己的成员集，它仍然不能访问`Car`基类的任何私有成员。记住，私有成员只能被定义它的类访问*。例如，`MiniVan`中的以下方法会导致编译器错误:*

```cs
// MiniVan derives from Car.
class MiniVan : Car
{
  public void TestMethod()
  {
    // OK! Can access public members
    // of a parent within a derived type.
    Speed = 10;

    // Error! Cannot access private
    // members of parent within a derived type.
    _currSpeed = 10;
  }
}

```

### 关于多个基类

说到基类，重要的是要记住 C# 要求一个给定的类只有一个直接基类。不可能创建直接从两个或更多基类派生的类类型(这种技术在非托管 C++中受支持，被称为*多重继承*，或简称为 *MI* )。如果您试图创建一个指定两个直接父类的类，如下面的代码所示，您将收到编译器错误:

```cs
// Illegal! C# does not allow
// multiple inheritance for classes!
class WontWork
  : BaseClassOne, BaseClassTwo
{}

```

正如您将在第 8 章中看到的。NET 核心平台允许给定的类或结构实现任意数量的离散接口。通过这种方式，C# 类型可以展示许多行为，同时避免与 MI 相关的复杂性。使用这种技术，你可以构建复杂的接口层次来模拟复杂的行为(同样，参见第 8 章)。

### 使用 sealed 关键字

C# 提供了另一个关键字`sealed`，它阻止了继承的发生。当你将一个类标记为`sealed`时，编译器不允许你从这个类型派生。例如，假设您已经决定进一步扩展`MiniVan`类是没有意义的。

```cs
// The MiniVan class cannot be extended!
sealed class MiniVan : Car
{
}

```

如果您(或您的队友)试图从这个类派生，您将会收到一个编译时错误。

```cs
// Error! Cannot extend
// a class marked with the sealed keyword!
class DeluxeMiniVan
  : MiniVan
{
}

```

大多数情况下，在设计实用程序类时，密封一个类是最有意义的。例如，`System`名称空间定义了许多密封类，比如`String`类。因此，就像`MiniVan`一样，如果您试图构建一个扩展了`System.String`的新类，您将会收到一个编译时错误。

```cs
// Another error! Cannot extend
// a class marked as sealed!
class MyString
  : String
{
}

```

Note

在第 [4](04.html) 章中，你学到了 C# 结构总是隐式密封的(见表 [4-3](04.html#Tab3) )。因此，您永远不能从另一个结构派生一个结构，从一个结构派生一个类，或者从一个类派生一个结构。结构只能用于建模独立的、原子的、用户定义的数据类型。如果你想利用“是-a”关系，你必须使用类。

正如您所猜测的，在本章的剩余部分，您将会了解到更多关于继承的细节。现在，只要记住冒号操作符允许您建立基类/派生类关系，而`sealed`关键字防止后续继承发生。

## 重温 Visual Studio 类图

在第 [2](02.html) 章中，我简要提到了 Visual Studio 允许你在设计时可视化地建立基类/派生类关系。为了利用 IDE 的这一方面，第一步是在当前项目中包含一个新的类图文件。为此，访问项目➤添加新项菜单选项，并单击类图图标(在图 [6-1](#Fig1) ，我将文件从`ClassDiagram1.cd`重命名为`Cars.cd`)。

![img/340876_10_En_6_Chapter/340876_10_En_6_Fig1_HTML.jpg](img/340876_10_En_6_Chapter/340876_10_En_6_Fig1_HTML.jpg)

图 6-1。

插入新的类图

单击“添加”按钮后，您将看到一个空白的设计器图面。若要向类设计器添加类型，只需将每个文件从解决方案资源管理器窗口拖到图面上。还记得，如果您从可视化设计器中删除一个项(只需选择它并按 delete 键)，这不会破坏关联的源代码，而只是将该项从设计器图面中移除。图 [6-2](#Fig2) 显示了当前的等级结构。

![img/340876_10_En_6_Chapter/340876_10_En_6_Fig2_HTML.jpg](img/340876_10_En_6_Chapter/340876_10_En_6_Fig2_HTML.jpg)

图 6-2。

Visual Studio 的视觉设计器

除了简单地显示当前应用中类型的关系之外，回想一下第 2 章中的内容，您还可以使用类设计器工具箱和类细节窗口创建新类型并填充它们的成员。

如果您想在本书的剩余部分使用这些可视化工具，请随意。但是，一定要确保您分析了生成的代码，以便您对这些工具为您做了什么有一个坚实的理解。

## 理解 OOP 的第二个支柱:继承的细节

既然您已经看到了继承的基本语法，让我们创建一个更复杂的例子，并了解构建类层次结构的众多细节。为此，你将重用你在第 [5 章](05.html)中设计的`Employee`类。首先，创建一个名为 Employees 的新 C# 控制台应用项目。

接下来，将您在第 [5 章](05.html)的 EmployeeApp 示例中创建的`Employee.cs`、`Employee.Core.cs`和`EmployeePayTypeEnum.cs`文件复制到 Employees 项目中。

Note

之前。NET Core 中，需要在`.csproj`文件中引用的文件才能在 C# 项目中使用它们。与。NET Core 中，当前目录结构中的所有文件都会自动包含到您的项目中。只需将这两个文件从另一个项目复制到当前项目目录中，就足以将它们包含在您的项目中。

在开始构建一些派生类之前，有两个细节需要注意。因为最初的`Employee`类是在一个名为 EmployeeApp 的项目中创建的，所以该类被包装在一个同名的。NET 核心命名空间。第 [16 章](16.html)将详细考察名称空间；然而，为了简单起见，将当前名称空间(在所有三个文件位置中)重命名为`Employees`,以匹配您的新项目名称。

```cs
// Be sure to change the namespace name in both C# files!
namespace Employees
{
  partial class Employee
  {...}
}

```

Note

如果你在第 [5 章](05.html)中修改`Employee`类的时候移除了默认构造函数，确保把它添加回类中。

第二个细节是从章节 [5](05.html) 示例的`Employee`类的不同迭代中移除任何注释代码。

Note

作为健全性检查，编译并运行您的新项目，方法是在命令提示符下(在您的项目目录中)输入`dotnet run`，或者如果您使用的是 Visual Studio，则按 Ctrl+F5。程序此时不会做任何事情；但是，这将确保您没有任何编译器错误。

您的目标是创建一系列类来模拟公司中各种类型的员工。假设您想要利用`Employee`类的功能来创建两个新类(`SalesPerson`和`Manager`)。新的`SalesPerson`级“is-an”`Employee`(as is a`Manager`)。请记住，在经典继承模型下，基类(如`Employee`)用于定义所有后代共有的一般特征。子类(比如`SalesPerson`和`Manager`)扩展了这个通用功能，同时增加了更多的特定功能。

对于您的示例，您将假设`Manager`类通过记录股票期权的数量来扩展`Employee`，而`SalesPerson`类维护销售的数量。插入一个新的类文件(`Manager.cs`)，该文件用以下自动属性定义了`Manager`类:

```cs
// Managers need to know their number of stock options.
class Manager : Employee
{
  public int StockOptions { get; set; }
}

```

接下来，添加另一个新的类文件(`SalesPerson.cs`)，该文件使用拟合自动属性定义了`SalesPerson`类。

```cs
// Salespeople need to know their number of sales.
class SalesPerson : Employee
{
  public int SalesNumber { get; set; }
}

```

既然已经建立了“是-a”关系，`SalesPerson`和`Manager`已经自动继承了`Employee`基类的所有公共成员。举例来说，按如下方式更新顶级语句:

```cs
// Create a subclass object and access base class functionality.
Console.WriteLine("***** The Employee Class Hierarchy *****\n");
SalesPerson fred = new SalesPerson
{
  Age = 31, Name = "Fred", SalesNumber = 50
};

```

### 用 Base 关键字调用基类构造函数

目前，`SalesPerson`和`Manager`只能使用“免费”的默认构造函数来创建(参见第 [5 章](05.html))。记住这一点，假设您已经向`Manager`类型添加了一个新的七参数构造函数，调用如下:

```cs
...
// Assume Manager has a constructor matching this signature:
// (string fullName, int age, int empId,
// float currPay, string ssn, int numbOfOpts)
Manager chucky = new Manager("Chucky", 50, 92, 100000, "333-23-2322", 9000);

```

如果你看一下参数列表，你可以清楚地看到这些参数大部分应该存储在由`Employee`基类定义的成员变量中。为此，您可以在`Manager`类上实现这个自定义构造函数，如下所示:

```cs
public Manager(string fullName, int age, int empId,
               float currPay, string ssn, int numbOfOpts)
{
  // This property is defined by the Manager class.
  StockOptions = numbOfOpts;

  // Assign incoming parameters using the
  // inherited properties of the parent class.
  Id = empId;
  Age = age;
  Name = fullName;
  Pay = currPay;
  PayType = EmployeePayTypeEnum.Salaried;
  // OOPS! This would be a compiler error,
  // if the SSN property were read-only!
  SocialSecurityNumber = ssn;
}

```

这种方法的第一个问题是，如果您将任何属性定义为只读(例如，`SocialSecurityNumber`属性)，您就不能将传入的`string`参数赋给这个字段，如这个自定义构造函数的最终代码语句所示。

第二个问题是，你已经间接地创建了一个相当低效的构造函数，假设在 C# 下，除非你另有说明，否则基类的默认构造函数是在派生构造函数的逻辑被执行之前自动调用的。在这之后，当前的实现访问`Employee`基类的许多公共属性来建立它的状态。因此，在创建一个`Manager`对象的过程中，您实际上已经完成了八次点击(六次继承属性和两次构造函数调用)!

为了帮助优化派生类的创建，最好实现子类构造函数来显式调用适当的自定义基类构造函数，而不是默认构造函数。这样，您就能够减少对继承的初始化成员的调用次数(从而节省处理时间)。首先，确保您的`Employee`父类具有以下六个参数的构造函数:

```cs
// Add to the Employee base class.
public Employee(string name, int age, int id, float pay, string empSsn, EmployeePayTypeEnum payType)
{
  Name = name;
  Id = id;
  Age = age;
  Pay = pay;
  SocialSecurityNumber = empSsn;
  PayType = payType;
}

```

现在，让我们改进`Manager`类型的定制构造函数，使用`base`关键字调用这个构造函数。

```cs
public Manager(string fullName, int age, int empId,
  float currPay, string ssn, int numbOfOpts)
  : base(fullName, age, empId, currPay, ssn,
         EmployeePayTypeEnum.Salaried)
{
  // This property is defined by the Manager class.
  StockOptions = numbOfOpts;
}

```

这里，`base`关键字挂在构造函数签名上(很像在第 [5](05.html) 章中讨论的使用`this`关键字链接单个类上的构造函数的语法)，它总是指示派生构造函数正在将数据传递给直接的父构造函数。在这种情况下，您显式地调用了由`Employee`定义的六参数构造函数，并在创建子类的过程中节省了不必要的调用。此外，您向`Manager`类添加了一个特定的行为，因为支付类型总是被设置为`Salaried.`，自定义的`SalesPerson`构造函数看起来几乎相同，除了支付类型被设置为`Commission.`

```cs
// As a general rule, all subclasses should explicitly call an appropriate
// base class constructor.
public SalesPerson(string fullName, int age, int empId,
  float currPay, string ssn, int numbOfSales)
  : base(fullName, age, empId, currPay, ssn,
         EmployeePayTypeEnum.Commission)
{
  // This belongs with us!
  SalesNumber = numbOfSales;
}

```

Note

每当子类想要访问由父类定义的公共或受保护成员时，可以使用`base`关键字。此关键字的使用不限于构造函数逻辑。在本章后面的多态性检查中，你会看到以这种方式使用`base`的例子。

最后，回想一下，一旦您将自定义构造函数添加到类定义中，默认构造函数就会被自动移除。因此，一定要为`SalesPerson`和`Manager`类型重新定义默认构造函数。这里有一个例子:

```cs
// Add back the default ctor
// in the Manager class as well.
public SalesPerson() {}

```

### 保守家庭秘密:受保护的关键字

正如您已经知道的，公共项可以从任何地方直接访问，而私有项只能由定义它们的类访问。回想一下第 5 章中的内容，C# 领先于许多其他现代对象语言，并提供了一个额外的关键字来定义成员可访问性:`protected`。

当基类定义受保护的数据或受保护的成员时，它建立了一组可以被任何后代直接访问的项。如果你想让`SalesPerson`和`Manager`子类直接访问由`Employee`定义的数据扇区，你可以如下更新原始的`Employee`类定义(在`EmployeeCore.cs`文件中):

```cs
// Protected state data.
partial class Employee
{
  // Derived classes can now directly access this information.
  protected string EmpName;
  protected int EmpId;
  protected float CurrPay;
  protected int EmpAge;
  protected string EmpSsn;
  protected EmployeePayTypeEnum EmpPayType;...
}

```

Note

约定是受保护的成员被命名为 Pascal-Case(`EmpName`)而不是下划线-Camel-Case ( `_empName`)。这不是语言的要求，而是一种常见的代码风格。如果您决定像我在这里所做的那样更新名称，请确保重命名属性中的所有支持方法，以匹配 Pascal 大小写受保护的属性。

在基类中定义受保护成员的好处是，派生类型不再需要使用公共方法或属性间接访问数据。当然，可能的问题是，当派生类型可以直接访问其父类型的内部数据时，就有可能意外地绕过公共属性中的现有业务规则。当您定义受保护成员时，您在父类和子类之间创建了一个信任级别，因为编译器不会捕捉到任何违反您的类型的业务规则的情况。

最后，请理解，就对象用户而言，受保护的数据被视为私有数据(因为用户“不属于”家庭)。因此，以下行为是非法的:

```cs
// Error! Can't access protected data from client code.
Employee emp = new Employee();
emp.empName = "Fred";

```

Note

虽然`protected`字段数据可以打破封装，但是定义`protected`方法是非常安全的(也是非常有用的)。在构建类层次结构时，通常定义一组只供派生类型使用的方法，而不是供外界使用的方法。

### 添加密封类

回想一下，一个*密封的*类不能被其他类扩展。如上所述，这种技术最常用于设计实用程序类。然而，当构建类层次结构时，您可能会发现继承链中的某个分支应该被“封顶”，因为进一步扩展血统是没有意义的。例如，假设您已经向您的程序(`PtSalesPerson`)添加了另一个类，它扩展了现有的`SalesPerson`类型。图 [6-3](#Fig3) 显示了当前的更新。

![img/340876_10_En_6_Chapter/340876_10_En_6_Fig3_HTML.jpg](img/340876_10_En_6_Chapter/340876_10_En_6_Fig3_HTML.jpg)

图 6-3。

PtSalesPerson 类

是一个代表兼职销售人员的类。为了便于讨论，假设您希望确保没有其他开发人员能够从`PTSalesPerson`继承子类。为了防止其他人扩展一个类，使用`sealed`关键字。

```cs
sealed class PtSalesPerson : SalesPerson
{
  public PtSalesPerson(string fullName, int age, int empId,
    float currPay, string ssn, int numbOfSales)
    : base(fullName, age, empId, currPay, ssn, numbOfSales)
  {
  }
  // Assume other members here...
}

```

### 了解记录类型的继承(新 9.0)

新的 C# 9.0 记录类型也支持继承。要探索这一点，请暂停 Employees 项目中的工作，并创建一个名为 RecordInheritance 的新控制台应用。添加两个名为`Car.cs`和`MiniVan.cs,`的新文件，并将以下记录定义代码添加到各自的文件中:

```cs
//Car.cs
namespace RecordInheritance
{
  //Car record type
  public record Car
  {
    public string Make { get; init; }
    public string Model { get; init; }
    public string Color { get; init; }

    public Car(string make, string model, string color)
    {
      Make = make;
      Model = model;
      Color = color;
    }
  }
}

//MiniVan.cs
namespace RecordInheritance
{
    //MiniVan record type
    public sealed record MiniVan : Car
    {
        public int Seating { get; init; }
        public MiniVan(string make, string model, string color, int seating) : base(make, model, color)
        {
            Seating = seating;
        }
    }
}

```

注意，这些使用记录类型的例子和前面使用类的例子没有太大的区别。属性和方法上的受保护访问修饰符行为相同，记录类型上的密封访问修饰符防止其他记录类型从密封记录类型派生。您还会发现本章的其余主题也与继承的记录类型有关。这是因为记录类型只是不可变类的一种特殊类型(详见第 [5](05.html) 章)。

记录类型还包括对其基类的隐式转换，如下面的代码所示:

```cs
using System;
using RecordInheritance;

Console.WriteLine("Record type inheritance!");

Car c = new Car("Honda","Pilot","Blue");
MiniVan m = new MiniVan("Honda", "Pilot", "Blue",10);
Console.WriteLine($"Checking MiniVan is-a Car:{m is Car}");

```

正如所料，检查`m`的输出是`Car`返回 true，如下面的输出所示:

```cs
Record type inheritance!
Checking minvan is-a car:True

```

重要的是要注意，即使记录类型是专门的类，也不能在类和记录之间交叉继承。明确地说，类不能从记录类型继承，记录类型也不能从类继承。考虑下面的代码，注意最后两个例子不能编译:

```cs
namespace RecordInheritance
{
  public class TestClass { }
  public record TestRecord { }

  //Classes cannot inherit records
  // public class Test2 : TestRecord { }

  //Records types cannot inherit from classes
  // public record Test2 : TestClass {  }
}

```

继承也适用于位置记录类型。在项目中创建一个名为`PositionalRecordTypes.cs`的新文件。将以下代码添加到您的文件中:

```cs
namespace RecordInheritance
{
  public record PositionalCar (string Make, string Model, string Color);
  public record PositionalMiniVan (string Make, string Model, string Color)
    : PositionalCar(Make, Model, Color);
}

```

添加以下代码，以说明您已经知道的事实，即位置记录类型的工作方式与记录类型完全相同:

```cs
PositionalCar pc = new PositionalCar("Honda", "Pilot", "Blue");
PositionalMiniVan pm = new PositionalMiniVan("Honda", "Pilot", "Blue", 10);
Console.WriteLine($"Checking PositionalMiniVan is-a PositionalCar:{pm is PositionalCar}");

```

#### 与继承的记录类型相等

回想一下第 [5](05.html) 章，记录类型使用值语义来确定相等性。关于记录类型的另一个细节是记录的*类型*是平等考虑的一部分。例如，考虑以下平凡的例子:

```cs
public record MotorCycle(string Make, string Model);
public record Scooter(string Make, string Model) : MotorCycle(Make,Model);

```

忽略通常继承的类扩展基类的事实，这些简单的例子定义了具有相同属性的两种不同的记录类型。当创建属性值相同的实例时，由于类型不同，它们无法通过相等性测试。以下面的代码和结果为例:

```cs
MotorCycle mc = new MotorCycle("Harley","Lowrider");
Scooter sc = new Scooter("Harley", "Lowrider");
Console.WriteLine($"MotorCycle and Scooter are equal: {Equals(mc,sc)}");

Record type inheritance!
MotorCycle and Scooter are equal: False

```

## 包容/委托的编程

回想一下，代码重用有两种形式。你刚刚探索了经典的“是”的关系。在检查 OOP 的第三个支柱(多态性)之前，让我们检查一下“has-a”关系(也称为*包容/委托模型*或*聚合*)。返回到 Employees 项目，创建一个名为`BenefitPackage.cs`的新文件，并添加代码来模拟雇员福利包，如下所示:

```cs
namespace Employees
{
  // This new type will function as a contained class.
  class BenefitPackage
  {
    // Assume we have other members that represent
    // dental/health benefits, and so on.
    public double ComputePayDeduction()
    {
      return 125.0;
    }
  }
}

```

显然，在`BenefitPackage`类和雇员类型之间建立“is-a”关系是很奇怪的。(`Employee`“is-a”`BenefitPackage`？我不这么认为。)然而，应该清楚的是，可以在两者之间建立某种关系。简而言之，你想表达的想法是，每个员工都“有-a”`BenefitPackage`。为此，您可以如下更新`Employee`类定义:

```cs
// Employees now have benefits.
partial class Employee
{
  // Contain a BenefitPackage object.
  protected BenefitPackage EmpBenefits = new BenefitPackage();
...
}

```

至此，您已经成功地包含了另一个对象。但是，向外界公开所包含对象的功能需要委托。委托是简单地将公共成员添加到使用被包含对象功能的包含类的行为。

例如，您可以更新`Employee`类，使用自定义属性公开包含的`empBenefits`对象，并使用名为`GetBenefitCost()`的新方法在内部使用其功能。

```cs
partial class Employee
{
  // Contain a BenefitPackage object.
  protected BenefitPackage EmpBenefits = new BenefitPackage();

  // Expose certain benefit behaviors of object.
  public double GetBenefitCost()
     => EmpBenefits.ComputePayDeduction();

  // Expose object through a custom property.
  public BenefitPackage Benefits
  {
    get { return EmpBenefits; }
    set { EmpBenefits = value; }
  }
}

```

在下面更新的`code`中，注意如何与由`Employee`类型定义的内部`BenefitsPackage`类型交互:

```cs
Console.WriteLine("***** The Employee Class Hierarchy *****\n");
...
Manager chucky = new Manager("Chucky", 50, 92, 100000, "333-23-2322", 9000);
double cost = chucky.GetBenefitCost();
Console.WriteLine($"Benefit Cost: {cost}");
Console.ReadLine();

```

### 了解嵌套类型定义

第 [5](05.html) 章简要提到了嵌套类型的概念，这是对你刚刚检查过的“has-a”关系的一个改进。在 C#(以及其他。NET 语言)，可以直接在类或结构的范围内定义类型(枚举、类、接口、结构或委托)。当您这样做时，嵌套(或“内部”)类型被视为嵌套(或“外部”)类的成员，并且在运行时看来，可以像任何其他成员(字段、属性、方法和事件)一样进行操作。用于嵌套类型的语法非常简单。

```cs
public class OuterClass
{
  // A public nested type can be used by anybody.
  public class PublicInnerClass {}

  // A private nested type can only be used by members
  // of the containing class.
  private class PrivateInnerClass {}
}

```

尽管语法相当清楚，但理解您为什么想要这样做可能并不容易。要理解这种技术，请思考嵌套类型的以下特征:

*   嵌套类型允许您完全控制内部类型的访问级别，因为它们可以被私有声明(回想一下，非嵌套类不能使用`private`关键字声明)。

*   因为嵌套类型是包含类的成员，所以它可以访问包含类的私有成员。

*   通常，嵌套类型只在作为外部类的助手时有用，并不打算供外部世界使用。

当一个类型嵌套另一个类类型时，它可以创建该类型的成员变量，就像对任何数据点一样。但是，如果要使用包含类型之外的嵌套类型，必须用嵌套类型的范围来限定它。考虑以下代码:

```cs
// Create and use the public inner class. OK!
OuterClass.PublicInnerClass inner;
inner = new OuterClass.PublicInnerClass();

// Compiler Error! Cannot access the private class.
OuterClass.PrivateInnerClass inner2;
inner2 = new OuterClass.PrivateInnerClass();

```

为了在雇员的例子中使用这个概念，假设您现在已经将`BenefitPackage`直接嵌套在了`Employee`类类型中。

```cs
partial class Employee
{
  public class BenefitPackage
  {
    // Assume we have other members that represent
    // dental/health benefits, and so on.
    public double ComputePayDeduction()
    {
      return 125.0;
    }
  }
...
}

```

嵌套过程可以像你要求的那样“深”。例如，假设您想要创建一个名为`BenefitPackageLevel`的枚举，它记录了员工可能选择的各种福利级别。为了以编程方式强制`Employee`、`BenefitPackage`和`BenefitPackageLevel`之间的紧密连接，可以如下嵌套枚举:

```cs
// Employee nests BenefitPackage.
public partial class Employee
{
  // BenefitPackage nests BenefitPackageLevel.
  public class BenefitPackage
  {
    public enum BenefitPackageLevel
    {
      Standard, Gold, Platinum
    }

    public double ComputePayDeduction()
    {
      return 125.0;
    }
  }
...
}

```

由于嵌套关系，请注意如何要求您使用此枚举:

```cs
...
// Define my benefit level.
Employee.BenefitPackage.BenefitPackageLevel myBenefitLevel =
    Employee.BenefitPackage.BenefitPackageLevel.Platinum;

```

太棒了！至此，您已经接触了许多关键字(和概念)，它们允许您通过传统的继承、包容和嵌套类型来构建相关类型的层次结构。如果细节现在还不清楚，不要担心。在本书的剩余部分，您将构建一些额外的层次结构。接下来，让我们检查 OOP 的最后一个支柱:多态性。

## 理解 OOP 的第三个支柱:C# 的多态支持

回想一下，`Employee`基类定义了一个名为`GiveBonus()`的方法，最初实现如下(在更新它以使用属性模式之前):

```cs
public partial class Employee
{
  public void GiveBonus(float amount) => _currPay += amount;
...
}

```

因为这个方法是用`public`关键字定义的，所以现在可以给销售人员和经理(以及兼职销售人员)发放奖金。

```cs
Console.WriteLine("***** The Employee Class Hierarchy *****\n");

// Give each employee a bonus?
Manager chucky = new Manager("Chucky", 50, 92, 100000, "333-23-2322", 9000);
chucky.GiveBonus(300);
chucky.DisplayStats();
Console.WriteLine();

SalesPerson fran = new SalesPerson("Fran", 43, 93, 3000, "932-32-3232", 31);
fran.GiveBonus(200);
fran.DisplayStats();
Console.ReadLine();

```

当前设计的问题是，公共继承的`GiveBonus()`方法对所有子类的操作都是一样的。理想情况下，销售人员或兼职销售人员的奖金应该考虑销售数量。或许经理们应该获得额外的股票期权，同时增加工资。考虑到这一点，您突然面临一个有趣的问题:“相关类型如何对同一请求做出不同的响应？”再次，很高兴你问了！

### 使用虚拟和覆盖关键字

多态性为子类提供了一种方法，通过使用称为*方法覆盖*的过程，来定义其基类定义的方法的自己的版本。要改进您当前的设计，您需要理解`virtual`和`override`关键字的含义。如果一个基类想要定义一个方法，使得*可以被子类*(但不是必须)覆盖，它必须用`virtual`关键字标记这个方法。

```cs
partial class Employee
{
  // This method can now be "overridden" by a derived class.
  public virtual void GiveBonus(float amount)
  {
    Pay += amount;
  }
...
}

```

Note

标有`virtual`关键字的方法(不足为奇)被称为*虚拟方法*。

当子类想要改变虚拟方法的实现细节时，它使用关键字`override`来实现。例如，`SalesPerson`和`Manager`可以如下覆盖`GiveBonus()`(假设`PTSalesPerson`不会覆盖`GiveBonus()`，因此，简单地继承由`SalesPerson`定义的版本):

```cs
using System;
class SalesPerson : Employee
{
...
  // A salesperson's bonus is influenced by the number of sales.
  public override void GiveBonus(float amount)
  {
    int salesBonus = 0;
    if (SalesNumber >= 0 && SalesNumber <= 100)
      salesBonus = 10;
    else
    {
      if (SalesNumber >= 101 && SalesNumber <= 200)
        salesBonus = 15;
      else
        salesBonus = 20;
    }
    base.GiveBonus(amount * salesBonus);
  }
}

class Manager : Employee
{
...
  public override void GiveBonus(float amount)
  {
    base.GiveBonus(amount);
    Random r = new Random();
    StockOptions += r.Next(500);
  }
}

```

注意每个被覆盖的方法是如何使用`base`关键字自由利用默认行为的。

这样，您不需要完全重新实现`GiveBonus()`背后的逻辑，而是可以重用(并且可能扩展)父类的默认行为。

还假设`Employee`类的当前`DisplayStats()`方法已经被虚拟声明。

```cs
public virtual void DisplayStats()
{
    Console.WriteLine("Name: {0}", Name);
    Console.WriteLine("Id: {0}", Id);
    Console.WriteLine("Age: {0}", Age);
    Console.WriteLine("Pay: {0}", Pay);
    Console.WriteLine("SSN: {0}", SocialSecurityNumber);
}

```

通过这样做，每个子类都可以覆盖这个方法来显示销售额(对于销售人员)和当前股票期权(对于经理)。例如，考虑一下`Manager`的`DisplayStats()`方法版本(`SalesPerson`类将以类似的方式实现`DisplayStats()`来显示销售额)。

```cs
//Manager.cs
public override void DisplayStats()
{
  base.DisplayStats();
  Console.WriteLine("Number of Stock Options: {0}", StockOptions);
}
//SalesPerson.cs
public override void DisplayStats()
{
  base.DisplayStats();
  Console.WriteLine("Number of Sales: {0}", SalesNumber);
}

```

现在每个子类都可以解释这些虚方法对自己的意义，每个对象实例都表现为一个更加独立的实体。

```cs
Console.WriteLine("***** The Employee Class Hierarchy *****\n");

// A better bonus system!
Manager chucky = new Manager("Chucky", 50, 92, 100000, "333-23-2322", 9000);
chucky.GiveBonus(300);
chucky.DisplayStats();
Console.WriteLine();

SalesPerson fran = new SalesPerson("Fran", 43, 93, 3000, "932-32-3232", 31);
fran.GiveBonus(200);
fran.DisplayStats();
Console.ReadLine();

```

以下输出显示了到目前为止您的应用可能的测试运行:

```cs
***** The Employee Class Hierarchy *****
Name: Chucky
ID: 92
Age: 50
Pay: 100300
SSN: 333-23-2322
Number of Stock Options: 9337

Name: Fran
ID: 93
Age: 43
Pay: 5000
SSN: 932-32-3232
Number of Sales: 31

```

### 用 Visual Studio/Visual Studio 代码重写虚拟成员

您可能已经注意到，当您重写一个成员时，您必须回忆每个参数的类型——更不用说方法名和参数传递约定(`ref`、`out`和`params`)。Visual Studio 和 Visual Studio 代码都有一个有用的功能，您可以在重写虚拟成员时加以利用。如果在类类型的范围内键入单词`override`(然后按空格键)，IntelliSense 将自动显示在父类中定义的所有可重写成员的列表，不包括已经被重写的方法。

当您选择一个成员并按下 Enter 键时，IDE 会自动为您填充方法存根。请注意，您还会收到一条代码语句，该语句调用您的父版本的虚拟成员(如果不需要，您可以随意删除这一行)。例如，如果您在重写`DisplayStats()`方法时使用了这种技术，您可能会发现以下自动生成的代码:

```cs
public override void DisplayStats()
{
  base.DisplayStats();
}

```

### 密封虚拟成员

回想一下，`sealed`关键字可以应用于一个类类型，以防止其他类型通过继承来扩展它的行为。您可能还记得，您密封了`PtSalesPerson`,因为您认为其他开发人员进一步扩展这条继承线是没有意义的。

另一方面，有时您可能不想密封整个类，而只想防止派生类型重写特定的虚方法。例如，假设您不希望兼职销售人员获得定制的奖金。为了防止`PTSalesPerson`类覆盖虚拟的`GiveBonus()`方法，您可以有效地将该方法密封在`SalesPerson`类中，如下所示:

```cs
// SalesPerson has sealed the GiveBonus() method!
class SalesPerson : Employee
{
...
  public override sealed void GiveBonus(float amount)
  {
    ...
  }
}

```

这里，`SalesPerson`确实覆盖了在`Employee`类中定义的虚拟`GiveBonus()`方法；但是，它已经明确标记为密封。因此，如果您试图在`PtSalesPerson`类中覆盖此方法，您将会收到编译时错误，如以下代码所示:

```cs
sealed class PTSalesPerson : SalesPerson
{
...
  // Compiler error! Can't override this method
  // in the PTSalesPerson class, as it was sealed.
  public override void GiveBonus(float amount)
  {
  }
}

```

### 理解抽象类

目前，`Employee`基类已经被设计为向它的后代提供各种数据成员，以及提供两个可能被给定后代覆盖的虚方法(`GiveBonus()`和`DisplayStats()`)。虽然这一切都很好，但目前的设计有一个相当奇怪的副产品；您可以直接创建`Employee`基类的实例。

```cs
// What exactly does this mean?
Employee X = new Employee();

```

在这个例子中，`Employee`基类的唯一真正目的是为所有子类定义公共成员。十有八九，你不希望任何人创建这个类的直接实例，原因是`Employee`类型本身是一个过于一般化的概念。例如，如果我走到你面前说“我是一名员工”，我敢打赌你的第一个问题会是“你是哪种*员工？你是顾问、培训师、行政助理、文字编辑还是白宫助理？”*

鉴于许多基类往往是相当模糊的实体，对于这个例子来说，更好的设计是防止在代码中直接创建新的`Employee`对象。在 C# 中，您可以通过在类定义中使用`abstract`关键字来以编程方式强制实现这一点，从而创建一个*抽象基类*。

```cs
// Update the Employee class as abstract
// to prevent direct instantiation.
abstract partial class Employee
{
  ...
}

```

这样，如果您现在试图创建一个`Employee`类的实例，就会出现一个编译时错误。

```cs
// Error! Cannot create an instance of an abstract class!
Employee X = new Employee();

```

乍一看，定义一个不能直接创建实例的类似乎很奇怪。然而，回想一下，基类(抽象或非抽象)是有用的，因为它们包含了派生类型的所有公共数据和功能。使用这种形式的抽象，你能够模拟一个雇员的“想法”是完全有效的；它只是不是一个具体的实体。还要明白，虽然你不能直接*创建一个抽象类的实例，但是当派生类被创建时，它仍然在内存中被组装。因此，当派生类被分配时，抽象类定义任意数量的被间接调用*的构造函数是非常好的(也是常见的)。**

至此，您已经构建了一个相当有趣的员工层次结构。在本章的后面，当你研究 C# 转换规则的时候，你会给这个应用添加更多的功能。在此之前，图 [6-4](#Fig4) 说明了您当前设计的症结所在。

![img/340876_10_En_6_Chapter/340876_10_En_6_Fig4_HTML.jpg](img/340876_10_En_6_Chapter/340876_10_En_6_Fig4_HTML.jpg)

图 6-4。

员工层级

### 理解多态接口

当一个类被定义为抽象基类时(通过`abstract`关键字)，它可以定义任意数量的*抽象成员*。当你想定义一个*不*提供默认实现，但是*必须*由每个派生类负责的成员时，可以使用抽象成员。通过这样做，您在每个后代上实施了一个*多态接口*，让他们去处理提供抽象方法背后的细节的任务。

简单来说，抽象基类的多态接口只是指它的一组虚拟和抽象方法。这比第一眼看到的要有趣得多，因为 OOP 的这一特性允许您构建易于扩展和灵活的软件应用。举例来说，在 OOP 支柱概述中，你将实现(并稍微修改)第 [5](05.html) 章中简要介绍的形状层次。首先，创建一个名为 Shapes 的新 C# 控制台应用项目。

在图 [6-5](#Fig5) 中，注意到`Hexagon`和`Circle`类型都扩展了`Shape`基类。像任何基类一样，`Shape`定义了许多成员(在本例中是一个`PetName`属性和一个`Draw()`方法)，这些成员是所有后代共有的。

![img/340876_10_En_6_Chapter/340876_10_En_6_Fig5_HTML.jpg](img/340876_10_En_6_Chapter/340876_10_En_6_Fig5_HTML.jpg)

图 6-5。

形状层次结构

与雇员层次结构非常相似，您应该能够判断出您不希望允许对象用户直接创建`Shape`的实例，因为它是一个太抽象的概念。同样，为了防止直接创建`Shape`类型，您可以将其定义为一个抽象类。同样，假设您希望派生类型唯一地响应`Draw()`方法，让我们将其标记为`virtual`并定义一个默认实现。请注意，构造函数被标记为 protected，因此它只能从派生类中调用。

```cs
// The abstract base class of the hierarchy.
abstract class Shape
{
  protected Shape(string name = "NoName")
  { PetName = name; }

  public string PetName { get; set; }

  // A single virtual method.
  public virtual void Draw()
  {
    Console.WriteLine("Inside Shape.Draw()");
  }
}

```

注意，虚拟的`Draw()`方法提供了一个默认的实现，它只是打印出一条消息，通知您正在调用`Shape`基类中的`Draw()`方法。现在回想一下，当一个方法用`virtual`关键字标记时，该方法提供了一个所有派生类型自动继承的默认实现。如果子类这样选择，它*可以*覆盖该方法，但是*没有*来覆盖该方法。鉴于此，考虑下面的`Circle`和`Hexagon`类型的实现:

```cs
// Circle DOES NOT override Draw().
class Circle : Shape
{
  public Circle() {}
  public Circle(string name) : base(name){}
}

// Hexagon DOES override Draw().
class Hexagon : Shape
{
  public Hexagon() {}
  public Hexagon(string name) : base(name){}
  public override void Draw()
  {
    Console.WriteLine("Drawing {0} the Hexagon", PetName);
  }
}

```

当你再次记住子类*从来不需要*覆盖虚方法时，抽象方法的用处就变得非常清楚了(就像在`Circle`的例子中一样)。因此，如果您创建一个`Hexagon`和`Circle`类型的实例，您会发现`Hexagon`知道如何正确地“绘制”自己，或者至少向控制台输出一条适当的消息。然而`Circle`却不止是有点困惑。

```cs
Console.WriteLine("***** Fun with Polymorphism *****\n");

Hexagon hex = new Hexagon("Beth");
hex.Draw();
Circle cir = new Circle("Cindy");
// Calls base class implementation!
cir.Draw();
Console.ReadLine();

```

现在考虑前面代码的以下输出:

```cs
***** Fun with Polymorphism *****
Drawing Beth the Hexagon
Inside Shape.Draw()

```

很明显，对于当前的等级制度来说，这不是一个明智的设计。为了强制每个子类覆盖`Draw()`方法，您可以将`Draw()`定义为`Shape`类的一个抽象方法，根据定义，这意味着您不提供任何默认实现。在 C# 中，要将一个方法标记为抽象的，可以使用`abstract`关键字。请注意，抽象成员不提供任何实现。

```cs
abstract class Shape
{
  // Force all child classes to define how to be rendered.
  public abstract void Draw();
  ...
}

```

Note

抽象方法只能在抽象类中定义。如果您尝试不这样做，您将被发出一个编译器错误。

标有`abstract`的方法是纯协议。它们只是定义名称、返回类型(如果有的话)和参数集(如果需要的话)。这里，抽象的`Shape`类通知派生的类型“我有一个名为`Draw()`的方法，它没有参数，也不返回任何东西。如果你从我这里得到，你就能弄清楚细节。”

鉴于此，您现在有义务在`Circle`类中覆盖`Draw()`方法。如果不这样做，`Circle`也被认为是一个不可创建的抽象类型，必须用`abstract`关键字来修饰(这在本例中显然没有用)。下面是代码更新:

```cs
// If we did not implement the abstract Draw() method, Circle would also be
// considered abstract, and would have to be marked abstract!
class Circle : Shape
{
  public Circle() {}
  public Circle(string name) : base(name) {}
  public override void Draw()
  {
    Console.WriteLine("Drawing {0} the Circle", PetName);
  }
}

```

简而言之，你现在可以假设从`Shape`派生的任何东西确实有一个唯一版本的`Draw()`方法。为了说明多态性的全部情况，考虑下面的代码:

```cs
Console.WriteLine("***** Fun with Polymorphism *****\n");

// Make an array of Shape-compatible objects.
Shape[] myShapes = {new Hexagon(), new Circle(), new Hexagon("Mick"),
  new Circle("Beth"), new Hexagon("Linda")};

// Loop over each item and interact with the
// polymorphic interface.
foreach (Shape s in myShapes)
{
  s.Draw();
}
Console.ReadLine();

```

下面是修改后的代码的输出:

```cs
***** Fun with Polymorphism *****
Drawing NoName the Hexagon
Drawing NoName the Circle
Drawing Mick the Hexagon
Drawing Beth the Circle
Drawing Linda the Hexagon

```

这段代码很好地说明了多态性。虽然不能直接*创建一个抽象基类的实例(T0)，但是你可以自由地存储对任何带有抽象基类变量的子类的引用。因此，当您创建一个由`Shape`组成的数组时，该数组可以保存从`Shape`基类派生的任何对象(如果您试图将`Shape`不兼容的对象放入该数组，您会收到一个编译器错误)。*

 *鉴于`myShapes`数组中的所有元素确实都是从`Shape`派生的，你知道它们都支持相同的“多态接口”(或者更直白地说，它们都有一个`Draw()`方法)。当您迭代`Shape`引用的数组时，底层类型是在运行时确定的。此时，内存中调用了正确版本的`Draw()`方法。

这种技术也使得安全地扩展当前层次变得简单。例如，假设您从抽象的`Shape`基类(`Triangle`、`Square`等)派生了更多的类。).由于多态接口，您的`foreach`循环中的代码不需要做任何改动，因为编译器强制要求只有与`Shape`兼容的类型才放在`myShapes`数组中。

### 了解成员隐藏

C# 提供了一个与方法覆盖逻辑相反的功能，称为*隐藏*。从形式上讲，如果一个派生类定义了一个与基类中定义的成员相同的成员，那么派生类就隐藏了父类的版本。在现实世界中，当您从一个不是您(或您的团队)自己创建的类中创建子类时(例如当您购买第三方软件包时)，这种情况发生的可能性最大。

为了便于说明，假设您从同事(或同学)那里收到一个名为`ThreeDCircle`的类，该类定义了一个名为`Draw()`的不带参数的子例程。

```cs
class ThreeDCircle
{
  public void Draw()
  {
    Console.WriteLine("Drawing a 3D Circle");
  }
}

```

你认为`ThreeDCircle`是-a`Circle`，所以你从你现有的`Circle`类型中派生出来。

```cs
class ThreeDCircle : Circle
{
  public void Draw()
  {
    Console.WriteLine("Drawing a 3D Circle");
  }
}

```

重新编译后，您会发现以下警告:

```cs
'ThreeDCircle.Draw()' hides inherited member 'Circle.Draw()'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword.

```

问题是您有一个派生类(`ThreeDCircle`)，它包含一个与继承方法相同的方法。要解决这个问题，您有几个选择。您可以使用`override`关键字简单地更新`Draw()`的子版本(正如编译器所建议的)。使用这种方法，`ThreeDCircle`类型能够根据需要扩展父类的默认行为。但是，如果您没有访问定义基类的代码的权限(这也是许多第三方库中的情况)，您将无法作为虚拟成员修改`Draw()`方法，因为您没有访问代码文件的权限！

作为一种选择，您可以将`new`关键字包含到派生类型的违规`Draw()`成员中(在本例中为`ThreeDCircle`)。这样做明确表明派生类型的实现是有意设计来有效忽略父版本的(同样，在现实世界中，如果外部软件以某种方式与您当前的软件冲突，这可能是有帮助的)。

```cs
// This class extends Circle and hides the inherited Draw() method.
class ThreeDCircle : Circle
{
  // Hide any Draw() implementation above me.
  public new void Draw()
  {
    Console.WriteLine("Drawing a 3D Circle");
  }
}

```

还可以将`new`关键字应用于从基类继承的任何成员类型(字段、常量、静态成员或属性)。作为进一步的例子，假设`ThreeDCircle`想要隐藏继承的`PetName`属性。

```cs
class ThreeDCircle : Circle
{
  // Hide the PetName property above me.
  public new string PetName { get; set; }

  // Hide any Draw() implementation above me.
  public new void Draw()
  {
    Console.WriteLine("Drawing a 3D Circle");
  }
}

```

最后，请注意，仍有可能使用显式强制转换来触发被隐藏成员的基类实现，如下一节所述。以下代码显示了一个示例:

```cs
...
// This calls the Draw() method of the ThreeDCircle.
ThreeDCircle o = new ThreeDCircle();
o.Draw();

// This calls the Draw() method of the parent!
((Circle)o).Draw();
Console.ReadLine();

```

## 了解基类/派生类转换规则

现在你可以构建一个相关类类型的家族，你需要学习类的规则*转换操作*。为此，让我们回到本章前面创建的雇员层次结构，并向`Program`类添加一些新方法(如果您正在学习，请在 Visual Studio 中打开 Employees 项目)。如本章后面所述，系统中的最终基类是`System.Object`。因此，`Object`一切事物都“是-个”并能被如此对待。鉴于这一事实，在对象变量中存储任何类型的实例都是合法的。

```cs
static void CastingExamples()
{
  // A Manager "is-a" System.Object, so we can
  // store a Manager reference in an object variable just fine.
  object frank = new Manager("Frank Zappa", 9, 3000, 40000, "111-11-1111", 5);
}

```

在 Employees 项目中，`Managers`、`SalesPerson`和`PtSalesPerson`类型都扩展了`Employee`，因此您可以在一个有效的基类引用中存储任何这些对象。因此，下列语句也是合法的:

```cs
static void CastingExamples()
{
  // A Manager "is-a" System.Object, so we can
  // store a Manager reference in an object variable just fine.
  object frank = new Manager("Frank Zappa", 9, 3000, 40000, "111-11-1111", 5);

  // A Manager "is-an" Employee too.
  Employee moonUnit = new Manager("MoonUnit Zappa", 2, 3001, 20000, "101-11-1321", 1);

  // A PtSalesPerson "is-a" SalesPerson.
  SalesPerson jill = new PtSalesPerson("Jill", 834, 3002, 100000, "111-12-1119", 90);
}

```

类类型之间转换的第一条法则是，当两个类通过“is-a”关系相关联时，将派生对象存储在基类引用中总是安全的。形式上，这被称为*隐式强制转换*，因为根据遗传法则“它 9 就是工作的”。这导致了一些强大的编程结构。例如，假设您已经在当前的`Program`类中定义了一个新方法。

```cs
static void GivePromotion(Employee emp)
{
  // Increase pay...
  // Give new parking space in company garage...

  Console.WriteLine("{0} was promoted!", emp.Name);
}

```

因为这个方法只接受一个类型为`Employee`的参数，考虑到“is-a”关系，您可以有效地将来自`Employee`类的任何后代直接传递给这个方法。

```cs
static void CastingExamples()
{
  // A Manager "is-a" System.Object, so we can
  // store a Manager reference in an object variable just fine.
  object frank = new Manager("Frank Zappa", 9, 3000, 40000, "111-11-1111", 5);

  // A Manager "is-an" Employee too.
  Employee moonUnit = new Manager("MoonUnit Zappa", 2, 3001, 20000, "101-11-1321", 1);
  GivePromotion(moonUnit);

  // A PTSalesPerson "is-a" SalesPerson.
  SalesPerson jill = new PtSalesPerson("Jill", 834, 3002, 100000, "111-12-1119", 90);
  GivePromotion(jill);
}

```

给定从基类类型(`Employee`)到派生类型的隐式转换，前面的代码进行编译。但是，如果您也想推广弗兰克·扎帕(目前存储在一个通用的`System.Object`引用中)呢？如果您将`frank`对象直接传递给这个方法，您会发现如下编译器错误:

```cs
object frank = new Manager("Frank Zappa", 9, 3000, 40000, "111-11-1111", 5);
// Error!
GivePromotion(frank);

```

问题是你试图传入一个没有被声明为`Employee`而是更一般的`System.Object`的变量。考虑到`object`比`Employee`在继承链中处于更高的位置，编译器将不允许隐式强制转换，以尽可能保证代码的类型安全。

即使您可以知道`object`引用指向内存中的`Employee`兼容类，编译器也不能，因为这要到运行时才能知道。您可以通过执行*显式强制转换*来满足编译器。这是造型的第二条法则:在这种情况下，可以使用 C# 造型运算符进行显式向下造型。执行显式强制转换时要遵循的基本模板如下所示:

```cs
(ClassIWantToCastTo)referenceIHave

```

因此，要将对象变量传递给`GivePromotion()`方法，您可以编写以下代码:

```cs
// OK!
GivePromotion((Manager)frank);

```

### 使用 C# 作为关键字

请注意，显式强制转换是在运行时进行评估的，而不是在编译时。为了便于讨论，假设您的 Employees 项目有一个本章前面创建的`Hexagon`类的副本。为简单起见，您可以将以下类添加到当前项目中:

```cs
class Hexagon
{
  public void Draw()
  {
    Console.WriteLine("Drawing a hexagon!");
  }
}

```

尽管将 employee 对象转换为 shape 对象完全没有意义，但可以编译如下代码，而不会出错:

```cs
// Ack! You can't cast frank to a Hexagon, but this compiles fine!
object frank = new Manager();
Hexagon hex = (Hexagon)frank;

```

然而，您会收到一个运行时错误，或者更正式地说，一个*运行时异常*。第 7 章[将研究结构化异常处理的全部细节；然而，目前值得指出的是，当您执行显式强制转换时，您可以使用`try`和`catch`关键字来捕获无效强制转换的可能性(同样，参见第](07.html) [7 章](07.html)了解全部细节)。

```cs
// Catch a possible invalid cast.
object frank = new Manager();
Hexagon hex;
try
{
  hex = (Hexagon)frank;
}
catch (InvalidCastException ex)
{
  Console.WriteLine(ex.Message);
}

```

显然，这是一个人为的例子；在这种情况下，你绝不会费心在这两种类型之间进行选择。然而，假设您有一个`System.Object`类型的数组，其中只有少数包含与`Employee`兼容的对象。在这种情况下，您希望确定数组中的某个项是否兼容，如果兼容，则执行强制转换。

C# 提供了关键字`as`来在运行时快速确定一个给定的类型是否与另一个兼容。当您使用`as`关键字时，您可以通过检查`null`返回值来确定兼容性。请考虑以下几点:

```cs
// Use "as" to test compatibility.
object[] things = new object[4];
things[0] = new Hexagon();
things[1] = false;
things[2] = new Manager();
things[3] = "Last thing";

foreach (object item in things)
{
  Hexagon h = item as Hexagon;
  if (h == null)
  {
    Console.WriteLine("Item is not a hexagon");
  }
  else
  {
    h.Draw();
  }
}

```

在这里，循环遍历对象数组中的每一项，检查每一项与`Hexagon`类的兼容性。如果(且仅如果！)找到一个与`Hexagon`兼容的对象，调用`Draw()`方法。否则，您只需报告项目不兼容。

### 使用 C# is 关键字(更新 7.0、9.0)

除了`as`关键字，C# 语言还提供了`is`关键字来确定两个项目是否兼容。然而，与`as`关键字不同，如果类型不兼容，`is`关键字返回`false`，而不是`null`引用。目前，`GivePromotion()`方法已经被设计成接受从`Employee`派生的任何可能的类型。考虑下面的更新，它现在检查以查看传入的是哪种“雇员类型”:

```cs
static void GivePromotion(Employee emp)
{
  Console.WriteLine("{0} was promoted!", emp.Name);
  if (emp is SalesPerson)
  {
    Console.WriteLine("{0} made {1} sale(s)!", emp.Name,
      ((SalesPerson)emp).SalesNumber);
    Console.WriteLine();
  }
  else if (emp is Manager)
  {
    Console.WriteLine("{0} had {1} stock options...", emp.Name,
      ((Manager)emp).StockOptions);
    Console.WriteLine();
  }
}

```

这里，您正在执行运行时检查，以确定传入的基类引用实际上指向内存中的什么。在确定接收的是`SalesPerson`还是`Manager`类型之后，您就可以执行显式强制转换来访问该类的专用成员。还要注意，您不需要将您的造型操作包装在一个`try` / `catch`构造中，因为您知道如果您进入任一个`if`范围，造型是安全的，给定您的条件检查。

在 C# 7.0 中新增的关键字`is`也可以将转换后的类型赋给一个变量，如果转换有效的话。这通过防止“双重转换”问题清理了前面的方法。在前面的示例中，第一次强制转换是在检查类型是否匹配时完成的，如果匹配，则变量必须再次强制转换。考虑对前面方法的更新:

```cs
static void GivePromotion(Employee emp)
{
  Console.WriteLine("{0} was promoted!", emp.Name);
  //Check if is SalesPerson, assign to variable s
  if (emp is SalesPerson s)
  {
    Console.WriteLine("{0} made {1} sale(s)!", s.Name,
      s.SalesNumber);
    Console.WriteLine();
  }
  //Check if is Manager, if it is, assign to variable m
  else if (emp is Manager m)
  {
    Console.WriteLine("{0} had {1} stock options...",
      m.Name, m.StockOptions);
    Console.WriteLine();
  }
}

```

C# 9.0 引入了额外的模式匹配功能(在第 [3 章](03.html)中介绍)。这些更新的模式匹配可以与关键字`is`一起使用。例如，要检查雇员是否不是`Manager`和`SalesPerson,`，请使用以下代码:

```cs
if (emp is not Manager and not SalesPerson)
{
  Console.WriteLine("Unable to promote {0}. Wrong employee type", emp.Name);
  Console.WriteLine();
}

```

#### 用 is 关键字丢弃(新 7.0)

关键字`is`也可以与丢弃变量占位符结合使用。如果您想在您的`if`或`switch`语句中创建一个总汇，您可以如下操作:

```cs
if (obj is var _)
{
//do something
}

```

这将匹配所有内容，所以要注意使用丢弃比较器的顺序。更新后的`GivePromotion()`方法如下所示:

```cs
if (emp is SalesPerson s)
{
  Console.WriteLine("{0} made {1} sale(s)!", s.Name, s.SalesNumber);
  Console.WriteLine();
}
//Check if is Manager, if it is, assign to variable m
else if (emp is Manager m)
{
  Console.WriteLine("{0} had {1} stock options...", m.Name, m.StockOptions);
  Console.WriteLine();
}
else if (emp is var _)
{
  Console.WriteLine("Unable to promote {0}. Wrong employee type", emp.Name);
  Console.WriteLine();
}

```

最后的`if`语句将捕获任何不是`Manager, SalesPerson,`或`PtSalesPerson.`的`Employee`实例。记住，你可以降级为基类，所以`PtSalesPerson` *将*注册为`SalesPerson` `.`

### 重温模式匹配(新 7.0)

第 3 章[T2 介绍了 C# 7 的模式匹配特性以及 C# 9.0 的更新。现在你已经对选角有了坚定的认识，是时候举个更好的例子了。现在可以干净地更新前面的示例，以使用模式匹配`switch`语句，如下所示:](03.html)

```cs
static void GivePromotion(Employee emp)
{
  Console.WriteLine("{0} was promoted!", emp.Name);
  switch (emp)
  {
    case SalesPerson s:
      Console.WriteLine("{0} made {1} sale(s)!", emp.Name,
        s.SalesNumber);
      break;
    case Manager m:
      Console.WriteLine("{0} had {1} stock options...",
        emp.Name, m.StockOptions);
      break;
  }
  Console.WriteLine();
}

```

当将一个`when`子句添加到`case`语句时，对象*的完整定义在被转换为*时可供使用。例如，`SalesNumber`属性只存在于`SalesPerson`类中，而不存在于`Employee`类中。如果第一个`case`语句中的转换成功，变量`s`将保存一个`SalesPerson`类的实例，因此`case`语句可以更新为:

```cs
case SalesPerson s when s.SalesNumber > 5:

```

对`is`和`switch`语句的这些新添加提供了很好的改进，有助于减少执行匹配的代码量，如前面的例子所示。

#### 用 switch 语句丢弃(新 7.0)

丢弃也可以用在`switch`语句中，如下面的代码所示:

```cs
switch (emp)
{
  case SalesPerson s when s.SalesNumber > 5:
    Console.WriteLine("{0} made {1} sale(s)!", emp.Name,
      s.SalesNumber);
    break;
  case Manager m:
    Console.WriteLine("{0} had {1} stock options...",
      emp.Name, m.StockOptions);
    break;
  case Employee _:
    Console.WriteLine("Unable to promote {0}. Wrong employee type", emp.Name);
    break;
}

```

每个传入的类型都已经是一个`Employee,`，所以最后的`case`语句总是真的。然而，正如在第三章[中介绍模式匹配时所讨论的，一旦匹配成功，就会退出`switch`语句。这证明了获得正确订单的重要性。如果最后一条语句被移到最上面，就不会有`Employee`被提升。](03.html)

## 理解超级父类:System。目标

为了结束这一章，我想检查一下超级父类的细节:`Object`。当您在阅读前一节时，您可能已经注意到您的层次结构中的基类(`Car`、`Shape`、`Employee`)从来没有显式地指定它们的父类。

```cs
// Who is the parent of Car?
class Car
{...}

```

在。NET Core universe，每个类型最终都是从一个名为`System.Object`的基类派生出来的，可以用 C# `object`关键字(小写 *o* )来表示。`Object`类为框架中的每种类型定义了一组公共成员。事实上，当您构建一个没有显式定义其父类的类时，编译器会自动从`Object`中派生出您的类型。如果你想弄清楚你的意图，你可以自由地如下定义从`Object`派生的类(然而，同样，没有必要这样做):

```cs
// Here we are explicitly deriving from System.Object.
class Car : object
{...}

```

像任何类一样，`System.Object`定义了一组成员。在下面的正式 C# 定义中，注意其中一些项被声明为`virtual`，它指定一个给定的成员可以被一个子类覆盖，而其他的被标记为`static`(因此在类级别被调用):

```cs
public class Object
{
  // Virtual members.
  public virtual bool Equals(object obj);
  protected virtual void Finalize();
  public virtual int GetHashCode();
  public virtual string ToString();

  // Instance-level, nonvirtual members.
  public Type GetType();
  protected object MemberwiseClone();

  // Static members.
  public static bool Equals(object objA, object objB);
  public static bool ReferenceEquals(object objA, object objB);
}

```

表 [6-1](#Tab1) 提供了一些你最可能使用的方法所提供的功能的概要。

表 6-1。

`System.Object`的核心成员

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

对象类的实例方法

 | 

生命的意义

 |
| --- | --- |
| `Equals()` | 默认情况下，只有当被比较的项目引用内存中的同一个项目时，该方法才返回`true`。因此，`Equals()`用于比较对象引用，而不是对象的状态。通常，只有当被比较的对象具有相同的内部状态值(即基于值的语义)时，该方法才会被覆盖以返回`true`。 |
|   | 注意，如果你覆盖了`Equals()`，你也应该覆盖`GetHashCode()`，因为这些方法被`Hashtable`类型内部使用来从容器中检索子对象。 |
|   | 还记得在第 4 章中，`ValueType`类覆盖了所有结构的这个方法，所以它们使用基于值的比较。 |
| `Finalize()` | 目前，您可以理解调用这个方法(当被覆盖时)是为了在对象被销毁之前释放所有分配的资源。我将在第 9 章中详细介绍 CoreCLR 垃圾收集服务。 |
| `GetHashCode()` | 该方法返回一个标识特定对象实例的`int`。 |
| `ToString()` | 这个方法使用`<namespace>.<type name>`格式(称为*完全限定名*)返回这个对象的字符串表示。这个方法通常会被一个子类覆盖，以返回一个表示对象内部状态的名称-值对的标记化字符串，而不是它的完全限定名。 |
| `GetType()` | 这个方法返回一个`Type`对象，它完整地描述了你当前引用的对象。简而言之，这是一个对所有对象都可用的运行时类型识别(RTTI)方法(在第 [16](16.html) 章有更详细的讨论)。 |
| `MemberwiseClone()` | 这个方法的存在是为了返回当前对象的一个成员接一个成员的副本，这在克隆对象时经常用到(见第 [8](08.html) 章)。 |

为了演示由`Object`基类提供的一些默认行为，创建一个名为 ObjectOverrides 的最终 C# 控制台应用项目。插入一个新的 C# 类类型，它包含以下名为`Person`的类型的空类定义:

```cs
// Remember! Person extends Object.
class Person {}

```

现在，更新您的顶级语句，以便与`System.Object`的继承成员进行交互，如下所示:

```cs
Console.WriteLine("***** Fun with System.Object *****\n");
Person p1 = new Person();

// Use inherited members of System.Object.
Console.WriteLine("ToString: {0}", p1.ToString());
Console.WriteLine("Hash code: {0}", p1.GetHashCode());
Console.WriteLine("Type: {0}", p1.GetType());

// Make some other references to p1.
Person p2 = p1;
object o = p2;
// Are the references pointing to the same object in memory?
if (o.Equals(p1) && p2.Equals(o))
{
  Console.WriteLine("Same instance!");
}
Console.ReadLine();
}

```

以下是当前代码的输出:

```cs
***** Fun with System.Object *****
ToString: ObjectOverrides.Person
Hash code: 58225482
Type: ObjectOverrides.Person
Same instance!

```

注意`ToString()`的默认实现如何返回当前类型的完全限定名(`ObjectOverrides.Person`)。正如你将在第 15 章[的构建定制名称空间的检查中看到的，每个 C# 项目都定义了一个“根名称空间”，它与项目本身同名。在这里，您创建了一个名为`ObjectOverrides`的项目；因此，`Person`类型和`Program`类都被放在了`ObjectOverrides`名称空间中。](15.html)

`Equals()`的默认行为是测试两个变量是否指向内存中的同一个对象。在这里，您创建了一个名为`p1`的新的`Person`变量。此时，一个新的`Person`对象被放在托管堆上。`p2`也是`Person`类型。然而，您不是在创建一个新的*实例，而是将这个变量分配给引用`p1`。因此，`p1`和`p2`都指向内存中的同一个对象，变量`o`(类型`object`，为了更好的测量，它被抛出)也是如此。假设`p1`、`p2`和`o`都指向相同的存储位置，则相等测试成功。*

虽然`System.Object`的固定行为在很多情况下可以满足要求，但是对于你的自定义类型来说，重写这些继承的方法是很常见的。举例来说，更新`Person`类以支持一些表示个人名字、姓氏和年龄的属性，每个属性都可以由自定义构造函数设置。

```cs
// Remember! Person extends Object.
class Person
{
  public string FirstName { get; set; } = "";
  public string LastName { get; set; } = "";
  public int Age { get; set; }

  public Person(string fName, string lName, int personAge)
  {
    FirstName = fName;
    LastName = lName;
    Age = personAge;
  }
  public Person(){}
}

```

### 超驰系统。Object.ToString()

您创建的许多类(和结构)可以受益于覆盖`ToString()`来返回类型当前状态的字符串文本表示。这对于调试非常有帮助(还有其他原因)。你如何选择构造这个字符串是个人的选择；但是，推荐的方法是用分号分隔每个名称-值对，并将整个字符串放在方括号内(许多类型在。NET 核心基类库遵循这种方法)。为您的`Person`类考虑以下被覆盖的`ToString()`:

```cs
public override string ToString() => $"[First Name: {FirstName}; Last Name: {LastName}; Age: {Age}]";

```

鉴于`Person`类只有三条状态数据，所以`ToString()`的实现非常简单。然而，永远记住一个适当的`ToString()`覆盖也应该考虑到继承链上的*定义的任何数据。*

当您为一个扩展自定义基类的类重写`ToString()`时，首先要做的是使用`base`关键字从父类获取`ToString()`值。获得父级的字符串数据后，可以追加派生类的自定义信息。

### 超驰系统。对象。等于()

让我们也覆盖`Object.Equals()`的行为来处理基于值的语义。回想一下，默认情况下，只有当被比较的两个对象引用内存中的同一个对象实例时，`Equals()`才会返回`true`。对于`Person`类，如果被比较的两个变量包含相同的状态值(例如，名字、姓氏和年龄)，实现`Equals()`以返回`true`可能会有所帮助。

首先，注意到`Equals()`方法的传入参数是一个通用的`System.Object`。鉴于此，您的首要任务是确保调用者确实传入了一个`Person`对象，并且作为额外的保护措施，确保传入的参数不是一个`null`引用。

在您建立了调用者已经向您传递了一个分配的`Person`之后，实现`Equals()`的一种方法是对传入对象的数据和当前对象的数据进行逐字段比较。

```cs
public override bool Equals(object obj)
{
  if (!(obj is Person temp))
  {
    return false;
  }
  if (temp.FirstName == this.FirstName
      && temp.LastName == this.LastName
      && temp.Age == this.Age)
  {
    return true;
  }
  return false;
}

```

这里，您将对照您的内部值检查传入对象的值(注意使用了`this`关键字)。如果每个对象的名称和年龄都相同，那么就有两个对象具有相同的状态数据，因此返回`true`。任何其他的可能性导致返回`false`。

虽然这种方法确实有效，但是您可以想象为可能包含几十个数据字段的非平凡类型实现一个定制的`Equals()`方法会有多费力。一个常见的捷径是利用您自己的`ToString()`实现。如果一个类有一个基本且正确的`ToString()`实现，它包含了继承链上的所有字段数据，那么你可以简单地比较对象的字符串数据(检查是否为空)。

```cs
// No need to cast "obj" to a Person anymore,
// as everything has a ToString() method.
public override bool Equals(object obj)
  => obj?.ToString() == ToString();

```

请注意，在这种情况下，您不再需要检查传入参数的类型是否正确(在本例中是 a `Person`),因为。NET 支持一个`ToString()`方法。更好的是，您不再需要执行逐个属性的相等检查，因为您现在只是测试从`ToString()`返回的值。

### 超驰系统。Object.GetHashCode()

当一个类覆盖了`Equals()`方法时，你也应该覆盖`GetHashCode()`的默认实现。简单地说，*散列码*是一个数值，它将一个对象表示为一个特定的状态。例如，如果您创建两个保存值`Hello`的`string`变量，您将获得相同的哈希代码。然而，如果其中一个`string`对象全部是小写的(`hello`，您将获得不同的散列码。

默认情况下，`System.Object.GetHashCode()`使用对象在内存中的当前位置来产生哈希值。但是，如果您正在构建一个自定义类型，并打算存储在一个`Hashtable`类型中(在`System.Collections`名称空间中)，您应该总是覆盖这个成员，因为`Hashtable`将在内部调用`Equals()`和`GetHashCode()`来检索正确的对象。

Note

更具体地说，`System.Collections.Hashtable`类在内部调用`GetHashCode()`来获得对象所在位置的大致信息，但是对`Equals()`的后续(内部)调用确定了精确匹配。

虽然在这个例子中你不打算把你的`Person`放入`System.Collections.Hashtable`中，但是为了完整起见，让我们覆盖`GetHashCode()`。有许多算法可以用来创建散列码——有些很奇特，有些则不那么奇特。大多数时候，您可以通过利用`System.String`的`GetHashCode()`实现来生成一个散列码值。

假设`String`类已经有了一个可靠的哈希代码算法，它使用`String`的字符数据来计算哈希值，如果您可以在您的类中识别出一个对于所有实例都应该是唯一的字段数据(比如一个社会保险号)，只需在该字段数据点上调用`GetHashCode()`。因此，如果`Person`类定义了一个`SSN`属性，您可以编写以下代码:

```cs
// Assume we have an SSN property as so.
class Person
{
  public string SSN {get; } = "";
  public Person(string fName, string lName, int personAge,
    string ssn)
  {
    FirstName = fName;
    LastName = lName;
    Age = personAge;
    SSN = ssn;
  }
  // Return a hash code based on unique string data.
  public override int GetHashCode() => SSN.GetHashCode();
}

```

如果使用读写属性作为哈希代码的基础，将会收到警告。一旦创建了对象，哈希代码应该是不可变的。在前面的例子中，SSN 属性只有一个`get`方法，该方法使属性成为只读的，并且只能在构造函数中设置。

如果您找不到唯一的`string`数据的单点，但是您已经覆盖了`ToString()`(它满足只读约定)，那么在您自己的字符串表示上调用`GetHashCode()`。

```cs
// Return a hash code based on the person's ToString() value.
public override int GetHashCode() => ToString().GetHashCode();

```

### 测试修改后的 Person 类

现在您已经覆盖了`Object`的`virtual`成员，更新顶层语句来测试您的更新。

```cs
Console.WriteLine("***** Fun with System.Object *****\n");

// NOTE: We want these to be identical to test
// the Equals() and GetHashCode() methods.
Person p1 = new Person("Homer", "Simpson", 50,
  "111-11-1111");
Person p2 = new Person("Homer", "Simpson", 50,
  "111-11-1111");

// Get stringified version of objects.
Console.WriteLine("p1.ToString() = {0}", p1.ToString());
Console.WriteLine("p2.ToString() = {0}", p2.ToString());

// Test overridden Equals().
Console.WriteLine("p1 = p2?: {0}", p1.Equals(p2));

// Test hash codes.
//still using the hash of the SSN
Console.WriteLine("Same hash codes?: {0}", p1.GetHashCode() == p2.GetHashCode());
Console.WriteLine();

// Change age of p2 and test again.
p2.Age = 45;
Console.WriteLine("p1.ToString() = {0}", p1.ToString());
Console.WriteLine("p2.ToString() = {0}", p2.ToString());
Console.WriteLine("p1 = p2?: {0}", p1.Equals(p2));
//still using the hash of the SSN
Console.WriteLine("Same hash codes?: {0}", p1.GetHashCode() == p2.GetHashCode());
Console.ReadLine();

```

输出如下所示:

```cs
***** Fun with System.Object *****
p1.ToString() = [First Name: Homer; Last Name: Simpson; Age: 50]
p2.ToString() = [First Name: Homer; Last Name: Simpson; Age: 50]
p1 = p2?: True
Same hash codes?: True

p1.ToString() = [First Name: Homer; Last Name: Simpson; Age: 50]
p2.ToString() = [First Name: Homer; Last Name: Simpson; Age: 45]
p1 = p2?: False
Same hash codes?: True

```

### 使用系统的静态成员。目标

除了您刚才检查的实例级成员之外，`System.Object`还定义了两个静态成员，它们也测试基于值或基于引用的相等性。考虑以下代码:

```cs
static void StaticMembersOfObject()
{
  // Static members of System.Object.
  Person p3 = new Person("Sally", "Jones", 4);
  Person p4 = new Person("Sally", "Jones", 4);
  Console.WriteLine("P3 and P4 have same state: {0}", object.Equals(p3, p4));
  Console.WriteLine("P3 and P4 are pointing to same object: {0}",
    object.ReferenceEquals(p3, p4));
}

```

在这里，您可以简单地发送两个对象(任何类型)并允许`System.Object`类自动确定细节。

输出(从顶级语句调用时)如下所示:

```cs
***** Fun with System.Object *****
P3 and P4 have the same state: True
P3 and P4 are pointing to the same object: False

```

## 摘要

本章探讨了继承和多态的作用和细节。在这些页面中，向您介绍了许多新的关键字和令牌来支持这些技术。例如，回想一下冒号标记用于建立给定类型的父类。父类型能够定义任意数量的虚拟和/或抽象成员来建立多态接口。派生类型使用`override`关键字覆盖这样的成员。

除了构建大量的类层次结构之外，本章还研究了如何在基类和派生类之间进行显式转换，并通过深入研究。NET 基础类库:`System.Object`。**