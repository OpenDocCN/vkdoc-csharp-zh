# 十一、高级 C# 语言功能

在本章中，您将通过研究几个更高级的主题来加深对 C# 编程语言的理解。首先，您将学习如何实现和使用一个*索引器方法*。这种 C# 机制使您能够构建自定义类型，这些自定义类型使用类似数组的语法提供对内部子项的访问。在您学习了如何构建索引器方法之后，您将看到如何重载各种操作符(`+`、`-`、`<`、`>`等)。)以及如何为您的类型创建自定义的显式和隐式转换例程(您将了解为什么您可能想要这样做)。

接下来，您将研究在使用以 LINQ 为中心的 API 时特别有用的主题(尽管您可以在 LINQ 的上下文之外使用它们)，特别是扩展方法和匿名类型。

最后，您将学习如何创建一个“不安全”的代码上下文来直接操作非托管指针。虽然在 C# 应用中使用指针确实是一种不常见的活动，但是在一些涉及复杂互操作性的情况下，理解如何使用指针会很有帮助。

## 了解索引器方法

作为一名程序员，您肯定很熟悉使用索引操作符(`[]`)访问一个简单数组中包含的各个项的过程。这里有一个例子:

```cs
// Loop over incoming command-line arguments
// using index operator.
for(int i = 0; i < args.Length; i++)
{
  Console.WriteLine("Args: {0}", args[i]);
}

// Declare an array of local integers.
int[] myInts = { 10, 9, 100, 432, 9874};

// Use the index operator to access each element.
for(int j = 0; j < myInts.Length; j++)
{
  Console.WriteLine("Index {0}  = {1} ", j,  myInts[j]);
}
Console.ReadLine();

```

这个代码绝不是一个主要的新闻快讯。然而，通过定义一个*索引器方法*，C# 语言提供了设计定制类和结构的能力，这些类和结构可以像标准数组一样被索引。当您创建自定义集合类(泛型或非泛型)时，此功能最有用。

在研究如何实现自定义索引器之前，让我们先来看一个实例。假设您已经在第 [10 章](10.html)中开发的自定义`PersonCollection`类型中添加了对索引器方法的支持(具体来说，就是 issueswingnongenericcollections 项目)。虽然您尚未添加索引器，但请在名为 SimpleIndexer 的新控制台应用项目中观察以下用法:

```cs
using System;
using System.Collections.Generic;
using System.Data;
using SimpleIndexer;

// Indexers allow you to access items in an array-like fashion.
Console.WriteLine("***** Fun with Indexers *****\n");

PersonCollection myPeople = new PersonCollection();

// Add objects with indexer syntax.
myPeople[0] = new Person("Homer", "Simpson", 40);
myPeople[1] = new Person("Marge", "Simpson", 38);
myPeople[2] = new Person("Lisa", "Simpson", 9);
myPeople[3] = new Person("Bart", "Simpson", 7);
myPeople[4] = new Person("Maggie", "Simpson", 2);

// Now obtain and display each item using indexer.
for (int i = 0; i < myPeople.Count; i++)
{
  Console.WriteLine("Person number: {0}", i);
  Console.WriteLine("Name: {0} {1}",
    myPeople[i].FirstName, myPeople[i].LastName);
  Console.WriteLine("Age: {0}", myPeople[i].Age);
  Console.WriteLine();
}

```

如您所见，索引器允许您像操作标准数组一样操作子对象的内部集合。现在来看一个大问题:如何配置`PersonCollection`类(或任何定制类或结构)来支持这个功能？索引器表示为稍加修改的 C# 属性定义。最简单的形式是使用`this[]`语法创建一个索引器。下面是`PersonCollection`类所需的更新:

```cs
using System.Collections;

namespace SimpleIndexer
{
  // Add the indexer to the existing class definition.
  public class PersonCollection : IEnumerable
  {
    private ArrayList arPeople = new ArrayList();
...
    // Custom indexer for this class.
    public Person this[int index]
    {
      get => (Person)arPeople[index];
      set => arPeople.Insert(index, value);
    }
  }
}

```

除了使用带括号的关键字`this`之外，索引器看起来就像任何其他 C# 属性声明一样。例如，`get`作用域的作用是将正确的对象返回给调用者。这里，您通过将请求委托给`ArrayList`对象的索引器来实现，因为这个类也支持索引器。`set`范围监督添加新的`Person`对象；这是通过调用`ArrayList`的`Insert()`方法实现的。

索引器是另一种形式的语法糖，因为这种功能也可以使用“普通的”公共方法来实现，比如`AddPerson()`或`GetPerson()`。然而，当您在自定义集合类型上支持索引器方法时，它们可以很好地集成到。NET 核心基本类库。

虽然创建索引器方法在构建自定义集合时很常见，但请记住泛型类型为您提供了开箱即用的功能。考虑下面的方法，它使用了一个通用的`Person`对象的`List<T>`。注意，你可以简单地直接使用`List<T>`的索引器。这里有一个例子:

```cs
using System.Collections.Generic;
static void UseGenericListOfPeople()
{
  List<Person> myPeople = new List<Person>();
  myPeople.Add(new Person("Lisa", "Simpson", 9));
  myPeople.Add(new Person("Bart", "Simpson", 7));

  // Change first person with indexer.
  myPeople[0] = new Person("Maggie", "Simpson", 2);

  // Now obtain and display each item using indexer.
  for (int i = 0; i < myPeople.Count; i++)
  {
    Console.WriteLine("Person number: {0}", i);
    Console.WriteLine("Name: {0} {1}", myPeople[i].FirstName, myPeople[i].LastName);
    Console.WriteLine("Age: {0}", myPeople[i].Age);
    Console.WriteLine();
  }
}

```

### 使用字符串值索引数据

当前的`PersonCollection`类定义了一个索引器，该索引器允许调用者使用数值来标识子项。但是，请理解，这不是索引器方法的要求。假设您更喜欢使用`System.Collections.Generic.Dictionary<TKey, TValue>`而不是`ArrayList`来包含`Person`对象。假设`Dictionary`类型允许使用一个键(比如一个人的名字)访问包含的类型，您可以如下定义一个索引器:

```cs
using System.Collections;
using System.Collections.Generic;
namespace SimpleIndexer
{
  public class PersonCollectionStringIndexer : IEnumerable
  {
    private Dictionary<string, Person> listPeople = new Dictionary<string, Person>();

    // This indexer returns a person based on a string index.
    public Person this[string name]
    {
      get => (Person)listPeople[name];
      set => listPeople[name] = value;
    }
    public void ClearPeople()
    {
      listPeople.Clear();
    }

    public int Count => listPeople.Count;

    IEnumerator IEnumerable.GetEnumerator() => listPeople.GetEnumerator();
  }
}

```

调用者现在能够与包含的`Person`对象交互，如下所示:

```cs
Console.WriteLine("***** Fun with Indexers *****\n");

PersonCollectionStringIndexer myPeopleStrings =
  new PersonCollectionStringIndexer();

myPeopleStrings["Homer"] =
  new Person("Homer", "Simpson", 40);
myPeopleStrings["Marge"] =
  new Person("Marge", "Simpson", 38);

// Get "Homer" and print data.
Person homer = myPeopleStrings["Homer"];
Console.ReadLine();

```

同样，如果您直接使用泛型`Dictionary<TKey, TValue>`类型，您将获得现成的索引器方法功能，而无需构建一个支持字符串索引器的自定义、非泛型类。尽管如此，请理解任何索引器的数据类型都将基于支持的集合类型如何允许调用方检索子项。

### 重载索引器方法

索引器方法可以在单个类或结构上重载。因此，如果允许调用者使用数字索引*或字符串值*访问子项是有意义的，那么可以为一个类型定义多个索引器。举例来说，在 ADO.NET(。NET 的本地数据库访问 API)，`DataSet`类支持一个名为`Tables`的属性，它返回给你一个强类型的`DataTableCollection`类型。事实证明，`DataTableCollection`定义了*三个*索引器来获取和设置`DataTable`对象——一个通过序号位置，另一个通过友好的字符串名字对象和可选的包含名称空间，如下所示:

```cs
public sealed class DataTableCollection : InternalDataCollectionBase
{
...
  // Overloaded indexers!
  public DataTable this[int index] { get; }
  public DataTable this[string name] { get; }
  public DataTable this[string name, string tableNamespace] { get; }
}

```

基类库中的类型支持索引器方法是很常见的。所以请注意，即使您当前的项目不要求您为您的类和结构构建自定义索引器，许多类型已经支持这种语法。

### 多维索引器

您还可以创建一个接受多个参数的索引器方法。假设您有一个在 2D 数组中存储子项的自定义集合。如果是这种情况，您可以按如下方式定义索引器方法:

```cs
public class SomeContainer
{
  private int[,] my2DintArray = new int[10, 10];

  public int this[int row, int column]
  {  /* get or set value from 2D array */  }
}

```

同样，除非您正在构建一个高度风格化的自定义集合类，否则您不太需要构建一个多维索引器。尽管如此，ADO.NET 再次展示了这种构造是多么有用。ADO.NET`DataTable`本质上是行和列的集合，很像一张绘图纸或 Microsoft Excel 电子表格的一般结构。

虽然通常使用相关的“数据适配器”代表您填充`DataTable`对象，但是下面的代码演示了如何手动创建包含三列(每个记录的名字、姓氏和年龄)的内存中的`DataTable`。请注意，一旦您向`DataTable`添加了一行，您如何使用多维索引器来钻取第一行(也是唯一一行)的每一列。(如果您正在跟进，您需要将`System.Data`名称空间导入到您的代码文件中。)

```cs
static void MultiIndexerWithDataTable()
{
  // Make a simple DataTable with 3 columns.
  DataTable myTable = new DataTable();
  myTable.Columns.Add(new DataColumn("FirstName"));
  myTable.Columns.Add(new DataColumn("LastName"));
  myTable.Columns.Add(new DataColumn("Age"));

  // Now add a row to the table.
  myTable.Rows.Add("Mel", "Appleby", 60);

  // Use multidimension indexer to get details of first row.
  Console.WriteLine("First Name: {0}", myTable.Rows[0][0]);
  Console.WriteLine("Last Name: {0}", myTable.Rows[0][1]);
  Console.WriteLine("Age : {0}", myTable.Rows[0][2]);
}

```

请注意，您将从第 21 章开始深入研究 ADO.NET，所以如果前面的一些代码看起来不熟悉，也不用担心。此示例的要点是索引器方法可以支持多维度，如果使用正确，可以简化您与自定义集合中包含的子对象的交互方式。

### 接口类型的索引器定义

索引器可以在给定的。NET 核心接口类型，以允许支持类型提供自定义实现。下面是一个简单的接口示例，它定义了使用数字索引器获取字符串对象的协议:

```cs
public interface IStringContainer
{
  string this[int index] { get; set; }
}

```

使用此接口定义，任何实现此接口的类或结构现在都必须支持读写索引器，该索引器使用数值来操作子项。下面是此类的部分实现:

```cs
class SomeClass : IStringContainer
{
  private List<string> myStrings = new List<string>();

  public string this[int index]
  {
    get => myStrings[index];
    set => myStrings.Insert(index, value);
  }
}

```

这就结束了本章的第一个主要话题。现在让我们来研究一个语言特性，它允许您构建定制的类或结构，这些类或结构对 C# 的内部运算符做出独特的响应。接下来，请允许我介绍一下*运算符重载*的概念。

## 理解运算符重载

像任何编程语言一样，C# 有一组固定的标记，用于对内部类型执行基本操作。例如，您知道可以将`+`运算符应用于两个整数，以产生一个更大的整数。

```cs
// The + operator with ints.
int a = 100;
int b = 240;
int c = a + b; // c is now 340

```

再说一次，这不是什么大新闻，但是你有没有停下来注意过同一个`+`操作符是如何应用于大多数 C# 数据类型的？例如，考虑以下代码:

```cs
// + operator with strings.
string s1 = "Hello";
string s2 = " world!";
string s3 = s1 + s2;  // s3 is now "Hello World!"

```

`+`操作符基于所提供的数据类型(本例中是字符串或整数)以特定的方式运行。当`+`运算符应用于数值类型时，结果是操作数的总和。然而，当`+`操作符应用于字符串类型时，结果是字符串连接。

C# 语言为您提供了构建定制类和结构的能力，这些定制类和结构也可以唯一地响应同一组基本标记(如`+`操作符)。虽然不是每个可能的 C# 操作符都可以重载，但是很多都可以，如表 [11-1](#Tab1) 所示。

表 11-1。

c# 运算符的可重载性

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

C# 运算符

 | 

过载能力

 |
| --- | --- |
| `+`、`-`、`!`、`~`、`++`、`--`、`true`、`false` | 这些一元运算符可以重载。C# 要求如果 true 或 false 被重载，两者都必须被重载。 |
| `+`、`-`、`*`、`/`、`%`、`&`、`&#124;`、`^`、`<<`、`>>` | 这些二元运算符可以重载。 |
| `==`、`!=`、`<`、`>`、`<=`、`>=` | 这些比较运算符可以重载。C# 要求“like”操作符(即`<`和`>`、`<=`和`>=`、`==`和`!=`)一起重载。 |
| `[]` | `[]`运算符不能重载。然而，正如您在本章前面所看到的，索引器构造提供了相同的功能。 |
| `()` | `()`运算符不能重载。然而，正如您将在本章后面看到的，自定义转换方法提供了相同的功能。 |
| `+=`、`-=`、`*=`、`/=`、`%=`、`&=`、`&#124;=`、`^=`、`<<=`、`>>=` | 速记赋值运算符不能重载；然而，当你重载相关的二元操作符时，你可以免费得到它们。 |

### 重载二元运算符

为了说明重载二元运算符的过程，假设在一个名为 OverloadedOps 的新控制台应用项目中定义了以下简单的`Point`类:

```cs
using System;
namespace OverloadedOps
{
  // Just a simple, everyday C# class.
  public class Point
  {
    public int X {get; set;}
    public int Y {get; set;}

    public Point(int xPos, int yPos)
    {
      X = xPos;
      Y = yPos;
    }
    public override string ToString()
      => $"[{this.X}, {this.Y}]";
  }
}

```

现在，从逻辑上讲，把`Point` s“加”在一起是有意义的。例如，如果你将两个`Point`变量加在一起，你应该得到一个新的`Point`，它是`X`和`Y`值的总和。当然，从另一个中减去一个`Point`也是有帮助的。理想情况下，您希望能够编写以下代码:

```cs
using System;
using OverloadedOps;

// Adding and subtracting two points?
Console.WriteLine("***** Fun with Overloaded Operators *****\n");

// Make two points.
Point ptOne = new Point(100, 100);
Point ptTwo = new Point(40, 40);
Console.WriteLine("ptOne = {0}", ptOne);
Console.WriteLine("ptTwo = {0}", ptTwo);
// Add the points to make a bigger point?
Console.WriteLine("ptOne + ptTwo: {0} ", ptOne + ptTwo);

// Subtract the points to make a smaller point?
  Console.WriteLine("ptOne - ptTwo: {0} ", ptOne - ptTwo);
  Console.ReadLine();

```

然而，就像现在的`Point`一样，您将会收到编译时错误，因为`Point`类型不知道如何响应`+`或`-`操作符。为了使自定义类型能够唯一地响应内部运算符，C# 提供了`operator`关键字，您只能将它与`static`关键字结合使用。当您重载一个二元操作符(比如`+`和`-`)时，您通常会传入两个与定义类类型相同的参数(本例中为`Point`)，如下面的代码更新所示:

```cs
// A more intelligent Point type.
public class Point
{
...
  // Overloaded operator +.
  public static Point operator + (Point p1, Point p2)
    => new Point(p1.X + p2.X, p1.Y + p2.Y);

  // Overloaded operator -.
  public static Point operator - (Point p1, Point p2)
    => new Point(p1.X - p2.X, p1.Y - p2.Y);
}

```

操作符`+`背后的逻辑只是基于传入的`Point`参数的字段总和返回一个新的`Point`对象。因此，当您编写`pt1` + `pt2`时，您可以想象下面对静态操作符`+`方法的隐藏调用:

```cs
// Pseudo-code: Point p3 = Point.operator+ (p1, p2)
Point p3 = p1 + p2;

```

同样，`p1`–`p2`映射到以下内容:

```cs
// Pseudo-code: Point p4 = Point.operator- (p1, p2)
Point p4 = p1 - p2;

```

有了这个更新，您的程序现在可以编译了，并且您发现您可以添加和减去`Point`对象，如下面的输出所示:

```cs
***** Fun with Overloaded Operators *****
ptOne = [100, 100]
ptTwo = [40, 40]
ptOne + ptTwo: [140, 140]
ptOne - ptTwo: [60, 60]

```

当重载二元运算符时，不需要传入两个相同类型的参数。如果这样做有意义，其中一个论点可以不同。例如，这里有一个重载操作符`+`，它允许调用者获得一个基于数字调整的新的`Point`:

```cs
public class Point
{
...
  public static Point operator + (Point p1, int change)
    => new Point(p1.X + change, p1.Y + change);

  public static Point operator + (int change, Point p1)
    => new Point(p1.X + change, p1.Y + change);
}

```

请注意，如果您希望参数以任意顺序传递，您需要方法的两个版本(即，您不能只定义其中一个方法，并期望编译器自动支持另一个)。您现在可以使用这些新版本的运算符`+`，如下所示:

```cs
// Prints [110, 110].
Point biggerPoint = ptOne + 10;
Console.WriteLine("ptOne + 10 = {0}", biggerPoint);

// Prints [120, 120].
Console.WriteLine("10 + biggerPoint = {0}", 10 + biggerPoint);
Console.WriteLine();

```

### +=和–=运算符是什么？

如果你是从 C++背景进入 C# 的，你可能会感叹重载速记赋值操作符(`+=`、`-=`等)的损失。).不要绝望。就 C# 而言，如果一个类型重载了相关的二元运算符，那么会自动模拟速记赋值运算符。因此，假设`Point`结构已经重载了`+`和`-`操作符，您可以编写如下代码:

```cs
// Overloading binary operators results in a freebie shorthand operator.
...
// Freebie +=
Point ptThree = new Point(90, 5);
Console.WriteLine("ptThree = {0}", ptThree);
Console.WriteLine("ptThree += ptTwo: {0}", ptThree += ptTwo);

// Freebie -=
Point ptFour = new Point(0, 500);
Console.WriteLine("ptFour = {0}", ptFour);
Console.WriteLine("ptFour -= ptThree: {0}", ptFour -= ptThree);
Console.ReadLine();

```

### 重载一元运算符

C# 还允许你重载各种一元运算符，比如`++`和`--`。当重载一元运算符时，还必须将`static`关键字与`operator`关键字一起使用；但是，在这种情况下，您只需传入一个与定义的类/结构类型相同的参数。例如，如果您要用以下重载操作符更新`Point`:

```cs
public class Point
{
...
  // Add 1 to the X/Y values for the incoming Point.
  public static Point operator ++(Point p1)
    => new Point(p1.X+1, p1.Y+1);

  // Subtract 1 from the X/Y values for the incoming Point.
  public static Point operator --(Point p1)
    => new Point(p1.X-1, p1.Y-1);
}

```

您可以像这样递增和递减`Point`的`x`和`y`值:

```cs
...
// Applying the ++ and -- unary operators to a Point.
Point ptFive = new Point(1, 1);
Console.WriteLine("++ptFive = {0}", ++ptFive);  // [2, 2]
Console.WriteLine("--ptFive = {0}", --ptFive);  // [1, 1]

// Apply same operators as postincrement/decrement.
Point ptSix = new Point(20, 20);
Console.WriteLine("ptSix++ = {0}", ptSix++);    // [20, 20]
Console.WriteLine("ptSix-- = {0}", ptSix--);    // [21, 21]
Console.ReadLine();

```

请注意，在前面的代码示例中，您以两种不同的方式应用了自定义的`++`和`--`操作符。在 C++中，可以分别重载前后递增/递减运算符。这在 C# 中是不可能的。然而，递增/递减的返回值会被自动“正确”地免费处理(例如，对于重载的`++`操作符，`pt++`将未修改对象的值作为其在表达式中的值，而`++pt`在表达式中使用之前应用了新值)。

### 重载相等运算符

你可能还记得第 [6](06.html) 章，可以覆盖`System.Object.Equals()`来执行引用类型之间基于值的(而不是基于引用的)比较。如果您选择覆盖`Equals()`(以及通常相关的`System.Object.GetHashCode()`方法)，重载等式操作符(`==`和`!=`)是微不足道的。为了说明，下面是更新后的`Point`类型:

```cs
// This incarnation of Point also overloads the == and != operators.
public class Point
{
...
  public override bool Equals(object o)
    => o.ToString() == this.ToString();

  public override int GetHashCode()
    => this.ToString().GetHashCode();

  // Now let's overload the == and != operators.
  public static bool operator ==(Point p1, Point p2)
    => p1.Equals(p2);

  public static bool operator !=(Point p1, Point p2)
    => !p1.Equals(p2);
}

```

注意操作符`==`和操作符`!=`的实现是如何简单地调用被覆盖的`Equals()`方法来完成大部分工作的。考虑到这一点，您现在可以如下练习您的`Point`类:

```cs
// Make use of the overloaded equality operators.
...
Console.WriteLine("ptOne == ptTwo : {0}", ptOne == ptTwo);
Console.WriteLine("ptOne != ptTwo : {0}", ptOne != ptTwo);
Console.ReadLine();

```

正如您所看到的，使用众所周知的`==`和`!=`操作符来比较两个对象是非常直观的，而不是调用`Object.Equals()`。如果你确实重载了给定类的等式操作符，记住 C# 要求如果你覆盖了`==`操作符，你*必须*也覆盖了`!=`操作符(如果你忘记了，编译器会告诉你)。

### 重载比较运算符

在第 [8](08.html) 章中，你学习了如何实现`IComparable`接口来比较两个相似对象之间的关系。事实上，您还可以为同一个类重载比较操作符(`<`、`>`、`<=`和`>=`)。和等式操作符一样，C# 要求如果你重载了`<`，你也必须重载`>`。这同样适用于`<=`和`>=`操作符。如果`Point`类型重载了这些比较操作符，对象用户现在可以比较`Point` s，如下所示:

```cs
// Using the overloaded < and > operators.
...
Console.WriteLine("ptOne < ptTwo : {0}", ptOne < ptTwo);
Console.WriteLine("ptOne > ptTwo : {0}", ptOne > ptTwo);
Console.ReadLine();

```

假设您已经实现了`IComparable`接口(或者更好的是通用等效接口)，重载比较操作符是微不足道的。下面是更新后的类定义:

```cs
// Point is also comparable using the comparison operators.
public class Point : IComparable<Point>
{
...
  public int CompareTo(Point other)
  {
    if (this.X > other.X && this.Y > other.Y)
    {
      return 1;
    }
    if (this.X < other.X && this.Y < other.Y)
    {
      return -1;
    }
    return 0;
  }
  public static bool operator <(Point p1, Point p2)
    => p1.CompareTo(p2) < 0;

  public static bool operator >(Point p1, Point p2)
    => p1.CompareTo(p2) > 0;

  public static bool operator <=(Point p1, Point p2)
    => p1.CompareTo(p2) <= 0;

  public static bool operator >=(Point p1, Point p2)
    => p1.CompareTo(p2) >= 0;
}

```

### 关于运算符重载的最终想法

正如您所看到的，C# 提供了构建类型的能力，这些类型可以唯一地响应各种固有的、众所周知的运算符。现在，在您修改您的所有类以支持这种行为之前，您必须确保您将要重载的操作符在世界范围内具有某种逻辑意义。

例如，假设您重载了`MiniVan`类的乘法运算符。将两个`MiniVan`对象相乘到底意味着什么？不多。事实上，如果队友看到`MiniVan`对象的以下用法，会感到困惑:

```cs
// Huh?! This is far from intuitive...
MiniVan newVan = myVan * yourVan;

```

重载操作符通常只在构建原子数据类型时有用。向量、矩阵、文本、点、形状、集合等。，是运算符重载的理想选择。人、管理人员、汽车、数据库连接和网页没有。根据经验，如果一个重载的操作符使用户理解一个类型的功能变得更加困难，那就不要这样做。明智地使用这个特性。

## 了解自定义类型转换

现在让我们研究一个与运算符重载密切相关的主题:自定义类型转换。为了给讨论做好准备，让我们快速回顾一下数字数据和相关类类型之间显式和隐式转换的概念。

### 回忆:数字转换

根据固有的数字类型(`sbyte`、`int`、`float`等)。)，当您试图在较小的容器中存储较大的值时，需要一个*显式转换*，因为这可能会导致数据丢失。基本上，这是你告诉编译器，“别管我，我知道我在做什么。”相反，当您试图将一个较小的类型放入一个不会导致数据丢失的目标类型中时，一个*隐式转换*会自动发生。

```cs
int a = 123;
long b = a;       // Implicit conversion from int to long.
int c = (int) b;  // Explicit conversion from long to int.

```

### 回忆:相关类类型之间的转换

如第 [6](06.html) 章所示，类类型可能通过经典继承相关(“is-a”关系)。在这种情况下，C# 转换过程允许您上下转换类层次结构。例如，派生类总是可以隐式转换为基类型。但是，如果您想在派生变量中存储基类类型，则必须执行显式转换，如下所示:

```cs
// Two related class types.
class Base{}
class Derived : Base{}

// Implicit cast between derived to base.
Base myBaseType;
myBaseType = new Derived();
// Must explicitly cast to store base reference
// in derived type.
Derived myDerivedType = (Derived)myBaseType;

```

这种显式强制转换是可行的，因为`Base`和`Derived`类通过传统继承相关联，并且`myBaseType`被构造为`Derived`的一个实例。但是，如果`myBaseType`是`Base`的一个实例，那么 cast 抛出一个`InvalidCastException`。如果对转换会失败有任何疑问，你应该使用`as`关键字，如第 [6](06.html) 章中所讨论的。下面是重新制作的示例来演示这一点:

```cs
// Implicit cast between derived to base.
Base myBaseType2 = new();
// Throws InvalidCastException
//Derived myDerivedType2 = (Derived)myBaseType2 as Derived;
//No exception, myDerivedType2 is null
Derived myDerivedType2 = myBaseType2 as Derived;

```

然而，如果在*不同的层次结构*中有两个类类型没有共同的父类(除了`System.Object`)需要转换，该怎么办呢？假设它们没有传统的继承关系，典型的造型操作不会提供任何帮助(而且你会得到一个编译错误！).

另一方面，考虑值类型(结构)。假设您有两个名为`Square`和`Rectangle`的结构。鉴于结构不能利用经典继承(因为它们总是密封的)，您没有自然的方法在这些看似相关的类型之间进行转换。

虽然您可以在结构中创建助手方法(如`Rectangle.ToSquare()`)，但 C# 允许您构建自定义转换例程，允许您的类型响应`()`转换操作符。因此，如果您正确配置了结构，您将能够使用以下语法在它们之间进行显式转换，如下所示:

```cs
// Convert a Rectangle to a Square!
Rectangle rect = new Rectangle
{
  Width = 3;
  Height = 10;
}
Square sq = (Square)rect;

```

### 创建自定义转换例程

首先创建一个名为 CustomConversions 的新控制台应用项目。C# 提供了两个关键字，`explicit`和`implicit`，您可以使用它们来控制您的类型在尝试转换期间如何响应。假设您有以下结构定义:

```cs
using System;

namespace CustomConversions
{
  public struct Rectangle
  {
    public int Width {get; set;}
    public int Height {get; set;}

    public Rectangle(int w, int h)
    {
      Width = w;
      Height = h;
    }

    public void Draw()
    {
      for (int i = 0; i < Height; i++)
      {
        for (int j = 0; j < Width; j++)
        {
          Console.Write("*");
        }
        Console.WriteLine();
      }
    }

    public override string ToString()
      => $"[Width = {Width}; Height = {Height}]";
  }
}

using System;

namespace CustomConversions
{
  public struct Square
  {
    public int Length {get; set;}
    public Square(int l) : this()
    {
      Length = l;
    }

    public void Draw()
    {
      for (int i = 0; i < Length; i++)
      {
        for (int j = 0; j < Length; j++)
        {
          Console.Write("*");
        }
        Console.WriteLine();
      }
    }

    public override string ToString() => $"[Length = {Length}]";

    // Rectangles can be explicitly converted into Squares.
    public static explicit operator Square(Rectangle r)
    {
      Square s = new Square {Length = r.Height};
      return s;
    }
  }
}

```

注意，`Square`类型的这个迭代定义了一个显式转换操作符。像重载操作符的过程一样，转换例程使用 C# `operator`关键字，结合`explicit`或`implicit`关键字，并且必须被定义为`static`。传入的参数是你要从转换*的实体，而操作符类型是你要从*转换*的实体。*

在这种情况下，假设可以从矩形的高度获得正方形(所有边都等长的几何图案)。因此，您可以自由地将`Rectangle`转换成`Square`，如下所示:

```cs
using System;
using CustomConversions;

Console.WriteLine("***** Fun with Conversions *****\n");
// Make a Rectangle.
Rectangle r = new Rectangle(15, 4);
Console.WriteLine(r.ToString());
r.Draw();

Console.WriteLine();

// Convert r into a Square,
// based on the height of the Rectangle.
Square s = (Square)r;
Console.WriteLine(s.ToString());
s.Draw();
Console.ReadLine();

```

您可以在这里看到输出:

```cs
***** Fun with Conversions *****
[Width = 15; Height = 4]

***************
***************
***************
***************

[Length = 4]
****
****
****
****

```

虽然在同一个作用域内将一个`Rectangle`转换成一个`Square`可能没什么帮助，但是假设你有一个被设计成接受`Square`参数的函数。

```cs
// This method requires a Square type.
static void DrawSquare(Square sq)
{
  Console.WriteLine(sq.ToString());
  sq.Draw();
}

```

使用对`Square`类型的显式转换操作，您现在可以传入`Rectangle`类型以使用显式强制转换进行处理，如下所示:

```cs
...
// Convert Rectangle to Square to invoke method.
Rectangle rect = new Rectangle(10, 5);
DrawSquare((Square)rect);
Console.ReadLine();

```

### Square 类型的其他显式转换

既然您已经可以显式地将`Rectangle`转换成`Square`了，那么让我们检查一些额外的显式转换。假设一个正方形在所有边上都是对称的，那么提供一个显式的转换例程，允许调用者从整数类型转换为`Square`(当然，它的边长等于传入的整数)可能会有所帮助。同样，如果您要更新`Square`以便调用者可以将中的*从`Square`转换为`int`会怎么样？下面是调用逻辑:*

```cs
...
// Converting an int to a Square.
Square sq2 = (Square)90;
Console.WriteLine("sq2 = {0}", sq2);

// Converting a Square to an int.
int side = (int)sq2;
Console.WriteLine("Side length of sq2 = {0}", side);
Console.ReadLine();

```

下面是对`Square`类的更新:

```cs
public struct Square
{
...
  public static explicit operator Square(int sideLength)
  {
    Square newSq = new Square {Length = sideLength};
    return newSq;
  }

  public static explicit operator int (Square s) => s.Length;
}

```

老实说，将`Square`转换成整数可能不是最直观(或最有用)的操作(毕竟，您可以将这些值传递给构造函数)。然而，它确实指出了关于自定义转换例程的一个重要事实:如果您编写了语法正确的代码，编译器并不关心您转换成什么或转换成什么。

因此，就像重载操作符一样，仅仅因为你*可以*为一个给定的类型创建一个显式的强制转换操作，并不意味着你*应该*。通常，这种技术在创建结构类型时最有帮助，因为它们不能参与经典继承(强制转换是免费的)。

### 定义隐式转换例程

到目前为止，您已经创建了各种自定义的*显式的*转换操作。但是，下面的*隐式*转换呢？

```cs
...
Square s3 = new Square {Length = 83};

// Attempt to make an implicit cast?
Rectangle rect2 = s3;

Console.ReadLine();

```

假定您没有为`Rectangle`类型提供隐式转换例程，这段代码将不会编译。这里有一个问题:在同一类型上定义显式和隐式转换函数是非法的，如果它们的返回类型或参数集没有区别的话。这似乎是一种限制；然而，第二个问题是，当一个类型定义了一个*隐式*转换例程时，调用者使用*显式*转换语法是合法的！

迷茫？为了弄清楚，让我们使用 C# `implicit`关键字向`Rectangle`结构添加一个隐式转换例程(注意，下面的代码假设产生的`Rectangle`的宽度是通过将`Square`的边乘以 2 来计算的):

```cs
public struct Rectangle
{
...
  public static implicit operator Rectangle(Square s)
  {
    Rectangle r = new Rectangle
    {
      Height = s.Length,
      Width = s.Length * 2 // Assume the length of the new Rectangle with (Length x 2).
    };
    return r;
  }
}

```

通过此更新，您现在可以在类型之间进行转换，如下所示:

```cs
...
// Implicit cast OK!
Square s3 = new Square { Length= 7};

Rectangle rect2 = s3;
Console.WriteLine("rect2 = {0}", rect2);

// Explicit cast syntax still OK!
Square s4 = new Square {Length = 3};
Rectangle rect3 = (Rectangle)s4;

Console.WriteLine("rect3 = {0}", rect3);
Console.ReadLine();

```

这就结束了您对自定义转换例程的定义。与重载操作符一样，记住这一点语法只是“普通”成员函数的简写符号，从这个角度来看，它总是可选的。然而，当正确使用时，自定义结构可以更自然地使用，因为它们可以被视为通过继承相关的真正的类类型。

## 理解扩展方法

。NET 3.5 引入了*扩展方法*的概念，它允许你向一个类或结构添加新的方法或属性，而不用以任何直接的方式修改原始类型。那么，这在哪里会有帮助呢？考虑以下可能性。

首先，假设您有一个生产中的给定类。随着时间的推移，很明显这个类应该支持一些新成员。如果直接修改当前的类定义，就有可能破坏使用它的旧代码库的向后兼容性，因为它们可能没有用最新和最好的类定义编译。确保向后兼容的一种方法是从现有父类创建新的派生类；然而，现在您有两个类需要维护。众所周知，代码维护是软件工程师工作描述中最不光彩的部分。

现在考虑这种情况。假设您有一个结构(或者一个密封的类)并想添加新的成员，这样它在您的系统中的行为就多样化了。由于结构和密封类不能被扩展，你唯一的选择就是将成员添加到类型中，这又一次冒着破坏向后兼容性的风险！

使用扩展方法，您可以修改类型，而无需创建子类，也无需直接修改类型。问题是，只有在当前项目中引用了扩展方法时，才会向类型提供新功能。

### 定义扩展方法

当你定义扩展方法时，第一个限制是它们必须在静态类中定义(见第 [5](05.html) 章)；因此，每个扩展方法都必须用关键字`static`声明。第二点是所有的扩展方法都是这样标记的，使用`this`关键字作为方法的第一个(也是唯一的一个)参数的修饰符。“`this`合格”参数代表被扩展的项目。

为了进行说明，创建一个名为 ExtensionMethods 的新控制台应用项目。现在，假设您正在创作一个名为`MyExtensions`的类，它定义了两个扩展方法。第一种方法允许任何一个`object`使用一个名为`DisplayDefiningAssembly()`的新方法，该方法利用`System.Reflection`名称空间中的类型来显示包含该类型的程序集的名称。

Note

你将在第 17 章中正式检查反射 API。如果您不熟悉这个主题，只需理解反射允许您在运行时发现程序集、类型和类型成员的结构。

第二种扩展方法名为`ReverseDigits()`，允许任何`int`获得其自身的新版本，其中值被逐位反转。例如，如果一个值为 1234 的整数被称为`ReverseDigits()`，那么返回的整数被设置为值 4321。考虑下面的类实现(如果您继续学习，请确保导入`System.Reflection`名称空间):

```cs
using System;
using System.Reflection;

namespace MyExtensionMethods
{
  static class MyExtensions
  {
    // This method allows any object to display the assembly
    // it is defined in.
    public static void DisplayDefiningAssembly(this object obj)
    {
      Console.WriteLine("{0} lives here: => {1}\n",
        obj.GetType().Name,
        Assembly.GetAssembly(obj.GetType()).GetName().Name);
    }

    // This method allows any integer to reverse its digits.
    // For example, 56 would return 65.
    public static int ReverseDigits(this int i)
    {
      // Translate int into a string, and then
      // get all the characters.
      char[] digits = i.ToString().ToCharArray();

      // Now reverse items in the array.
      Array.Reverse(digits);

      // Put back into string.
      string newDigits = new string(digits);

      // Finally, return the modified string back as an int.
      return int.Parse(newDigits);
    }
  }
}

```

同样，在定义参数类型之前，注意每个扩展方法的第一个参数是如何用关键字`this`限定的。扩展方法的第一个参数总是表示被扩展的类型。鉴于`DisplayDefiningAssembly()`已经被原型化以扩展`System.Object`，每个类型现在都有了这个新成员，因为`Object`是。NET 核心平台。然而，`ReverseDigits()`已经被原型化，只扩展整数类型；因此，如果整数以外的任何东西试图调用此方法，您将收到一个编译时错误。

Note

理解一个给定的扩展方法可以有多个参数，但是*只有*的第一个参数可以用`this`限定。附加参数将被视为该方法使用的正常输入参数。

### 调用扩展方法

现在已经有了这些扩展方法，请考虑下面的代码示例，该示例将扩展方法应用于基类库中的各种类型:

```cs
using System;
using MyExtensionMethods;

Console.WriteLine("***** Fun with Extension Methods *****\n");

// The int has assumed a new identity!
int myInt = 12345678;
myInt.DisplayDefiningAssembly();

// So has the DataSet!
System.Data.DataSet d = new System.Data.DataSet();
d.DisplayDefiningAssembly();

// Use new integer functionality.
Console.WriteLine("Value of myInt: {0}", myInt);
Console.WriteLine("Reversed digits of myInt: {0}",
  myInt.ReverseDigits());

Console.ReadLine();

```

以下是输出:

```cs
***** Fun with Extension Methods *****
Int32 lives here: => System.Private.CoreLib

DataSet lives here: => System.Data.Common

Value of myInt: 12345678
Reversed digits of myInt: 87654321

```

### 导入扩展方法

当您定义一个包含扩展方法的类时，它无疑将被定义在一个名称空间中。如果这个名称空间不同于使用扩展方法的名称空间，您将需要使用预期的 C# `using`关键字。当您这样做时，您的代码文件可以访问被扩展类型的所有扩展方法。记住这一点很重要，因为如果不显式导入正确的命名空间，扩展方法就不能用于该 C# 代码文件。

实际上，尽管表面上看起来扩展方法本质上是全局的，但实际上它们仅限于定义它们的命名空间或导入它们的命名空间。回想一下，您将`MyExtensions`类包装到一个名为`MyExtensionMethods`的名称空间中，如下所示:

```cs
namespace MyExtensionMethods
{
  static class MyExtensions
  {
    ...
  }
}

```

要在类中使用扩展方法，您需要显式导入`MyExtensionMethods`名称空间，正如我们在用于练习示例的顶级语句中所做的那样。

### 扩展实现特定接口的类型

至此，您已经看到了如何通过扩展方法用新的功能来扩展类(并间接地扩展遵循相同语法的结构)。也可以定义一个只能扩展实现正确接口的类或结构的扩展方法。例如，你可以说“如果一个类或结构实现了`IEnumerable<T>`，那么该类型将获得下面的新成员。”当然，有可能要求一个类型支持任何接口，包括您自己的自定义接口。

为了进行说明，创建一个名为 InterfaceExtensions 的新控制台应用项目。这里的目标是向实现`IEnumerable`的任何类型添加一个新方法，这将包括任何数组和许多非泛型集合类(回想一下第 [10 章](10.html)中的泛型`IEnumerable<T>`接口扩展了非泛型`IEnumerable`接口)。将以下扩展类添加到新项目中:

```cs
using System;

namespace InterfaceExtensions
{
  static class AnnoyingExtensions
  {
    public static void PrintDataAndBeep(
      this System.Collections.IEnumerable iterator)
    {
      foreach (var item in iterator)
      {
        Console.WriteLine(item);
        Console.Beep();
      }
    }
  }
}

```

假设任何实现`IEnumerable`的类或结构都可以使用`PrintDataAndBeep()`方法，您可以通过下面的代码进行测试:

```cs
using System;
using System.Collections.Generic;
using InterfaceExtensions;

Console.WriteLine("***** Extending Interface Compatible Types *****\n");

// System.Array implements IEnumerable!
string[] data =
  { "Wow", "this", "is", "sort", "of", "annoying",
      "but", "in", "a", "weird", "way", "fun!"};
data.PrintDataAndBeep();

Console.WriteLine();

// List<T> implements IEnumerable!
List<int> myInts = new List<int>() {10, 15, 20};
myInts.PrintDataAndBeep();

Console.ReadLine();

```

这就结束了对 C# 扩展方法的研究。请记住，每当您希望扩展类型的功能，但不想创建子类(或者如果类型是密封的，则无法创建子类)时，这种语言特性就非常有用，因为这是为了实现多态性。正如您将在本文后面看到的，扩展方法对 LINQ API 起着关键作用。事实上，你会看到在 LINQ API 下，最常见的扩展项之一是一个类或结构实现(惊喜！)通用版的`IEnumerable`。

### 扩展方法 GetEnumerator 支持(新 9.0)

在 C# 9.0 之前，要在一个类上使用`foreach`，必须直接在那个类上定义`GetEnumerator()`方法。在 C# 9.0 中，`foreach`方法将检查类的扩展方法，如果找到了`GetEnumerator()`方法，将使用该方法获取该类的`IEnumerator`。要看到这一点，添加一个名为 ForEachWithExtensionMethods 的新控制台应用，并添加第 [8 章](08.html)中的`Car`和`Garage`类的简化版本。

```cs
//Car.cs
using System;

namespace ForEachWithExtensionMethods
{
  class Car
  {
    // Car properties.
    public int CurrentSpeed {get; set;} = 0;
    public string PetName {get; set;} = "";

    // Constructors.
    public Car() {}
    public Car(string name, int speed)
    {
      CurrentSpeed = speed;
      PetName = name;
    }

    // See if Car has overheated.
  }
}

//Garage.cs
namespace ForEachWithExtensionMethods
{
  class Garage
  {
    public Car[] CarsInGarage { get; set; }

    // Fill with some Car objects upon startup.
    public Garage()
    {
      CarsInGarage = new Car[4];
      CarsInGarage[0] = new Car("Rusty", 30);
      CarsInGarage[1] = new Car("Clunker", 55);
      CarsInGarage[2] = new Car("Zippy", 30);
      CarsInGarage[3] = new Car("Fred", 30);
    }

  }
}

```

注意，`Garage`类没有实现`IEnumerable`，也没有`GetEnumerator()`方法。通过`GarageExtensions`类添加了`GetEnumerator()`方法，如下所示:

```cs
using System.Collections;

namespace ForEachWithExtensionMethods
{
  static class GarageExtensions
  {
    public static IEnumerator GetEnumerator(this Garage g)
        => g.CarsInGarage.GetEnumerator();
  }
}

```

测试这个新特性的代码与测试第 [8](08.html) 章中的`GetEnumerator()`方法的代码相同。将`Program.cs`更新如下:

```cs
using System;
using ForEachWithExtensionMethods;

Console.WriteLine("***** Support for Extension Method GetEnumerator *****\n");
Garage carLot = new Garage();

// Hand over each car in the collection?
foreach (Car c in carLot)
{
    Console.WriteLine("{0} is going {1} MPH",
        c.PetName, c.CurrentSpeed);
}

```

您将看到代码起作用了，将汽车及其速度的列表打印到控制台上。

```cs
***** Support for Extension Method GetEnumerator *****

Rusty is going 30 MPH
Clunker is going 55 MPH
Zippy is going 30 MPH
Fred is going 30 MPH

```

Note

这个新特性有一个潜在的缺点，那就是从来没有打算`foreach` ed 的类现在可以`foreach` ed 了。

## 了解匿名类型

作为一个面向对象的程序员，您知道定义类来表示您试图建模的给定项目的状态和功能的好处。可以肯定的是，每当您需要定义一个要在项目中重用的类，并且这个类通过一组方法、事件、属性和自定义构造函数提供大量的功能时，创建一个新的 C# 类是常见的做法。

然而，有些时候，您希望定义一个类，只是为了对一组封装的(或以某种方式相关的)数据点进行建模，而没有任何相关的方法、事件或其他专门的功能。此外，如果程序中只有少数方法使用这种类型，那该怎么办呢？当你很清楚这个类只在少数地方使用时，定义一个完整的类定义会很麻烦，如下所示。为了强调这一点，下面是当您需要创建一个遵循典型的基于值的语义的“简单”数据类型时，您可能需要做的事情的大致轮廓:

```cs
class SomeClass
{
  // Define a set of private member variables...

  // Make a property for each member variable...

  // Override ToString() to account for key member variables...

  // Override GetHashCode() and Equals() to work with value-based equality...
}

```

如你所见，事情不一定这么简单。您不仅需要编写大量的代码，还需要在系统中维护另一个类。对于像这样的临时数据，快速创建一个自定义数据类型会很有用。例如，假设您需要构建一个接收一组传入参数的自定义方法。您希望获取这些参数，并使用它们来创建一个新的数据类型，以便在此方法范围内使用。此外，您可能希望使用典型的`ToString()`方法快速打印出这些数据，并且可能使用`System.Object`的其他成员。您可以使用匿名类型语法来做这件事。

### 定义匿名类型

当你定义一个匿名类型时，你可以通过使用`var`关键字(参见第 [3](03.html) 章)和对象初始化语法(参见第 [5](05.html) 章)来实现。您必须使用`var`关键字，因为编译器会在编译时自动生成一个新的类定义(并且您永远不会在 C# 代码中看到这个类的名称)。初始化语法用于告诉编译器为新创建的类型创建私有支持字段和(只读)属性。

举例来说，创建一个名为 AnonymousTypes 的新控制台应用项目。现在，使用传入的参数数据，将下面的方法添加到您的`Program`类中，动态地组成一个新的类型:

```cs
static void BuildAnonymousType( string make, string color, int currSp )
{
  // Build anonymous type using incoming args.
  var car = new { Make = make, Color = color, Speed = currSp };

  // Note you can now use this type to get the property data!
   Console.WriteLine("You have a {0} {1} going {2} MPH", car.Color, car.Make, car.Speed);

  // Anonymous types have custom implementations of each virtual
  // method of System.Object. For example:
  Console.WriteLine("ToString() == {0}", car.ToString());
}

```

请注意，除了将代码包装在函数中之外，还可以以内联方式创建匿名类型，如下所示:

```cs
Console.WriteLine("***** Fun with Anonymous Types *****\n");

// Make an anonymous type representing a car.
var myCar = new { Color = "Bright Pink", Make = "Saab", CurrentSpeed = 55 };

// Now show the color and make.
Console.WriteLine("My car is a {0} {1}.", myCar.Color, myCar.Make);

// Now call our helper method to build anonymous type via args.
BuildAnonymousType("BMW", "Black", 90);

Console.ReadLine();

```

因此，在这一点上，简单地理解一下，匿名类型允许您以很少的开销快速地对数据的“形状”建模。这种技术只不过是一种快速创建新数据类型的方法，它通过属性支持基本的封装，并根据基于值的语义进行操作。为了理解最后一点，让我们看看 C# 编译器如何在编译时构建匿名类型，具体来说，它如何覆盖`System.Object`的成员。

### 匿名类型的内部表示

所有匿名类型都是从`System.Object`自动派生的，因此支持这个基类提供的每个成员。鉴于此，您可以对隐式类型化的`myCar`对象调用`ToString()`、`GetHashCode()`、`Equals()`或`GetType()`。假设您的`Program`类定义了以下静态助手函数:

```cs
static void ReflectOverAnonymousType(object obj)
{
  Console.WriteLine("obj is an instance of: {0}",
    obj.GetType().Name);
  Console.WriteLine("Base class of {0} is {1}",
    obj.GetType().Name, obj.GetType().BaseType);
  Console.WriteLine("obj.ToString() == {0}", obj.ToString());
  Console.WriteLine("obj.GetHashCode() == {0}",
    obj.GetHashCode());
  Console.WriteLine();
}

```

现在假设您调用这个方法，将`myCar`对象作为参数传入，如下所示:

```cs
Console.WriteLine("***** Fun with Anonymous Types *****\n");

// Make an anonymous type representing a car.
var myCar = new {Color = "Bright Pink", Make = "Saab",
  CurrentSpeed = 55};

// Reflect over what the compiler generated.
ReflectOverAnonymousType(myCar);
...

Console.ReadLine();

```

输出将如下所示:

```cs
***** Fun with Anonymous Types *****
obj is an instance of: <>f__AnonymousType0`3
Base class of <>f__AnonymousType0`3 is System.Object
obj.ToString() = { Color = Bright Pink, Make = Saab, CurrentSpeed = 55 }
obj.GetHashCode() = -564053045

```

首先，注意，在这个例子中，`myCar`对象的类型是`<>f__AnonymousType0`3`(您的名字可能不同)。请记住，分配的类型名称完全由编译器决定，并且不能在 C# 代码库中直接访问。

也许最重要的是，注意使用对象初始化语法定义的每个名称-值对都被映射到一个同名的只读属性和一个相应的私有的仅支持`init`的字段。下面的 C# 代码近似于编译器生成的用于表示`myCar`对象的类(同样可以使用`ildasm.exe`进行验证):

```cs
private sealed class <>f__AnonymousType0'3'<'<Color>j__TPar',
  '<Make>j__TPar', <CurrentSpeed>j__TPar>'
  extends [System.Runtime][System.Object]
{
  // init-only fields.
  private initonly <Color>j__TPar <Color>i__Field;
  private initonly <CurrentSpeed>j__TPar <CurrentSpeed>i__Field;
  private initonly <Make>j__TPar <Make>i__Field;

  // Default constructor.
  public <>f__AnonymousType0(<Color>j__TPar Color,
    <Make>j__TPar Make, <CurrentSpeed>j__TPar CurrentSpeed);
  // Overridden methods.
  public override bool Equals(object value);
  public override int GetHashCode();
  public override string ToString();

  // Read-only properties.
  <Color>j__TPar Color { get; }
  <CurrentSpeed>j__TPar CurrentSpeed { get; }
  <Make>j__TPar Make { get; }
}

```

### ToString()和 GetHashCode()的实现

所有匿名类型都自动从`System.Object`派生而来，并提供有`Equals()`、`GetHashCode()`和`ToString()`的覆盖版本。`ToString()`实现简单地从每个名称-值对构建一个字符串。这里有一个例子:

```cs
public override string ToString()
{
  StringBuilder builder = new StringBuilder();
  builder.Append("{ Color = ");
  builder.Append(this.<Color>i__Field);
  builder.Append(", Make = ");
  builder.Append(this.<Make>i__Field);
  builder.Append(", CurrentSpeed = ");
  builder.Append(this.<CurrentSpeed>i__Field);
  builder.Append(" }");
  return builder.ToString();
}

```

`GetHashCode()`实现使用每个匿名类型的成员变量作为`System.Collections.Generic.EqualityComparer<T>`类型的输入来计算哈希值。使用`GetHashCode()`的这种实现，当(且仅当)两个匿名类型具有相同的属性集并被赋予相同的值时，它们将产生相同的哈希值。给定这个实现，匿名类型非常适合包含在一个`Hashtable`容器中。

### 匿名类型相等的语义

虽然被覆盖的`ToString()`和`GetHashCode()`方法的实现很简单，但是您可能想知道`Equals()`方法是如何实现的。例如，如果您要定义两个指定相同名称-值对的“匿名汽车”变量，这两个变量会被认为是相等的吗？为了直接看到结果，用下面的新方法更新您的`Program`类型:

```cs
static void EqualityTest()
{
  // Make 2 anonymous classes with identical name/value pairs.
  var firstCar = new { Color = "Bright Pink", Make = "Saab",
    CurrentSpeed = 55 };
  var secondCar = new { Color = "Bright Pink", Make = "Saab",
    CurrentSpeed = 55 };

  // Are they considered equal when using Equals()?
  if (firstCar.Equals(secondCar))
  {
    Console.WriteLine("Same anonymous object!");
  }
  else
  {
    Console.WriteLine("Not the same anonymous object!");
  }

  // Are they considered equal when using ==?
  if (firstCar == secondCar)
  {
    Console.WriteLine("Same anonymous object!");
  }
  else
  {
    Console.WriteLine("Not the same anonymous object!");
  }

  // Are these objects the same underlying type?
  if (firstCar.GetType().Name == secondCar.GetType().Name)
  {
    Console.WriteLine("We are both the same type!");
  }
  else
  {
    Console.WriteLine("We are different types!");
  }

  // Show all the details.
  Console.WriteLine();
  ReflectOverAnonymousType(firstCar);
  ReflectOverAnonymousType(secondCar);
}

```

当您调用此方法时，输出可能有些令人惊讶。

```cs
My car is a Bright Pink Saab.
You have a Black BMW going 90 MPH
ToString() == { Make = BMW, Color = Black, Speed = 90 }

Same anonymous object!
Not the same anonymous object!
We are both the same type!

obj is an instance of: <>f__AnonymousType0`3
Base class of <>f__AnonymousType0`3 is System.Object
obj.ToString() == { Color = Bright Pink, Make = Saab, CurrentSpeed = 55 }
obj.GetHashCode() == -925496951

obj is an instance of: <>f__AnonymousType0`3
Base class of <>f__AnonymousType0`3 is System.Object
obj.ToString() == { Color = Bright Pink, Make = Saab, CurrentSpeed = 55 }
obj.GetHashCode() == -925496951

```

当您运行这个测试代码时，您将看到您调用`Equals()`的第一个条件测试返回了`true`，因此，消息“相同的匿名对象！”打印到屏幕上。这是因为编译器生成的`Equals()`方法在测试相等性时使用基于值的语义(例如，检查被比较对象的每个字段的值)。

然而，第二个条件测试使用了 C# 的等式操作符(`==`)，打印出“不是同一个匿名对象！”乍一看，这似乎有点违反直觉。这个结果是因为匿名类型*没有*接收 C# 等式操作符的重载版本(`==`和`!=`)。鉴于此，当您使用 C# 相等操作符(而不是`Equals()`方法)测试匿名类型的相等性时，测试的是*引用*，而不是对象维护的值。

最后，在最后的条件测试中(检查底层类型名)，您会发现匿名类型是同一个编译器生成的类类型的实例(在本例中为`<>f AnonymousType0`3`)，因为`firstCar`和`secondCar`具有相同的属性(`Color`、`Make`和`CurrentSpeed`)。

这说明了重要但微妙的一点:只有当匿名类型包含匿名类型的唯一名称时，编译器才会生成新的类定义。因此，如果在同一个程序集中声明相同的匿名类型(也就是相同的名称)，编译器只会生成一个匿名类型定义。

### 包含匿名类型的匿名类型

可以创建一个由其他匿名类型组成的匿名类型。例如，假设您想要对一个由时间戳、价格点和购买的汽车组成的采购订单进行建模。下面是一个新的(稍微复杂一点)匿名类型，表示这样一个实体:

```cs
// Make an anonymous type that is composed of another.
var purchaseItem = new {
  TimeBought = DateTime.Now,
  ItemBought = new {Color = "Red", Make = "Saab", CurrentSpeed = 55},
  Price = 34.000};

ReflectOverAnonymousType(purchaseItem);

```

至此，您应该理解了用于定义匿名类型的语法，但是您可能仍然想知道在什么地方(以及什么时候)使用这个新的语言特性。坦率地说，匿名类型声明应该尽量少用，通常只在使用 LINQ 技术集时使用(参见第 [13 章](13.html))。鉴于匿名类型的诸多限制，您绝不会为了放弃使用强类型类/结构而放弃使用它们，这些限制包括:

*   您不能控制匿名类型的名称。

*   匿名类型总是扩展`System.Object`。

*   匿名类型的字段和属性总是只读的。

*   匿名类型不支持事件、自定义方法、自定义运算符或自定义重写。

*   匿名类型总是隐式密封的。

*   匿名类型总是使用默认构造函数创建的。

然而，当使用 LINQ 技术集编程时，您会发现，在许多情况下，当您想要快速建模一个实体的整体*形状*而不是它的功能时，这个语法会很有帮助。

## 使用指针类型

现在是本章的最后一个主题，它很可能是大多数 C# 中最少使用的特性。净核心项目。

Note

在下面的例子中，我假设你有一些 C++指针操作的背景知识。如果不是这样，请完全跳过这个话题。对于大多数 C# 应用来说，使用指针并不是一项常见的任务。

在第 4 章中，你了解到。NET 核心平台定义了两大类数据:值类型和引用类型。不过，说实话，还有第三类:*指针类型*。要使用指针类型，您需要特定的运算符和关键字来绕过。Net 5 运行时的内存管理方案，把事情掌握在自己手中(见表 [11-2](#Tab2) )。

表 11-2。

以指针为中心的 C# 运算符和关键字

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

运算符/关键字

 | 

生命的意义

 |
| --- | --- |
| `*` | 该操作符用于创建指针变量(即表示内存中直接位置的变量)。与 C++中一样，这个操作符也用于指针间接寻址。 |
| `&` | 该操作符用于获取变量在内存中的地址。 |
| `->` | 该运算符用于访问由指针表示的类型的字段(C# 点运算符的不安全版本)。 |
| `[]` | 这个操作符(在不安全的上下文中)允许你索引指针变量所指向的槽(如果你是 C++程序员，你会记得指针变量和`[]`操作符之间的相互作用)。 |
| `++`，`--` | 在不安全的上下文中，递增和递减运算符可以应用于指针类型。 |
| `+`，`-` | 在不安全的上下文中，加法和减法运算符可以应用于指针类型。 |
| `==`、`!=`、`<`、`>`、`<=`、`=>` | 在不安全的上下文中，比较和相等运算符可以应用于指针类型。 |
| `Stackalloc` | 在不安全的上下文中，`stackalloc`关键字可以用来直接在堆栈上分配 C# 数组。 |
| `Fixed` | 在不安全的上下文中，`fixed`关键字可以用来临时修复一个变量，以便可以找到它的地址。 |

现在，在深入细节之前，让我再次指出，你将*很少需要使用指针类型。尽管 C# 确实允许您下降到指针操作的级别，但是要理解。NET 核心运行时完全不知道你的意图。因此，如果你对一个指针管理不当，你就是负责处理后果的人。考虑到这些警告，什么时候需要使用指针类型呢？有两种常见情况。*

*   您希望通过在管理之外直接操作内存来优化应用的选定部分。NET 5 运行时。

*   您正在调用基于 C 的`.dll`或 COM 服务器的方法，这些方法需要指针类型作为参数。即使在这种情况下，你也可以绕过指针类型，转而使用`System.IntPtr`类型和`System.Runtime.InteropServices.Marshal`类型的成员。

当您决定利用 C# 语言的这一特性时，您需要通过使您的项目支持“不安全代码”来告知 C# 编译器您的意图。创建一个名为 UnsafeCode 的新控制台应用项目，并通过将以下内容添加到`UnsafeCode.csproj`文件中，将该项目设置为支持不安全代码:

```cs
<PropertyGroup>
  <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
</PropertyGroup>

```

Visual Studio 提供了一个 GUI 来设置此属性。访问项目的属性页，导航到 Build 选项卡，选择顶部的所有配置，然后选中“允许不安全的代码”框。见图 [11-1](#Fig1) 。

![img/340876_10_En_11_Chapter/340876_10_En_11_Fig1_HTML.jpg](img/340876_10_En_11_Chapter/340876_10_En_11_Fig1_HTML.jpg)

图 11-1。

使用 Visual Studio 启用不安全代码

### 不安全的关键字

当您想在 C# 中使用指针时，您必须使用`unsafe`关键字明确声明一个“不安全代码”块(任何没有用`unsafe`关键字标记的代码都自动被认为是“安全的”)。例如，下面的`Program`类在安全顶级语句中声明了不安全代码的范围:

```cs
using System;
using UnsafeCode;

Console.WriteLine("***** Calling method with unsafe code *****");

unsafe
{
  // Work with pointer types here!
}
// Can't work with pointers here!

```

除了在方法中声明不安全代码的范围之外，您还可以构建“不安全”的结构、类、类型成员和参数下面是几个例子(不需要在当前项目中定义`Node`或`Node2`类型):

```cs
// This entire structure is "unsafe" and can
// be used only in an unsafe context.
unsafe struct Node
{
  public int Value;
  public Node* Left;
  public Node* Right;
}

// This struct is safe, but the Node2* members
// are not. Technically, you may access "Value" from
// outside an unsafe context, but not "Left" and "Right".
public struct Node2
{
  public int Value;

  // These can be accessed only in an unsafe context!
  public unsafe Node2* Left;
  public unsafe Node2* Right;
}

```

方法(静态或实例级)也可能被标记为不安全的。例如，假设您知道静态方法将使用指针逻辑。为了确保只能从不安全的上下文中调用该方法，可以将该方法定义如下:

```cs
static unsafe void SquareIntPointer(int* myIntPointer)
{
  // Square the value just for a test.
  *myIntPointer *= *myIntPointer;
}

```

您的方法的配置要求调用者如下调用`SquareIntPointer()`:

```cs
  unsafe
  {
    int myInt = 10;

    // OK, because we are in an unsafe context.
    SquareIntPointer(&myInt);
    Console.WriteLine("myInt: {0}", myInt);
  }

  int myInt2 = 5;

  // Compiler error! Must be in unsafe context!
  SquareIntPointer(&myInt2);
  Console.WriteLine("myInt: {0}", myInt2);

```

如果您不想强迫调用者在不安全的上下文中包装调用，您可以用不安全的块包装所有的顶级语句。如果你使用一个`Main()`方法作为入口点，你可以用`unsafe`关键字更新`Main()`。在这种情况下，将编译以下代码:

```cs
static unsafe void Main(string[] args)
{
  int myInt2 = 5;
  SquareIntPointer(&myInt2);
  Console.WriteLine("myInt: {0}", myInt2);
}

```

如果您运行这个版本的`code`，您将看到以下输出:

```cs
myInt: 25

```

Note

值得注意的是，选择术语*不安全*是有原因的。直接访问堆栈和使用指针会导致应用以及运行它的机器出现意外问题。如果你不得不用不安全的代码工作，要格外勤奋。

### 使用*和&运算符

在你建立了一个不安全的上下文之后，你就可以使用`*`操作符构建指向数据类型的指针，并使用`&`操作符获得所指向的地址。与 C 或 C++不同，在 C# 中,`*`运算符只应用于基础类型，而不是作为每个指针变量名的前缀。例如，考虑下面的代码，它说明了声明指向整型变量的指针的正确和不正确的方法:

```cs
// No! This is incorrect under C#!
int *pi, *pj;

// Yes! This is the way of C#.
int* pi, pj;

```

考虑以下不安全的方法:

```cs
static unsafe void PrintValueAndAddress()
{
  int myInt;

  // Define an int pointer, and
  // assign it the address of myInt.
  int* ptrToMyInt = &myInt;

  // Assign value of myInt using pointer indirection.
  *ptrToMyInt = 123;

  // Print some stats.
  Console.WriteLine("Value of myInt {0}", myInt);
  Console.WriteLine("Address of myInt {0:X}", (int)&ptrToMyInt);
}

```

如果您从不安全的块中运行此方法，您将看到以下输出:

```cs
**** Print Value And Address ****
Value of myInt 123
Address of myInt 90F7E698

```

### 不安全(和安全)的交换函数

当然，仅仅为了赋值而声明指向局部变量的指针(如前一个例子)从来都不是必需的，也不是完全有用的。为了说明不安全代码的一个更实际的例子，假设您想使用指针算法构建一个交换函数。

```cs
unsafe static void UnsafeSwap(int* i, int* j)
{
  int temp = *i;
  *i = *j;
  *j = temp;
}

```

很 C 的样子，你不觉得吗？但是，鉴于您之前的工作，您应该知道您可以使用 C# `ref`关键字编写以下安全版本的交换算法:

```cs
static void SafeSwap(ref int i, ref int j)
{
  int temp = i;
  i = j;
  j = temp;
}

```

每个方法的功能都是相同的，因此强调了直接指针操作不是 C# 下的强制任务这一点。下面是使用安全顶级语句和不安全上下文的调用逻辑:

```cs
Console.WriteLine("***** Calling method with unsafe code *****");

// Values for swap.
int i = 10, j = 20;

// Swap values "safely."
Console.WriteLine("\n***** Safe swap *****");
Console.WriteLine("Values before safe swap: i = {0}, j = {1}", i, j);
SafeSwap(ref i, ref j);
Console.WriteLine("Values after safe swap: i = {0}, j = {1}", i, j);

// Swap values "unsafely."
Console.WriteLine("\n***** Unsafe swap *****");
Console.WriteLine("Values before unsafe swap: i = {0}, j = {1}", i, j);
unsafe { UnsafeSwap(&i, &j); }

Console.WriteLine("Values after unsafe swap: i = {0}, j = {1}", i, j);
Console.ReadLine();

```

### 通过指针访问字段(运算符->运算符)

现在假设您已经定义了一个简单、安全的`Point`结构，如下所示:

```cs
struct Point
{
  public int x;
  public int y;

  public override string ToString() => $"({x}, {y})";
}

```

如果你声明一个指向`Point`类型的指针，你将需要使用指针字段访问操作符(由`->`表示)来访问它的公共成员。如表 [11-2](#Tab2) 所示，这是标准(安全)点运算符(`.`的不安全版本。事实上，使用指针间接操作符(`*`)，可以取消引用指针(再次)应用点操作符符号。检查不安全的方法:

```cs
static unsafe void UsePointerToPoint()
{
  // Access members via pointer.
  Point;
  Point* p = &point;
  p->x = 100;
  p->y = 200;
  Console.WriteLine(p->ToString());

  // Access members via pointer indirection.
  Point point2;
  Point* p2 = &point2;
  (*p2).x = 100;
  (*p2).y = 200;
  Console.WriteLine((*p2).ToString());
}

```

### stackalloc 关键字

在不安全的上下文中，您可能需要声明一个局部变量，该变量直接从调用堆栈分配内存(因此不受。NET 核心垃圾收集)。为此，C# 提供了`stackalloc`关键字，它相当于 C 运行时库的`_alloca`函数。这里有一个简单的例子:

```cs
static unsafe string UnsafeStackAlloc()
{
  char* p = stackalloc char[52];
  for (int k = 0; k < 52; k++)
  {
    p[k] = (char)(k + 65)k;
  }
  return new string(p);
}

```

### 通过 fixed 关键字固定类型

正如您在前面的例子中看到的，在不安全的上下文中分配一块内存可能会通过关键字`stackalloc`变得更容易。由于这种操作的本质，一旦分配方法返回(从堆栈中获取内存)，分配的内存就会被清除。然而，假设一个更复杂的例子。在我们检查`->`操作符的过程中，您创建了一个名为`Point`的值类型。像所有值类型一样，一旦执行范围终止，分配的内存将弹出堆栈。为了便于讨论，假设`Point`被定义为*引用*类型，如下所示:

```cs
class PointRef // <= Renamed and retyped.
{
  public int x;
  public int y;
  public override string ToString() => $"({x}, {y})";
}

```

如您所知，如果调用者声明了一个类型为`Point`的变量，那么内存将被分配到垃圾收集堆中。紧迫的问题变成了“如果一个不安全的上下文想要与这个对象(或者堆上的任何对象)交互怎么办？”考虑到垃圾收集可能在任何时候发生，想象一下当访问`Point`的成员时遇到的问题，就在这样一个正在进行堆清理的时间点上。从理论上讲，不安全上下文有可能试图与一个不再可访问的成员进行交互，或者在经历了分代清除之后被重新定位到堆上(这是一个明显的问题)。

为了从不安全的上下文中锁定内存中的引用类型变量，C# 提供了`fixed`关键字。`fixed`语句设置一个指向托管类型的指针，并在代码执行期间“固定”该变量。如果没有`fixed`，指向托管变量的指针将没有什么用处，因为垃圾收集可能会不可预测地重新定位变量。(事实上，除了在`fixed`语句中，C# 编译器不允许你设置指向托管变量的指针。)

因此，如果您创建了一个`PointRef`对象并希望与其成员交互，您必须编写以下代码(否则会收到一个编译器错误):

```cs
unsafe static void UseAndPinPoint()
{
  PointRef pt = new PointRef
  {
    x = 5,
    y = 6
  };

  // Pin pt in place so it will not
  // be moved or GC-ed.
  fixed (int* p = &pt.x)
  {
    // Use int* variable here!
  }

  // pt is now unpinned, and ready to be GC-ed once
  // the method completes.
  Console.WriteLine ("Point is: {0}", pt);
}

```

简而言之，`fixed`关键字允许您构建一个锁定内存中引用变量的语句，这样它的地址在语句(或作用域块)的持续时间内保持不变。任何时候在不安全代码的上下文中与引用类型进行交互时，都必须锁定引用。

### sizeof 关键字

最后要考虑的以不安全为中心的 C# 关键字是`sizeof`。与 C++一样，C# `sizeof`关键字用于获取*内在数据类型*的字节大小，但不是自定义类型，除非在不安全的上下文中。例如，下面的方法不需要声明为“不安全”,因为`sizeof`关键字的所有参数都是内部类型:

```cs
static void UseSizeOfOperator()
{
  Console.WriteLine("The size of short is {0}.", sizeof(short));
  Console.WriteLine("The size of int is {0}.", sizeof(int));
  Console.WriteLine("The size of long is {0}.", sizeof(long));
}

```

但是，如果您想获得自定义的`Point`结构的大小，您需要更新这个方法(注意已经添加了`unsafe`关键字):

```cs
unsafe static void UseSizeOfOperator()
{
...
  unsafe {
    Console.WriteLine("The size of Point is {0}.", sizeof(Point));
  }
}

```

以上介绍了 C# 编程语言的一些更高级的特性。为了确保我们都在同一页上，我必须再次说，你的大部分。NET 项目可能永远不需要直接使用这些特性(尤其是指针)。然而，正如你将在后面的章节中看到的，当使用 LINQ API 时，有些主题即使不是必需的，也是非常有用的，尤其是扩展方法和匿名类型。

## 摘要

本章的目的是加深你对 C# 编程语言的理解。首先，您研究了各种高级类型构造技术(索引器方法、重载操作符和自定义转换例程)。

接下来，您研究了扩展方法和匿名类型的作用。正如你将在第 [13](13.html) 章中看到的一些细节，这些特性在使用以 LINQ 为中心的 API 时很有用(尽管你可以在代码中的任何地方使用它们，如果它们有用的话)。回想一下，匿名方法允许您快速地为类型的“形状”建模，而扩展方法允许您为类型添加新的功能，而不需要子类化。

在本章的剩余部分，您研究了一小组鲜为人知的关键字(`sizeof`、`unsafe`等)。)并在此过程中学习了如何使用原始指针类型。正如在整个指针类型的研究中所说的，你的大多数 C# 应用永远不需要使用它们。