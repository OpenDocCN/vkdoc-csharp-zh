# 二十四、WPF 和 XAML 简介

当 1.0 版的。NET 平台发布后，需要构建图形桌面应用的程序员使用了两个名为 Windows Forms 和 GDI+的 API，它们主要打包在`System.Windows.Forms.dll`和`System.Drawing.dll`程序集中。虽然 Windows 窗体和 GDI+仍然是构建传统桌面 GUI 的可行 API，但从发布开始，Microsoft 提供了一个名为 Windows Presentation Foundation(WPF)的替代 GUI 桌面 API。NET 3.0。WPF 和 Windows 窗体加入了。NET 核心系列的发布。网芯 3.0。

WPF 的第一章从研究这个新的 GUI 框架背后的动机开始，这将帮助你了解 Windows 窗体/GDI+和 WPF 编程模型之间的区别。接下来，您将了解几个重要类的作用，包括`Application`、`Window`、`ContentControl`、`Control`、`UIElement`和`FrameworkElement`。

本章将向你介绍一种基于 XML 的语法，名为*可扩展应用标记语言*(XAML；发音为“zammel”)。在这里，您将学习 XAML 的语法和语义(包括附加属性语法以及类型转换器和标记扩展的角色)。

本章通过构建您的第一个 WPF 应用来研究 Visual Studio 的集成 WPF 设计器。在此期间，您将学习截取键盘和鼠标活动，定义应用范围的数据，以及执行其他常见的 WPF 任务。

## WPF 背后的动机

多年来，微软创造了许多图形用户界面工具包(原始 C/C++/Windows API 开发，VB6，MFC 等。)来构建桌面可执行文件。这些 API 中的每一个都提供了一个代码库来表示 GUI 应用的基本方面，包括主窗口、对话框、控件、菜单系统等。的初始版本。NET 平台，Windows Forms API 很快成为 UI 开发的首选模型，因为它具有简单而强大的对象模型。

虽然许多功能齐全的桌面应用已经使用 Windows 窗体成功地创建出来，但事实是这种编程模型是相当*不对称的*。简而言之，`System.Windows.Forms.dll`和`System.Drawing.dll`没有为构建功能丰富的桌面应用所需的许多附加技术提供直接支持。为了说明这一点，考虑一下 WPF 发布之前 GUI 桌面开发的特殊性质(见表 [24-1](#Tab1) )。

表 24-1。

针对所需功能的 WPF 前解决方案

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

期望的功能

 | 

技术

 |
| --- | --- |
| 用控件构建窗口 | Windows 窗体 |
| 2D 图形支持 | GDI+ ( `System.Drawing.dll`) |
| 3D 图形支持 | directx apis |
| 支持流式视频 | Windows Media Player APIs |
| 支持流样式的文档 | PDF 文件的编程操作 |

如您所见，Windows 窗体开发人员必须从几个不相关的 API 和对象模型中引入类型。虽然使用这些不同的 API 在语法上看起来确实相似(毕竟只是 C# 代码)，但您可能也同意每种技术需要完全不同的思维方式。例如，使用 DirectX 创建 3D 渲染动画所需的技能与将数据绑定到网格所需的技能完全不同。当然，Windows 窗体程序员很难掌握每个 API 的多样性。

### 统一不同的 API

WPF 的创建是为了将这些以前不相关的编程任务合并到一个统一的对象模型中。因此，如果您需要创作一个 3D 动画，您不需要针对 DirectX API 手动编程(尽管您可以这样做),因为 3D 功能是直接嵌入到 WPF 中的。为了了解事情已经清理得有多好，考虑一下表 [24-2](#Tab2) ，它展示了从。NET 3.0。

表 24-2。

。针对所需功能的. NET 3.0+解决方案

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

期望的功能

 | 

技术

 |
| --- | --- |
| 使用控件构建窗体 | 数据绑定 |
| 2D 图形支持 | 数据绑定 |
| 3D 图形支持 | 数据绑定 |
| 支持流式视频 | 数据绑定 |
| 支持流样式的文档 | 数据绑定 |

这里明显的好处是。NET 程序员现在有一个单一的、*对称的* API 来满足所有常见的 GUI 桌面编程需求。当你熟悉了关键的 WPF 程序集的功能和 XAML 的语法后，你会惊奇地发现你可以如此快速地创建复杂的 ui。

### 通过 XAML 提供关注点分离

也许最引人注目的好处之一是 WPF 提供了一种方法，将 GUI 应用的外观和感觉与驱动它的编程逻辑完全分开。使用 XAML，可以通过 XML *标记*定义应用的 UI。这种标记(理想情况下使用 Microsoft Visual Studio 或 Blend for Visual Studio 等工具生成)可以连接到相关的 C# 代码文件，以提供程序功能的核心。

Note

XAML 不限于 WPF 应用。任何应用都可以用 XAML 来描述一棵。NET 对象，即使它们与可见的用户界面无关。

当你深入研究 WPF 时，你可能会惊讶于这种“桌面标记”所提供的灵活性。XAML 不仅允许你定义简单的用户界面元素(按钮、网格、列表框等)。)以及交互式 2D 和 3D 图形、动画、数据绑定逻辑和多媒体功能(如视频回放)。

XAML 还使得自定义控件如何呈现其视觉外观变得容易。例如，定义一个使公司徽标生动的圆形按钮控件只需要几行标记。如第 [27](27.html) 章所示，WPF 控件可以通过样式和模板来修改，这允许你用最少的麻烦和麻烦来改变应用的整体外观。与 Windows 窗体开发不同，从头构建自定义 WPF 控件的唯一令人信服的理由是，如果您需要更改控件的*行为*(例如，添加自定义方法、属性或事件；子类化现有控件以重写虚拟成员)。如果你仅仅需要改变一个控件的*外观和感觉*(比如一个圆形的动画按钮)，你可以完全通过标记来完成。

### 提供优化的渲染模型

GUI 工具包(如 Windows 窗体、MFC 或 VB6)使用低级的、基于 C 的 API (GDI)来执行所有图形呈现请求(包括按钮和列表框等 UI 元素的呈现),该 API 多年来一直是 Windows 操作系统的一部分。GDI 为典型的商业应用或简单的图形程序提供了足够的性能；然而，如果一个 UI 应用需要利用高性能图形，DirectX 是必需的。

WPF 编程模型非常不同，在渲染图形数据时使用的是 GDI*而不是*。所有渲染操作(例如，2D 图形、3D 图形、动画、控件渲染等。)现在利用 DirectX API。第一个明显的好处是，您的 WPF 应用将自动利用硬件和软件优化。此外，WPF 应用可以利用丰富的图形服务(模糊效果、抗锯齿、透明度等)。)而没有直接针对 DirectX API 编程的复杂性。

Note

尽管 WPF 确实将所有渲染请求都推送到 DirectX 层，但我并不想暗示 WPF 应用会像直接使用非托管 C++和 DirectX 构建应用一样快。尽管 WPF 的每个版本都取得了显著的性能提升，但是如果您打算构建一个需要尽可能快的执行速度的桌面应用(如 3D 视频游戏)，非托管 C++和 DirectX 仍然是最好的方法。

### 简化复杂的 UI 编程

概括一下到目前为止的故事，Windows Presentation Foundation(WPF)是一个用于构建桌面应用的 API，它将各种桌面 API 集成到单个对象模型中，并通过 XAML 提供了关注点的清晰分离。除了这些要点之外，WPF 应用还受益于一种将服务集成到程序中的简单方法，这在历史上是相当复杂的。以下是 WPF 核心功能的简要概述:

*   多个布局管理器(比 Windows 窗体多得多)为内容的放置和重新定位提供了极其灵活的控制。

*   使用增强的数据绑定引擎以多种方式将内容绑定到 UI 元素。

*   一个内置的样式引擎，允许你为 WPF 应用定义“主题”。

*   使用矢量图形，允许内容自动调整大小，以适应应用所在屏幕的大小和分辨率。

*   支持 2D 和三维图形，动画，视频和音频播放。

*   丰富的排版 API，例如支持 XML 纸张规范(XPS)文档、固定文档(WYSIWYG)、流文档和文档注释(例如，便笺 API)。

*   支持与传统 GUI 模型(例如，Windows 窗体、ActiveX 和 Win32 HWNDs)的互操作。例如，您可以将自定义 Windows 窗体控件合并到 WPF 应用中，反之亦然。

现在您已经对 WPF 带来了什么有了一些了解，让我们看看可以使用这个 API 创建的各种类型的应用。这些特性中的许多将在后面的章节中详细探讨。

## 调查 WPF 议会

WPF 最终不过是捆绑在其中的类型的集合。NET 核心程序集。表 [24-3](#Tab3) 描述了用于构建 WPF 应用的关键组件，每个组件在创建新项目时都必须被引用。正如您所希望的，Visual Studio WPF 项目会自动引用这些必需的程序集。

表 24-3。

核心 WPF 组件

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

装配

 | 

生命的意义

 |
| --- | --- |
| `PresentationCore` | 该程序集定义了许多名称空间，这些名称空间构成了 WPF GUI 层的基础。例如，该程序集包含对 WPF 墨迹 API、动画原语和许多图形呈现类型的支持。 |
| `PresentationFramework` | 该程序集包含大多数 WPF 控件、`Application`和`Window`类、对交互式 2D 图形的支持以及数据绑定中使用的许多类型。 |
| `System.Xaml.dll` | 此程序集提供了允许您在运行时针对 XAML 文档进行编程的命名空间。总的来说，这个库只有在创作 WPF 支持工具或者需要在运行时绝对控制 XAML 时才有用。 |
| `WindowsBase.dll` | 这个程序集定义了构成 WPF API 基础设施的类型，包括那些代表 WPF 线程类型、安全类型、各种类型转换器以及对*依赖属性*和*路由事件*的支持(在第 [27 章](27.html)中描述)。 |

这四个程序集共同定义了新的命名空间和。NET 核心类、接口、结构、枚举和委托。表 [24-4](#Tab4) 描述了一些(但肯定不是全部)重要名称空间的角色。

表 24-4。

核心 WPF 命名空间

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

命名空间

 | 

生命的意义

 |
| --- | --- |
| `System.Windows` | 这是 WPF 的根命名空间。在这里，您会发现任何 WPF 桌面项目都需要的核心类(比如`Application`和`Window`)。 |
| `System.Windows.Controls` | 它包含了所有预期的 WPF 小部件，包括构建菜单系统、工具提示和许多布局管理器的类型。 |
| `System.Windows.Data` | 这包含使用 WPF 数据绑定引擎的类型，以及对数据绑定模板的支持。 |
| `System.Windows.Documents` | 它包含使用 documents API 的类型，允许您通过 XML Paper Specification (XPS)协议将 PDF 样式的功能集成到您的 WPF 应用中。 |
| `System.Windows.Ink` | 这提供了对 Ink API 的支持，它允许您捕获来自手写笔或鼠标的输入，响应输入手势，等等。这对平板电脑编程很有用；然而，任何 WPF 都可以使用这个 API。 |
| `System.Windows.Markup` | 该命名空间定义了几种类型，允许以编程方式解析和处理 XAML 标记(以及等效的二进制格式 BAML)。 |
| `System.Windows.Media` | 这是几个以媒体为中心的命名空间的根命名空间。在这些命名空间中，您可以找到处理动画、3D 呈现、文本呈现和其他多媒体原语的类型。 |
| `System.Windows.Navigation` | 此命名空间提供了一些类型，用于说明 XAML 浏览器应用(XBAPs)以及需要导航页面模型的标准桌面应用所采用的导航逻辑。 |
| `System.Windows.Shapes` | 这定义了一些类，允许您呈现自动响应鼠标输入的交互式 2D 图形。 |

为了开始您的 WPF 编程模型之旅，您将研究任何传统桌面开发工作中常见的两个名称空间成员:`Application`和`Window`。

Note

如果您已经使用 Windows 窗体 API 创建了桌面用户界面，请注意`System.Windows.Forms.*`和`System.Drawing.*`程序集与 WPF 无关。这些库代表了原始的。NET GUI 工具包，Windows Forms/GDI+。

### 应用类的角色

`System.Windows.Application`类代表一个正在运行的 WPF 应用的全局实例。这个类提供了一个`Run()`方法(启动应用)，一系列你可以处理的事件，以便与应用的生命周期交互(比如`Startup`和`Exit`)。表 [24-5](#Tab5) 详细列出了一些关键属性。

表 24-5。

应用类型的关键属性

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

财产

 | 

生命的意义

 |
| --- | --- |
| `Current` | 这个静态属性允许您从代码中的任何地方访问正在运行的`Application`对象。当一个窗口或对话框需要访问创建它的`Application`对象时，这是很有帮助的，通常是访问应用范围的变量和功能。 |
| `MainWindow` | 此属性允许您以编程方式获取或设置应用的主窗口。 |
| `Properties` | 此属性允许您建立和获取可在 WPF 应用的所有方面(窗口、对话框等)访问的数据。). |
| `StartupUri` | 此属性获取或设置一个 URI，它指定应用启动时自动打开的窗口或页面。 |
| `Windows` | 该属性返回一个`WindowCollection`类型，它提供对从创建`Application`对象的线程创建的每个窗口的访问。当您想要迭代应用的每个打开的窗口并改变其状态(例如最小化所有窗口)时，这可能很有帮助。 |

### 构造应用类

任何 WPF 应用都需要定义一个扩展`Application`的类。在这个类中，您将定义程序的入口点(`Main()`方法)，它创建这个子类的一个实例，并且通常处理`Startup`和`Exit`事件(如果需要的话)。这里有一个例子:

```cs
// Define the global application object
// for this WPF program.
class MyApp : Application
{
  [STAThread]
  static void Main(string[] args)
  {
    // Create the application object.
    MyApp app = new MyApp();

    // Register the Startup/Exit events.
    app.Startup += (s, e) => { /* Start up the app */ };
    app.Exit += (s, e) => { /* Exit the app */ };
  }
}

```

在`Startup`处理程序中，您通常会处理任何传入的命令行参数，并启动程序的主窗口。如您所料，在`Exit`处理程序中，您可以为程序编写任何必要的关闭逻辑(例如，保存用户首选项，写入 Windows 注册表)。

Note

WPF 应用的`Main()`方法必须具有`[STAThread]`属性，这确保了应用使用的任何遗留 COM 对象都是线程安全的。如果你不以这种方式注释`Main()`，你将会遇到一个运行时异常。即使在 C# 9.0 中引入了顶级语句，您仍然希望在您的 WPF 应用中使用更传统的`Main()`方法。事实上，`Main()`方法是自动为您生成的。

### 枚举 Windows 集合

`Application`公开的另一个有趣的属性是`Windows`，它提供了对一个集合的访问，该集合代表当前 WPF 应用加载到内存中的每个窗口。当您创建新的`Window`对象时，它们会自动添加到`Application.Windows`集合中。下面是一个最小化应用每个窗口的示例方法(可能是为了响应终端用户触发的给定键盘手势或菜单选项):

```cs
static void MinimizeAllWindows()
{
  foreach (Window wnd in Application.Current.Windows)
  {
    wnd.WindowState = WindowState.Minimized;
  }
}

```

您将很快构建一些 WPF 应用，但在此之前，让我们检查一下`Window`类型的核心功能，并在此过程中了解一些重要的 WPF 基类。

### 窗口类的作用

`System.Windows.Window`类(位于`PresentationFramework.dll`汇编中)代表由`Application`派生类拥有的单个窗口，包括主窗口显示的任何对话框。毫不奇怪，`Window`有一系列的父类，每个父类都为表带来了更多的功能。考虑图 [24-1](#Fig1) ，它显示了通过 Visual Studio 对象浏览器看到的`System.Windows.Window`的继承链(和实现的接口)。

![img/340876_10_En_24_Chapter/340876_10_En_24_Fig1_HTML.jpg](img/340876_10_En_24_Chapter/340876_10_En_24_Fig1_HTML.jpg)

图 24-1。

窗口类的层次结构

随着本章和后续章节的学习，你会逐渐理解这些基类所提供的功能。然而，为了激起您的兴趣，下面几节将对每个基类提供的功能进行细分(请参考。NET 5 文档以获得完整的详细信息)。

#### 系统的作用。窗口.控件.内容控件

`Window`的直接父类是`ContentControl`，它很可能是所有 WPF 类中最吸引人的。这个基类为派生类型提供了承载单个*内容*的能力，简单地说，就是通过`Content`属性引用放置在控件表面区域内部的可视数据。WPF 内容模型使得定制内容控件的基本外观变得非常简单。

例如，当您想到一个典型的“按钮”控件时，您倾向于假设内容是一个简单的字符串(OK、Cancel、Abort 等)。).如果您使用 XAML 来描述一个 WPF 控件，并且您想要分配给属性`Content`的值可以被捕获为一个简单的字符串，那么您可以在元素的开始定义中这样设置`Content`属性(此时不要担心确切的标记):

```cs
<!-- Setting the Content value in the opening element -->
<Button Height="80" Width="100" Content="OK"/>

```

Note

也可以在 C# 代码中设置`Content`属性，这允许你在运行时改变控件的内部。

然而，内容几乎可以是任何东西。例如，假设您想要一个比简单字符串更有趣的“按钮”，可能是一个自定义图形和一个文本广告。在其他 UI 框架(如 Windows 窗体)中，您可能需要构建一个自定义控件，这可能需要维护相当多的代码和一个全新的类。对于 WPF 内容模型，没有必要这样做。

当您想要将`Content`属性赋给一个不能被捕获为简单字符数组的值时，您不能使用控件的开始定义中的属性来分配它。相反，您必须在元素的范围内隐式定义内容数据*。例如，下面的`<Button>`包含一个`<StackPanel>`作为内容，它本身包含一些唯一的数据(确切地说是一个`<Ellipse>`和`<Label>`):*

```cs
<!-- Implicitly setting the Content property with complex data -->
<Button Height="80" Width="100">
  <StackPanel>
    <Ellipse Fill="Red" Width="25" Height="25"/>
    <Label Content ="OK!"/>
  </StackPanel>
</Button>

```

你也可以利用 XAML 的*属性元素语法*来设置复杂的内容。考虑下面的功能等价的`<Button>`定义，它使用属性元素语法显式地设置了`Content`属性(同样，在本章的后面你会找到更多关于 XAML 的信息，所以现在还不要过多考虑细节):

```cs
<!-- Setting the Content property using property-element syntax -->
<Button Height="80" Width="100">
  <Button.Content>
    <StackPanel>
      <Ellipse Fill="Red" Width="25" Height="25"/>
      <Label Content ="OK!"/>
    </StackPanel>
  </Button.Content>
</Button>

```

请注意，不是每个 WPF 元素都是从`ContentControl`派生的，因此，不是所有的控件都支持这种独特的内容模型(然而，大多数都支持)。此外，一些 WPF 控件对您刚刚检查过的基本内容模型进行了一些改进。第 25 章将会更详细的讨论 WPF 内容的作用。

#### 系统的作用。窗口.控件.控件

与`ContentControl`不同，所有的 WPF 控件共享`Control`基类作为一个公共的父类。这个基类提供了许多核心成员，这些成员负责基本的 UI 功能。例如，`Control`定义属性来建立控件的大小、不透明度、tab 键顺序逻辑、显示光标、背景颜色等等。此外，这个父类提供了对*模板服务*的支持。正如第 [27](27.html) 章所解释的，WPF 控件可以使用模板和样式完全改变它们的外观。表 [24-6](#Tab6) 记录了`Control`类型的一些关键成员，按相关功能分组。

表 24-6。

控制类型的关键成员

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

成员

 | 

生命的意义

 |
| --- | --- |
| `Background`、`Foreground`、`BorderBrush`、`BorderThickness`、`Padding`、`HorizontalContentAlignment`、`VerticalContentAlignment` | 这些属性允许您设置有关如何呈现和定位控件的基本设置。 |
| `FontFamily`、`FontSize`、`FontStretch`、`FontWeight` | 这些属性控制各种字体居中设置。 |
| `IsTabStop`，`TabIndex` | 这些属性用于在窗口上的控件之间建立 tab 键顺序。 |
| `MouseDoubleClick`，`PreviewMouseDoubleClick` | 这些事件处理双击小部件的行为。 |
| `Template` | 此属性允许您获取和设置控件的模板，该模板可用于更改小部件的呈现输出。 |

#### 系统的作用。Windows.FrameworkElement

这个基类提供了许多在整个 WPF 框架中使用的成员，例如对故事板(在动画中使用)和数据绑定的支持，以及命名成员(通过`Name`属性)的能力，获取由派生类型定义的任何资源，以及建立派生类型的整体维度。表 [24-7](#Tab7) 击中亮点。

表 24-7。

FrameworkElement 类型的关键成员

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

成员

 | 

生命的意义

 |
| --- | --- |
| `ActualHeight`、`ActualWidth`、`MaxHeight`、`MaxWidth`、`MinHeight`、`MinWidth`、`Height`、`Width` | 这些属性控制派生类型的大小。 |
| `ContextMenu` | 获取或设置与派生类型关联的弹出菜单。 |
| `Cursor` | 获取或设置与派生类型关联的鼠标光标。 |
| `HorizontalAlignment`，`VerticalAlignment` | 获取或设置类型在容器(如面板或列表框)中的定位方式。 |
| `Name` | 允许您为类型指定一个名称，以便在代码文件中访问其功能。 |
| `Resources` | 提供对由类型定义的任何资源的访问(参见第 [29](29.html) 章检查 WPF 资源系统)。 |
| `ToolTip` | 获取或设置与派生类型关联的工具提示。 |

#### 系统的作用。Windows.UIElement

在`Window`的继承链中的所有类型中，`UIElement`基类提供了最多的功能。`UIElement`的主要任务是为派生类型提供大量的事件，以允许派生类型接收焦点和处理输入请求。例如，该类提供了许多事件来解释拖放操作、鼠标移动、键盘输入、手写笔输入和触摸。

第 [25 章](25.html)详细挖掘 WPF 事件模型；然而，许多核心事件看起来都很熟悉(`MouseMove`、`KeyUp`、`MouseDown`、`MouseEnter`、`MouseLeave`等)。).除了定义几十个事件之外，这个父类还提供了几个属性来说明控件焦点、启用状态、可见性和点击测试逻辑，如表 [24-8](#Tab8) 所示。

表 24-8。

`UIElement`类型的主要成员

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

成员

 | 

生命的意义

 |
| --- | --- |
| `Focusable`，`IsFocused` | 这些属性允许您将焦点设置在给定的派生类型上。 |
| `IsEnabled` | 此属性允许您控制是启用还是禁用给定的派生类型。 |
| `IsMouseDirectlyOver`，`IsMouseOver` | 这些属性提供了一种执行点击测试逻辑的简单方法。 |
| `IsVisible`，`Visibility` | 这些属性允许您使用派生类型的可见性设置。 |
| `RenderTransform` | 此属性允许您建立将用于呈现派生类型的转换。 |

#### 系统的作用。Windows.Media.Visual

`Visual`类类型在 WPF 中提供核心渲染支持，包括图形数据的点击测试、坐标转换和边界框计算。实际上，`Visual`类与底层 DirectX 子系统交互，在屏幕上绘制数据。正如你将在第 26 章[中看到的，WPF 提供了三种可能的方式来呈现图形数据，每种方式在功能和性能上都有所不同。使用`Visual`类型(及其子类型，如`DrawingVisual`)提供了最轻量级的方式来呈现图形数据，但它也需要大量的手动代码来处理所有需要的服务。同样，更多细节将在第 28 章](26.html)中介绍。

#### 系统的作用。Windows . DependencyObject 对象

WPF 支持一种特殊的口味。NET 属性称为*依赖属性*。简而言之，这种属性样式提供了额外的代码，以允许属性响应多种 WPF 技术，如样式、数据绑定、动画等。对于支持这个新属性方案的类型，它需要从`DependencyObject`基类派生。虽然依赖属性是 WPF 开发的一个关键方面，但是大部分时间它们的细节是隐藏的。第 25 章进一步深入依赖属性的细节。

#### 系统的作用。windows . threading . dispatch object

`Window`类型的最后一个基类是`DispatcherObject`(在`System.Object`之后，我认为在这本书的这一点上不需要进一步解释)。这个类型提供了一个感兴趣的属性，`Dispatcher`，它返回相关的`System.Windows.Threading.Dispatcher`对象。`Dispatcher`类是 WPF 应用事件队列的入口点，它提供了处理并发和线程的基本构造。第 [15 章](15.html)探讨了`Dispatcher`职业。

## 理解 WPF·XAML 的句法

生产级 WPF 应用通常会利用专用工具来生成必要的 XAML。尽管这些工具很有帮助，但是理解 XAML 标记的整体结构是一个好主意。为了帮助你的学习过程，请允许我介绍一个流行的(免费的)工具，它可以让你轻松地体验 XAML。

### Kaxaml 简介

当你第一次学习 XAML 语法时，使用一个名为 *Kaxaml* 的免费工具会很有帮助。你可以从 [`https://github.com/punker76/kaxaml`](https://github.com/punker76/kaxaml) 获得这个流行的 XAML 编辑器/解析器。

Note

对于这本书的许多版本，我都将用户指向 [`www.kaxaml.com`](http://www.kaxaml.com) ，但不幸的是，那个网站已经被停用了。Jan Karger ( [`https://github.com/punker76`](https://github.com/punker76) )继承了旧代码，并做了一些改进工作。你可以在 GitHub [`https://github.com/punker76/kaxaml/releases`](https://github.com/punker76/kaxaml/releases) 上找到他版本的工具。非常尊重和感谢 Kaxaml 的最初开发者和 Jan 让它保持活力；这是一个很棒的工具，帮助了无数开发者学习 XAML。

Kaxaml 很有帮助，因为它对 C# 源代码、事件处理程序或实现逻辑一无所知。与使用完整的 Visual Studio WPF 项目模板相比，这是一种更直接的测试 XAML 代码片段的方法。此外，Kaxaml 有几个集成的工具，如颜色选择器，xaml 片段管理器，甚至还有一个“XAML 洗涤器”选项，可以根据您的设置格式化您的 XAML。当您第一次打开 Kaxaml 时，您会发现一个`<Page>`控件的简单标记，如下所示:

```cs
<Page
  xmlns:="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
  <Grid>

  </Grid>
</Page>

```

像`Window`一样，`Page`包含各种布局管理器和控件。然而，与`Window`不同，`Page`对象不能作为独立实体运行。相反，它们必须放在合适的主机中，如`NavigationWindow`或`Frame`。好消息是，您可以在`<Page>`或`<Window>`范围内键入相同的标记。

Note

如果您将 Kaxaml 标记窗口中的`<Page>`和`</Page>`元素更改为`<Window>`和`</Window>`，您可以按 F5 键将一个新窗口加载到屏幕上。

作为初始测试，在工具底部的 XAML 窗格中输入以下标记:

```cs
<Page
  xmlns:="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
  <Grid>
    <!-- A button with custom content -->
    <Button Height="100" Width="100">
      <Ellipse Fill="Green" Height="50" Width="50"/>
    </Button>
  </Grid>
</Page>

```

现在你应该看到你的页面呈现在 Kaxaml 编辑器的上部(见图 [24-2](#Fig2) )。

![img/340876_10_En_24_Chapter/340876_10_En_24_Fig2_HTML.jpg](img/340876_10_En_24_Chapter/340876_10_En_24_Fig2_HTML.jpg)

图 24-2。

Kaxaml 是一个有用的(免费的)工具，用来学习 xaml 的语法

当您使用 Kaxaml 时，请记住该工具不允许您创作任何需要代码编译的标记(但是，允许使用`x:Name`)。这包括定义一个`x:Class`属性(用于指定代码文件)，在标记中输入事件处理程序名称，或者使用任何需要代码编译的 XAML 关键字(比如`FieldModifier`或者`ClassModifier`)。任何这样做的尝试都将导致标记错误。

### XAML XML 名称空间和 XAML“关键词”

WPF XAML 文档的根元素(如`<Window>`、`<Page>`、`<UserControl>`或`<Application>`定义)几乎总是引用以下两个预定义的 XML 名称空间:

```cs
<Page
  xmlns:="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
  <Grid>

  </Grid>
</Page>

```

第一个 XML 名称空间， [`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation) ，映射了一系列 WPF。NET 命名空间供当前的`*.xaml`文件使用(`System.Windows`、`System.Windows.Controls`、`System.Windows.Ink`、`System.Windows.Media`、`System.Windows.Navigation`等)。).

这种一对多的映射是在 WPF 程序集(`WindowsBase.dll`、`PresentationCore.dll`和`PresentationFramework.dll`)中使用程序集级的`[XmlnsDefinition]`属性硬编码的。例如，如果您打开 Visual Studio 对象浏览器并选择`PresentationCore.dll`程序集，您将看到如下清单，它实际上导入了`System.Windows`:

```cs
[assembly: XmlnsDefinition("http://schemas.microsoft.com/winfx/2006/xaml/presentation",
                           "System.Windows")]

```

第二个 XML 名称空间， [`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml) ，用于包含特定于 XAML 的“关键字”(因为缺少更好的术语)以及`System.Windows.Markup`名称空间，如下所示:

```cs
[assembly: XmlnsDefinition("http://schemas.microsoft.com/winfx/2006/xaml",
                           "System.Windows.Markup")]

```

任何格式良好的 XML 文档的一个规则(记住，XAML 是一种基于 XML 的语法)是，开始的根元素指定一个 XML 名称空间作为*主名称空间*，它是包含最常见项的名称空间。如果根元素需要包含额外的辅助名称空间(如此处所示)，则必须使用惟一的标记前缀来定义它们(以解决任何可能的名称冲突)。按照惯例，前缀简单来说就是`x`；然而，这可以是您需要的任何唯一令牌，比如`XamlSpecificStuff`。

```cs
<Page
  xmlns:="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
  xmlns:XamlSpecificStuff="http://schemas.microsoft.com/winfx/2006/xaml">
  <Grid>
    <!-- A button with custom content -->
    <Button XamlSpecificStuff:Name="button1" Height="100" Width="100">
      <Ellipse Fill="Green" Height="50" Width="50"/>
    </Button>
  </Grid>
</Page>

```

定义冗长的 XML 名称空间前缀的明显缺点是，每次 XAML 文件需要引用这个以 XAML 为中心的 XML 名称空间中定义的一个项目时，您都需要键入`XamlSpecificStuff`。鉴于`XamlSpecificStuff`需要许多额外的击键，只需坚持使用`x`。

在任何情况下，除了`x:Name`、`x:Class`和`x:Code`关键字之外， [`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml) XML 名称空间还提供了对其他 XAML 关键字的访问，其中最常见的如表 [24-9](#Tab9) 所示。

表 24-9。

XAML 关键词

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

XAML 关键词

 | 

生命的意义

 |
| --- | --- |
| `x:Array` | 表示 XAML 中的. NET 数组类型。 |
| `x:ClassModifier` | 允许您定义由关键字`Class`表示的 C# 类(内部或公共)的可见性。 |
| `x:FieldModifier` | 允许您为根的任何命名子元素(例如，`<Window>`元素中的`<Button>`)定义类型成员(内部、公共、私有或受保护)的可见性。使用关键字`Name` XAML 定义了一个*命名元素*。 |
| `x:Key` | 允许您为将放入 dictionary 元素中的 XAML 项建立一个键值。 |
| `x:Name` | 允许您指定给定 XAML 元素的生成 C# 名称。 |
| `x:Null` | 代表一个`null`引用。 |
| `x:Static` | 允许您引用某个类型的静态成员。 |
| `x:Type` | C# `typeof`操作符的 XAML 等价物(它将基于所提供的名称产生一个`System.Type`)。 |
| `x:TypeArguments` | 允许您将元素建立为具有特定类型参数的泛型类型(例如，`List<int>`与`List<bool>`)。 |

除了这两个必要的 XML 名称空间声明之外，在 XAML 文档的开始元素中定义额外的标记前缀是可能的，有时也是必要的。每当您需要在 XAML 中描述一个在外部程序集中定义的. NET 核心类时，您通常会这样做。

例如，假设您已经构建了一些定制的 WPF 控件，并将它们打包在一个名为`MyControls.dll`的库中。现在，如果您想创建一个使用这些控件的新的`Window`，您可以使用`clr-namespace`和`assembly`标记建立一个映射到您的库的定制 XML 名称空间。以下是创建名为`myCtrls`的标签前缀的一些示例标记，该标签前缀可用于访问库中的控件:

```cs
<Window x:Class="WpfApplication1.MainWindow"
  xmlns:="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
  xmlns:myCtrls="clr-namespace:MyControls;assembly=MyControls"
  Title="MainWindow" Height="350" Width="525">
  <Grid>
    <myCtrls:MyCustomControl />
  </Grid>
</Window>

```

`clr-namespace`标记被分配给。NET 核心命名空间，而`assembly`标记被设置为外部`*.dll`程序集的友好名称。您可以将此语法用于任何外部。NET 核心库你想操纵的标记。虽然目前还不需要这样做，但以后的章节将要求您定义自定义的 XML 名称空间声明来描述标记中的类型。

Note

如果需要在标记中定义一个类，该标记是当前程序集的一部分，但在不同的。NET 核心命名空间中，您的`xmlns`标记前缀是在没有`assembly=`属性的情况下定义的，比如:`xmlns:myCtrls="clr-namespace:SomeNamespaceInMyApp"`。

### 控制类和成员变量的可见性

在接下来的章节中，你会在需要的地方看到很多这样的关键词；然而，作为一个简单的例子，考虑下面的 XAML `<Window>`定义，它使用了`ClassModifier`和`FieldModifier`关键字，以及`x:Name`和`x:Class`(记住`kaxaml.exe`不允许您使用任何需要代码编译的 XAML 关键字，比如`x:Code`、`x:FieldModifier`或`x:ClassModifier`):

```cs
<!-- This class will now be declared internal in the *.g.cs file -->
<Window x:Class="MyWPFApp.MainWindow" x:ClassModifier ="internal"
  xmlns:="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">

  <!-- This button will be public in the *.g.cs file -->
  <Button x:Name ="myButton" x:FieldModifier ="public" Content = "OK"/>
</Window>

```

默认情况下，所有 C#/XAML 类型定义都是`public`，而成员默认为`internal`。然而，基于您的 XAML 定义，最终自动生成的文件包含一个带有公共`Button`变量的内部类类型。

```cs
internal partial class MainWindow :
System.Windows.Window,
  System.Windows.Markup.IComponentConnector
{
  public System.Windows.Controls.Button myButton;
...
}

```

### XAML 元素、XAML 属性和类型转换器

在建立了根元素和任何所需的 XML 名称空间之后，下一个任务是用一个*子元素*填充根元素。在现实世界的 WPF 应用中，这个孩子将是一个布局管理器(比如一个`Grid`或`StackPanel`)，它依次包含任意数量的描述用户界面的附加 UI 元素。下一章将详细研究这些布局管理器，所以现在假设您的`<Window>`类型将包含一个`Button`元素。

正如你在本章已经看到的，XAML 元素映射到一个给定的类或结构类型。NET 核心名称空间，而开始元素标记中的*属性*映射到该类型的属性或事件。举例来说，在 Kaxaml 中输入下面的`<Button>`定义:

```cs
<Page
  xmlns:="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
  <Grid>
    <!-- Configure the look and feel of a Button -->
    <Button Height="50" Width="100" Content="OK!"
            FontSize="20" Background="Green" Foreground="Yellow"/>
  </Grid>
</Page>

```

请注意，分配给每个属性的值已经被捕获为一个简单的文本值。这看起来像是完全不匹配的数据类型，因为如果你在 C# 代码中使用这个`Button`，你将*而不是*给这些属性分配字符串对象，而是使用特定的数据类型。例如，下面是用代码创作的同一个按钮:

```cs
public void MakeAButton()
{
  Button myBtn = new Button();
  myBtn.Height = 50;
  myBtn.Width = 100;
  myBtn.FontSize = 20;
  myBtn.Content = "OK!";
  myBtn.Background = new SolidColorBrush(Colors.Green);
  myBtn.Foreground = new SolidColorBrush(Colors.Yellow);
}

```

事实证明，WPF 附带了几个*类型转换器*类，用于将简单的文本值转换成正确的底层数据类型。这个过程透明地(并且自动地)发生。

虽然这很好，但是很多时候您需要为 XAML 属性分配一个更复杂的值，而这个值不能作为一个简单的字符串被捕获。例如，假设您想要构建一个自定义画笔来设置`Button`的`Background`属性。如果你在代码中构建画笔，这是非常简单的，如下所示:

```cs
public void MakeAButton()
{
...
  // A fancy brush for the background.
  LinearGradientBrush fancyBruch =
    new LinearGradientBrush(Colors.DarkGreen, Colors.LightGreen, 45);
  myBtn.Background = fancyBruch;
  myBtn.Foreground = new SolidColorBrush(Colors.Yellow);
}

```

如何将复杂的画笔表示为字符串？你不能！幸运的是，XAML 提供了一种特殊的语法，当你需要给一个复杂的对象赋值时，可以使用这种语法，称为*属性元素语法*。

### 理解 XAML 属性元素语法

*属性元素语法*允许你将复杂的对象分配给一个属性。下面是一个对使用一个`LinearGradientBrush`来设置其`Background`属性的`Button`的 XAML 描述:

```cs
<Button Height="50" Width="100" Content="OK!"
        FontSize="20" Foreground="Yellow">
  <Button.Background>
    <LinearGradientBrush>
      <GradientStop Color="DarkGreen" Offset="0"/>
      <GradientStop Color="LightGreen" Offset="1"/>
    </LinearGradientBrush>
  </Button.Background>
</Button>

```

注意，在`<Button>`和`</Button>`标记的范围内，您已经定义了一个名为`<Button.Background>`的子范围。在这个范围内，您已经定义了一个自定义的`<LinearGradientBrush>`。(不要担心画笔的确切代码；你会在第 28 章[中了解到 WPF 图形。)](28.html)

任何属性都可以使用属性元素语法来设置，该语法通常分为以下模式:

```cs
<DefiningClass>
  <DefiningClass.PropertyOnDefiningClass>
    <!-- Value for Property here! -->
  </DefiningClass.PropertyOnDefiningClass>
</DefiningClass>

```

虽然任何属性*都可以使用这个语法进行设置，但是如果您可以将一个值捕获为一个简单的字符串，那么您将节省自己的输入时间。例如，这里有一个更详细的方法来设置您的`Button`的`Width`:*

```cs
<Button Height="50" Content="OK!"
        FontSize="20" Foreground="Yellow">
...
  <Button.Width>
    100
  </Button.Width>
</Button>

```

### 了解 XAML 附加属性

除了属性元素语法之外，XAML 还定义了一种特殊的语法，用于为附加到属性的*设置一个值。本质上，附加属性允许子元素为父元素中定义的属性设置值。要遵循的通用模板如下所示:*

```cs
<ParentElement>
  <ChildElement ParentElement.PropertyOnParent = "Value">
</ParentElement>

```

附加属性语法最常见的用法是将 UI 元素放置在 WPF 布局管理器的一个类中(`Grid`、`DockPanel`等)。).下一章将详细介绍这些面板；现在，在 Kaxaml 中输入以下内容:

```cs
<Page
  xmlns:="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
  <Canvas Height="200" Width="200" Background="LightBlue">
    <Ellipse Canvas.Top="40" Canvas.Left="40" Height="20" Width="20" Fill="DarkBlue"/>
  </Canvas>
</Page>

```

这里，您已经定义了一个包含一个`Ellipse`的`Canvas`布局管理器。注意，`Ellipse`可以使用附加的属性语法通知其父节点(`Canvas`)在哪里放置它的顶部/左侧位置。

关于附加属性，有一些事项需要注意。首先也是最重要的，这不是一个可以应用于 *any* 父节点的 *any* 属性的通用语法。例如，以下 XAML 无法正确解析:

```cs
<!-- Error! Set Background property on Canvas via attached property? -->
<Canvas Height="200" Width="200">
  <Ellipse Canvas.Background="LightBlue"
           Canvas.Top="40" Canvas.Left="90"
           Height="20" Width="20" Fill="DarkBlue"/>
</Canvas>

```

附加属性是 WPF 特有概念的一种特殊形式，称为*依赖属性*。除非属性是以特定方式实现的，否则不能使用附加属性语法设置其值。你将在第 25 章[中详细探究依赖属性。](25.html)

Note

Visual Studio 具有 IntelliSense，它将向您显示可由给定元素设置的有效附加属性。

### 了解 XAML 标记扩展

如前所述，属性值通常使用简单的字符串或通过属性元素语法来表示。然而，还有另一种方法来指定 XAML 属性的值，使用*标记扩展*。标记扩展允许 XAML 解析器从专用的外部类获取属性值。考虑到一些属性值需要执行几个代码语句来计算值，这可能是有益的。

标记扩展提供了一种用新功能干净地扩展 XAML 语法的方法。标记扩展在内部表示为从`MarkupExtension`派生的类。请注意，您需要构建自定义标记扩展的机会微乎其微。然而，XAML 关键字的子集(如`x:Array`、`x:Null`、`x:Static`和`x:Type`)是伪装的标记扩展！

标记扩展夹在大括号之间，就像这样:

```cs
<Element PropertyToSet = "{MarkUpExtension}"/>

```

要查看一些正在运行的标记扩展，请将以下代码编写到 Kaxaml 中:

```cs
<Page
  xmlns:="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
  xmlns:CorLib="clr-namespace:System;assembly=mscorlib">

  <StackPanel>
    <!-- The Static markup extension lets us obtain a value
         from a static member of a class -->
    <Label Content ="{x:Static CorLib:Environment.OSVersion}"/>
    <Label Content ="{x:Static CorLib:Environment.ProcessorCount}"/>

    <!-- The Type markup extension is a XAML version of
         the C# typeof operator -->
    <Label Content ="{x:Type Button}" />
    <Label Content ="{x:Type CorLib:Boolean}" />

    <!-- Fill a ListBox with an array of strings! -->
    <ListBox Width="200" Height="50">
      <ListBox.ItemsSource>
        <x:Array Type="CorLib:String">
          <CorLib:String>Sun Kil Moon</CorLib:String>
          <CorLib:String>Red House Painters</CorLib:String>
          <CorLib:String>Besnard Lakes</CorLib:String>
        </x:Array>
      </ListBox.ItemsSource>
    </ListBox>
  </StackPanel>
</Page>

```

首先，注意到`<Page>`定义有一个新的 XML 名称空间声明，它允许您访问`mscorlib.dll`的`System`名称空间。建立了这个 XML 名称空间后，首先使用`x:Static`标记扩展，并从`System.Environment`类的`OSVersion`和`ProcessorCount`中获取值。

`x:Type`标记扩展允许您访问指定项目的元数据描述。这里，您只是简单地指定了 WPF `Button`和`System.Boolean`类型的完全限定名。

这个标记中最有趣的部分是`ListBox`。这里，您将`ItemsSource`属性设置为完全在标记中声明的字符串数组！注意这里的`x:Array`标记扩展如何允许你在它的范围内指定一组子项:

```cs
<x:Array Type="CorLib:String">
  <CorLib:String>Sun Kil Moon</CorLib:String>
  <CorLib:String>Red House Painters</CorLib:String>
  <CorLib:String>Besnard Lakes</CorLib:String>
</x:Array>

```

Note

前面的 XAML 例子只是用来说明标记扩展的作用。正如你将在第 25 章中看到的，填充`ListBox`控件有更简单的方法！

图 [24-3](#Fig3) 显示了这个`<Page>`在 Kaxaml 中的标记。

![img/340876_10_En_24_Chapter/340876_10_En_24_Fig3_HTML.jpg](img/340876_10_En_24_Chapter/340876_10_En_24_Fig3_HTML.jpg)

图 24-3。

标记扩展允许您通过专用类的功能来设置值

现在，您已经看到了许多展示 XAML 语法每个核心方面的例子。你可能会同意，XAML 是有趣的，因为它允许你描述一个树。NET 对象。虽然这在配置图形用户界面时非常有用，但请记住，XAML 可以描述来自*任何*程序集的*任何*类型，只要它是包含默认构造函数的非抽象类型。

## 使用 Visual Studio 构建 WPF 应用

让我们看看 Visual Studio 如何简化 WPF 程序的构造。虽然您可以使用 Visual Studio 代码生成 WPF 应用，但 Visual Studio 代码没有任何用于生成 WPF 应用的设计器支持。Visual Studio 具有丰富的 XAML 支持，在构建 WPF 应用时是一个更高效的 IDE。

Note

在这里，我将指出使用 Visual Studio 构建 WPF 应用的一些关键特性。接下来的章节将在必要的地方说明 IDE 的其他方面。

### WPF 项目模板

Visual Studio 的新建项目对话框定义了一组 WPF 项目模板，包括 WPF App、WPF 自定义控件库、WPF 用户控件库。创建新的 WPF 应用(。NET)名为 WpfTesterApp 的项目。

Note

当从 Visual Studio“添加新项目”屏幕中选择 WPF 项目时，请确保选择具有“(”的 WPF 项目模板。NET)“在标题中，而不是”(。NET 框架)。”的当前版本。NET Core 已经被简单地重命名为。净 5。如果选择带有“(”的模板。NET Framework)”在标题中，您将使用。NET Framework 4.x。

除了将项目 SDK 设置为`Microsoft.NET.Sdk`之外，还将为您提供初始的`Window`和`Application`派生类，每一个都使用 XAML 和 C# 代码文件来表示。

### 工具箱和 XAML 设计器/编辑器

Visual Studio 提供了一个工具箱(可以通过“视图”菜单打开)，其中包含许多 WPF 控件。面板的顶部包含最常用的控件，底部包含所有控件(参见图 [24-4](#Fig4) )。

![img/340876_10_En_24_Chapter/340876_10_En_24_Fig4_HTML.jpg](img/340876_10_En_24_Chapter/340876_10_En_24_Fig4_HTML.jpg)

图 24-4。

工具箱包含可以放置在设计器图面上的 WPF 控件

使用标准的拖放操作，您可以将这些控件中的任何一个放置在窗口的设计器图面上，或者将控件拖动到设计器底部的 XAML 标记编辑器中。当你这样做的时候，最初的 XAML 将会以你的名义被创作。用鼠标将一个`Button`控件和一个`Calendar`控件拖动到设计器表面上。完成后，请注意如何重新定位和调整控件的大小(并确保检查基于编辑生成的 XAML)。

除了通过鼠标和工具箱构建 UI 之外，您还可以使用集成的 XAML 编辑器手动输入标记。正如你在图 [24-5](#Fig5) 中看到的，你得到了智能感知支持，这可以帮助简化标记的创作。例如，尝试将`Background`属性添加到开始的`<Window>`元素中。

![img/340876_10_En_24_Chapter/340876_10_En_24_Fig5_HTML.jpg](img/340876_10_En_24_Chapter/340876_10_En_24_Fig5_HTML.jpg)

图 24-5。

WPF 橱窗设计师

花点时间在 XAML 编辑器中直接添加一些属性值。确保你花时间去适应使用 WPF 设计器的这个方面。

### 使用“属性”窗口设置属性

将一些控件放置到设计器上(或在编辑器中手动定义它们)后，可以利用“属性”窗口来设置所选控件的属性值，以及装配所选控件的事件处理程序。通过一个简单的测试，在设计器上选择您的`Button`控件。现在，使用属性窗口通过集成笔刷编辑器改变`Button`的`Background`颜色(见图[24-6](#Fig6)；在你检查 WPF 图形的时候，你会在第 26 章[学到更多关于笔刷编辑器的知识。](26.html)

![img/340876_10_En_24_Chapter/340876_10_En_24_Fig6_HTML.jpg](img/340876_10_En_24_Chapter/340876_10_En_24_Fig6_HTML.jpg)

图 24-6。

“属性”窗口可用于配置 WPF 控件的用户界面

Note

“属性”窗口的顶部提供了一个搜索文本区域。键入要设置的属性的名称，以便快速找到有问题的项目。

在您完成了对画笔编辑器的修改之后，检查生成的标记。它可能看起来像这样:

```cs
<Button Content="Button" HorizontalAlignment="Left" Margin="10,10,0,0" VerticalAlignment="Top" Width="75">
  <Button.Background>
    <LinearGradientBrush EndPoint="0.5,1" StartPoint="0.5,0">
      <GradientStop Color="Black" Offset="0"/>
      <GradientStop Color="#FFE90E0E" Offset="1"/>
      <GradientStop Color="#FF1F4CE3"/>
    </LinearGradientBrush>
  </Button.Background>
</Button>

```

### 使用“属性”窗口处理事件

如果您想要处理给定控件的事件，也可以利用“属性”窗口，但是这一次您需要单击“属性”窗口右上角的“事件”按钮(寻找闪电图标)。确保在您的设计器上选择了按钮，并定位到`Click`事件。完成后，直接双击`Click`事件条目。这将导致 Visual Studio 自动生成一个事件处理程序，该处理程序采用以下常规形式:

```cs
NameOfControl_NameOfEvent

```

因为你没有重命名你的按钮，属性窗口显示它生成了一个名为`Button_Click`的事件处理程序(见图 [24-7](#Fig7) )。

![img/340876_10_En_24_Chapter/340876_10_En_24_Fig7_HTML.jpg](img/340876_10_En_24_Chapter/340876_10_En_24_Fig7_HTML.jpg)

图 24-7。

使用“属性”窗口处理事件

同样，Visual Studio 在窗口的代码文件中生成了相应的 C# 事件处理程序。在这里，您可以添加任何类型的代码，这些代码必须在按钮被单击时执行。要进行快速测试，只需输入以下代码语句:

```cs
private void Button_Click(object sender, RoutedEventArgs e)
{
  MessageBox.Show("You clicked the button!");
}

```

### 在 XAML 编辑器中处理事件

您也可以直接在 XAML 编辑器中处理事件。举个例子，将鼠标放在`<Window>`元素中，输入`MouseMove`事件，后面跟着等号。一旦你这样做了，你会看到 Visual Studio 在你的代码文件中显示任何兼容的处理程序(如果它们存在的话)，以及创建一个新的事件处理程序的选项(见图 [24-8](#Fig8) )。

![img/340876_10_En_24_Chapter/340876_10_En_24_Fig8_HTML.jpg](img/340876_10_En_24_Chapter/340876_10_En_24_Fig8_HTML.jpg)

图 24-8。

使用 XAML 编辑器处理事件

让 IDE 创建`MouseMove`事件处理程序，输入以下代码，然后运行应用以查看结果:

```cs
private void MainWindow_MouseMove (object sender, MouseEventArgs e)
{
  this.Title = e.GetPosition(this).ToString();
}

```

Note

第 28 章讲述了 MVVM 和命令模式，这是在企业应用中处理点击事件的一种更好的方式。但是如果你只需要一个简单的应用，用一个直接的事件处理器来处理点击事件是完全可以接受的。

### “文档大纲”窗口

当你处理任何基于 XAML 的项目时，你肯定会使用大量的标记来表示你的用户界面。当您开始处理更复杂的 XAML 时，可视化标记以快速选择要在 Visual Studio 设计器上编辑的项会很有用。

目前，您的标记相当平淡，因为您只在初始的`<Grid>`中定义了几个控件。但是，在 IDE 中找到文档大纲窗口，默认情况下，该窗口安装在 Visual Studio 的左侧(如果找不到，只需使用“查看➤其他窗口”菜单选项激活它)。现在，确保你的 XAML 设计器是 IDE 中的活动窗口(而不是 C# 代码文件)，你会注意到文档大纲窗口显示了嵌套的元素(见图 [24-9](#Fig9) )。

![img/340876_10_En_24_Chapter/340876_10_En_24_Fig9_HTML.jpg](img/340876_10_En_24_Chapter/340876_10_En_24_Fig9_HTML.jpg)

图 24-9。

通过文档大纲窗口可视化您的 XAML

此工具还提供了一种在设计器上临时隐藏给定项(或一组项)以及锁定项以防止发生额外编辑的方法。在下一章中，您将看到文档大纲窗口如何还提供了许多其他功能来将所选项目分组到新的布局管理器中(以及其他功能)。

### 启用或禁用 XAML 调试器

当您运行应用时，您会在屏幕上看到`MainWindow`。您还会看到交互式调试器，如图 [24-10](#Fig10) 所示。

![img/340876_10_En_24_Chapter/340876_10_En_24_Fig10_HTML.jpg](img/340876_10_En_24_Chapter/340876_10_En_24_Fig10_HTML.jpg)

图 24-10。

XAML 用户界面调试

如果你想关闭它，你可以在工具➤选项➤调试➤热重装下找到 XAML 调试的条目。取消选择顶部的框，以防止调试器窗口覆盖您的窗口。图 [24-11](#Fig11) 显示了条目。

![img/340876_10_En_24_Chapter/340876_10_En_24_Fig11_HTML.jpg](img/340876_10_En_24_Chapter/340876_10_En_24_Fig11_HTML.jpg)

图 24-11。

XAML 用户界面调试

### 检查 App.xaml 文件

项目如何知道启动哪个窗口？更有趣的是，如果您检查应用中的代码文件，您还会发现到处都找不到`Main()`方法。你已经通过这本书了解到应用必须有一个入口点，那么。不知道如何启动你的应用？幸运的是，这两个管道项目都是通过 Visual Studio 模板和 WPF 框架来处理的。

为了解决启动哪个窗口的难题，`App.xaml`文件通过标记定义了一个应用类。除了名称空间定义，它还定义了应用属性，如`StartupUri`、应用范围的资源(在第 [27 章](27.html)中介绍)以及应用事件的特定处理程序，如`Startup`和`Exit`。`StartupUri`指示启动时加载哪个窗口。打开`App.xaml`文件并检查标记，如下所示:

```cs
<Application x:Class="WpfTesterApp.App"
             xmlns:="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="clr-namespace:WpfTesterApp"
             StartupUri="MainWindow.xaml">
    <Application.Resources>
    </Application.Resources>
</Application>

```

使用 XAML 设计器和 Visual Studio 代码完成功能，为`Startup`和`Exit`事件添加处理程序。更新后的 XAML 应该是这样的(注意以粗体显示的变化):

```cs
<Application x:Class="WpfTesterApp.App"
             xmlns:="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="clr-namespace:WpfTesterApp"
             StartupUri="MainWindow.xaml" Startup="App_OnStartup" Exit="App_OnExit">
    <Application.Resources>
    </Application.Resources>
</Application>

```

如果您查看`App.xaml.cs`文件，它应该是这样的:

```cs
public partial class App : Application
{
  private void App_OnStartup(object sender, StartupEventArgs e)
  {
  }
  private void App_OnExit(object sender, ExitEventArgs e)
  {
  }
}

```

请注意，该类被标记为分部类。事实上，XAML 文件的所有代码隐藏窗口都被标记为分部窗口。这是解开`Main()`方法存在于何处之谜的关键。但是首先，您需要检查当`msbuild.exe`处理 XAML 文件时发生了什么。

### 将窗口 XAML 标记映射到 C# 代码

当`msbuild.exe`处理您的`*.csproj`文件时，它为您项目中的每个 XAML 文件生成三个文件，格式为`*.g.cs`(其中`g`表示自动*生成*)、`*.g.i.cs`(其中 *i* 表示智能感知)、以及`*.baml`(用于二进制应用标记语言)。这些文件被保存到`\obj\Debug`目录中(可以通过点击 Show All Files 按钮在 Solution Explorer 中查看)。您可能必须点击解决方案资源管理器中的刷新按钮才能看到它们，因为它们不是实际项目的一部分，而是构建工件。

为了更好地理解该过程，为控件提供名称会很有帮助。继续为`Button`和`Calendar`控件提供名称，如下所示:

```cs
<Button Name="ClickMe" Content="Button" HorizontalAlignment="Left" Margin="10,10,0,0"
       VerticalAlignment="Top" Width="75" Click="Button_Click">
//omitted for brevity
</Button>
<Calendar Name="MyCalendar" HorizontalAlignment="Left" Margin="10,41,0,0" VerticalAlignment="Top"/>

```

现在重新生成您的解决方案(或项目)并刷新解决方案资源管理器中的文件。如果你在文本编辑器中打开`MainWindow.g.cs`文件，你会发现一个名为`MainWindow`的类，它扩展了`Window`基类。这个类的名字是由`<Window>`开始标签中的`x:Class`属性直接产生的。

这个类定义了一个类型为`bool`(名为`_contentLoaded`)的私有成员变量，它在 XAML 标记中没有被直接考虑。这个数据成员用于确定(并确保)窗口的内容只被分配一次。这个类还包含一个类型为`System.Windows.Controls.Button`的成员变量，名为`ClickMe`。控件的名称基于开始的`<Button>`声明中的`x:Name`(或者简写为`form Name`)属性值。你看不到的是`Calendar`控件的变量。这是因为`msbuild.exe`为 XAML 中每个名为的*控件创建了一个变量，该控件在代码隐藏中有相关的代码。如果没有任何代码，就不需要变量。更令人困惑的是，如果您没有命名`Button`控件，它也不会有变量。这是 WPF 魔力的一部分，并且与`IComponentConnector`接口实现紧密相连。*

编译器生成的类还显式实现了在`System.Windows.Markup`名称空间中定义的 WPF `IComponentConnector`接口。该接口定义了一个名为`Connect()`的方法，该方法已经被实现来准备标记中定义的每个控件，并按照原始`MainWindow.xaml`文件中指定的那样装配事件逻辑。您可以看到为`ClickMe`点击事件设置的处理程序。在该方法完成之前，`_contentLoaded`成员变量被设置为`true`。这是该方法的关键:

```cs
void System.Windows.Markup.IComponentConnector.Connect(int connectionId, object target)
{
  switch (connectionId)
  {
    case 1:
    this.ClickMe = ((System.Windows.Controls.Button)(target));
    #line 11 "..\..\MainWindow.xaml"
    this.ClickMe.Click += new System.Windows.RoutedEventHandler(this.Button_Click);
    #line default
    #line hidden
    return;
  }
  this._contentLoaded = true;
}

```

要用代码显示未命名控件的效果，请为日历上的`SelectedDatesChanged`事件添加一个事件处理程序。重新构建应用，刷新文件，并重新加载`MainWindow.g.cs`文件。在`Connect()`方法中，您现在可以看到下面的代码块:

```cs
#line 20 "..\..\MainWindow.xaml"
this.MyCalendar.SelectedDatesChanged += new
     System.EventHandler<System.Windows.Controls.SelectionChangedEventArgs>(
         this.MyCalendar_OnSelectedDatesChanged);

```

这告诉框架 XAML 文件第 20 行的控件分配了`SelectedDatesChanged`事件处理程序，如前面的代码所示。

最后，`MainWindow`类定义并实现了一个名为`InitializeComponent()`的方法。您可能希望这个方法包含通过设置各种属性(`Height`、`Width`、`Content`等)来设置每个控件的外观和感觉的代码。).然而事实并非如此！那么控件如何呈现正确的用户界面呢？带有`InitializeComponent()`的逻辑解析与原始`*.xaml`文件同名的嵌入式汇编资源的位置，如下所示:

```cs
public void InitializeComponent() {
  if (_contentLoaded) {
    return;
    }
    _contentLoaded = true;
    System.Uri resourceLocater = new System.Uri("/WpfTesterApp;component/mainwindow.xaml",
        System.UriKind.Relative);
    #line 1 "..\..\MainWindow.xaml"
    System.Windows.Application.LoadComponent(this, resourceLocater);
    #line default
    #line hidden
}

```

此时，问题变成了*“*这个嵌入式资源到底是什么？”

### BAML 的角色

正如您可能从名称中猜到的那样，二进制应用标记语言(BAML)是原始 XAML 数据的一种紧凑的二进制表示。这个`*.baml`文件作为资源(通过一个生成的`*.g.resources`文件)嵌入到编译后的程序集中。这个 BAML 资源包含了建立 UI 小部件的外观所需的所有数据(同样，比如`Height`和`Width`属性)。

这里重要的一点是理解 WPF 应用本身包含标记的二进制表示(BAML)。在运行时，这个 BAML 将从资源容器中提取出来，用于确保所有的窗口和控件都被初始化为正确的外观。

另外，请记住，这些二进制资源的名称*与您创作的独立`*.xaml`文件的名称*相同。然而，这并不意味着您必须将松散的`*.xaml`文件与您编译的 WPF 程序一起分发。除非您构建了一个 WPF 应用，可以在运行时动态加载和解析`*.xaml`文件，否则您永远不需要发送原始标记。

### 解开 Main 之谜()

现在您已经知道了 MSBuild 过程是如何工作的，打开`App.g.cs`文件。在这里，您将找到自动生成的`Main()`方法，它初始化并运行您的应用对象。

```cs
public static void Main() {
  WpfTesterApp.App app = new WpfTesterApp.App();
  app.InitializeComponent();
  app.Run();
}

```

`InitializeComponent()`方法配置应用属性，包括`StartupUri`以及`Startup`和`Exit`事件的事件处理程序。

```cs
public void InitializeComponent() {
    #line 5 "..\..\App.xaml"
    this.Startup += new System.Windows.StartupEventHandler(this.App_OnStartup);
    #line default
    #line hidden
    #line 5 "..\..\App.xaml"
    this.Exit += new System.Windows.ExitEventHandler(this.App_OnExit);
    #line default
    #line hidden
    #line 5 "..\..\App.xaml"
    this.StartupUri = new System.Uri("MainWindow.xaml", System.UriKind.Relative);
    #line default
    #line hidden
}

```

### 与应用级数据交互

回想一下，`Application`类定义了一个名为`Properties`的属性，它允许您通过类型索引器定义一组名称-值对。因为这个索引器被定义为在类型`System.Object`上操作，所以您可以在这个集合中存储任何种类的项(包括您的自定义类),以便以后使用友好的名字对象进行检索。使用这种方法，在 WPF 应用的所有窗口之间共享数据变得很简单。

举例来说，您将更新当前的`Startup`事件处理程序，以检查名为`/GODMODE`(许多 PC 视频游戏的常见欺骗代码)的值的传入命令行参数。如果找到这个标记，您将在同名的 properties 集合中建立一个设置为`true`的`bool`值(否则，您将把该值设置为`false`)。

这听起来很简单，但是如何将传入的命令行参数(通常从`Main()`方法获得)传递给`Startup`事件处理程序呢？一种方法是调用静态的`Environment.GetCommandLineArgs()`方法。然而，这些相同的参数被自动添加到传入的`StartupEventArgs`参数中，并且可以通过`Args`属性来访问。以下是对当前代码库的首次更新:

```cs
private void App_OnStartup(object sender, StartupEventArgs e)
{
  Application.Current.Properties["GodMode"] = false;
  // Check the incoming command-line arguments and see if they
  // specified a flag for /GODMODE.
  foreach (string arg in e.Args)
  {
    if (arg.Equals("/godmode",StringComparison.OrdinalIgnoreCase))
    {
      Application.Current.Properties["GodMode"] = true;
      break;
    }
  }
}

```

可以从 WPF 应用中的任何位置访问应用范围的数据。您需要做的就是获得一个全局应用对象的访问点(通过`Application.Current`)并研究这个集合。例如，您可以这样更新`Button`的`Click`事件处理程序:

```cs
private void Button_Click(object sender, RoutedEventArgs e)
{
  // Did user enable /godmode?
  if ((bool)Application.Current.Properties["GodMode"])
  {
    MessageBox.Show("Cheater!");
  }
}

```

这样，如果您在项目属性的 Debug 选项卡中输入`/godmode`命令行参数，然后运行程序，您将会感到羞愧，程序将会退出。您也可以通过输入以下命令从命令行运行该程序(打开命令提示符并导航到`bin/debug`目录):

```cs
WpfAppAllCode.exe /godmode

```

当终止应用时，你会看到一个不光彩的消息框。

Note

回想一下，您可以在 Visual Studio 中提供命令行参数。只需双击解决方案资源管理器中的属性图标，在结果编辑器中单击 Debug 选项卡，然后在“命令行参数”编辑器中输入`/godmode`。

### 处理窗口对象的关闭

最终用户可以通过使用许多内置的系统级技术(例如，单击窗口框架上的 x 关闭按钮)或通过间接调用`Close()`方法来响应一些用户交互元素(例如，文件➤退出)来关闭窗口。在这两种情况下，WPF 都提供了两个事件，您可以截取它们来确定用户是否真的准备好关闭窗口并从内存中删除它。第一个触发的事件是`Closing`，它与`CancelEventHandler`委托一起工作。

该委托期望目标方法将`System.ComponentModel.CancelEventArgs`作为第二个参数。`CancelEventArgs`提供了`Cancel`属性，当设置为`true`时，将阻止窗口实际关闭(当您询问用户是否真的想关闭窗口，或者他是否想先保存他的工作时，这很方便)。

如果用户确实想关闭窗口，可以将`CancelEventArgs.Cancel`设置为`false`(默认设置)。这将导致`Closed`事件被触发(与`System.EventHandler`委托一起工作)，使它成为窗口将要被永久关闭的点。

通过将这些代码语句添加到当前构造函数中，更新`MainWindow`类来处理这两个事件，如下所示:

```cs
public MainWindow()
{
  InitializeComponent();
  this.Closed+=MainWindow_Closed;
  this.Closing += MainWindow_Closing;
}

```

现在，实现相应的事件处理程序，如下所示:

```cs
private void MainWindow_Closing(object sender, System.ComponentModel.CancelEventArgs e)
{
  // See if the user really wants to shut down this window.
  string msg = "Do you want to close without saving?";
  MessageBoxResult result = MessageBox.Show(msg,
    "My App", MessageBoxButton.YesNo, MessageBoxImage.Warning);
  if (result == MessageBoxResult.No)
  {
    // If user doesn't want to close, cancel closure.
    e.Cancel = true;
  }
}

private void MainWindow_Closed(object sender, EventArgs e)
{
  MessageBox.Show("See ya!");
}

```

现在，运行您的程序并尝试关闭窗口，方法是单击窗口右上角的 X 图标或单击按钮控件。您应该会看到确认对话框，询问您是否真的要离开。如果您回答是，您将会看到告别信息。单击“否”按钮会将该窗口保留在内存中。

### 拦截鼠标事件

WPF API 提供了几个事件，您可以捕捉这些事件来与鼠标交互。具体来说，`UIElement`基类定义了以鼠标为中心的事件，比如`MouseMove`、`MouseUp`、`MouseDown`、`MouseEnter`、`MouseLeave`等等。

例如，考虑处理`MouseMove`事件的行为。该事件与`System.Windows.Input.MouseEventHandler`委托协同工作，该委托期望其目标将一个`System.Windows.Input.MouseEventArgs`类型作为第二个参数。使用`MouseEventArgs`，可以提取鼠标的(x，y)位置和其他相关细节。考虑以下部分定义:

```cs
public class MouseEventArgs : InputEventArgs
{
...
  public Point GetPosition(IInputElement relativeTo);
  public MouseButtonState LeftButton { get; }
  public MouseButtonState MiddleButton { get; }
  public MouseDevice MouseDevice { get; }
  public MouseButtonState RightButton { get; }
  public StylusDevice StylusDevice { get; }
  public MouseButtonState XButton1 { get; }
  public MouseButtonState XButton2 { get; }
}

```

Note

`XButton1`和`XButton2`属性允许您与“扩展鼠标按钮”交互(例如一些鼠标控件上的“下一个”和“上一个”按钮)。这些通常用于与浏览器的历史列表交互，以便在访问过的页面之间导航。

方法允许你获得相对于窗口中 UI 元素的(x，y)值。如果您对捕捉相对于激活窗口的位置感兴趣，只需传入`this`。在你的`MainWindow`类的构造函数中处理`MouseMove`事件，就像这样:

```cs
public MainWindow(string windowTitle, int height, int width)
{
...
  this.MouseMove += MainWindow_MouseMove;
}

```

这里有一个`MouseMove`的事件处理程序，它将在窗口的标题区域显示鼠标的位置(注意，您正在通过`ToString()`将返回的`Point`类型转换为文本值):

```cs
private void MainWindow_MouseMove(object sender,
  System.Windows.Input.MouseEventArgs e)
{
  // Set the title of the window to the current (x,y) of the mouse.
  this.Title = e.GetPosition(this).ToString();
}

```

### 截取键盘事件

为聚焦窗口处理键盘输入也很简单。`UIElement`定义您可以捕获的事件，以截取活动元素上键盘的按键(例如`KeyUp`、`KeyDown`)。`KeyUp`和`KeyDown`事件都与`System.Windows.Input.KeyEventHandler`委托一起工作，委托期望目标的第二个事件处理程序是`KeyEventArgs`类型，它定义了几个感兴趣的公共属性，如下所示:

```cs
public class KeyEventArgs : KeyboardEventArgs
{
...
  public bool IsDown { get; }
  public bool IsRepeat { get; }
  public bool IsToggled { get; }
  public bool IsUp { get; }
  public Key Key { get; }
  public KeyStates KeyStates { get; }
  public Key SystemKey { get; }
}

```

为了说明如何在`MainWindow`的构造函数中处理`KeyDown`事件(就像您对前面事件所做的那样)，实现下面的事件处理程序，它用当前按下的键来改变按钮的内容:

```cs
private void MainWindow0s_KeyDown(object sender, System.Windows.Input.KeyEventArgs e)
{
  // Display key press on the button.
  ClickMe.Content = e.Key.ToString();
}

```

在本章的这一点上，WPF 可能看起来只不过是另一个 GUI 框架，提供(或多或少)与 Windows 窗体、MFC 或 VB6 相同的服务。如果事实上是这样的话，您可能会质疑是否还需要另一个 UI 工具包。要真正了解 WPF 的独特之处，你需要理解基于 XML 的语法，XAML。

## 摘要

windows Presentation Foundation(WPF)是随发行版推出的用户界面工具包。NET 3.0。WPF 的主要目标是集成和统一以前不相关的桌面技术(2D 图形、3D 图形、窗口和控件开发等)。)集成到一个统一的编程模型中。除此之外，WPF 程序通常使用 XAML，它允许你通过标记声明 WPF 元素的外观。

回想一下 XAML 允许你描述。NET 对象使用声明性语法。在本章对 XAML 的研究中，您接触到了一些新的语法，包括属性元素语法和附加属性，以及类型转换器和 XAML 标记扩展的作用。

XAML 是任何生产级 WPF 应用的一个关键方面。本章的最后一个例子让你有机会构建一个 WPF 应用，展示本章中讨论的许多概念。接下来的章节将会深入这些概念，并引入更多的概念。*