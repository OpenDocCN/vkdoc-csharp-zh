# 3.核心 C#编程构造，第 1 部分

本章介绍了一些在您探索 C#编程语言时必须熟悉的小范围独立主题，从而开始了您对 C #编程语言的正式研究。NET 核心框架。首要任务是理解如何构建程序的*应用对象*，并检查可执行程序入口点的组成:方法`Main()`以及 C# 9.0 的一个新特性，顶级语句。接下来，您将研究基本的 C#数据类型(以及它们在`System`名称空间中的等价类型)，包括对`System.String`和`System.Text.StringBuilder`类的研究。

在你了解了基本的细节之后。NET 核心数据类型，然后您将研究许多数据类型转换技术，包括收缩操作、扩大操作以及关键字`checked`和`unchecked`的使用。

本章还将考察 C# `var`关键字的作用，它允许你*隐式地*定义一个局部变量。正如您将在本书后面看到的，当使用 LINQ 技术集时，隐式类型非常有用，如果不是偶尔强制的话。您将通过快速检查 C#关键字和操作符来结束本章，这些关键字和操作符允许您使用各种循环和决策结构来控制应用程序的流程。

## 分解一个简单的 C#程序

C#要求所有的程序逻辑都包含在一个类型定义中(回想一下第 [1 章](01.html)中的*类型*是一个通用术语，指集合{类、接口、结构、枚举、委托}的成员)。与许多其他语言不同，在 C#中不可能创建全局函数或全局数据点。相反，所有数据成员和所有方法都必须包含在类型定义中。首先，创建一个名为`Chapter3_AllProject.sln`的新的空解决方案，其中包含一个名为 SimpleCSharpApp 的 C#控制台应用程序。

从 Visual Studio 中，选择“创建新项目”屏幕上的空白解决方案模板。当解决方案打开时，在解决方案资源管理器中右击该解决方案，然后选择“添加➤新项目”。从模板中选择“C#控制台应用程序”，命名为 **SimpleCSharpApp** ，点击创建。记得把目标框架更新到 net5.0

从命令行执行以下操作:

```
dotnet new sln -n Chapter3_AllProjects

dotnet new console -lang c# -n SimpleCSharpApp -o .\SimpleCSharpApp -f net5.0
dotnet sln .\Chapter3_AllProjects.sln add .\SimpleCSharpApp

```

您可能同意初始`Program.cs`文件中的代码相当平淡无奇。

```
using System;

namespace SimpleCSharpApp
{
  class Program
  {
    static void Main(string[] args)
    {
      Console.WriteLine("Hello World!");
    }
  }
}

```

鉴于此，用下面的代码语句更新您的`Program`类的`Main()`方法:

```
class Program
{
  static void Main(string[] args)
  {
    // Display a simple message to the user.
    Console.WriteLine("***** My First C# App *****");
    Console.WriteLine("Hello World!");
    Console.WriteLine();

    // Wait for Enter key to be pressed before shutting down.
    Console.ReadLine();
  }
}

```

Note

C#是一种区分大小写的编程语言。因此，*主*与*主*不同，*读线*与*读线*不同。请注意，所有 C#关键字都是小写的(例如，`public`、`lock`、`class`、`dynamic`)，而名称空间、类型和成员名称(按照惯例)以首字母大写开始，任何嵌入单词的首字母都是大写的(例如，`Console.WriteLine`、`System.Windows.MessageBox`、`System.Data.SqlClient`)。作为一个经验法则，每当你收到一个关于“未定义符号”的编译器错误时，一定要首先检查你的拼写和大小写！

前面的代码包含一个支持名为`Main()`的单一方法的类类型的定义。默认情况下，Visual Studio 命名定义`Main() Program`的类；但是，如果您愿意，您可以自由更改。在 C# 9.0 之前，每个可执行的 C#应用程序(控制台程序、Windows 桌面程序或 Windows 服务)都必须包含一个定义`Main()`方法的类，该方法用于表示应用程序的入口点。

正式来说，定义`Main()`方法的类被称为*应用程序对象*。一个可执行的应用程序可能有多个应用程序对象(这在执行单元测试时很有用)，但是编译器必须知道哪个`Main()`方法应该被用作入口点。这可以通过项目文件中的<startupobject>元素或位于 Visual Studio 项目属性窗口的应用程序选项卡上的启动对象下拉列表框来完成。</startupobject>

请注意，`Main()`的签名带有`static`关键字，这将在第 [5](05.html) 章中详细讨论。目前，只需理解静态成员的作用域是类级别(而不是对象级别)，因此无需首先创建新的类实例就可以调用静态成员。

除了关键字`static`之外，这个`Main()`方法还有一个参数，这个参数恰好是一个字符串数组(`string[] args`)。尽管您目前并不想处理这个数组，但是这个参数可能包含任意数量的传入命令行参数(稍后您将看到如何访问它们)。最后，这个`Main()`方法已经设置了一个`void`返回值，这意味着在退出方法范围之前，不需要使用`return`关键字显式定义返回值。

`Program`类的逻辑在`Main()`内。这里，您使用了在`System`名称空间中定义的`Console`类。它的一组成员中有一个静态的`WriteLine()`，正如您可能想到的，它向标准输出发送一个文本字符串和回车。您还调用了`Console.ReadLine()`来确保 Visual Studio IDE 启动的命令提示符保持可见。跑步的时候。NET Core 控制台应用程序，默认情况下，控制台窗口仍然可见。可以通过启用“工具”“➤”“选项”“➤调试”下的“调试停止时自动关闭控制台”设置来更改此行为。控制台。如果通过双击产品`*.exe`文件从 Windows 资源管理器执行程序，ReadLine 方法可以保持窗口打开。你很快会学到更多关于`System.Console`类的知识。

### 使用 Main()方法的变体(更新 7.1)

默认情况下，Visual Studio 将生成一个`Main()`方法，该方法有一个`void`返回值和一个`string`类型的数组作为单个输入参数。然而，这并不是`Main()`的唯一可能形式。允许使用以下任何签名构造应用程序的入口点(假设它包含在 C#类或结构定义中):

```
// int return type, array of strings as the parameter.
static int Main(string[] args)
{
  // Must return a value before exiting!
  return 0;
}

// No return type, no parameters.
static void Main()
{
}

// int return type, no parameters.
static int Main()
{
  // Must return a value before exiting!
  return 0;
}

```

随着 C# 7.1 的发布，`Main()`方法现在可以异步了。异步编程包含在第 15 章中，但是现在意识到还有四个额外的签名。

```
static Task Main()
static Task<int> Main()
static Task Main(string[])
static Task<int> Main(string[])

```

Note

`Main()`方法也可以被定义为 public 而不是 private。请注意，如果不提供特定的访问修饰符，则假定为 private。Visual Studio 自动将程序的`Main()`方法定义为隐式私有。第 [5](05.html) 章详细介绍了访问修饰符。

显然，你对如何构造`Main()`的选择将基于三个问题。首先，当`Main()`已经完成并且你的程序终止时，你想给系统返回值吗？如果是这样，你需要返回一个`int`数据类型，而不是`void`。第二，您需要处理任何用户提供的命令行参数吗？如果是，它们将被存储在`string` s 的数组中。最后，你需要从`Main()`方法中调用异步代码吗？让我们更详细地检查前两个选项，将异步选项留到第 [15](15.html) 章。

### 使用顶级语句(新 9.0)

虽然在 C# 9.0 之前，所有的 C#都是。NET 核心应用程序必须有一个`Main()`方法，C# 9.0 引入了顶级语句，消除了围绕 C#应用程序入口点的许多仪式。类(`Program`)和`Main()`方法都可以被移除。要查看这一点，请更新`Program.cs`类以匹配以下内容:

```
using System;

// Display a simple message to the user.
Console.WriteLine("***** My First C# App *****");
Console.WriteLine("Hello World!");
Console.WriteLine();

// Wait for Enter key to be pressed before shutting down.
Console.ReadLine();

```

你会看到，当你运行程序时，你会得到同样的结果！使用顶级语句有一些规则:

*   应用程序中只有一个文件可以使用顶级语句。

*   使用顶级语句时，程序不能有声明的入口点。

*   顶级语句不能包含在命名空间中。

*   顶级语句仍然访问一个`string`参数数组。

*   顶级语句通过使用 return 返回应用程序代码(见下一节)。

*   在`Program`类中声明的函数成为顶级语句的局部函数。(本地功能包含在第 [4 章](04.html)中。)

*   附加类型可以在所有顶级语句之后声明。在顶级语句结束之前声明的任何类型都将导致编译错误。

在幕后，编译器填充空白。检查为更新代码生成的 IL，您将看到下面的`TypeDef`是应用程序的入口点:

```
// TypeDef #1 (02000002)
// -------------------------------------------------------
//     TypDefName: <Program>$  (02000002)
//     Flags     : [NotPublic] [AutoLayout] [Class] [Abstract] [Sealed] [AnsiClass] [BeforeFieldInit]  (00100180)
//     Extends   : 0100000D [TypeRef] System.Object
//     Method #1 (06000001) [ENTRYPOINT]
//     -------------------------------------------------------
//             MethodName: <Main>$ (06000001)

```

将它与第 [1 章](01.html)中的入口点`TypeDef`进行比较:

```
// TypeDef #1 (02000002)
// -------------------------------------------------------
//     TypDefName: CalculatorExamples.Program  (02000002)
//     Flags     : [NotPublic] [AutoLayout] [Class] [AnsiClass] [BeforeFieldInit]  (00100000)
//     Extends   : 0100000C [TypeRef] System.Object
//     Method #1 (06000001) [ENTRYPOINT]
//     -------------------------------------------------------
//             MethodName: Main (06000001)

```

注意第 [1](01.html) 章的例子，`TypDefName`值显示为名称空间(`CalculatorExamples`)加上类名(`Program`),`MethodName`值为`Main`。在使用顶级语句的更新示例中，编译器为`TypDefName`填充了`<Program>$`的值，为方法名填充了`<Main>$`的值。

### 指定应用程序错误代码(更新 9.0)

虽然绝大多数的`Main()`方法(或顶级语句)将返回`void`作为返回值，但是返回`int`(或`Task<int>`)的能力使 C#与其他基于 C 的语言保持一致。按照惯例，返回值`0`表示程序已经成功终止，而另一个值(比如`-1`)表示一个错误条件(注意，值`0`是自动返回的，即使您构造了一个原型化的`Main()`方法来返回`void`)。

当使用顶级语句时(因此没有`Main()`方法)，如果执行代码返回一个整数，那就是返回代码。如果没有显式返回任何东西，它仍然返回 0，就像显式使用一个`Main()`方法一样。

在 Windows 操作系统上，应用程序的返回值存储在名为`%ERRORLEVEL%`的系统环境变量中。如果你要创建一个以编程方式启动另一个可执行文件的应用程序(这个主题在第 [19 章](19.html)中讨论)，你可以使用已启动进程的`ExitCode`属性获得`%ERRORLEVEL%`的值。

假设应用程序的返回值是在应用程序终止时传递给系统的，那么应用程序显然不可能在运行时获得并显示其最终的错误代码。但是，为了说明如何在程序终止时查看该错误级别，首先更新顶级语句，如下所示:

```
// Note we are explicitly returning an int, rather than void.
// Display a message and wait for Enter key to be pressed.
Console.WriteLine("***** My First C# App *****");
Console.WriteLine("Hello World!");
Console.WriteLine();
Console.ReadLine();

// Return an arbitrary error code.
return -1;

```

如果程序仍然使用一个`Main()`方法作为入口点，改变方法签名以返回`int`而不是`void`，如下所示:

```
static int Main()
{
…
}

```

现在让我们在批处理文件的帮助下捕获程序的返回值。使用 Windows 资源管理器，导航到包含您的项目文件的文件夹(例如，`C:\SimpleCSharpApp`)并将一个新的文本文件(名为`SimpleCSharpApp.cmd`)添加到该文件夹。将文件夹的内容更新为以下内容(如果您以前没有创作过`*.cmd`文件，请不要关心这些细节):

```
@echo off
rem A batch file for SimpleCSharpApp.exe
rem which captures the app's return value.

dotnet run
@if "%ERRORLEVEL%" == "0" goto success

:fail
  echo This application has failed!
  echo return value = %ERRORLEVEL%
  goto end
:success
  echo This application has succeeded!
  echo return value = %ERRORLEVEL%
  goto end
:end
echo All Done.

```

此时，打开命令提示符(或使用 VSC 终端)并导航到包含新的`*.cmd`文件的文件夹。通过键入文件名并按回车键来执行文件。假设您的`Main()`方法正在返回`-1`，您应该会发现如下所示的输出。如果`Main()`方法返回了`0`，您将会看到消息“该应用程序已经成功！”打印到控制台。

```
***** My First C# App *****

Hello World!

This application has failed!
return value = -1
All Done.

```

前面的`*.cmd`文件的 PowerShell 等价物如下:

```
dotnet run
if ($LastExitCode -eq 0) {
    Write-Host "This application has succeeded!"
} else
{
    Write-Host "This application has failed!"
}
Write-Host "All Done."

```

要运行这个脚本，在 VSC 终端中键入`PowerShell`,然后通过键入以下命令执行脚本:

`.\SimpleCSharpApp.ps1`

您将在终端窗口中看到以下内容:

```
***** My First C# App *****

Hello World!

This application has failed!
All Done.

```

绝大多数(如果不是全部的话)C#应用程序将使用`void`作为来自`Main()`的返回值，正如您所记得的，它隐式返回错误代码 0。为此，本文中使用的`Main()`方法(超出当前示例)将返回`void`。

### 处理命令行参数(已更新 9.0)

现在您已经更好地理解了`Main()`方法或顶级语句的返回值，让我们检查一下`string`数据的传入数组。假设您现在想要更新您的应用程序来处理任何可能的命令行参数。一种方法是使用 C# `for`循环。(请注意，C#的迭代结构将在本章末尾详细讨论。)

```
// Display a message and wait for Enter key to be pressed.
Console.WriteLine("***** My First C# App *****");
Console.WriteLine("Hello World!");
Console.WriteLine();
// Process any incoming args.
for (int i = 0; i < args.Length; i++)
{
  Console.WriteLine("Arg: {0}", args[i]);
}
Console.ReadLine();
// Return an arbitrary error code.
return 0;

```

Note

这个例子使用了顶级语句，它没有使用`Main()`方法。更新`Main()`方法以接受`args`参数的内容将很快介绍。

再次使用顶级语句检查程序的生成 IL，注意，`<Main>$`方法接受一个名为`args`的`string`数组，如下所示(缩写为 space):

```
.class private abstract auto ansi sealed beforefieldinit '<Program>$'
       extends [System.Runtime]System.Object
{
  .custom instance void [System.Runtime]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor()=
    ( 01 00 00 00 )
  .method private hidebysig static
          void  '<Main>$'(string[] args) cil managed
  {
    .entrypoint
…
  } // end of method '<Program>$'::'<Main>$'
} // end of class '<Program>$'

```

如果程序仍然使用`Main()`方法作为入口点，确保方法签名接受名为`args`的`string`数组，如下所示:

```
static int Main(string[] args)
{
…
}

```

在这里，您使用`System.Array`的`Length`属性来检查`string`的数组是否包含一些条目。正如你将在第四章[中看到的，所有 C#数组实际上都是`System.Array`类的别名，因此，共享一组公共成员。当您循环数组中的每一项时，它的值会打印到控制台窗口。在命令行提供参数同样简单，如下所示:](04.html)

```
C:\SimpleCSharpApp>dotnet run /arg1 -arg2

***** My First C# App *****
Hello World!
Arg: /arg1
Arg: -arg2

```

作为标准`for`循环的替代方法，您可以使用 C# `foreach`关键字迭代一个传入的`string`数组。下面是一些示例用法(但同样，你将在本章后面看到循环结构的细节):

```
// Notice you have no need to check the size of the array when using "foreach".
// Process any incoming args using foreach.
foreach(string arg in args)
{
  Console.WriteLine("Arg: {0}", arg);
}
Console.ReadLine();
return 0;

```

最后，您还可以使用`System.Environment`类型的静态`GetCommandLineArgs()`方法来访问命令行参数。该方法的返回值是一个由`string`组成的数组。第一个条目包含应用程序本身的名称，而数组中的其余元素包含各个命令行参数。

```
.
// Get arguments using System.Environment.
string[] theArgs = Environment.GetCommandLineArgs();
foreach(string arg in theArgs)
{
  Console.WriteLine("Arg: {0}", arg);
}
Console.ReadLine();
return 0;

```

Note

`GetCommandLineArgs`方法不通过`Main()`方法接收应用程序的参数，也不依赖于`string[] args`参数。

当然，由您来决定您的程序将响应哪些命令行参数(如果有的话)以及它们必须如何被格式化(比如用一个`-`或`/`前缀)。在这里，我只是传递了一系列直接打印到命令提示符下的选项。然而，假设您正在创建一个新的视频游戏，并编写您的应用程序来处理一个名为`-godmode`的选项。如果用户用这个标志启动你的应用程序，你知道他实际上是一个骗子，你可以采取适当的行动。

### 用 Visual Studio 指定命令行参数

在现实世界中，最终用户在启动程序时可以选择提供命令行参数。但是，在开发周期中，出于测试目的，您可能希望指定可能的命令行标志。若要使用 Visual Studio 执行此操作，请在解决方案资源管理器中右击项目名称，选择“属性”,然后导航到左侧的“调试”选项卡。在那里，使用“应用参数”文本框指定值(见图 [3-1](#Fig1) )并保存您的更改。

![../images/340876_10_En_3_Chapter/340876_10_En_3_Fig1_HTML.jpg](../images/340876_10_En_3_Chapter/340876_10_En_3_Fig1_HTML.jpg)

图 3-1。

在 Visual Studio 中设置应用程序参数

在您建立了这样的命令行参数之后，当在 Visual Studio IDE 中调试或运行您的应用程序时，它们将自动传递给`Main()`方法。

## 一个有趣的旁白:该系统的一些额外成员。环境类

除了`GetCommandLineArgs()`之外，`Environment`类还公开了许多非常有用的方法。具体来说，这个类允许您获取有关当前承载您的。NET 5 应用程序使用各种静态成员。为了说明`System.Environment`的用处，更新您的代码来调用名为`ShowEnvironmentDetails()`的本地方法。

```
// Local method within the Top-level statements.
ShowEnvironmentDetails();

Console.ReadLine();
return -1;
}

```

在顶级语句之后实现这个方法来调用`Environment`类型的各种成员:

```
static void ShowEnvironmentDetails()
{
  // Print out the drives on this machine,
  // and other interesting details.
  foreach (string drive in Environment.GetLogicalDrives())
  {
    Console.WriteLine("Drive: {0}", drive);
  }
  Console.WriteLine("OS: {0}", Environment.OSVersion);
  Console.WriteLine("Number of processors: {0}",
    Environment.ProcessorCount);
  Console.WriteLine(".NET Core Version: {0}",
    Environment.Version);
}

```

以下输出显示了调用此方法的可能测试运行:

```
***** My First C# App *****

Hello World!

Drive: C:\
OS: Microsoft Windows NT 10.0.19042.0
Number of processors: 16
.NET Core Version: 5.0.0

```

`Environment`类型定义的成员不同于上一个示例中显示的成员。表 [3-1](#Tab1) 记录了一些感兴趣的附加属性；但是，请务必查看在线文档以了解完整的详细信息。

表 3-1

选择系统属性。环境

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

财产

 | 

生命的意义

 |
| --- | --- |
| `ExitCode` | 获取或设置应用程序的退出代码 |
| `Is64BitOperatingSystem` | 返回一个`bool`来表示主机是否运行 64 位操作系统 |
| `MachineName` | 获取当前计算机的名称 |
| `NewLine` | 获取当前环境的换行符 |
| `SystemDirectory` | 返回系统目录的完整路径 |
| `UserName` | 返回启动该应用程序的用户名 |
| `Version` | 返回一个代表。网络核心平台 |

## 使用系统。控制台类

在本书前几章中创建的几乎所有示例应用程序都大量使用了`System.Console`类。虽然控制台用户界面(CUI)确实不如图形用户界面(GUI)或 web 应用程序那样吸引人，但是将早期的示例限制在控制台程序将使您能够专注于 C#的语法和。NET 5 平台，而不是处理构建桌面 GUI 或网站的复杂性。

顾名思义，`Console`类封装了基于控制台的应用程序的输入、输出和错误流操作。表 [3-2](#Tab2) 列出了一些(但肯定不是全部)感兴趣的成员。正如您所看到的，`Console`类确实提供了一些成员，可以为简单的命令行应用程序增添趣味，比如改变背景和前景色以及发出哔哔声(各种频率！).

表 3-2。

选择系统成员。安慰

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

成员

 | 

生命的意义

 |
| --- | --- |
| `Beep()` | 此方法强制控制台发出指定频率和持续时间的嘟嘟声。 |
| `BackgroundColor` | 这些属性设置当前输出的背景/前景色。 |
| `ForegroundColor` | 它们可以被赋予`ConsoleColor`枚举的任何成员。 |
| `BufferHeightBufferWidth` | 这些属性控制控制台缓冲区的高度/宽度。 |
| `Title` | 此属性获取或设置当前控制台的标题。 |
| `WindowHeightWindowWidthWindowTopWindowLeft` | 这些属性控制控制台相对于已建立缓冲区的尺寸。 |
| `Clear()` | 此方法清除已建立的缓冲区和控制台显示区域。 |

### 使用控制台类执行基本输入和输出(I/O)

除了表 [3-2](#Tab2) 中的成员之外，`Console`类型还定义了一组捕获输入和输出的方法，所有这些方法都是静态的，因此通过在方法名前面加上类名(`Console`)来调用。正如您所看到的，`WriteLine()`将一个文本字符串(包括回车)抽取到输出流中。`Write()`方法将文本抽取到输出流中，不需要回车。`ReadLine()`允许您从输入流接收信息，直到按下回车键，而`Read()`用于从输入流中捕获单个字符。

为了说明使用`Console`类的简单 I/O，创建一个名为 BasicConsoleIO 的新控制台应用程序项目，并使用以下 CLI 命令将其添加到您的解决方案中:

```
dotnet new console -lang c# -n BasicConsoleIO -o .\BasicConsoleIO -f net5.0
dotnet sln .\Chapter3_AllProjects.sln add .\BasicConsoleIO

```

用以下代码替换`Program.cs`代码:

```
using System;
Console.WriteLine("***** Basic Console I/O *****");
GetUserData();
Console.ReadLine();
static void GetUserData()
{
}

```

Note

Visual Studio 和 Visual Studio 代码都支持许多“代码片段”,这些代码片段在激活后将插入代码。在本文的前几章中，`cw`代码片段非常有用，因为它会自动扩展到`Console.WriteLine()`！为了测试你自己，在你的`code`中输入`cw`，然后按 Tab 键。注意:在 Visual Studio 代码中，你按一次 Tab 键；在 Visual Studio 中，必须按两次 Tab 键。

在顶级语句之后实现此方法，逻辑提示用户输入一些信息，并将每一项回显到标准输出流。例如，您可以要求用户输入姓名和年龄(为简单起见，将其视为文本值，而不是预期的数值)，如下所示:

```
static void GetUserData()
{
  // Get name and age.
  Console.Write("Please enter your name: ");
  string userName = Console.ReadLine();
  Console.Write("Please enter your age: ");
  string userAge = Console.ReadLine();

  // Change echo color, just for fun.
  ConsoleColor prevColor = Console.ForegroundColor;
  Console.ForegroundColor = ConsoleColor.Yellow;

  // Echo to the console.
  Console.WriteLine("Hello {0}! You are {1} years old.",
  userName, userAge);

  // Restore previous color.
  Console.ForegroundColor = prevColor;
}

```

毫不奇怪，当您运行这个应用程序时，输入数据被打印到控制台(使用自定义颜色启动！).

### 格式化控制台输出

在这前几章中，您可能已经注意到在各种字符串文字中出现了大量的标记，如`{0}`和`{1}`。那个。NET 5 平台支持的字符串格式有点类似于 c 语言的`printf()`语句。简而言之，当您定义一个包含数据段的字符串文字时，其值直到运行时才知道，您可以使用这个花括号语法在字符串文字中指定一个占位符。在运行时，传入`Console.WriteLine()`的值会替换每个占位符。

`WriteLine()`的第一个参数代表一个字符串文字，它包含由`{0}`、`{1}`、`{2}`等指定的可选占位符。请注意，花括号占位符的第一个序号总是以`0`开头。`WriteLine()`的其余参数只是插入到各自占位符中的值。

Note

如果唯一编号的花括号占位符比填充参数多，将在运行时收到格式异常。但是，如果填充参数多于占位符，未使用的填充参数将被忽略。

允许给定的占位符在给定的字符串中重复出现。例如，如果你是披头士的粉丝，想要构建字符串`"9, Number 9, Number 9"`，你可以这样写:

```
// John says...
Console.WriteLine("{0}, Number {0}, Number {0}", 9);

```

另外，要知道可以将每个占位符放在字符串中的任何位置，并且不需要按照递增的顺序。例如，考虑下面的代码片段:

```
// Prints: 20, 10, 30
Console.WriteLine("{1}, {0}, {2}", 10, 20, 30);

```

字符串也可以使用字符串内插法格式化，这将在本章后面介绍。

### 格式化数字数据

如果需要对数字数据进行更精细的格式化，每个占位符可以选择包含各种格式字符。表 [3-3](#Tab3) 显示了最常见的格式化选项。

表 3-3。

。网络核心数字格式字符

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

字符串格式字符

 | 

生命的意义

 |
| --- | --- |
| `C`或`c` | 用于格式化货币。默认情况下，旗帜会将当地文化符号作为前缀(美元符号[$]代表美国英语)。 |
| `D`或`d` | 用于格式化十进制数。该标志还可以指定用于填充该值的最小位数。 |
| `E`或`e` | 用于指数记数法。大小写控制指数常数是大写(`E`)还是小写(`e`)。 |
| `F`或`f` | 用于定点格式化。该标志还可以指定用于填充该值的最小位数。 |
| `G`或`g` | 代表*将军*。此字符可用于将数字格式化为固定格式或指数格式。 |
| `N`或`n` | 用于基本的数字格式(带逗号)。 |
| `X`或`x` | 用于十六进制格式。如果您使用大写的`X`，您的十六进制格式也将包含大写字符。 |

这些格式字符使用冒号标记作为给定占位符值的后缀(例如，`{0:C}`、`{1:d}`、`{2:X}`)。举例来说，更新`Main()`方法来调用名为`FormatNumericalData()`的新助手函数。在您的`Program`类中实现这个方法，以多种方式格式化一个固定的数值。

```
// Now make use of some format tags.
static void FormatNumericalData()
{
  Console.WriteLine("The value 99999 in various formats:");
  Console.WriteLine("c format: {0:c}", 99999);
  Console.WriteLine("d9 format: {0:d9}", 99999);
  Console.WriteLine("f3 format: {0:f3}", 99999);
  Console.WriteLine("n format: {0:n}", 99999);

  // Notice that upper- or lowercasing for hex
  // determines if letters are upper- or lowercase.
  Console.WriteLine("E format: {0:E}", 99999);
  Console.WriteLine("e format: {0:e}", 99999);
  Console.WriteLine("X format: {0:X}", 99999);
  Console.WriteLine("x format: {0:x}", 99999);
}

```

下面的输出显示了调用`FormatNumericalData()`方法的结果:

```
The value 99999 in various formats:

c format: $99,999.00
d9 format: 000099999
f3 format: 99999.000
n format: 99,999.00
E format: 9.999900E+004
e format: 9.999900e+004
X format: 1869F
x format: 1869f

```

在整篇文章中，您会看到其他需要的格式示例；但是，如果您有兴趣进一步研究字符串格式，请在。NET 核心文档。

### 格式化控制台应用程序之外的数字数据

最后要注意的是，字符串格式字符的使用不仅限于控制台程序。当调用静态`string.Format()`方法时，可以使用相同的格式化语法。当您需要在运行时编写文本数据以用于任何类型的应用程序(例如，桌面 GUI 应用程序、ASP.NET web 应用程序等)时，这很有帮助。).

`string.Format()`方法返回一个新的`string`对象，该对象根据提供的标志进行格式化。以下代码将字符串格式化为十六进制:

```
  // Using string.Format() to format a string literal.
  string userMessage = string.Format("100000 in hex is {0:x}", 100000);

```

## 使用系统数据类型和相应的 C#关键字

与任何编程语言一样，C#为基本数据类型定义了关键字，这些关键字用于表示局部变量、类数据成员变量、方法返回值和参数。然而，与其他编程语言不同，这些关键字不仅仅是简单的编译器可识别的标记。相反，C#数据类型关键字实际上是在`System`名称空间中成熟类型的简写符号。表 [3-4](#Tab4) 列出了每个系统数据类型、其范围、相应的 C#关键字以及该类型是否符合通用语言规范(CLS)。所有的系统类型都在 system 命名空间中，为了便于阅读，没有在图表中显示。

表 3-4。

C#的内在数据类型

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"> <col class="tcol4 align-left"> <col class="tcol5 align-left"></colgroup> 
| 

C#速记

 | 

CLS 顺从吗？

 | 

系统类型

 | 

范围

 | 

生命的意义

 |
| --- | --- | --- | --- | --- |
| `bool` | 是 | `Boolean` | 对还是错 | 代表真理或谬误 |
| `sbyte` | 不 | `SByte` | –128 至 127 | 有符号的 8 位数字 |
| `byte` | 是 | `Byte` | 0 到 255 | 无符号 8 位数 |
| `short` | 是 | `Int16` | –32768 至 32767 | 有符号的 16 位数字 |
| `ushort` | 不 | `UInt16` | 0 到 65，535 | 无符号 16 位数 |
| `int` | 是 | `Int32` | -2147483648 至 2147483647 | 有符号的 32 位数字 |
| `uint` | 不 | `UInt32` | 0 到 4，294，967，295 | 无符号 32 位数字 |
| `long` | 是 | `Int64` | -9 223 372 036 854 775 808 至 9 223 372 036 854 775 807 | 带符号的 64 位数字 |
| `ulong` | 不 | `UInt64` | 0 到 18446744073709551615 | 无符号 64 位数字 |
| `char` | 是 | `Char` | U+0000 至 U+ffff | 单个 16 位 Unicode 字符 |
| `float` | 是 | `Single` | –3.4 10<sup>38</sup>至+3.4 10 <sup>38</sup> | 32 位浮点数 |
| `double` | 是 | `Double` | 5.0 10<sup>–324</sup>至 1.7 10 <sup>308</sup> | 64 位浮点数 |
| `decimal` | 是 | `Decimal` | (–7.9 x 10<sup>28</sup>至 7.9 x 10 <sup>28</sup> )/(10 <sup>0 至 28</sup> | 128 位有符号数 |
| `string` | 是 | `String` | 受系统内存限制 | 表示一组 Unicode 字符 |
| `object` | 是 | `Object` | 可以在对象变量中存储任何数据类型 | 中所有类型的基类。净宇宙 |

Note

回想一下第 [1](01.html) 章中提到的 CLS 合规。NET 核心代码可以被任何其他人使用。NET 核心编程语言。如果您从您的程序中公开不符合 CLS 标准的数据，其他。NET 核心语言可能无法利用它。

### 理解变量声明和初始化

当声明局部变量(例如，成员范围内的变量)时，可以通过指定数据类型，后跟变量名来实现。首先，创建一个名为 BasicDataTypes 的新控制台应用程序项目，并使用以下命令将其添加到解决方案中:

```
dotnet new console -lang c# -n BasicDataTypes -o .\BasicDataTypes -f net5.0
dotnet sln .\Chapter3_AllProjects.sln add .\BasicDataTypes

```

将代码更新为以下内容:

```
using System;
using System.Numerics;

Console.WriteLine("***** Fun with Basic Data Types *****\n");

```

现在，添加以下静态局部函数，并从顶级语句中调用它:

```
static void LocalVarDeclarations()
{
  Console.WriteLine("=> Data Declarations:");
  // Local variables are declared as so:
  // dataType varName;
  int myInt;
  string myString;
  Console.WriteLine();
}

```

请注意，在赋值初始值之前使用局部变量是一个*编译器错误*。考虑到这一点，在声明时给本地数据点分配一个初始值是一个好的做法。您可以在一行中完成，也可以将声明和赋值分成两个代码语句来完成。

```
static void LocalVarDeclarations()
{
  Console.WriteLine("=> Data Declarations:");
  // Local variables are declared and initialized as follows:
  // dataType varName = initialValue;
  int myInt = 0;

  // You can also declare and assign on two lines.
  string myString;
  myString = "This is my character data";

  Console.WriteLine();
}

```

也允许在一行代码中声明同一基础类型的多个变量，如以下三个`bool`变量:

```
static void LocalVarDeclarations()
{
  Console.WriteLine("=> Data Declarations:");
  int myInt = 0;
  string myString;
  myString = "This is my character data";

  // Declare 3 bools on a single line.
  bool b1 = true, b2 = false, b3 = b1;
  Console.WriteLine();
}

```

由于 C# `bool`关键字只是`System.Boolean`结构的简写符号，所以也可以使用全名来分配任何数据类型(当然，对于任何 C#数据类型关键字也是如此)。下面是`LocalVarDeclarations()`的最终实现，它说明了声明一个局部变量的各种方法:

```
static void LocalVarDeclarations()
{
  Console.WriteLine("=> Data Declarations:");
  // Local variables are declared and initialized as follows:
  // dataType varName = initialValue;
  int myInt = 0;

  string myString;
  myString = "This is my character data";

  // Declare 3 bools on a single line.
  bool b1 = true, b2 = false, b3 = b1;

  // Use System.Boolean data type to declare a bool.
  System.Boolean b4 = false;

  Console.WriteLine("Your data: {0}, {1}, {2}, {3}, {4}, {5}",
      myInt, myString, b1, b2, b3, b4);
  Console.WriteLine();
}

```

#### 默认文字(新 7.1)

`default`文字为变量分配其数据类型的默认值。这适用于标准数据类型以及定制类(第 [5 章](05.html)和泛型类型(第 [10 章](10.html))。创建一个名为`DefaultDeclarations()`的新方法，并添加以下代码:

```
static void DefaultDeclarations()
{
  Console.WriteLine("=> Default Declarations:");
  int myInt = default;
}

```

### 使用内部数据类型和新运算符(更新 9.0)

所有的内在数据类型都支持所谓的默认构造函数 T2(见第 5 章)。此功能允许您使用`new`关键字创建一个变量，该关键字会自动将变量设置为其默认值:

*   `bool`变量被设置为`false`。

*   数值数据被设置为`0`(或者在浮点数据类型的情况下设置为`0.0`)。

*   `char`变量被设置为单个空字符。

*   `BigInteger`变量被设置为`0`。

*   `DateTime`变量被设置为`1/1/0001 12:00:00 AM`。

*   对象引用(包括`string` s)被设置为`null`。

Note

前面列表中提到的`BigInteger`数据类型将在稍后解释。

尽管在创建基本数据类型变量时使用`new`关键字更麻烦，但下面是语法上格式良好的 C#代码:

```
static void NewingDataTypes()
{
  Console.WriteLine("=> Using new to create variables:");
  bool b = new bool();              // Set to false.
  int i = new int();                // Set to 0.
  double d = new double();          // Set to 0.
  DateTime dt = new DateTime();     // Set to 1/1/0001 12:00:00 AM
  Console.WriteLine("{0}, {1}, {2}, {3}", b, i, d, dt);
  Console.WriteLine();
}

```

C# 9.0 增加了创建变量实例的快捷方式。这个快捷方式只是使用没有数据类型的关键字`new()`。这里显示的是`NewingDataTypes`的更新版本:

```
static void NewingDataTypesWith9()
{
  Console.WriteLine("=> Using new to create variables:");
  bool b = new();              // Set to false.
  int i = new();                // Set to 0.
  double d = new();          // Set to 0.
  DateTime dt = new();     // Set to 1/1/0001 12:00:00 AM
  Console.WriteLine("{0}, {1}, {2}, {3}", b, i, d, dt);
  Console.WriteLine();
}

```

### 了解数据类型类层次结构

有趣的是，即使是原始人。NET Core 数据类型被安排在一个*类层次结构*中。如果你是遗产领域的新手，你会在第六章[中发现全部细节。在此之前，只需理解位于类层次结构顶部的类型提供了一些授予派生类型的默认行为。这些核心系统类型之间的关系如图](06.html) [3-2](#Fig2) 所示。

![../images/340876_10_En_3_Chapter/340876_10_En_3_Fig2_HTML.jpg](../images/340876_10_En_3_Chapter/340876_10_En_3_Fig2_HTML.jpg)

图 3-2。

系统类型的类层次结构

注意，每个类型最终都是从`System.Object`派生出来的，它定义了一组方法(例如，`ToString()`、`Equals()`、`GetHashCode()`)，这些方法对。NET 核心基础类库(这些方法在第 [6 章](06.html)中有详细介绍)。

还要注意，许多数字数据类型都是从名为`System.ValueType`的类中派生出来的。`ValueType`的后代被自动分配到堆栈上，因此具有可预测的生命周期，并且非常高效。另一方面，继承链中没有`System.ValueType`的类型(比如`System.Type`、`System.String`、`System.Array`、`System.Exception`和`System.Delegate`)不会被分配到堆栈中，而是被分配到垃圾收集堆中。(你可以在第 [4](04.html) 章找到更多关于这种区别的信息。)

不要太纠结于`System.Object`和`System.ValueType`的细节，只要理解因为 C#关键字(比如`int`)只是对应系统类型(在本例中为`System.Int32`)的简写符号，下面是完全合法的语法，假设`System.Int32`(c#`int`)最终从`System.Object`派生而来，因此可以调用它的任何公共成员，如这个额外的助手函数所示:

```
static void ObjectFunctionality()
{
  Console.WriteLine("=> System.Object Functionality:");

  // A C# int is really a shorthand for System.Int32,
  // which inherits the following members from System.Object.
  Console.WriteLine("12.GetHashCode() = {0}", 12.GetHashCode());
  Console.WriteLine("12.Equals(23) = {0}", 12.Equals(23));
  Console.WriteLine("12.ToString() = {0}", 12.ToString());
  Console.WriteLine("12.GetType() = {0}", 12.GetType());
  Console.WriteLine();
}

```

如果您要从`Main()`中调用这个方法，您会发现如下所示的输出:

```
=> System.Object Functionality:

12.GetHashCode() = 12
12.Equals(23) = False
12.ToString() = 12
12.GetType() = System.Int32

```

### 了解数字数据类型的成员

要继续试验固有的 C#数据类型，请理解。NET Core 支持`MaxValue`和`MinValue`属性，这些属性提供关于给定类型可以存储的范围的信息。除了`MinValue` / `MaxValue`属性之外，一个给定的数值系统类型可以定义更多有用的成员。例如，`System.Double`类型允许您获得ε和无穷大的值(这可能会引起那些数学爱好者的兴趣)。举例来说，考虑下面的助手函数:

```
static void DataTypeFunctionality()
{
  Console.WriteLine("=> Data type Functionality:");

  Console.WriteLine("Max of int: {0}", int.MaxValue);
  Console.WriteLine("Min of int: {0}", int.MinValue);
  Console.WriteLine("Max of double: {0}", double.MaxValue);
  Console.WriteLine("Min of double: {0}", double.MinValue);
  Console.WriteLine("double.Epsilon: {0}", double.Epsilon);
  Console.WriteLine("double.PositiveInfinity: {0}",
    double.PositiveInfinity);
  Console.WriteLine("double.NegativeInfinity: {0}",
    double.NegativeInfinity);
  Console.WriteLine();
}

```

当您定义一个文字整数(比如`500`)时，运行时会将数据类型默认为`int`。同样，文字浮点数据(如`55.333`)将默认为`double`。要将底层数据类型设置为`long`，请使用后缀`l`或`L` ( `4L`)。要声明一个`float`变量，对原始数值(`5.3F`)使用后缀`f`或`F`，对浮点数使用后缀`m`或`M`声明一个小数(`300.5M`)。这在隐式声明变量时变得更加重要，这将在本章后面讨论。

### 了解系统成员。布尔代数学体系的

接下来，考虑`System.Boolean`数据类型。C# `bool`可以接受的唯一有效赋值是来自集合{ `true || false` }。鉴于这一点，应该清楚的是`System.Boolean`不支持`MinValue` / `MaxValue`属性集，而是支持`TrueString` / `FalseString`(分别产生字符串`"True"`或`"False"`)。这里有一个例子:

```
Console.WriteLine("bool.FalseString: {0}", bool.FalseString);
Console.WriteLine("bool.TrueString: {0}", bool.TrueString);

```

### 了解系统成员。茶

C#文本数据由关键字`string`和`char`表示，它们是`System.String`和`System.Char`的简单简写符号，两者都是 Unicode。您可能已经知道，`string`代表一组连续的字符(例如`"Hello"`，而`char`可以代表`string`中的一个槽(例如`'H'`)。

除了保存单点字符数据的能力之外，`System.Char`类型还为您提供了大量的功能。使用`System.Char`的静态方法，您能够确定一个给定的字符是数字、字母、标点符号还是其他什么。考虑以下方法:

```
static void CharFunctionality()
{
  Console.WriteLine("=> char type Functionality:");
  char myChar = 'a';
  Console.WriteLine("char.IsDigit('a'): {0}", char.IsDigit(myChar));
  Console.WriteLine("char.IsLetter('a'): {0}", char.IsLetter(myChar));
  Console.WriteLine("char.IsWhiteSpace('Hello There', 5): {0}",
    char.IsWhiteSpace("Hello There", 5));
  Console.WriteLine("char.IsWhiteSpace('Hello There', 6): {0}",
    char.IsWhiteSpace("Hello There", 6));
  Console.WriteLine("char.IsPunctuation('?'): {0}",
    char.IsPunctuation('?'));
  Console.WriteLine();
}

```

如前面的方法所示，`System.Char`的许多成员有两个调用约定:一个单独的字符或一个带有数字索引的字符串，该数字索引指定了要测试的字符的位置。

### 解析字符串数据中的值

那个。NET Core 数据类型提供了在给定文本等价(例如，解析)的情况下生成其基础类型的变量的能力。当您想要将一些用户输入数据(例如从基于 GUI 的下拉列表框中选择的数据)转换成数值时，这种技术非常有用。考虑名为`ParseFromStrings()`的方法中的以下解析逻辑:

```
static void ParseFromStrings()
{
  Console.WriteLine("=> Data type parsing:");
  bool b = bool.Parse("True");
  Console.WriteLine("Value of b: {0}", b);
  double d = double.Parse("99.884");
  Console.WriteLine("Value of d: {0}", d);
  int i = int.Parse("8");
  Console.WriteLine("Value of i: {0}", i);
  char c = Char.Parse("w");
  Console.WriteLine("Value of c: {0}", c);
  Console.WriteLine();
}

```

### 使用 TryParse 解析字符串数据中的值

上述代码的一个问题是，如果字符串不能完全转换为正确的数据类型，将会引发异常。例如，以下内容将在运行时失败:

```
bool b = bool.Parse("Hello");

```

一种解决方案是将每个对`Parse()`的调用包装在一个`try-catch`块中(异常处理在第 [7](07.html) 章中有详细介绍)，这可能会增加很多代码，或者使用一个`TryParse()`语句。`TryParse()`语句接受一个`out`参数(第 [4](04.html) 章详细介绍了`out`修饰符)，如果解析成功，则返回一个`bool`。创建一个名为`ParseFromStringWithTryParse()`的新方法，并添加以下代码:

```
static void ParseFromStringsWithTryParse()
{
  Console.WriteLine("=> Data type parsing with TryParse:");
  if (bool.TryParse("True", out bool b))
  {
    Console.WriteLine("Value of b: {0}", b);
  }
  else
  {
    Console.WriteLine("Default value of b: {0}", b);
  }
  string value = "Hello";
  if (double.TryParse(value, out double d))
  {
    Console.WriteLine("Value of d: {0}", d);
  }
  else
  {
    Console.WriteLine("Failed to convert the input ({0}) to a double and the variable was assigned the default {1}", value,d);
  }
  Console.WriteLine();
}

```

如果你是编程新手，不知道`if` / `else`语句是如何工作的，本章后面会详细介绍。从前面的例子中需要注意的重要一点是，如果一个字符串可以被转换成所请求的数据类型，`TryParse()`方法返回`true`，并将解析后的值赋给传递给该方法的变量。如果值不能被解析，变量被赋予默认值，并且`TryParse()`方法返回`false`。

### 使用系统。日期时间和系统。时间间隔

名称空间定义了一些没有 C#关键字的有用的数据类型，比如结构 T1 和 T2。(关于`System.Void`的调查，如图 [3-2](#Fig2) ，我就留给感兴趣的读者吧。)

`DateTime`类型包含表示特定日期(月、日、年)和时间值的数据，这两种数据都可以使用提供的成员以多种方式进行格式化。`TimeSpan`结构允许您使用各种成员轻松定义和转换时间单位。

```
static void UseDatesAndTimes()
{
  Console.WriteLine("=> Dates and Times:");

  // This constructor takes (year, month, day).
  DateTime dt = new DateTime(2015, 10, 17);

  // What day of the month is this?
  Console.WriteLine("The day of {0} is {1}", dt.Date, dt.DayOfWeek);

  // Month is now December.
  dt = dt.AddMonths(2);
  Console.WriteLine("Daylight savings: {0}", dt.IsDaylightSavingTime());

  // This constructor takes (hours, minutes, seconds).
  TimeSpan ts = new TimeSpan(4, 30, 0);
  Console.WriteLine(ts);

  // Subtract 15 minutes from the current TimeSpan and
  // print the result.
  Console.WriteLine(ts.Subtract(new TimeSpan(0, 15, 0)));
}

```

### 与系统一起工作。数字命名空间

`System.Numerics`名称空间定义了一个名为`BigInteger`的结构。顾名思义，`BigInteger`数据类型可以在需要表示*巨大的*数值时使用，这些数值不受固定上限或下限的约束。

Note

`System.Numerics`名称空间定义了第二个名为`Complex`的结构，它允许您对复杂的数字数据进行数学建模(例如，虚数、实数、双曲正切)。请参考。NET 核心文档。

而你们中的许多人。NET 核心应用程序可能永远不需要使用`BigInteger`结构，如果您发现需要定义大量数值，您的第一步是将下面的`using`指令添加到文件中:

```
// BigInteger lives here!
using System.Numerics;

```

此时，您可以使用`new`操作符创建一个`BigInteger`变量。在构造函数中，可以指定一个数值，包括浮点数据。然而，C#隐式地将非浮点数类型化为`int`，将浮点数类型化为`double`。那么，如何将`BigInteger`设置为一个巨大的值，同时又不会溢出用于原始数值的默认数据类型呢？

最简单的方法是将大量数值建立为文本文字，可以通过静态的`Parse()`方法将其转换为`BigInteger`变量。如果需要的话，你也可以将一个字节数组直接传递给`BigInteger`类的构造函数。

Note

在你给一个`BigInteger`变量赋值后，你不能改变它，因为数据是不可变的。然而，`BigInteger`类定义了许多成员，这些成员将根据您的数据修改返回新的`BigInteger`对象(例如下面代码示例中使用的静态`Multiply()`方法)。

在任何情况下，在你定义了一个`BigInteger`变量之后，你会发现这个类定义了类似的成员作为其他内在的 C#数据类型(例如`float`、`int`)。此外，`BigInteger`类定义了几个静态成员，允许您将基本的数学表达式(如加法和乘法)应用于`BigInteger`变量。下面是一个使用`BigInteger`类的例子:

```
static void UseBigInteger()
{
  Console.WriteLine("=> Use BigInteger:");
  BigInteger biggy =
    BigInteger.Parse("9999999999999999999999999999999999999999999999");
  Console.WriteLine("Value of biggy is {0}", biggy);
  Console.WriteLine("Is biggy an even value?: {0}", biggy.IsEven);
  Console.WriteLine("Is biggy a power of two?: {0}", biggy.IsPowerOfTwo);
  BigInteger reallyBig = BigInteger.Multiply(biggy,
    BigInteger.Parse("8888888888888888888888888888888888888888888"));
  Console.WriteLine("Value of reallyBig is {0}", reallyBig);
}

```

同样重要的是要注意到，`BigInteger`数据类型响应 C#固有的数学运算符，如`+`、`-`和`*`。因此，您可以编写以下代码，而不是调用`BigInteger.Multiply()`将两个巨大的数字相乘:

```
BigInteger reallyBig2 = biggy * reallyBig;

```

至此，我希望您理解表示基本数据类型的 C#关键字在。NET 核心基类库，每个都公开一个固定的功能。虽然我没有详细介绍这些数据类型的每个成员，但是您可以根据自己的需要深入研究这些细节。请务必查阅。NET 核心文档，了解有关各种。NET 数据类型—您可能会对内置功能的数量感到惊讶。

### 使用数字分隔符(新 7.0)

有时，当给一个数值变量分配一个大的数字时，数字的数量会超过肉眼所能看到的数量。C# 7.0 引入了下划线(_)作为数字分隔符(用于`integer`、`long`、`decimal`、`double`数据或十六进制类型)。C# 7.2 允许十六进制值(以及接下来介绍的新的二进制文字，在开始声明后以下划线开头)。以下是使用新数字分隔符的示例:

```
static void DigitSeparators()
{
  Console.WriteLine("=> Use Digit Separators:");
  Console.Write("Integer:");
  Console.WriteLine(123_456);
  Console.Write("Long:");
  Console.WriteLine(123_456_789L);
  Console.Write("Float:");
  Console.WriteLine(123_456.1234F);
  Console.Write("Double:");
  Console.WriteLine(123_456.12);
  Console.Write("Decimal:");
  Console.WriteLine(123_456.12M);
  //Updated in 7.2, Hex can begin with _
  Console.Write("Hex:");
  Console.WriteLine(0x_00_00_FF);
}

```

### 使用二进制文字(新的 7.0/7.2)

C# 7.0 为二进制值引入了新的文字，例如，用于创建位掩码。新的数字分隔符适用于二进制文字，C# 7.2 允许二进制和十六进制数字以下划线开头。现在，二进制数可以像你想的那样书写。这里有一个例子:

```
0b_0001_0000

```

下面是一个方法，显示了如何使用带有数字分隔符的新文字:

```
 static void BinaryLiterals()
{
  //Updated in 7.2, Binary can begin with _
  Console.WriteLine("=> Use Binary Literals:");
  Console.WriteLine("Sixteen: {0}",0b_0001_0000);
  Console.WriteLine("Thirty Two: {0}",0b_0010_0000);
  Console.WriteLine("Sixty Four: {0}",0b_0100_0000);
}

```

## 使用字符串数据

`System.String`提供了许多您期望从这样一个实用程序类中得到的方法，包括返回字符数据长度、在当前字符串中查找子字符串以及在大写/小写之间进行转换的方法。表 [3-5](#Tab5) 列出了一些(但绝不是全部)有趣的成员。

表 3-5。

选择系统成员。线

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

字符串成员

 | 

生命的意义

 |
| --- | --- |
| `Length` | 该属性返回当前字符串的长度。 |
| `Compare()` | 这个静态方法比较两个字符串。 |
| `Contains()` | 此方法确定字符串是否包含特定的子字符串。 |
| `Equals()` | 此方法测试两个 string 对象是否包含相同的字符数据。 |
| `Format()` | 这个静态方法使用其他原语(例如，数字数据、其他字符串)和本章前面讨论过的`{0}`符号来格式化字符串。 |
| `Insert()` | 此方法在给定的字符串中插入一个字符串。 |
| `PadLeft() \ PadRight()` | 这些方法用于用一些字符填充字符串。 |
| `Remove() \ Replace()` | 这些方法用于接收经过修改(字符被删除或替换)的字符串副本。 |
| `Split()` | 该方法返回一个包含该实例中子字符串的`String`数组，这些子字符串由指定的`char`数组或`string`数组的元素分隔。 |
| `Trim()` | 此方法从当前字符串的开头和结尾移除一组指定字符的所有匹配项。 |
| `ToUpper() \ ToLower()` | 这些方法分别以大写或小写格式创建当前字符串的副本。 |

### 执行基本的字符串操作

与`System.String`的成员一起工作正如你所料。只需声明一个`string`变量，并通过点运算符使用提供的功能。请注意，`System.String`的一些成员是静态成员，因此在类(而不是对象)级别被调用。

假设您已经创建了一个名为 FunWithStrings 的新控制台应用程序项目，并将其添加到您的解决方案中。清除现有代码并添加以下内容:

```
using System;
using System.Text;
BasicStringFunctionality();

static void BasicStringFunctionality()
{
  Console.WriteLine("=> Basic String functionality:");
  string firstName = "Freddy";
  Console.WriteLine("Value of firstName: {0}", firstName);
  Console.WriteLine("firstName has {0} characters.", firstName.Length);
  Console.WriteLine("firstName in uppercase: {0}", firstName.ToUpper());
  Console.WriteLine("firstName in lowercase: {0}", firstName.ToLower());
  Console.WriteLine("firstName contains the letter y?: {0}",
    firstName.Contains("y"));
  Console.WriteLine("New first name: {0}", firstName.Replace("dy", ""));
  Console.WriteLine();
}

```

这里没有太多要说的，因为这个方法只是在一个本地`string`变量上调用各种成员，比如`ToUpper()`和`Contains()`，以产生各种格式和转换。以下是初始输出:

```
***** Fun with Strings *****

=> Basic String functionality:
Value of firstName: Freddy
firstName has 6 characters.
firstName in uppercase: FREDDY
firstName in lowercase: freddy
firstName contains the letter y?: True
firstName after replace: Fred

```

虽然这个输出看起来不太令人惊讶，但是通过调用`Replace()`方法看到的输出有点误导。实际上，`firstName`变量一点都没变；相反，你会收到一个修改后的新的`string`。过一会儿，您将重新审视字符串不可变的本质。

### 执行字符串串联

`String`变量可以通过 C# `+`(以及`+=`)操作符连接起来构建更大的`string`。如你所知，这种技术被正式命名为*字符串连接*。考虑以下新的助手函数:

```
static void StringConcatenation()
{
  Console.WriteLine("=> String concatenation:");
  string s1 = "Programming the ";
  string s2 = "PsychoDrill (PTP)";
  string s3 = s1 + s2;
  Console.WriteLine(s3);
  Console.WriteLine();
}

```

您可能有兴趣知道 C# `+`符号是由编译器处理的，以发出对静态`String.Concat()`方法的调用。考虑到这一点，可以通过直接调用`String.Concat()`来执行字符串连接，如下面这个方法的修改版本所示(尽管这样做并没有带来任何好处——事实上，您已经招致了额外的击键！):

```
static void StringConcatenation()
{
  Console.WriteLine("=> String concatenation:");
  string s1 = "Programming the ";
  string s2 = "PsychoDrill (PTP)";
  string s3 = String.Concat(s1, s2);
  Console.WriteLine(s3);
  Console.WriteLine();
}

```

### 使用转义字符

与其他基于 C 的语言一样，C#字符串文字可能包含各种*转义字符*，这些字符限定了字符数据应该如何输出到输出流。每个转义字符都以反斜杠开头，后跟一个特定的标记。如果你对这些转义字符背后的含义有点生疏，表 [3-6](#Tab6) 列出了更常见的选项。

表 3-6。

字符串转义字符

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

性格；角色；字母

 | 

生命的意义

 |
| --- | --- |
| `\'` | 在字符串中插入单引号。 |
| `\"` | 在字符串中插入双引号。 |
| `\\` | 在字符串中插入反斜杠。这在定义文件或网络路径时非常有用。 |
| `\a` | 触发系统警报(嘟嘟声)。对于控制台程序，这可以是给用户的音频提示。 |
| `\n` | 插入新行(在 Windows 平台上)。 |
| `\r` | 插入一个回车。 |
| `\t` | 在字符串中插入水平制表符。 |

例如，要打印每个单词之间包含一个制表符的字符串，可以使用`\t`转义字符。或者假设您想要创建一个包含引号的字符串文字，另一个定义目录路径，最后一个在打印字符数据后插入三个空行的字符串文字。要做到这一点而不出现编译器错误，您需要使用`\"`、`\\`和`\n`转义字符。此外，为了骚扰你周围 10 英尺范围内的任何人，请注意，我在每个字符串文字中嵌入了一个警报(触发一个嘟嘟声)。请考虑以下几点:

```
static void EscapeChars()
{
  Console.WriteLine("=> Escape characters:\a");
  string strWithTabs = "Model\tColor\tSpeed\tPet Name\a ";
  Console.WriteLine(strWithTabs);

  Console.WriteLine("Everyone loves \"Hello World\"\a ");
  Console.WriteLine("C:\\MyApp\\bin\\Debug\a ");

  // Adds a total of 4 blank lines (then beep again!).
  Console.WriteLine("All finished.\n\n\n\a ");
  Console.WriteLine();
}

```

### 执行字符串插值

本章中说明的花括号语法(`{0}`、`{1}`等)。)已经存在于。NET 平台从 1.0 版本开始。从 C# 6 开始，C#程序员可以使用另一种语法来构建包含变量占位符的字符串文字。形式上，这被称为*字符串插值*。虽然该操作的输出与传统的字符串格式语法相同，但这种新方法允许您直接嵌入变量本身，而不是将它们作为逗号分隔的列表附加上去。

考虑您的`Program`类(`StringInterpolation()`)的以下附加方法，它使用每种方法构建一个`string`变量:

```
static void StringInterpolation()
{
    Console.WriteLine("=> String interpolation:\a");

    // Some local variables we will plug into our larger string
    int age = 4;
    string name = "Soren";

    // Using curly-bracket syntax.
    string greeting = string.Format("Hello {0} you are {1} years old.", name, age);
    Console.WriteLine(greeting);

    // Using string interpolation
    string greeting2 = $"Hello {name} you are {age} years old.";
    Console.WriteLine(greeting2);
}

```

在`greeting2`变量中，注意您正在构建的字符串是如何以美元符号(`$`)前缀开始的。接下来，注意花括号仍然用于标记变量占位符；但是，您可以将变量直接放入作用域中，而不是使用数字标记。假定的优点是，这种新的格式化语法更容易以线性(从左到右)方式阅读，因为您不需要“跳到末尾”来查看运行时要插入的值列表。

这种新语法还有一个有趣的方面:字符串插值中使用的花括号是一个有效的作用域。因此，您可以对变量使用点操作来更改它们的状态。考虑对每个汇编的`string`变量进行更新。

```
string greeting = string.Format("Hello {0} you are {1} years old.", name.ToUpper(), age);
string greeting2 = $"Hello {name.ToUpper()} you are {age} years old.";

```

在这里，我通过调用`ToUpper()`将名称大写。请注意，在字符串插值方法中，您在调用该方法时不需要*而不是*添加分号终止符。鉴于此，您不能将花括号作用域用作包含多行可执行代码的完全成熟的方法作用域。相反，您可以使用点运算符调用对象上的单个成员，并定义一个简单的通用表达式，如`{age += 1}`。

同样值得注意的是，在这个新语法中，您仍然可以在字符串中使用转义字符。因此，如果您想插入一个制表符，您可以将一个`\t`标记作为前缀，如下所示:

```
string greeting = string.Format("\tHello {0} you are {1} years old.", name.ToUpper(), age);
string greeting2 = $"\tHello {name.ToUpper()} you are {age} years old.";

```

### 定义逐字字符串(更新 8.0)

当您在一个字符串前面加上`@`符号时，您就创建了一个被称为*的逐字字符串*。使用逐字字符串，您可以禁用对文字转义字符的处理，并按原样打印出一个`string`。这在使用代表目录和网络路径的`string`时非常有用。因此，您可以简单地编写以下代码，而不是使用`\\`转义字符:

```
// The following string is printed verbatim,
// thus all escape characters are displayed.
Console.WriteLine(@"C:\MyApp\bin\Debug");

```

另请注意，逐字字符串可以用于保留多行字符串的空白。

```
// Whitespace is preserved with verbatim strings.
string myLongString = @"This is a very
     very
          very
               long string";
Console.WriteLine(myLongString);

```

使用逐字字符串，您还可以通过将`"`标记加倍来直接将双引号插入到文字字符串中。

```
Console.WriteLine(@"Cerebus said ""Darrr! Pret-ty sun-sets""");

```

通过指定插值运算符($)和逐字运算符(@)，逐字字符串也可以是插值字符串。

```
string interp = "interpolation";
string myLongString2 = $@"This is a very
   very
         long string with {interp}";

```

这是 C# 8 中的新特性，顺序无关紧要。使用`$@`或`@$`都可以。

### 使用字符串和等式

正如将在第 [4](04.html) 章中全面解释的那样，*引用类型*是在垃圾收集托管堆上分配的对象。默认情况下，当您对引用类型执行相等测试时(通过 C# `==`和`!=`操作符)，如果引用指向内存中的同一个对象，您将返回`true`。然而，即使`string`数据类型确实是一个引用类型，相等操作符已经被重新定义来比较`string`对象的*值*，而不是它们引用的内存中的对象。

```
static void StringEquality()
{
  Console.WriteLine("=> String equality:");
  string s1 = "Hello!";
  string s2 = "Yo!";
  Console.WriteLine("s1 = {0}", s1);
  Console.WriteLine("s2 = {0}", s2);
  Console.WriteLine();

  // Test these strings for equality.
  Console.WriteLine("s1 == s2: {0}", s1 == s2);
  Console.WriteLine("s1 == Hello!: {0}", s1 == "Hello!");
  Console.WriteLine("s1 == HELLO!: {0}", s1 == "HELLO!");
  Console.WriteLine("s1 == hello!: {0}", s1 == "hello!");
  Console.WriteLine("s1.Equals(s2): {0}", s1.Equals(s2));
  Console.WriteLine("Yo!.Equals(s2): {0}", "Yo!".Equals(s2));
  Console.WriteLine();
}

```

默认情况下，C#相等运算符对`string`对象执行区分大小写、不区分区域性、逐个字符的相等测试。因此，`"Hello!"`不等于`"HELLO!"`，这也与`"hello!"`不同。此外，记住`string`和`System.String`之间的联系，注意您可以使用`String`的`Equals()`方法以及内置的等式操作符来测试等式。最后，假设每个字符串文字(比如`"Yo!"`)都是一个有效的`System.String`实例，那么您就能够从固定的字符序列中访问以字符串为中心的功能。

#### 修改字符串比较行为

如上所述，字符串相等运算符(`Compare()`、`Equals()`和`==`)以及`IndexOf()`函数在默认情况下是区分大小写和不区分文化的。如果您的程序不关心大小写，这可能会导致问题。克服这个问题的一个方法是将所有内容转换为大写或小写，然后进行比较，如下所示:

```
if (firstString.ToUpper() == secondString.ToUpper())
{
  //Do something
}

```

这将复制所有小写字母的每个字符串。在大多数情况下，这可能不是问题，但如果字符串非常大，可能会影响性能。就算不是性能问题，每次写都有点痛苦。如果你忘记打电话给`ToUpper()`怎么办？这可能会导致程序中出现难以发现的错误。

一个更好的实践是使用前面列出的方法的重载，这些重载接受一个`StringComparison`枚举的值来精确地控制比较是如何完成的。表 [3-7](#Tab7) 描述了`StringComparison`值。

表 3-7。

StringComparison 枚举的值

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

C#等式/关系运算符

 | 

生命的意义

 |
| --- | --- |
| `CurrentCulture` | 使用区分区域性的排序规则和当前区域性比较字符串 |
| `CurrentCultureIgnoreCase` | 使用区分区域性的排序规则和当前区域性比较字符串，并忽略被比较字符串的大小写 |
| `InvariantCulture` | 使用区分区域性的排序规则和固定区域性比较字符串 |
| `InvariantCultureIgnoreCase` | 使用区分区域性的排序规则和固定区域性比较字符串，并忽略被比较字符串的大小写 |
| `Ordinal` | 使用序数(二进制)排序规则比较字符串 |
| `OrdinalIgnoreCare` | 使用序数(二进制)排序规则比较字符串，并忽略被比较字符串的大小写 |

要查看使用`StringComparison`选项的效果，创建一个名为`StringEqualitySpecifyingCompareRules()`的新方法，并添加以下代码:

```
static void StringEqualitySpecifyingCompareRules()
{
  Console.WriteLine("=> String equality (Case Insensitive:");
  string s1 = "Hello!";
  string s2 = "HELLO!";
  Console.WriteLine("s1 = {0}", s1);
  Console.WriteLine("s2 = {0}", s2);
  Console.WriteLine();

  // Check the results of changing the default compare rules.
  Console.WriteLine("Default rules: s1={0},s2={1}s1.Equals(s2): {2}", s1, s2, s1.Equals(s2));
  Console.WriteLine("Ignore case: s1.Equals(s2, StringComparison.OrdinalIgnoreCase): {0}",
    s1.Equals(s2, StringComparison.OrdinalIgnoreCase));
  Console.WriteLine("Ignore case, Invariant Culture: s1.Equals(s2, StringComparison.InvariantCultureIgnoreCase): {0}",
    s1.Equals(s2, StringComparison.InvariantCultureIgnoreCase));
  Console.WriteLine();
  Console.WriteLine("Default rules: s1={0},s2={1} s1.IndexOf(\"E\"): {2}", s1, s2, s1.IndexOf("E"));
  Console.WriteLine("Ignore case: s1.IndexOf(\"E\", StringComparison.OrdinalIgnoreCase): {0}", s1.IndexOf("E",
    StringComparison.OrdinalIgnoreCase));
  Console.WriteLine("Ignore case, Invariant Culture: s1.IndexOf(\"E\", StringComparison.InvariantCultureIgnoreCase): {0}",
    s1.IndexOf("E", StringComparison.InvariantCultureIgnoreCase));
  Console.WriteLine();
}

```

虽然这里的例子很简单，并且在大多数文化中使用相同的字母，但是如果您的应用程序需要考虑不同的文化集，那么使用`StringComparison`选项是必须的。

### 字符串是不可变的

`System.String`的一个有趣的方面是，在你给一个`string`对象赋了初始值之后，角色数据*就不能被改变*。乍一看，这似乎是一个彻头彻尾的谎言，因为您总是将字符串重新分配给新值，并且因为`System.String`类型定义了许多方法，这些方法似乎以某种方式修改字符数据(例如大写和小写)。然而，如果你更仔细地观察幕后发生的事情，你会注意到`string`类型的方法实际上是以修改后的格式返回给你一个新的`string`对象。

```
static void StringsAreImmutable()
{
    Console.WriteLine("=> Immutable Strings:\a");
  // Set initial string value.
  string s1 = "This is my string.";
  Console.WriteLine("s1 = {0}", s1);

  // Uppercase s1?
  string upperString = s1.ToUpper();
  Console.WriteLine("upperString = {0}", upperString);

  // Nope! s1 is in the same format!
  Console.WriteLine("s1 = {0}", s1);
}

```

如果您检查下面的相关输出，您可以验证原始的`string`对象(`s1`)在调用`ToUpper()`时没有大写。相反，你会得到一个经过修改的`string`的*副本*。

```
s1 = This is my string.

upperString = THIS IS MY STRING.
s1 = This is my string.

```

当您使用 C#赋值操作符时，不变性法则同样适用。举例来说，实现下面的`StringsAreImmutable2()`方法:

```
static void StringsAreImmutable2()
{
    Console.WriteLine("=> Immutable Strings 2:\a");
  string s2 = "My other string";
  s2 = "New string value";
}

```

现在，编译你的应用程序并运行`ildasm.exe`(参见第 [1 章](01.html))。下面的输出显示了如果您要为`StringsAreImmutable2()`方法生成 CIL 代码，您会发现什么:

```
.method private hidebysig static void  StringsAreImmutable2() cil managed

{
  // Code size       21 (0x15)
  .maxstack  1
  .locals init (string V_0)
  IL_0000:  nop
  IL_0001:  ldstr      "My other string"
  IL_0006:  stloc.0
  IL_0007:  ldstr      "New string value" /* 70000B3B */
  IL_000c:  stloc.0
  IL_000d:  ldloc.0
  IL_0013:  nop
  IL_0014:  ret
} // end of method Program::StringsAreImmutable2

```

尽管您还没有检查 CIL 的底层细节，但是请注意对`ldstr` (load string)操作码的大量调用。简单地说，CIL 的`ldstr`操作码在托管堆上加载一个新的`string`对象。包含值`"My other string"`的前一个`string`对象最终将被垃圾回收。

那么，你从这种洞察力中能收集到什么呢？简而言之，`string`类可能效率低下，如果误用会导致代码膨胀，尤其是在执行字符串连接或处理大量文本数据时。如果您需要表示基本的字符数据，比如美国社会保险号、名字或姓氏，或者应用程序中使用的简单文本，那么`string`类是最佳选择。

然而，如果您正在构建一个大量使用频繁变化的文本数据的应用程序(比如一个字处理程序)，那么使用`string`对象来表示字处理数据将是一个坏主意，因为您将最有可能(并且经常是间接地)最终制作不必要的字符串数据副本。那么，程序员要做什么呢？很高兴你问了。

### 使用系统。Text.StringBuilder 类型

鉴于`string`类型在鲁莽使用时可能效率低下，因此。NET 核心基类库提供了`System.Text`命名空间。在这个(相对较小的)名称空间中有一个名为`StringBuilder`的类。例如，像`System.String`类一样，`StringBuilder`定义了允许你替换或格式化段的方法。当您希望在 C#代码文件中使用此类型时，第一步是确保将以下命名空间导入到代码文件中(对于新的 Visual Studio 项目，这应该已经是这样的情况):

```
// StringBuilder lives here!
using System.Text;

```

`StringBuilder`的独特之处在于，当您调用这种类型的成员时，您是在直接修改对象的内部字符数据(使其更有效)，而不是以修改后的格式获得数据的副本。当您创建一个`StringBuilder`的实例时，您可以通过许多*构造函数*中的一个来提供对象的初始启动值。如果你是构造函数的新手，只需理解构造函数允许你在应用`new`关键字时创建一个具有初始状态的对象。考虑`StringBuilder`的以下用法:

```
static void FunWithStringBuilder()
{
  Console.WriteLine("=> Using the StringBuilder:");
  StringBuilder sb = new StringBuilder("**** Fantastic Games ****");
  sb.Append("\n");
  sb.AppendLine("Half Life");
  sb.AppendLine("Morrowind");
  sb.AppendLine("Deus Ex" + "2");
  sb.AppendLine("System Shock");
  Console.WriteLine(sb.ToString());
  sb.Replace("2", " Invisible War");
  Console.WriteLine(sb.ToString());
  Console.WriteLine("sb has {0} chars.", sb.Length);
  Console.WriteLine();
}

```

这里，我构造了一个设置为初始值`"**** Fantastic Games ****"`的`StringBuilder`。正如你所看到的，我附加到内部缓冲区，并能够随意替换或删除字符。默认情况下，`StringBuilder`最初只能容纳 16 个字符或更少的字符串(但是如果需要会自动扩展)；但是，这个默认的起始值可以通过一个额外的构造函数参数来更改。

```
// Make a StringBuilder with an initial size of 256.
StringBuilder sb = new StringBuilder("**** Fantastic Games ****", 256);

```

如果您添加的字符超过了指定的限制，`StringBuilder`对象会将其数据复制到一个新的实例中，并按照指定的限制增加缓冲区。

## 缩小和扩大数据类型转换

既然您已经理解了如何使用内部 C#数据类型，那么让我们来研究一下相关的主题*数据类型转换*。假设您有一个名为 TypeConversions 的新控制台应用程序项目，并将其添加到您的解决方案中。更新代码以匹配以下内容:

```
using System;

Console.WriteLine("***** Fun with type conversions *****");

// Add two shorts and print the result.
short numb1 = 9, numb2 = 10;
Console.WriteLine("{0} + {1} = {2}",
  numb1, numb2, Add(numb1, numb2));
Console.ReadLine();

static int Add(int x, int y)
{
  return x + y;
}

```

注意，`Add()`方法期望被发送两个`int`参数。然而，调用代码实际上发送了两个`short`变量。虽然这看起来像是数据类型完全不匹配，但程序编译和执行时没有错误，返回预期的结果 19。

编译器认为这段代码在语法上是正确的，因为它不可能丢失数据。鉴于 a 的最大值`short` (32，767)正好在 a 的最大范围`int` (2，147，483，647)内，编译器隐式地*将每个`short`的*加宽为`int`。正式来说，*加宽*是用来定义不会导致数据丢失的隐式*向上转换*的术语。

Note

中查找“类型转换表”。NET Core 文档，如果您想了解每种 C#数据类型允许的扩大(和缩小，下面讨论)转换。

虽然在前面的例子中，这种隐式扩展对您有利，但在其他时候，这种“特性”可能是编译时错误的来源。例如，假设您已经设置了`numb1`和`numb2`的值，当它们加在一起时，溢出了`short`的最大值。另外，假设您将`Add()`方法的返回值存储在一个新的本地`short`变量中，而不是直接将结果打印到控制台。

```
static void Main(string[] args)
{
  Console.WriteLine("***** Fun with type conversions *****");

  // Compiler error below!
  short numb1 = 30000, numb2 = 30000;
  short answer = Add(numb1, numb2);

  Console.WriteLine("{0} + {1} = {2}",
    numb1, numb2, answer);
  Console.ReadLine();
}

```

在这种情况下，编译器会报告以下错误:

```
Cannot implicitly convert type 'int' to 'short'. An explicit conversion exists (are you missing a cast?)

```

问题是，尽管`Add()`方法能够返回值为 60，000 的`int`(这在`System.Int32`的范围内)，但是该值不能存储在`short`中，因为它溢出了该数据类型的界限。从形式上讲，CoreCLR 无法应用*缩小操作*。正如您所猜测的，缩小与扩大在逻辑上是相反的，因为较大的值存储在较小的数据类型变量中。

需要指出的是，所有收缩转换都会导致编译器错误，即使您可以推断收缩转换确实应该成功。例如，以下代码也会导致编译器错误:

```
// Another compiler error!
static void NarrowingAttempt()
{
  byte myByte = 0;
  int myInt = 200;
  myByte = myInt;

  Console.WriteLine("Value of myByte: {0}", myByte);
}

```

这里，`int`变量(`myInt`)中包含的值安全地在一个`byte`的范围内；因此，您可能希望收缩操作不会导致运行时错误。然而，考虑到 C#是一种考虑到类型安全的语言，您确实会收到一个编译器错误。

当您想要通知编译器您愿意处理由于缩小操作而可能丢失的数据时，您必须使用 C#强制转换运算符`()`应用*显式强制转换*。考虑下面对`Program`类型的更新:

```
class Program
{
  static void Main(string[] args)
  {
    Console.WriteLine("***** Fun with type conversions *****");
    short numb1 = 30000, numb2 = 30000;

    // Explicitly cast the int into a short (and allow loss of data).
    short answer = (short)Add(numb1, numb2);

    Console.WriteLine("{0} + {1} = {2}",
      numb1, numb2, answer);
    NarrowingAttempt();
    Console.ReadLine();
}

  static int Add(int x, int y)
{
    return x + y;
}

  static void NarrowingAttempt()
{
    byte myByte = 0;
    int myInt = 200;

    // Explicitly cast the int into a byte (no loss of data).
    myByte = (byte)myInt;
    Console.WriteLine("Value of myByte: {0}", myByte);
  }
}

```

此时，代码编译完毕；但是，相加的结果是完全不正确的。

```
***** Fun with type conversions *****

30000 + 30000 = -5536
Value of myByte: 200

```

正如您刚刚看到的，显式强制转换允许您强制编译器应用收缩转换，即使这样做可能会导致数据丢失。在使用`NarrowingAttempt()`方法的情况下，这不是一个问题，因为值 200 可以恰好在`byte`的范围内。但是在`Main()`内的两个`short`相加的情况下，最终结果是完全不能接受的(30000+30000 =–5536？).

如果您正在构建一个数据丢失总是不可接受的应用程序，C#提供了`checked`和`unchecked`关键字来确保数据丢失不会不被发现。

### 使用选中的关键字

让我们从学习关键字`checked`的作用开始。假设您在`Program`中有一个新方法，它试图添加两个`byte`，每个都被赋予一个低于最大值(255)的安全值。如果您要将这些类型的值相加(将返回的`int`转换为`byte`，您会认为结果将是每个成员的精确总和。

```
static void ProcessBytes()
{
  byte b1 = 100;
  byte b2 = 250;
  byte sum = (byte)Add(b1, b2);

  // sum should hold the value 350\. However, we find the value 94!
  Console.WriteLine("sum = {0}", sum);
}

```

如果您要查看这个应用程序的输出，您可能会惊讶地发现`sum`包含值 94(而不是预期的 350)。原因很简单。假定`System.Byte`只能保存 0 到 255 之间的值(包括 0 和 255，总共 256 个槽)，`sum`现在包含溢出值(350–256 = 94)。默认情况下，如果您不采取纠正措施，上溢/下溢情况会正确发生。

要处理应用程序中的上溢或下溢情况，有两种选择。您的第一选择是利用您的智慧和编程技能来手动处理所有上溢/下溢情况。当然，这种技术的问题是一个简单的事实，即你是人，即使你尽了最大的努力也可能导致你没有注意到的错误。

谢天谢地，C#提供了`checked`关键字。当您在`checked`关键字的范围内包装一个语句(或一个语句块)时，C#编译器会发出额外的 CIL 指令来测试两个数字数据类型的加、乘、减或除时可能导致的溢出情况。

如果发生溢出，您将收到一个运行时异常:`System.OverflowException`。第 7 章[将研究结构化异常处理的所有细节以及`try`和`catch`关键字的使用。在这一点上不要太纠结于细节，观察下面的更新:](07.html)

```
static void ProcessBytes()
{
  byte b1 = 100;
  byte b2 = 250;

  // This time, tell the compiler to add CIL code
  // to throw an exception if overflow/underflow
  // takes place.
  try
  {
    byte sum = checked((byte)Add(b1, b2));
    Console.WriteLine("sum = {0}", sum);
  }
  catch (OverflowException ex)
  {
    Console.WriteLine(ex.Message);
  }
}

```

注意，`Add()`的返回值已经被包装在`checked`关键字的范围内。因为总和大于一个`byte`，这触发了一个运行时异常。注意通过`Message`属性打印出来的错误消息。

```
Arithmetic operation resulted in an overflow.

```

如果希望对代码语句块强制进行溢出检查，可以通过定义如下的“检查范围”来实现:

```
try
{
  checked
  {
    byte sum = (byte)Add(b1, b2);
    Console.WriteLine("sum = {0}", sum);
  }
}
catch (OverflowException ex)
{
  Console.WriteLine(ex.Message);
}

```

在这两种情况下，将自动评估有问题的代码是否存在可能的溢出条件，如果遇到这种情况，将触发溢出异常。

### 设置项目范围的溢出检查

如果您正在创建一个永远不允许静默溢出发生的应用程序，您可能会发现自己处于一个恼人的位置，即在 checked 关键字的范围内包装许多行代码。作为替代，C#编译器支持`/checked`标志。当它被启用时，你所有的算法都将被计算溢出，而不需要使用 C# `checked`关键字。如果已经发现溢出，您仍然会收到一个运行时异常。要为整个项目设置此项，请在项目文件中输入以下内容:

```
<PropertyGroup>
    <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
</PropertyGroup>

```

### 设置项目范围的溢出检查(Visual Studio)

若要使用 Visual Studio 启用此标志，请打开项目的属性页。选择所有配置，然后单击“构建”选项卡上的“高级”按钮。从出现的对话框中，选择“检查算术溢出/下溢”复选框(见图 [3-3](#Fig3) )。在创建调试版本时，启用此设置会很有帮助。在所有溢出异常都被挤出代码库之后，您可以为后续构建禁用`/checked`标志(这可以提高应用程序的运行时性能)。

![../images/340876_10_En_3_Chapter/340876_10_En_3_Fig3_HTML.jpg](../images/340876_10_En_3_Chapter/340876_10_En_3_Fig3_HTML.jpg)

图 3-3。

启用项目范围的溢出/下溢数据检查

Note

如果不选择所有配置，则该设置将仅应用于当前选定的配置(例如，调试、发布)

### 使用未检查的关键字

现在，假设您已经启用了这个项目范围的设置，如果您有一个数据丢失*是*可接受的代码块，您该怎么办？考虑到`/checked`标志将评估所有的算术逻辑，C#提供了`unchecked`关键字来根据具体情况禁止抛出溢出异常。该关键字的用法与`checked`关键字的用法相同，因为您可以指定一条语句或一组语句。

```
// Assuming /checked is enabled,
// this block will not trigger
// a runtime exception.
unchecked
{
  byte sum = (byte)(b1 + b2);
  Console.WriteLine("sum = {0} ", sum);
}

```

所以，总结一下 C# `checked`和`unchecked`关键字，记住。NET 核心运行时忽略算术上溢/下溢。当你想有选择地处理离散语句时，使用`checked`关键字。如果您想在整个应用程序中捕获溢出错误，启用`/checked`标志。最后，如果您有一个溢出是可接受的代码块(因此不应该触发运行时异常)，可以使用`unchecked`关键字。

## 理解隐式类型的局部变量

直到本章的这一点，当你已经定义了局部变量，你已经明确地指定了每个变量的底层数据类型。

```
static void DeclareExplicitVars()
{
  // Explicitly typed local variables
  // are declared as follows:
  // dataType variableName = initialValue;
  int myInt = 0;
  bool myBool = true;
  string myString = "Time, marches on...";
}

```

虽然许多人认为显式指定每个变量的数据类型通常是一种好的做法，但 C#语言确实提供了使用`var`关键字隐式键入局部变量的。`var`关键字可以用来代替指定特定的数据类型(例如`int`、`bool`或`string`)。当您这样做时，编译器将根据用于初始化本地数据点的初始值自动推断基础数据类型。

为了说明隐式类型的作用，创建一个名为 ImplicitlyTypedLocalVars 的新控制台应用程序项目，并将其添加到您的解决方案中。将`Program.cs`中的代码更新如下:

```
using System;
using System.Linq;

Console.WriteLine("***** Fun with Implicit Typing *****");

```

添加以下函数来演示隐式声明:

```
static void DeclareImplicitVars()
{
  // Implicitly typed local variables
  // are declared as follows:
  // var variableName = initialValue;
  var myInt = 0;
  var myBool = true;
  var myString = "Time, marches on...";
}

```

Note

严格来说，`var`不是 C#关键字。允许在没有编译时错误的情况下声明名为`var`的变量、参数和字段。然而，当`var`标记被用作数据类型时，编译器会根据上下文将其视为关键字。

在这种情况下，给定初始赋值，编译器能够推断出`myInt`实际上是一个`System.Int32`，`myBool`是一个`System.Boolean`，`myString`确实是类型`System.String`。您可以通过*反射*打印类型名来验证这一点。正如你将在第 [17](17.html) 章中看到的更多细节，*反射*是在运行时确定一个类型的组成的行为。例如，使用反射，可以确定隐式类型化局部变量的数据类型。使用以下代码语句更新您的方法:

```
static void DeclareImplicitVars()
{
  // Implicitly typed local variables.
  var myInt = 0;
  var myBool = true;
  var myString = "Time, marches on...";

  // Print out the underlying type.
  Console.WriteLine("myInt is a: {0}", myInt.GetType().Name);
  Console.WriteLine("myBool is a: {0}", myBool.GetType().Name);
  Console.WriteLine("myString is a: {0}", myString.GetType().Name);
}

```

Note

请注意，您可以对任何类型使用这种隐式类型，包括数组、泛型类型(参见第 [10](10.html) 章)和您自己的自定义类型。在本书的过程中，你会看到其他隐式类型的例子。

如果您从顶层语句中调用`DeclareImplicitVars()`方法，您会发现如下所示的输出:

```
***** Fun with Implicit Typing *****

myInt is a: Int32
myBool is a: Boolean
myString is a: String

```

### 隐式声明数字

如前所述，整数默认为整数，浮点数默认为双精度。创建一个名为`DeclareImplicitNumerics`的新方法，并添加以下代码来演示 numerics 的隐式声明:

```
static void DeclareImplicitNumerics()
{
  // Implicitly typed numeric variables.
  var myUInt = 0u;
  var myInt = 0;
  var myLong = 0L;
  var myDouble = 0.5;
  var myFloat = 0.5F;
  var myDecimal = 0.5M;

  // Print out the underlying type.
  Console.WriteLine("myUInt is a: {0}", myUInt.GetType().Name);
  Console.WriteLine("myInt is a: {0}", myInt.GetType().Name);
  Console.WriteLine("myLong is a: {0}", myLong.GetType().Name);
  Console.WriteLine("myDouble is a: {0}", myDouble.GetType().Name);
  Console.WriteLine("myFloat is a: {0}", myFloat.GetType().Name);
  Console.WriteLine("myDecimal is a: {0}", myDecimal.GetType().Name);
}

```

### 了解隐式类型变量的限制

关于`var`关键字的使用有各种限制。首先，隐式类型将*仅*应用于方法或属性范围内的局部变量。使用`var`关键字定义自定义类型的返回值、参数或字段数据是非法的。例如，下面的类定义将导致各种编译时错误:

```
class ThisWillNeverCompile
{
  // Error! var cannot be used as field data!
  private var myInt = 10;

  // Error! var cannot be used as a return value
  // or parameter type!
  public var MyMethod(var x, var y){}
}

```

同样，用关键字`var`声明的局部变量*必须在声明的确切时间*被赋予一个初始值，而*不能被赋予初始值`null`。这最后一个限制应该是有意义的，因为编译器不能仅仅根据`null`来推断变量将指向内存中的哪种类型。*

```
// Error! Must assign a value!
var myData;

// Error! Must assign value at exact time of declaration!
var myInt;
myInt = 0;

// Error! Can't assign null as initial value!
var myObj = null;

```

然而，允许在初始赋值后将推断的局部变量赋值给`null`(假设它是引用类型)。

```
// OK, if SportsCar is a reference type!
var myCar = new SportsCar();
myCar = null;

```

此外，允许将隐式类型的局部变量的值赋给其他变量的值，无论是否是隐式类型的。

```
// Also OK!
var myInt = 0;
var anotherInt = myInt;

string myString = "Wake up!";
var myData = myString;

```

此外，如果方法返回类型与`var`定义的数据点是相同的底层类型，那么允许向调用者返回隐式类型的局部变量。

```
static int GetAnInt()
{
  var retVal = 9;
  return retVal;
}

```

### 隐式类型数据是强类型数据

请注意，局部变量的隐式类型化会导致*强类型数据*。因此，`var`关键字的使用是*而不是*与脚本语言(如 JavaScript 或 Perl)或 COM `Variant`数据类型使用的相同技术，其中变量可以在程序的生存期内保存不同类型的值(通常称为*动态类型化*)。

Note

C#允许使用名为-surprise，surprise-`dynamic`的关键字进行动态输入。你会在第 18 章学到这方面的知识。

相反，类型推断保留了 C#语言的强类型特征，并且只影响编译时的变量声明。之后，数据点被视为是用该类型声明的；将不同类型的值赋给该变量将导致编译时错误。

```
static void ImplicitTypingIsStrongTyping()
{
  // The compiler knows "s" is a System.String.
  var s = "This variable can only hold string data!";
  s = "This is fine...";

  // Can invoke any member of the underlying type.
  string upper = s.ToUpper();

  // Error! Can't assign numerical data to a string!
  s = 44;
}

```

### 理解隐式类型化局部变量的有用性

既然您已经看到了用于声明隐式类型化局部变量的语法，我相信您一定想知道什么时候使用这种结构。首先，仅仅为了声明局部变量而使用`var`并没有带来什么好处。这样做可能会让阅读您代码的其他人感到困惑，因为快速确定底层数据类型变得更加困难，因此理解变量的整体功能也更加困难。所以，如果你知道你需要一个`int`，那就声明一个`int`！

然而，正如你将在第 [13 章](13.html)开始看到的，LINQ 技术集利用了*查询表达式*，它可以基于查询本身的格式产生动态创建的结果集。在这些情况下，隐式类型非常有用，因为您不需要显式定义查询可能返回的类型，而这在某些情况下实际上是不可能做到的。不要纠结于下面的 LINQ 示例代码，看看您是否能弄清楚`subset`的底层数据类型:

```
static void LinqQueryOverInts()
{
  int[] numbers = { 10, 20, 30, 40, 1, 2, 3, 8 };

  // LINQ query!
  var subset = from i in numbers where i < 10 select i;

  Console.Write("Values in subset: ");
  foreach (var i in subset)
  {
    Console.Write("{0} ", i);
  }
  Console.WriteLine();

  // Hmm...what type is subset?
  Console.WriteLine("subset is a: {0}", subset.GetType().Name);
  Console.WriteLine("subset is defined in: {0}", subset.GetType().Namespace);
}

```

您可能会假设`subset`数据类型是一个整数数组。看起来是这样，但事实上，它是一种低级的 LINQ 数据类型，除非你已经做了很长时间的 LINQ，或者你在`ildasm.exe`中打开编译后的图像，否则你永远不会知道它。好消息是，当您使用 LINQ 时，您很少(如果曾经)关心查询返回值的底层类型；您只需将值赋给隐式类型的局部变量。

事实上，可以说*唯一一次*使用`var`关键字是在定义从 LINQ 查询返回的数据时。记住，如果你知道你需要一个`int`，就声明一个`int`！过度使用隐式类型(通过`var`关键字)被大多数开发人员认为是产品代码中糟糕的风格。

## 使用 C#迭代构造

所有编程语言都提供了重复代码块的方法，直到满足终止条件。不管你过去使用过哪种语言，我想 C#迭代语句应该不会引起太多的关注，也不需要太多的解释。C#提供了以下四种迭代构造:

*   `for`循环

*   `foreach/in`循环

*   `while`循环

*   `do` / `while`循环

让我们使用一个名为 IterationsAndDecisions 的新控制台应用程序项目，依次快速检查每个循环构造。

Note

我将保持本章的这一节简明扼要，因为我假设你有使用类似关键字的经验(`if`、`for`、`switch`等)。)用你现在的编程语言。如果您需要更多信息，请在 C#文档中查找主题“迭代语句(C#参考)”、“跳转语句(C#参考)”和“选择语句(C#参考)”。

### 使用 for 循环

当您需要迭代固定次数的代码块时，`for`语句提供了很大的灵活性。本质上，您可以指定一段代码重复多少次，以及终止条件。无需赘述这一点，下面是一个语法示例:

```
// A basic for loop.
static void ForLoopExample()
{
  // Note! "i" is only visible within the scope of the for loop.
  for(int i = 0; i < 4; i++)
  {
    Console.WriteLine("Number is: {0} ", i);
  }
  // "i" is not visible here.
}

```

在构建 C# `for`语句时，您所有的 C、C++和 Java 技巧仍然有效。您可以创建复杂的终止条件，构建无限循环，反向循环(通过`--`操作符)，并使用`goto`、`continue`和`break`跳转关键字。

### 使用 foreach 循环

C# `foreach`关键字允许你遍历容器中的所有条目，而不需要测试上限。然而，与`for`循环不同的是，`foreach`循环只会以线性(n+1)的方式遍历容器(因此，你不能向后遍历容器，跳过每三个元素，等等)。

然而，当您只是需要一个一个地浏览集合时，`foreach`循环是完美的选择。这里有两个使用`foreach`的例子——一个遍历字符串数组，另一个遍历整数数组。注意，`in`关键字之前的数据类型代表容器中的数据类型。

```
// Iterate array items using foreach.
static void ForEachLoopExample()
{
  string[] carTypes = {"Ford", "BMW", "Yugo", "Honda" };
  foreach (string c in carTypes)
  {
    Console.WriteLine(c);
  }

  int[] myInts = { 10, 20, 30, 40 };
  foreach (int i in myInts)
  {
    Console.WriteLine(i);
  }
}

```

关键字`in`之后的项可以是一个简单的数组(见这里),或者更具体地说，可以是实现`IEnumerable`接口的任何类。正如你将在第 10 章[中看到的。NET 核心基类库附带了许多集合，这些集合包含通用抽象数据类型(ADT)的实现。这些项目中的任何一个(比如通用的`List<T>`)都可以在`foreach`循环中使用。](10.html)

### 在 foreach 构造中使用隐式类型

也可以在一个`foreach`循环结构中使用隐式类型。如你所料，编译器会正确地推断出正确的“类型”回想一下本章前面展示的 LINQ 示例方法。假设您不知道`subset`变量的确切底层数据类型，那么您可以使用隐式类型对结果集进行迭代。确保将下面的`using`语句添加到文件的顶部:

```
using System.Linq;
static void LinqQueryOverInts()
{
  int[] numbers = { 10, 20, 30, 40, 1, 2, 3, 8 };

  // LINQ query!
  var subset = from i in numbers where i < 10 select i;
  Console.Write("Values in subset: ");

  foreach (var i in subset)
  {
    Console.Write("{0} ", i);
  }
}

```

### 使用 while 和 do/while 循环结构

如果您想执行一个语句块，直到达到某个终止条件，那么`while`循环结构非常有用。在一个`while`循环的范围内，您需要确保这个终止事件确实被建立；否则，你会陷入死循环。在下面的例子中，消息`"In while loop"`将持续打印，直到用户在命令提示符下输入`yes`终止循环:

```
static void WhileLoopExample()
{
  string userIsDone = "";

  // Test on a lower-class copy of the string.
  while(userIsDone.ToLower() != "yes")
  {
    Console.WriteLine("In while loop");
    Console.Write("Are you done? [yes] [no]: ");
    userIsDone = Console.ReadLine();
  }
}

```

与`while`循环密切相关的是`do` / `while`语句。像一个简单的`while`循环一样，`do` / `while`在你需要执行某个动作不确定的次数时使用。不同的是`do` / `while`循环保证至少执行一次相应的代码块。相反，如果终止条件从一开始就是假的，那么简单的`while`循环可能永远不会执行。

```
static void DoWhileLoopExample()
{
  string userIsDone = "";

  do
  {
    Console.WriteLine("In do/while loop");
    Console.Write("Are you done? [yes] [no]: ");
    userIsDone = Console.ReadLine();
  }while(userIsDone.ToLower() != "yes"); // Note the semicolon!
}

```

## 关于范围的快速讨论

像所有基于 C 的语言(C#，Java 等。)，使用花括号创建一个*范围*。到目前为止，您已经在许多示例中看到了这一点，包括名称空间、类和方法。迭代和决策构造也在一个范围内操作，如下例所示:

```
for(int i = 0; i < 4; i++)
{
  Console.WriteLine("Number is: {0} ", i);
}

```

对于这些结构(在前一节和下一节中)，不使用花括号是允许的。换句话说，下面的代码*与前面的例子*完全相同:

```
for(int i = 0; i < 4; i++)
  Console.WriteLine("Number is: {0} ", i);

```

虽然这是允许的，但通常不是一个好主意。问题不在于一行语句，而在于从一行到多行的语句。如果没有大括号，在迭代/决策结构中扩展代码时可能会出错。例如，下面两个例子是 ***而不是*** 相同:

```
for(int i = 0; i < 4; i++)
{
  Console.WriteLine("Number is: {0} ", i);
  Console.WriteLine("Number plus 1 is: {0} ", i+1)
}
for(int i = 0; i < 4; i++)
  Console.WriteLine("Number is: {0} ", i);
  Console.WriteLine("Number plus 1 is: {0} ", i+1)

```

如果你幸运的话(就像这个例子)，额外的一行代码会产生一个编译错误，因为变量 *i* 只在`for`循环的范围内定义。如果您运气不好，您正在执行的代码不会被标记为编译器错误，而是一个逻辑错误，更难发现和调试。

## 使用决策构造和关系/等式运算符

既然可以迭代语句块，下一个相关的概念就是如何控制程序执行的流程。C#定义了两个简单的构造来根据各种意外情况改变程序的流程:

*   `if` / `else`语句

*   `switch`声明

Note

C# 7 用一种叫做*模式匹配*的技术扩展了`is`表达式和`switch`语句。为了完整起见，这里显示了这些扩展如何影响`if` / `else`和`switch`语句的基础知识。阅读完第 [6](06.html) 章后，这些扩展会更有意义，这一章涵盖了基类/派生类规则、类型转换和标准的`is`操作符。

### 使用 if/else 语句

首先是`if` / `else`语句。与 C 和 C++不同，C#中的`if` / `else`语句只对布尔表达式进行操作，而不是像`–1`或`0`这样的特殊值。

### 使用等式和关系运算符

C# `if` / `else`语句通常涉及使用表 [3-8](#Tab8) 中所示的 C#运算符来获得一个文字布尔值。

表 3-8。

C#关系和等式运算符

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

C#等式/关系运算符

 | 

用法示例

 | 

生命的意义

 |
| --- | --- | --- |
| `==` | `if(age == 30)` | 仅当每个表达式都相同时，才返回`true` |
| `!=` | `if("Foo" != myStr)` | 仅当每个表达式不同时才返回`true` |
| `<` | `if(bonus < 2000)` | 如果表达式 A ( `bonus`)小于表达式 B ( `2000`)，则返回`true` |
| `>` | `if(bonus > 2000)` | 如果表达式 A ( `bonus`)大于表达式 B ( `2000`)，则返回`true` |
| `<=` | `if(bonus <= 2000)` | 如果表达式 A ( `bonus`)小于或等于表达式 B ( `2000`)，则返回`true` |
| `>=` | `if(bonus >= 2000)` | 如果表达式 A ( `bonus`)大于或等于表达式 B ( `2000`)，则返回`true` |

同样，C 和 C++程序员需要知道，测试不等于零的条件的老把戏在 C#中不起作用。假设您想要查看您正在使用的`string`是否长于零个字符。你可能会想这样写:

```
static void IfElseExample()
{
  // This is illegal, given that Length returns an int, not a bool.
  string stringData = "My textual data";
  if(stringData.Length)
  {
    Console.WriteLine("string is greater than 0 characters");
  }
  else
  {
    Console.WriteLine("string is not greater than 0 characters");
  }
  Console.WriteLine();
}

```

如果您想要使用`String.Length`属性来确定真或假，您需要修改您的条件表达式来解析为布尔值。

```
// Legal, as this resolves to either true or false.
If (stringData.Length > 0)
{
  Console.WriteLine("string is greater than 0 characters");
}

```

### 使用带有模式匹配的 if/else(新 7.0)

C# 7.0 新增，*模式匹配*在`if` / `else`语句中是允许的。模式匹配允许代码检查对象的某些特征和属性，并根据这些属性和特征的存在与否做出决定。如果您是面向对象编程的新手，请不要担心；前面的句子将在后面的章节中详细解释。只需知道(目前)你可以使用`is`关键字检查一个对象的类型，如果模式匹配，将该对象赋给一个变量，然后使用该变量。

`IfElsePatternMatching`方法检查两个对象变量，确定它们是 string 还是 int，然后将结果打印到控制台:

```
static void IfElsePatternMatching()
{
  Console.WriteLine("===If Else Pattern Matching ===/n");
  object testItem1 = 123;
  object testItem2 = "Hello";
  if (testItem1 is string myStringValue1)
  {
    Console.WriteLine($"{myStringValue1} is a string");
  }
  if (testItem1 is int myValue1)
  {
    Console.WriteLine($"{myValue1} is an int");
  }
  if (testItem2 is string myStringValue2)
  {
    Console.WriteLine($"{myStringValue2} is a string");
  }
  if (testItem2 is int myValue2)
  {
    Console.WriteLine($"{myValue2} is an int");
  }
  Console.WriteLine();
}

```

### 改进模式匹配(新 9.0)

C# 9.0 引入了大量对模式匹配的改进，如表 [3-9](#Tab9) 所示。

表 3-9。

模式匹配改进

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

模式

 | 

生命的意义

 |
| --- | --- |
| `Type patterns` | 检查变量是否是一种类型 |
| `Parenthesized patterns` | 强制或强调模式组合的优先级 |
| `Conjuctive (and) patterns` | 要求两种模式匹配 |
| `Disjunctive (or) patterns` | 要求两种模式匹配 |
| `Negated (not) patterns` | 要求模式不匹配 |
| `Relational patterns` | 要求输入小于、小于或等于、大于或大于或等于 |

更新后的`IfElsePatternMatchingUpdatedInCSharp9()`展示了这些新模式的作用:

```
static void IfElsePatternMatchingUpdatedInCSharp9()
{
    Console.WriteLine("================ C# 9 If Else Pattern Matching Improvements ===============/n");
    object testItem1 = 123;
    Type t = typeof(string);
    char c = 'f';

    //Type patterns
    if (t is Type)
    {
        Console.WriteLine($"{t} is a Type");
    }

    //Relational, Conjuctive, and Disjunctive patterns
    if (c is >= 'a' and <= 'z' or >= 'A' and <= 'Z')
    {
        Console.WriteLine($"{c} is a character");
    };

    //Parenthesized patterns
    if (c is (>= 'a' and <= 'z') or (>= 'A' and <= 'Z') or '.' or ',')
    {
        Console.WriteLine($"{c} is a character or separator");
    };

    //Negative patterns
    if (testItem1 is not string)
    {
        Console.WriteLine($"{testItem1} is not a string");
    }
    if (testItem1 is not null)
    {
        Console.WriteLine($"{testItem1} is not null");
    }
    Console.WriteLine();
}

```

### 使用条件运算符(更新了 7.2、9.0)

条件运算符(`?:`)，也称为*三元条件运算符*，是书写简单`if` / `else`语句的一种速记方法。语法是这样的:

```
condition ? first_expression : second_expression;

```

这个条件就是条件测试(`if` / `else`语句的`if`部分)。如果测试通过，则执行问号(`?`)后面的代码。如果测试结果不为真，则执行冒号后的代码(`if` / `else`语句的`else`部分)。前面的代码示例可以使用条件运算符编写，如下所示:

```
static void ExecuteIfElseUsingConditionalOperator()
{
  string stringData = "My textual data";
  Console.WriteLine(stringData.Length > 0
    ? "string is greater than 0 characters"
    : "string is not greater than 0 characters");
  Console.WriteLine();
}

```

条件运算符有一些限制。首先，`first_expression`和`second_expression`两种类型都必须有从一个到另一个的隐式转换，或者，C# 9.0 中的新特性，每种类型都必须有到目标类型的隐式转换。其次，条件运算符只能在赋值语句中使用。以下代码将导致编译器错误“只有赋值、调用、递增、递减和新对象表达式可以用作语句”:

```
  stringData.Length > 0
    ? Console.WriteLine("string is greater than 0 characters")
    : Console.WriteLine("string is not greater than 0 characters");

```

C# 7.2 中新增的条件运算符可用于返回对条件结果的引用。以下面的例子为例，它使用了两种形式的条件运算符 by ref:

```
static void ConditionalRefExample()
{
  var smallArray = new int[] { 1, 2, 3, 4, 5 };
  var largeArray = new int[] { 10, 20, 30, 40, 50 };

  int index = 7;
  ref int refValue = ref ((index < 5)
    ? ref smallArray[index]
    : ref largeArray[index - 5]);
  refValue = 0;

  index = 2;
  ((index < 5)
    ? ref smallArray[index]
    : ref largeArray[index - 5]) = 100;

  Console.WriteLine(string.Join(" ", smallArray));
  Console.WriteLine(string.Join(" ", largeArray));
}

```

如果你不熟悉关键字`ref`，在这一点上不要太担心，因为它将在下一章中深入讨论。总而言之，第一个例子返回一个引用到用条件检查的数组位置，并将变量`refValue`赋给这个引用。从概念上来说，可以把引用看作是指向数组中位置的指针，而不是数组位置的实际值。这允许通过改变分配给变量的值来直接改变该位置的数组值。将`refValue`变量的值设置为零的结果会将第二个数组的值更改为 10，20， **0** ，40，50。第二个示例将第一个数组的第二个值更新为 100，得到 1，2， **100** ，4，5。

### 使用逻辑运算符

一个`if`语句也可以由复杂的表达式组成，并且可以包含`else`语句来执行更复杂的测试。语法与 C(和 C++)和 Java 相同。为了构建复杂的表达式，C#提供了一组预期的逻辑运算符，如表 [3-10](#Tab10) 所示。

表 3-10。

C#逻辑运算符

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

操作员

 | 

例子

 | 

生命的意义

 |
| --- | --- | --- |
| `&&` | `if(age == 30 && name == "Fred")` | 和运算符。如果所有表达式都为真，则返回`true`。 |
| `&#124;&#124;` | `if(age == 30 &#124;&#124; name == "Fred")` | 或操作员。如果至少有一个表达式为真，则返回`true`。 |
| `!` | `if(!myBool)` | 不是操作员。如果为假，则返回`true`，如果为真，则返回`false`。 |

Note

必要时，`&&`和`||`操作器都“短路”。这意味着在一个复杂表达式被确定为假之后，剩余的子表达式将不会被检查。如果你需要测试所有的表达式，你可以使用相关的`&`和`|`操作符。

### 使用 switch 语句

C#提供的另一个简单的选择结构是`switch`语句。与其他基于 C 的语言一样，`switch`语句允许您基于一组预定义的选项来处理程序流。例如，下面的逻辑基于两个可能的选择之一打印一个特定的字符串消息(T2 案例处理一个无效的选择):

```
// Switch on a numerical value.
static void SwitchExample()
{
  Console.WriteLine("1 [C#], 2 [VB]");
  Console.Write("Please pick your language preference: ");

  string langChoice = Console.ReadLine();
  int n = int.Parse(langChoice);

  switch (n)
  {
    case 1:
      Console.WriteLine("Good choice, C# is a fine language.");
      break;
    case 2:
      Console.WriteLine("VB: OOP, multithreading, and more!");
      break;
    default:
      Console.WriteLine("Well...good luck with that!");
      break;
  }
}

```

Note

C#要求每个包含可执行语句的 case(包括`default`)都有一个终止`return`、`break`或`goto`，以避免陷入下一个语句。

C# `switch`语句的一个很好的特性是，除了数值数据之外，您还可以计算`string`数据。事实上，所有版本的 C#都可以评估`char`、`string`、`bool`、`int`、`long`、`enum`数据类型。正如您将在下一节看到的，C# 7 增加了额外的功能。下面是更新后的`switch`语句，它计算一个字符串变量:

```
static void SwitchOnStringExample()
{
  Console.WriteLine("C# or VB");
  Console.Write("Please pick your language preference: ");

  string langChoice = Console.ReadLine();
  switch (langChoice.ToUpper())
  {
    case "C#":
      Console.WriteLine("Good choice, C# is a fine language.");
      break;
    case "VB":
      Console.WriteLine("VB: OOP, multithreading and more!");
      break;
    default:
      Console.WriteLine("Well...good luck with that!");
      break;
  }
}

```

也可以打开枚举数据类型。正如你将在第 4 章[中看到的，C# `enum`关键字允许你定义一组定制的名称-值对。为了激起您的兴趣，考虑下面的最后一个助手函数，它在`System.DayOfWeek enum`上执行一个`switch`测试。您会注意到一些我还没有检查的语法，但是重点是切换到`enum`本身的问题；缺失的部分将在后面的章节中补上。](04.html)

```
static void SwitchOnEnumExample()
{
  Console.Write("Enter your favorite day of the week: ");
  DayOfWeek favDay;
  try
  {
    favDay = (DayOfWeek) Enum.Parse(typeof(DayOfWeek), Console.ReadLine());
  }
  catch (Exception)
  {
    Console.WriteLine("Bad input!");
    return;
  }
  switch (favDay)
  {
    case DayOfWeek.Sunday:
      Console.WriteLine("Football!!");
      break;
    case DayOfWeek.Monday:
      Console.WriteLine("Another day, another dollar");
      break;
    case DayOfWeek.Tuesday:
      Console.WriteLine("At least it is not Monday");
      break;
    case DayOfWeek.Wednesday:
      Console.WriteLine("A fine day.");
      break;
    case DayOfWeek.Thursday:
      Console.WriteLine("Almost Friday...");
      break;
    case DayOfWeek.Friday:
      Console.WriteLine("Yes, Friday rules!");
      break;
    case DayOfWeek.Saturday:
      Console.WriteLine("Great day indeed.");
      break;
  }
  Console.WriteLine();
}

```

不允许从一个`case`语句跳到另一个`case`语句，但是如果多个`case`语句产生相同的结果呢？幸运的是，它们可以组合在一起，如下面的代码片段所示:

```
case DayOfWeek.Saturday:
case DayOfWeek.Sunday:
  Console.WriteLine("It’s the weekend!");
  break;

```

如果在`case`语句之间包含任何代码，编译器将抛出一个错误。只要是连续的语句，如前所示，`case`语句可以组合在一起，共享共同的代码。

除了前面代码示例中显示的`return`和`break`语句，`switch`语句还支持使用`goto`来退出`case`条件并执行另一个`case`语句。虽然这是受支持的，但它被普遍认为是一种反模式，并不常用。下面是一个在`switch`块中使用`goto`语句的例子:

```
static void SwitchWithGoto()
{
  var foo = 5;
  switch (foo)
  {
    case 1:
      //do something
      goto case 2;
    case 2:
      //do something else
      break;
    case 3:
      //yet another action
      goto default;
    default:
      //default action
      break;
  }
}

```

### 执行 switch 语句模式匹配(新 7.0，更新 9.0)

在 C# 7 之前，`switch`语句中的匹配表达式仅限于将变量与常量值进行比较，有时也称为*常量模式*。在 C# 7 中，`switch`语句也可以使用*类型模式*，其中`case`语句可以评估被检查变量的*类型*，并且`case`表达式不再局限于常量值。每个`case`语句必须以`return`或`break`结束的规则仍然适用；但是，使用类型模式不支持`goto`语句。

Note

如果您是面向对象编程的新手，这一节可能会有点混乱。当你在类和基类的上下文中重新审视 C# 7 的新模式匹配特性时，这些都会在第 6 章[T2 中出现。现在，只要明白有一种强有力的新方法来编写`switch`语句。](06.html)

添加另一个名为`ExecutePatternMatchingSwitch()`的方法，并添加以下代码:

```
static void ExecutePatternMatchingSwitch()
{
  Console.WriteLine("1 [Integer (5)], 2 [String (\"Hi\")], 3 [Decimal (2.5)]");
  Console.Write("Please choose an option: ");
  string userChoice = Console.ReadLine();
  object choice;
  //This is a standard constant pattern switch statement to set up the example
  switch (userChoice)
  {
    case "1":
      choice = 5;
      break;
    case "2":
      choice = "Hi";
      break;
    case "3":
      choice = 2.5;
      break;
    default:
      choice = 5;
      break;
  }
  //This is new the pattern matching switch statement
  switch (choice)
  {
    case int i:
      Console.WriteLine("Your choice is an integer.");
      break;
    case string s:
      Console.WriteLine("Your choice is a string.");
      break;
    case decimal d:
      Console.WriteLine("Your choice is a decimal.");
      break;
    default:
      Console.WriteLine("Your choice is something else");
      break;
  }
  Console.WriteLine();
}

```

第一个`switch`语句使用了标准的常量模式，它只是用来设置这个(琐碎的)例子。在第二个`switch`语句中，变量被类型化为`object`，并且根据用户的输入，可以被解析为`int`、`string`或`decimal`数据类型。基于变量的*类型*，匹配不同的 case 语句。除了检查数据类型之外，在每个`case`语句中都分配了一个变量(除了`default`的情况)。将代码更新为以下内容，以使用变量中的值:

```
//This is new the pattern matching switch statement
switch (choice)
{
  case int i:
    Console.WriteLine("Your choice is an integer {0}.",i);
    break;
  case string s:
    Console.WriteLine("Your choice is a string. {0}", s);
    break;
  case decimal d:
    Console.WriteLine("Your choice is a decimal. {0}", d);
    break;
  default:
    Console.WriteLine("Your choice is something else");
    break;
}

```

除了评估匹配表达式的类型之外，`when`子句可以添加到`case`语句中，以评估变量的条件。在此示例中，除了检查类型之外，还会检查转换类型的值是否匹配:

```
static void ExecutePatternMatchingSwitchWithWhen()
{
  Console.WriteLine("1 [C#], 2 [VB]");
  Console.Write("Please pick your language preference: ");

  object langChoice = Console.ReadLine();
  var choice = int.TryParse(langChoice.ToString(), out int c) ? c : langChoice;

  switch (choice)
  {
    case int i when i == 2:
    case string s when s.Equals("VB", StringComparison.OrdinalIgnoreCase):
      Console.WriteLine("VB: OOP, multithreading, and more!");
      break;
    case int i when i == 1:
    case string s when s.Equals("C#", StringComparison.OrdinalIgnoreCase):
      Console.WriteLine("Good choice, C# is a fine language.");
      break;
    default:
      Console.WriteLine("Well...good luck with that!");
      break;
  }
  Console.WriteLine();
}

```

这给`switch`语句增加了一个新的维度，因为`case`语句的顺序现在很重要。对于固定模式，每个`case`语句都必须是唯一的。有了类型模式，就不再是这种情况了。例如，下面的代码将匹配第一个 case 语句中的每个整数，并且永远不会执行第二个或第三个(实际上，下面的代码将无法编译):

```
switch (choice)
{
  case int i:
    //do something
    break;
  case int i when i == 0:
    //do something
    break;
  case int i when i == -1:
    // do something
    break;
}

```

在 C# 7 的最初版本中，当使用泛型类型时，模式匹配有一个小问题。C# 7.1 已经解决了这个问题。通用类型将在第 [10 章](10.html)中介绍。

Note

之前演示的 C# 9.0 中的所有模式匹配改进也可用于 switch 语句中。

### 使用开关表达式(新 8.0)

C# 8 中的新特性是`switch`表达式，允许在简洁的语句中给变量赋值。考虑这个方法的 C# 7 版本，它接受一种颜色并返回颜色名称的十六进制值:

```
static string FromRainbowClassic(string colorBand)
{
  switch (colorBand)
  {
    case "Red":
      return "#FF0000";
    case "Orange":
      return "#FF7F00";
    case "Yellow":
      return "#FFFF00";
    case "Green":
      return "#00FF00";
    case "Blue":
      return "#0000FF";
    case "Indigo":
      return "#4B0082";
    case "Violet":
      return "#9400D3";
    default:
      return "#FFFFFF";
  };
}

```

有了 C# 8 中的新开关表达式，以前的方法可以写成如下形式，这要简洁得多:

```
static string FromRainbow(string colorBand)
{
  return colorBand switch
  {
    "Red" => "#FF0000",
    "Orange" => "#FF7F00",
    "Yellow" => "#FFFF00",
    "Green" => "#00FF00",
    "Blue" => "#0000FF",
    "Indigo" => "#4B0082",
    "Violet" => "#9400D3",
    _ => "#FFFFFF",
  };
}

```

在这个例子中，有很多东西需要解开，从 lambda ( `=>`)语句到 discard ( `_`)。这些都将在后面的章节中讨论，这个例子将会更详细。

在结束 switch 表达式的主题之前，还有一个例子，它涉及到元组。元组在第 4 章[中有详细介绍，所以现在把元组想象成一个简单的结构，它保存多个值并用括号定义，就像这个保存一个`string`和一个`int`的元组:](04.html)

```
(string, int)

```

在下面的示例中，传递到`RockPaperScissors`方法中的两个值被转换为一个元组，然后 switch 表达式在单个表达式中计算这两个值。这种模式允许在一个`switch`语句中比较多个值。

```
//Switch expression with Tuples
static string RockPaperScissors(string first, string second)
{
  return (first, second) switch
  {
    ("rock", "paper") => "Paper wins.",
    ("rock", "scissors") => "Rock wins.",
    ("paper", "rock") => "Paper wins.",
    ("paper", "scissors") => "Scissors wins.",
    ("scissors", "rock") => "Rock wins.",
    ("scissors", "paper") => "Scissors wins.",
    (_, _) => "Tie.",
  };
}

```

要调用这个方法，将下面几行代码添加到`Main()`方法中:

```
Console.WriteLine(RockPaperScissors("paper","rock"));
Console.WriteLine(RockPaperScissors("scissors","rock"));

```

当引入元组时，将在第 [4](04.html) 章中再次讨论这个例子。

## 摘要

本章的目标是向你展示 C#编程语言的许多核心方面。您研究了您可能有兴趣构建的任何应用程序中的常见结构。在研究了 application 对象的角色之后，您了解到每个 C#可执行程序都必须有一个定义`Main()`方法的类型，要么显式定义，要么通过使用顶级语句来定义。这个方法作为程序的入口点。

接下来，您深入研究了 C#内置数据类型的细节，并开始理解每个数据类型关键字(例如，`int`)实际上是在`System`名称空间中成熟类型的简写符号(在本例中是`System.Int32`)。鉴于此，每种 C#数据类型都有许多内置成员。同样，您还了解了*扩大*和*缩小*的作用，以及`checked`和`unchecked`关键字的作用。

本章最后介绍了使用`var`关键字的隐式类型的作用。如前所述，隐式类型最有用的地方是在使用 LINQ 编程模型时。最后，您快速检查了 C#支持的各种迭代和决策结构。

现在你已经理解了一些基本的细节，下一章(第[章和第](04.html)章)将会完成你对核心语言特性的研究。之后，你将为从第 5 章[开始研究 C#的面向对象特性做好充分准备。](05.html)