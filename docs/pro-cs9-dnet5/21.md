# 二十一、ADO.NET 的数据访问

那个。NET Core platform 定义了几个名称空间，允许您与关系数据库系统进行交互。总的来说，这些名称空间被称为 ADO.NET。在这一章中，您将了解 about 的整体作用以及核心类型和名称空间，然后您将继续讨论 about 数据提供者的主题。那个。NET 核心平台支持许多数据提供者(都是作为。NET 核心框架并可从第三方来源获得)，其中每一个都被优化以与特定的数据库管理系统(例如，Microsoft SQL Server、Oracle 和 MySQL)通信。

在理解了各种数据提供者提供的通用功能之后，您将会看到数据提供者工厂模式。正如您将看到的，使用`System.Data`名称空间中的类型(包括`System.Data.Common`和特定于提供者的名称空间，如`Microsoft.Data.SqlClient`、`System.Data.Odbc`，以及仅用于 Windows 的`System.Data.Oledb`)，您可以构建一个单一的代码库，该代码库可以动态地挑选底层数据提供者，而无需重新编译或重新部署应用的代码库。

接下来，您将学习如何直接使用 SQL Server 数据库提供程序，创建和打开连接以检索数据，然后继续插入、更新和删除数据，最后研究数据库事务主题。最后，您将使用 ADO.NET 执行 SQL Server 的批量复制功能，将记录列表加载到数据库中。

Note

这一章主要讲述未加工的 ADO.NET。从第 22 章开始，我将介绍实体框架(EF)核心，微软的对象关系映射(ORM)框架。由于实体框架核心使用 ADO.NET 进行后台数据访问，因此在排除数据访问故障时，对 ADO.NET 工作方式的深入了解至关重要。还有一些场景是 EF Core 无法解决的(比如执行 SQL 批量复制)，你需要了解 ADO.NET 来解决这些问题。

## ADO.NET 对阿多

如果您有 Microsoft 以前基于 COM 的数据访问模型(活动数据对象[ADO])的背景，并且刚刚开始使用。NET 核心平台，你需要明白 ADO.NET 除了字母 *A* 、 *D* 、 *O* 之外和 ADO 关系不大。虽然这两个系统之间确实存在一些关系(例如，每个系统都有连接和命令对象的概念)，但是一些熟悉的 ADO 类型(例如，`Recordset`)已经不存在了。此外，您可以找到许多在传统 ADO 下没有直接对等物的新类型(例如，数据适配器)。

## 了解 ADO.NET 数据提供者

ADO.NET 不提供与多个数据库管理系统(DBMSs)通信的单一对象集。相反，ADO.NET 支持多个*数据提供者*，其中每一个都被优化为与特定的 DBMS 交互。这种方法的第一个好处是，您可以对特定的数据提供程序进行编程，以访问特定 DBMS 的任何独特功能。第二个好处是，特定的数据提供者可以直接连接到所讨论的 DBMS 的底层引擎，而无需在各层之间设置中间映射层。

简单地说，数据提供者是在给定的名称空间中定义的一组类型，它们知道如何与特定类型的数据源进行通信。无论您使用哪种数据提供程序，都定义了一组提供核心功能的类类型。表 [21-1](#Tab1) 记录了一些核心基类和它们实现的关键接口。

表 21-1。

ADO.NET 数据提供者的核心对象

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

基础类

 | 

相关接口

 | 

生命的意义

 |
| --- | --- | --- |
| `DbConnection` | `IDbConnection` | 提供连接到数据存储和从数据存储断开连接的能力。连接对象还提供对相关事务对象的访问。 |
| `DbCommand` | `IDbCommand` | 表示 SQL 查询或存储过程。命令对象还提供对提供程序的数据读取器对象的访问。 |
| `DbDataReader` | `IDataReader`，`IDataRecord` | 使用服务器端游标提供对数据的只进、只读访问。 |
| `DbDataAdapter` | `IDataAdapter`，`IDbDataAdapter` | 在调用者和数据存储器之间传输。数据适配器包含一个连接和一组四个内部命令对象，用于从数据存储中选择、插入、更新和删除信息。 |
| `DbParameter` | `IDataParameter`，`IDbDataParameter` | 表示参数化查询中的命名参数。 |
| `DbTransaction` | `IDbTransaction` | 封装数据库事务。 |

尽管这些核心类的具体名称在数据提供者之间会有所不同(例如，`SqlConnection`与`OdbcConnection`)，但是每个类都是从实现相同接口(例如，`IDbConnection`)的同一个基类(在连接对象的情况下是`DbConnection`)中派生出来的。考虑到这一点，您可以正确地假设，在您学会如何使用一个数据提供者之后，其余的提供者都很简单。

Note

当您引用 ADO.NET 下的一个连接对象时，您实际上是在引用一个特定的`DbConnection`派生类型；没有一个类字面上叫做*连接*。同样的想法也适用于*命令对象*、*数据适配器对象*，等等。作为命名约定，特定数据提供者中的对象以相关 DBMS 的名称为前缀(例如，`SqlConnection`、`SqlCommand`和`SqlDataReader`)。

图 [21-1](#Fig1) 展示了 ADO.NET 数据提供商背后的大图景。客户端程序集可以是任何类型的。NET 核心应用:控制台程序，Windows 窗体，WPF，ASP.NET 核心。NET 核心代码库等等。

![img/340876_10_En_21_Chapter/340876_10_En_21_Fig1_HTML.jpg](img/340876_10_En_21_Chapter/340876_10_En_21_Fig1_HTML.jpg)

图 21-1。

ADO.NET 数据提供程序提供对给定 DBMS 的访问

除了图 [21-1](#Fig1) 所示的对象之外，数据提供者将为您提供其他类型；然而，这些核心对象定义了所有数据提供者的公共基线。

### ADO.NET 数据提供商

和所有的一样。NET 核心，数据提供者作为 NuGet 包提供。微软和许多第三方提供商都支持这几种软件。表 [21-2](#Tab2) 记录了微软支持的一些数据提供者。

表 21-2。

一些微软支持的数据提供者

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

数据提供者

 | 

namespace/nu 获取包名

 |
| --- | --- |
| 搜寻配置不当的 | `Microsoft.Data.SqlClient` |
| 开放式数据库连接性 | `System.Data.Odbc` |
| OLE DB(仅适用于 Windows) | `System.Data.OleDb` |

微软 SQL Server 数据提供者提供对微软 SQL Server 数据存储的直接访问——并且仅*提供对* SQL Server 数据存储(包括 SQL Azure)的直接访问。`Microsoft.Data.SqlClient`名称空间包含 SQL Server 提供程序使用的类型。

Note

虽然仍然支持`System.Data.SqlClient`，但是与 SQL Server(和 SQL Azure)交互的所有开发工作都集中在新的`Microsoft.Data.SqlClient`提供者库上。

ODBC 提供者(`System.Data.Odbc`)提供对 ODBC 连接的访问。在`System.Data.Odbc`名称空间中定义的 ODBC 类型通常只有在您需要与没有自定义的给定 DBMS 通信时才有用。NET 核心数据提供者。这是真的，因为 ODBC 是一种广泛使用的模型，它提供了对多个数据存储的访问。

OLE DB 数据提供程序由在`System.Data.OleDb`命名空间中定义的类型组成，它允许您访问位于任何支持传统的基于 COM 的 OLE DB 协议的数据存储中的数据。由于对 COM 的依赖，此提供程序只能在 Windows 操作系统上工作，在的跨平台环境中应被视为不推荐使用。NET 核心。

## 系统的类型。数据命名空间

在所有的 ADO.NET 名称空间中，`System.Data`是最小的公分母。此命名空间包含所有 among 数据提供程序共享的类型，而不考虑基础数据存储。除了许多以数据库为中心的异常(例如，`NoNullAllowedException`、`RowNotInTableException`和`MissingPrimaryKeyException`)，`System.Data`包含表示各种数据库原语(例如，表、行、列和约束)的类型，以及由数据提供者对象实现的公共接口。表 [21-3](#Tab3) 列出了一些你应该知道的核心类型。

表 21-3。

`System.Data`名称空间的核心成员

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

类型

 | 

生命的意义

 |
| --- | --- |
| `Constraint` | 代表给定`DataColumn`对象的约束 |
| `DataColumn` | 表示一个`DataTable`对象中的一列 |
| `DataRelation` | 表示两个`DataTable`对象之间的父子关系 |
| `DataRow` | 代表一个`DataTable`对象中的一行 |
| `DataSet` | 表示由任意数量的相关`DataTable`对象组成的数据的内存缓存 |
| `DataTable` | 表示内存中数据的表格块 |
| `DataTableReader` | 允许您将`DataTable`视为消防水龙带光标(只进、只读数据访问) |
| `DataView` | 表示用于排序、过滤、搜索、编辑和导航的`DataTable`的定制视图 |
| `IDataAdapter` | 定义数据适配器对象的核心行为 |
| `IDataParameter` | 定义参数对象的核心行为 |
| `IDataReader` | 定义数据读取器对象的核心行为 |
| `IDbCommand` | 定义命令对象的核心行为 |
| `IDbDataAdapter` | 扩展`IDataAdapter`以提供数据适配器对象的附加功能 |
| `IDbTransaction` | 定义事务对象的核心行为 |

你的下一个任务是在高层次上检查`System.Data`的核心接口；这可以帮助您理解任何数据提供者提供的通用功能。在本章中，您还将了解具体的细节；然而，现在最好关注每种接口类型的整体行为。

### IDbConnection 接口的作用

`IDbConnection`类型由数据提供者的*连接对象*实现。此接口定义了一组用于配置到特定数据存储的连接的成员。它还允许您获取数据提供者的事务对象。下面是`IDbConnection`的正式定义:

```cs
public interface IDbConnection : IDisposable
{
  string ConnectionString { get; set; }
  int ConnectionTimeout { get; }
  string Database { get; }
  ConnectionState State { get; }

  IDbTransaction BeginTransaction();
  IDbTransaction BeginTransaction(IsolationLevel il);
  void ChangeDatabase(string databaseName);
  void Close();
  IDbCommand CreateCommand();
  void Open();
  void Dispose();
}

```

### IDbTransaction 接口的作用

由`IDbConnection`定义的重载`BeginTransaction()`方法提供了对提供者的*事务对象*的访问。您可以使用由`IDbTransaction`定义的成员以编程方式与事务性会话和底层数据存储进行交互。

```cs
public interface IDbTransaction : IDisposable
{
  IDbConnection Connection { get; }
  IsolationLevel IsolationLevel { get; }

  void Commit();
  void Rollback();
  void Dispose();
}

```

### IDbCommand 接口的作用

接下来是`IDbCommand`接口，它将由数据提供者的*命令对象*实现。与其他数据访问对象模型一样，命令对象允许对 SQL 语句、存储过程和参数化查询进行编程操作。命令对象还通过重载的`ExecuteReader()`方法提供对数据提供者的数据读取器类型的访问。

```cs
public interface IDbCommand : IDisposable
{
  string CommandText { get; set; }
  int CommandTimeout { get; set; }
  CommandType CommandType { get; set; }
  IDbConnection Connection { get; set; }
  IDbTransaction Transaction { get; set; }
  IDataParameterCollection Parameters { get; }
  UpdateRowSource UpdatedRowSource { get; set; }

  void Prepare();
  void Cancel();
  IDbDataParameter CreateParameter();
  int ExecuteNonQuery();
  IDataReader ExecuteReader();
  IDataReader ExecuteReader(CommandBehavior behavior);
  object ExecuteScalar();
  void Dispose();
}

```

### IDbDataParameter 和 IDataParameter 接口的作用

注意，`IDbCommand`的`Parameters`属性返回一个实现了`IDataParameterCollection`的强类型集合。该接口提供对一组符合`IDbDataParameter`的类类型(例如，参数对象)的访问。

```cs
public interface IDbDataParameter : IDataParameter
{
//Plus members in the IDataParameter interface
  byte Precision { get; set; }
  byte Scale { get; set; }
  int Size { get; set; }
}

```

`IDbDataParameter`扩展`IDataParameter`接口以获得以下附加行为:

```cs
public interface IDataParameter
{
  DbType DbType { get; set; }
  ParameterDirection Direction { get; set; }
  bool IsNullable { get; }
  string ParameterName { get; set; }
  string SourceColumn { get; set; }
  DataRowVersion SourceVersion { get; set; }
  object Value { get; set; }
}

```

正如您将看到的，`IDbDataParameter`和`IDataParameter`接口的功能允许您通过特定的 ADO.NET 参数对象来表示 SQL 命令(包括存储过程)中的参数，而不是通过硬编码的字符串文字。

### IDbDataAdapter 和 IDataAdapter 接口的作用

您使用*数据适配器*将`DataSet`推送到给定的数据存储，或者从给定的数据存储中拉出。`IDbDataAdapter`接口定义了以下一组属性，您可以使用这些属性来维护相关选择、插入、更新和删除操作的 SQL 语句:

```cs
public interface IDbDataAdapter : IDataAdapter
{
  //Plus members of IDataAdapter
  IDbCommand SelectCommand { get; set; }
  IDbCommand InsertCommand { get; set; }
  IDbCommand UpdateCommand { get; set; }
  IDbCommand DeleteCommand { get; set; }
}

```

除了这四个属性之外，ADO.NET 数据适配器还会选择基本接口`IDataAdapter`中定义的行为。这个接口定义了数据适配器类型的关键功能:使用`Fill()`和`Update()`方法在调用者和底层数据存储之间传输`DataSet`的能力。`IDataAdapter`接口还允许您使用`TableMappings`属性将数据库列名映射到更加用户友好的显示名称。

```cs
public interface IDataAdapter
{
  MissingMappingAction MissingMappingAction { get; set; }
  MissingSchemaAction MissingSchemaAction { get; set; }
  ITableMappingCollection TableMappings { get; }

  DataTable[] FillSchema(DataSet dataSet, SchemaType schemaType);
  int Fill(DataSet dataSet);
  IDataParameter[] GetFillParameters();
  int Update(DataSet dataSet);
}

```

### IDataReader 和 IDataRecord 接口的作用

下一个需要注意的关键接口是`IDataReader`，它表示给定数据读取器对象支持的常见行为。当您从 ADO.NET 数据提供者那里获得一个与`IDataReader`兼容的类型时，您可以以只进、只读的方式迭代结果集。

```cs
public interface IDataReader : IDisposable, IDataRecord
{
  //Plus members from IDataRecord
  int Depth { get; }
  bool IsClosed { get; }
  int RecordsAffected { get; }

  void Close();
  DataTable GetSchemaTable();
  bool NextResult();
  bool Read();
  Dispose();
}

```

最后，`IDataReader`扩展了`IDataRecord`，它定义了许多成员，允许您从流中提取强类型值，而不是强制转换从数据读取器的重载索引器方法中检索的通用`System.Object`。下面是`IDataRecord interface`的定义:

```cs
public interface IDataRecord
{
  int FieldCount { get; }
  object this[ int i ] { get; }
  object this[ string name ] { get; }
  bool GetBoolean(int i);
  byte GetByte(int i);
  long GetBytes(int i, long fieldOffset, byte[] buffer,
    int bufferoffset, int length);
  char GetChar(int i);
  long GetChars(int i, long fieldoffset, char[] buffer,
    int bufferoffset, int length);
  IDataReader GetData(int i);
  string GetDataTypeName(int i);
  DateTime GetDateTime(int i);
  Decimal GetDecimal(int i);
  double GetDouble(int i);
  Type GetFieldType(int i);
  float GetFloat(int i);
  Guid GetGuid(int i);
  short GetInt16(int i);
  int GetInt32(int i);
  long GetInt64(int i);
  string GetName(int i);
  int GetOrdinal(string name);
  string GetString(int i);
  object GetValue(int i);
  int GetValues(object[] values);
  bool IsDBNull(int i);
}

```

Note

在尝试从数据读取器获取值之前，可以使用`IDataReader.IsDBNull()`方法以编程方式发现指定的字段是否设置为`null`(以避免触发运行时异常)。还记得 C#支持可空数据类型(参见第 4 章[的](04.html)，这是与数据库表中可能是`null`的数据列交互的理想选择。

## 使用接口抽象数据提供者

至此，您应该对所有这些工具的共同功能有了更好的了解。NET 核心数据提供者。回想一下，尽管实现类型的确切名称在不同的数据提供者之间会有所不同，但是您可以以类似的方式针对这些类型进行编程——这就是基于接口的多态性的美妙之处。例如，如果您定义一个采用`IDbConnection`参数的方法，您可以传入任何 ADO.NET 连接对象，如下所示:

```cs
public static void OpenConnection(IDbConnection cn)
{
  // Open the incoming connection for the caller.
  connection.Open();
}

```

Note

接口不是严格要求的；使用抽象基类(如`DbConnection`)作为参数或返回值，可以达到相同的抽象级别。然而，使用接口而不是基类是普遍接受的最佳实践。

这同样适用于成员返回值。创建新的。NET 核心控制台应用名为 MyConnectionFactory。将以下 NuGet 包添加到项目中(`OleDb`包仅在 Windows 上有效):

*   `Microsoft.Data.SqlClient`

*   `System.Data.Common`

*   `System.Data.Odbc`

*   `System.Data.OleDb`

接下来，添加一个名为`DataProviderEnum.cs`的新文件，并将代码更新如下:

```cs
namespace MyConnectionFactory
{
  //OleDb is Windows only and is not supported in .NET Core
  enum DataProviderEnum
  {
    SqlServer,
#if PC
    OleDb,
#endif
    Odbc,
    None
  }
}

```

如果您在开发机器上使用 Windows 操作系统，请更新项目文件以定义条件编译器符号`PC`。

```cs
<PropertyGroup>
  <DefineConstants>PC</DefineConstants>
</PropertyGroup>

```

如果您使用的是 Visual Studio，请右击项目，选择“属性”,然后转到“生成”选项卡，输入“条件编译器符号”值。

下面的代码示例允许您基于自定义枚举的值获取特定的连接对象。出于诊断目的，您只需使用反射服务打印底层连接对象。

```cs
using System;
using System.Data;
using System.Data.Odbc;
#if PC
  using System.Data.OleDb;
#endif
using Microsoft.Data.SqlClient;
using MyConnectionFactory;

Console.WriteLine("**** Very Simple Connection Factory *****\n");
Setup(DataProviderEnum.SqlServer);
#if PC
  Setup(DataProviderEnum.OleDb); //Not supported on macOS
#endif
Setup(DataProviderEnum.Odbc);
Setup(DataProviderEnum.None);
Console.ReadLine();

void Setup(DataProviderEnum provider)
{
  // Get a specific connection.
  IDbConnection myConnection = GetConnection(provider);
  Console.WriteLine($"Your connection is a {myConnection?.GetType().Name ?? "unrecognized type"}");
  // Open, use and close connection...
}

// This method returns a specific connection object
// based on the value of a DataProvider enum.
IDbConnection GetConnection(DataProviderEnum dataProvider)
  => dataProvider switch
  {
    DataProviderEnum.SqlServer => new SqlConnection(),
#if PC
    //Not supported on macOS
    DataProviderEnum.OleDb => new OleDbConnection(),
#endif
    DataProviderEnum.Odbc => new OdbcConnection(),
    _ => null,
  };

```

使用`System.Data`的通用接口(或者，就此而言，`System.Data.Common`的抽象基类)的好处是，您有更好的机会构建一个灵活的代码库，可以随着时间的推移而发展。例如，今天您可能正在构建一个面向 Microsoft SQL Server 的应用；但是，您的公司可能会切换到不同的数据库。如果您构建的解决方案对特定于 Microsoft SQL Server 的`System.Data.SqlClient`类型进行了硬编码，那么您将需要为新的数据库提供者编辑、重新编译和重新部署代码。

至此，您已经编写了一些(相当简单的)point 代码，允许您创建不同类型的特定于提供者的连接对象。然而，获得连接对象只是使用 ADO.NET 的一个方面。要创建一个有价值的数据提供者工厂库，您还必须考虑命令对象、数据读取器、事务对象和其他以数据为中心的类型。构建这样一个代码库并不困难，但是需要大量的代码和时间。

自从发布以来。在. NET 2.0 中，Redmond 的好心人已经将这种精确的功能直接构建到。NET 基础类库。此功能已针对进行了重大更新。NET 核心。

一会儿您将检查这个正式的 API 但是，首先您需要创建一个自定义数据库，以便在本章(以及后面的许多章节)中使用。

## 设置 SQL Server 和 Azure Data Studio

在学习本章的过程中，您将对一个名为`AutoLot`的简单 SQL Server 测试数据库执行查询。为了与本书通篇使用的汽车主题保持一致，该数据库将包含五个相互关联的表(`Inventory`、`Makes`、`Orders`、`Customers`和`CreditRisks`)，这些表包含代表一家虚构的汽车销售公司的信息的各种数据。在了解数据库详细信息之前，您必须设置 SQL Server 和 SQL Server IDE。

Note

如果您使用的是基于 Windows 的开发机器，并且安装了 Visual Studio 2019，那么您还安装了 SQL Server Express 的一个实例(名为`localdb`)，它可以用于本书中的所有示例。如果您愿意使用该版本，请跳到“安装 SQL Server IDE”一节

### 正在安装 SQL Server

对于本章以及本书中的许多剩余章节，您需要能够访问 SQL Server 的实例。如果您使用的是非基于 Windows 的开发机器，并且没有可用的外部 SQL Server 实例，或者选择不使用外部 SQL Server 实例，则可以在基于 Mac 或 Linux 的工作站上的 Docker 容器中运行 SQL Server。Docker 也可以在 Windows 机器上运行，所以不管你选择什么操作系统，都欢迎你使用 Docker 来运行本书中的例子。

#### 在 Docker 容器中安装 SQL Server

如果您使用的是非基于 Windows 的开发计算机，并且没有可用于示例的 SQL Server 实例，则可以在基于 Mac 或 Linux 的工作站上的 Docker 容器中运行 SQL Server。Docker 也可以在 Windows 机器上运行，所以不管你选择什么操作系统，都欢迎你使用 Docker 来运行本书中的例子。

Note

集装箱化是一个很大的话题，在这本书里没有足够的空间来深入探讨集装箱或码头的细节。这本书将涵盖足够的内容，因此你可以通过例子。

Docker 桌面可以从 [`www.docker.com/get-started`](http://www.docker.com/get-started) 下载。为您的工作站下载并安装合适的版本(Windows、Mac、Linux)(您需要一个免费的 DockerHub 用户帐户)。确保在出现提示时选择 Linux 容器。

Note

容器选择(Windows 或 Linux)是在容器内运行的操作系统，而不是您工作站的操作系统。

##### 提取映像并运行 SQL Server 2019

容器基于图像，每个图像都是构建最终产品的分层集合。要在容器中获取运行 SQL Server 2019 所需的映像，请打开命令窗口并输入以下命令:

```cs
docker pull mcr.microsoft.com/mssql/server:2019-latest

```

一旦将映像加载到机器上，就需要启动 SQL Server。为此，请输入以下命令(全部在一行中):

```cs
docker run -e "ACCEPT_EULA=Y" -e "SA_PASSWORD=P@ssw0rd" -p 5433:1433 --name AutoLot -d mcr.microsoft.com/mssql/server:2019-latest

```

前面的命令接受最终用户许可协议，设置密码(在现实生活中，您需要使用强密码)，设置端口映射(您机器上的端口 5433 映射到容器中 SQL Server 的默认端口(1433)，然后命名容器(AutoLot)，最后通知 Docker 使用之前下载的映像。

Note

这些不是您想要在实际开发中使用的设置。有关更改 SA 密码的信息以及查看教程，请转至 [`https://docs.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker?view=sql-server-ver15&pivots=cs1-bash`](https://docs.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker%253Fview%253Dsql-server-ver15%2526pivots%253Dcs1-bash) 。

要确认它正在运行，请在命令提示符下输入命令`docker ps -a`。您将看到如下所示的输出(为简洁起见，省略了一些列):

```cs
C:\Users\japik>docker ps -a
CONTAINER ID IMAGE                                     STATUS         PORTS          NAMES
347475cfb823 mcr.microsoft.com/mssql/server:2019-latest Up 6 minutes 0.0.0.0:5433->1433/tcp   AutoLot

```

要停止集装箱，输入`docker stop 34747`，其中数字 34747 是集装箱 ID 的前五个字符。要重启容器，输入`docker start 34747`，再次用容器 ID 的开头更新命令。

Note

您还可以在 Docker CLI 命令中使用容器的名称(本例中为`AutoLot`)，例如`docker start AutoLot`。请注意，无论操作系统如何，Docker 命令都是区分大小写的。

如果您想使用 Docker Dashboard，右键单击 Docker ship(在您的系统托盘中)并选择 Dashboard，您应该会看到在端口 5433 上运行的图像。将鼠标悬停在图像名称上，您将看到停止、启动和删除命令(以及其他命令)，如图 [21-2](#Fig2) 所示。

![img/340876_10_En_21_Chapter/340876_10_En_21_Fig2_HTML.jpg](img/340876_10_En_21_Chapter/340876_10_En_21_Fig2_HTML.jpg)

图 21-2。

Docker 仪表板

#### 正在安装 SQL Server 2019

SQL Server 的一个特殊实例(名为`(localdb)\mssqllocaldb`)随 Visual Studio 2019 一起安装。如果选择不使用 SQL Server Express LocalDB(或 Docker)，并且使用的是 Windows 机器，则可以安装 SQL Server 2019 Developer Edition。SQL Server 2019 开发者版是免费的，可以从这里下载:

```cs
https://www.microsoft.com/en-us/sql-server/sql-server-downloads

```

如果你有另一个版本，你也可以在这本书上使用那个实例；您只需要适当地更改您的连接屏幕。

### 安装 SQL Server IDE

Azure Data Studio 是一个用于 SQL Server 的新 IDE。它是免费的和跨平台的，所以它可以在 Windows、Mac 或 Linux 上运行。可以从这里下载:

```cs
https://docs.microsoft.com/en-us/sql/azure-data-studio/download-azure-data-studio

```

Note

如果您使用的是 Windows 机器，并且更喜欢使用 SQL Server Management Studio (SSMS)，您可以从这里下载最新版本: [`https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms`](https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms) 。

### 正在连接到 SQL Server

一旦安装了 Azure Data Studio 或 SSMS，就该连接到数据库实例了。以下部分介绍了 Docker 或 LocalDb 容器中 SQL Server 的连接。如果您使用的是 SQL Server 的另一个实例，请相应地更新以下部分中使用的连接字符串。

#### 连接到 Docker 容器中的 SQL Server

要连接到 Docker 容器中运行的 SQL Server 实例，首先要确保它已经启动并正在运行。接下来在 Azure Data Studio 中点击“创建连接”，如图 [21-3](#Fig3) 所示。

![img/340876_10_En_21_Chapter/340876_10_En_21_Fig3_HTML.jpg](img/340876_10_En_21_Chapter/340876_10_En_21_Fig3_HTML.jpg)

图 21-3。

在 Azure Data Studio 中创建连接

在连接细节对话框中，输入**。，5433"** 为服务器值。圆点表示当前主机，5433 是您在 Docker 容器中创建 SQL Server 实例时指定的端口。输入 **sa** 作为用户名；并且密码与您在创建 SQL Server 实例时输入的密码相同。该名称是可选的，但允许您在后续 Azure Data Studio 会话中快速选择此连接。图 [21-4](#Fig4) 显示了这些连接选项。

![img/340876_10_En_21_Chapter/340876_10_En_21_Fig4_HTML.jpg](img/340876_10_En_21_Chapter/340876_10_En_21_Fig4_HTML.jpg)

图 21-4。

为 Docker SQL Server 设置连接选项

#### 正在连接到 SQL Server LocalDb

若要连接到 SQL Server Express LocalDb 的 Visual Studio 安装版本，请更新连接信息以匹配图 [21-5](#Fig5) 中所示的内容。

![img/340876_10_En_21_Chapter/340876_10_En_21_Fig5_HTML.jpg](img/340876_10_En_21_Chapter/340876_10_En_21_Fig5_HTML.jpg)

图 21-5。

为 SQL Server LocalDb 设置连接选项

当连接到 LocalDb 时，您可以使用 Windows 身份验证，因为该实例与 Azure Data Studio 运行在同一台计算机上，并且与当前登录的用户具有相同的安全上下文。

#### 连接到任何其他 SQL Server 实例

如果要连接到任何其他 SQL Server 实例，请相应地更新连接属性。

## 恢复汽车人数据库备份

您可以使用 SSMS 或 Azure Data Studio 来恢复包含在存储库中的章节文件中的备份，而不是从头开始构建数据库。提供了两个备份:名为`AutoLotWindows.ba_`的备份是为在 Windows 机器(LocalDb、Windows Server 等)上使用而设计的。)，名为`AutoLotDocker.ba_`的是为 Docker 容器设计的。

Note

默认情况下，Git 会忽略扩展名为`bak`的文件。在恢复数据库之前，您需要将扩展名从`ba_`重命名为`bak`。

### 将备份文件复制到容器中

如果在 Docker 容器中使用 SQL Server，首先必须将备份文件复制到容器中。幸运的是，Docker CLI 提供了一种处理容器文件系统的机制。首先，在主机上的命令窗口中使用以下命令为备份创建一个新目录:

```cs
docker exec -it AutoLot mkdir var/opt/mssql/backup

```

路径结构必须匹配容器的操作系统(在本例中是 Ubuntu)，即使您的主机是基于 Windows 的。接下来，使用以下命令将备份复制到您的新目录(将`AutoLotDocker.bak`的位置更新到您本地机器的相对或绝对路径):

```cs
[Windows]
docker cp .\AutoLotDocker.bak AutoLot:var/opt/mssql/backup

[Non-Windows]
docker cp ./AutoLotDocker.bak AutoLot:var/opt/mssql/backup

```

注意，源目录结构匹配主机(在我的例子中是 Windows)，而目标是容器名，然后是目录路径(以目标 OS 格式)。

### 使用 SSMS 恢复数据库

若要使用 SSMS 还原数据库，请在对象资源管理器中右键单击“数据库”节点。选择恢复数据库。选择设备并单击省略号。这将打开“选择备份设备”对话框。

#### 将数据库还原到 SQL Server (Docker)

保持“备份媒体类型”设置为文件，然后单击添加，导航到容器中的`AutoLotDocker.bak`文件，并单击确定。当你回到主恢复屏幕时，点击确定，如图 [21-6](#Fig6) 所示。

![img/340876_10_En_21_Chapter/340876_10_En_21_Fig6_HTML.jpg](img/340876_10_En_21_Chapter/340876_10_En_21_Fig6_HTML.jpg)

图 21-6。

使用 SSMS 恢复数据库

#### 将数据库还原到 SQL Server (Windows)

保持“备份媒体类型”设置为文件，然后点击添加，导航至`AutoLotWindows.bak`，并点击确定。当你回到主恢复屏幕时，点击确定，如图 [21-7](#Fig7) 所示。

![img/340876_10_En_21_Chapter/340876_10_En_21_Fig7_HTML.jpg](img/340876_10_En_21_Chapter/340876_10_En_21_Fig7_HTML.jpg)

图 21-7。

使用 SSMS 恢复数据库

### 使用 Azure Data Studio 恢复数据库

要使用 Azure Data Studio 恢复数据库，请单击查看，选择命令面板(或按 Ctrl+Shift+P)，然后选择恢复。选择“备份文件”作为“恢复自”选项，然后选择您刚刚复制的文件。目标数据库和相关字段将为您填充，如图 [21-8](#Fig8) 所示。

![img/340876_10_En_21_Chapter/340876_10_En_21_Fig8_HTML.jpg](img/340876_10_En_21_Chapter/340876_10_En_21_Fig8_HTML.jpg)

图 21-8。

使用 Azure Data Studio 将数据库恢复到 Docker

Note

使用 Azure Data Studio 恢复 Windows 版本备份的过程是相同的。只需调整文件名和路径。

## 创建汽车人数据库

这一整节致力于使用 Azure Data Studio 创建`AutoLot`数据库。如果您正在使用 SSMS，您可以使用这里讨论的 SQL 脚本或者使用 GUI 工具来执行这些步骤。如果您恢复了备份，可以跳到“ADO.NET 数据提供者工厂模型”一节

Note

所有的脚本文件都位于 Git 存储库中的一个名为`Scripts`的文件夹中。

### 创建数据库

要创建`AutoLot`数据库，使用 Azure Data Studio 连接到您的数据库服务器。通过选择文件➤新查询(或按 Ctrl+N)并输入以下命令文本来打开新查询:

```cs
USE [master]
GO
/****** Object:  Database [AutoLot50]    Script Date: 12/20/2020 01:48:05 ******/
CREATE DATABASE [AutoLot]
GO
ALTER DATABASE [AutoLot50] SET RECOVERY SIMPLE
GO

```

除了将恢复模式更改为 simple 之外，它还使用 SQL Server 默认值创建了`AutoLot`数据库。单击运行(或按 F5)创建数据库。

### 创建表

`AutoLot`数据库包含五个表格:`Inventory`、`Makes`、`Customers`、`Orders`和`CreditRisks`。

#### 创建库存表

创建了数据库之后，就该创建表了。首先是`Inventory`表。打开一个新查询，并输入以下 SQL:

```cs
USE [AutoLot]
GO
CREATE TABLE [dbo].[Inventory](
    [Id] [int] IDENTITY(1,1) NOT NULL,
    [MakeId] [int] NOT NULL,
    [Color] [nvarchar](50) NOT NULL,
    [PetName] [nvarchar](50) NOT NULL,
    [TimeStamp] [timestamp] NULL,
 CONSTRAINT [PK_Inventory] PRIMARY KEY CLUSTERED
(
  [Id] ASC
) ON [PRIMARY]
) ON [PRIMARY]
GO

```

单击运行(或按 F5)创建表。

#### 创建 Makes 表

`Inventory`表存储(尚未创建)`Makes`表的外键。创建一个新的查询，并输入以下 SQL 来创建`Makes`表:

```cs
USE [AutoLot]
GO
CREATE TABLE [dbo].[Makes](
  [Id] [int] IDENTITY(1,1) NOT NULL,
  [Name] [nvarchar](50) NOT NULL,
  [TimeStamp] [timestamp] NULL,
 CONSTRAINT [PK_Makes] PRIMARY KEY CLUSTERED
(
  [Id] ASC
) ON [PRIMARY]
) ON [PRIMARY]
GO

```

单击运行(或按 F5)创建表。

#### 创建客户表

`Customers`表(顾名思义)将包含一个客户列表。创建一个新查询，并输入以下 SQL 命令:

```cs
USE [AutoLot]
GO
CREATE TABLE [dbo].[Customers](
  [Id] [int] IDENTITY(1,1) NOT NULL,
  [FirstName] [nvarchar](50) NOT NULL,
  [LastName] [nvarchar](50) NOT NULL,
  [TimeStamp] [timestamp] NULL,
 CONSTRAINT [PK_Customers] PRIMARY KEY CLUSTERED
(
  [Id] ASC
) ON [PRIMARY]
) ON [PRIMARY]
GO

```

点击运行(或按 F5)创建`Customers`表。

#### 创建订单表

您将使用下一个表`Orders`来表示给定客户订购的汽车。创建一个新查询，输入以下代码，然后单击 Run(或按 F5 键):

```cs
USE [AutoLot]
GO
CREATE TABLE [dbo].[Orders](
  [Id] [int] IDENTITY(1,1) NOT NULL,
  [CustomerId] [int] NOT NULL,
  [CarId] [int] NOT NULL,
  [TimeStamp] [timestamp] NULL,
 CONSTRAINT [PK_Orders] PRIMARY KEY CLUSTERED
(
  [Id] ASC
) ON [PRIMARY]
) ON [PRIMARY]
GO

```

#### 创建信用风险表

您将使用您的最终表`CreditRisks`来代表被认为有信用风险的客户。创建一个新查询，输入以下代码，然后单击 Run(或按 F5 键):

```cs
USE [AutoLot]
GO
CREATE TABLE [dbo].[CreditRisks](
  [Id] [int] IDENTITY(1,1) NOT NULL,
  [FirstName] [nvarchar](50) NOT NULL,
  [LastName] [nvarchar](50) NOT NULL,
  [CustomerId] [int] NOT NULL,
  [TimeStamp] [timestamp] NULL,
 CONSTRAINT [PK_CreditRisks] PRIMARY KEY CLUSTERED
(
    [Id] ASC
) ON [PRIMARY]
) ON [PRIMARY]
GO

```

### 创建表关系

下一节将添加相关表之间的外键关系。

#### 创建库存以建立关系

打开一个新查询，输入以下 SQL，然后单击 Run(或按 F5 键):

```cs
USE [AutoLot]
GO
CREATE NONCLUSTERED INDEX [IX_Inventory_MakeId] ON [dbo].[Inventory]
(
  [MakeId] ASC
) ON [PRIMARY]
GO
ALTER TABLE [dbo].[Inventory]  WITH CHECK ADD  CONSTRAINT [FK_Make_Inventory] FOREIGN KEY([MakeId])
REFERENCES [dbo].[Makes] ([Id])
GO
ALTER TABLE [dbo].[Inventory] CHECK CONSTRAINT [FK_Make_Inventory]
GO

```

#### 创建库存与订单的关系

打开一个新查询，输入以下 SQL，然后单击 Run(或按 F5 键):

```cs
USE [AutoLot]
GO
CREATE NONCLUSTERED INDEX [IX_Orders_CarId] ON [dbo].[Orders]
(
  [CarId] ASC
) ON [PRIMARY]
GO
ALTER TABLE [dbo].[Orders]  WITH CHECK ADD  CONSTRAINT [FK_Orders_Inventory] FOREIGN KEY([CarId])
REFERENCES [dbo].[Inventory] ([Id])
GO
ALTER TABLE [dbo].[Orders] CHECK CONSTRAINT [FK_Orders_Inventory]
GO

```

#### 创建订单到客户的关系

打开一个新查询，输入以下 SQL，然后单击 Run(或按 F5 键):

```cs
USE [AutoLot]
GO
CREATE UNIQUE NONCLUSTERED INDEX [IX_Orders_CustomerId_CarId] ON [dbo].[Orders]
(
  [CustomerId] ASC,
  [CarId] ASC
) ON [PRIMARY]
GO
ALTER TABLE [dbo].[Orders]  WITH CHECK ADD  CONSTRAINT [FK_Orders_Customers] FOREIGN KEY([CustomerId])
REFERENCES [dbo].[Customers] ([Id])
ON DELETE CASCADE
GO
ALTER TABLE [dbo].[Orders] CHECK CONSTRAINT [FK_Orders_Customers]
GO

```

#### 创建客户与信贷风险的关系

打开一个新查询，输入以下 SQL，然后单击 Run(或按 F5 键):

```cs
USE [AutoLot]
GO
CREATE NONCLUSTERED INDEX [IX_CreditRisks_CustomerId] ON [dbo].[CreditRisks]
(
  [CustomerId] ASC
) ON [PRIMARY]
GO
ALTER TABLE [dbo].[CreditRisks]  WITH CHECK ADD  CONSTRAINT [FK_CreditRisks_Customers] FOREIGN KEY([CustomerId])
REFERENCES [dbo].[Customers] ([Id])
ON DELETE CASCADE
GO
ALTER TABLE [dbo].[CreditRisks] CHECK CONSTRAINT [FK_CreditRisks_Customers]
GO

```

Note

如果您想知道为什么有与客户表有关系的列`FirstName`和`LastName` *和*，这只是为了演示的目的。我可以为它想出一个创造性的理由，但最终，它很好地建立了第 23 章。

### 创建 GetPetName()存储过程

在本章的后面，你将学习如何使用 ADO.NET 来调用存储过程。正如您可能已经知道的那样，存储过程是存储在数据库中的代码例程，用来做一些事情。像 C#方法一样，存储过程可以返回数据或者只对数据进行操作而不返回任何东西。您将添加一个单独的存储过程，它将根据提供的`carId`返回汽车的昵称。为此，创建一个新的查询窗口，并输入以下 SQL 命令:

```cs
USE [AutoLot]
GO
CREATE PROCEDURE [dbo].[GetPetName]
@carID int,
@petName nvarchar(50) output
AS
SELECT @petName = PetName from dbo.Inventory where Id = @carID
GO

```

单击“运行”(或按 F5)创建存储过程。

### 添加测试记录

没有数据的数据库是相当枯燥的，拥有能够快速将测试记录加载到数据库中的脚本是一个好主意。

#### 制作表格记录

创建一个新的查询并执行以下 SQL 语句，将记录添加到`Makes`表中:

```cs
USE [AutoLot]
GO
SET IDENTITY_INSERT [dbo].[Makes] ON
INSERT INTO [dbo].[Makes] ([Id], [Name]) VALUES (1, N'VW')
INSERT INTO [dbo].[Makes] ([Id], [Name]) VALUES (2, N'Ford')
INSERT INTO [dbo].[Makes] ([Id], [Name]) VALUES (3, N'Saab')
INSERT INTO [dbo].[Makes] ([Id], [Name]) VALUES (4, N'Yugo')
INSERT INTO [dbo].[Makes] ([Id], [Name]) VALUES (5, N'BMW')
INSERT INTO [dbo].[Makes] ([Id], [Name]) VALUES (6, N'Pinto')
SET IDENTITY_INSERT [dbo].[Makes] OFF

```

#### 库存表记录

要将记录添加到您的第一个表中，创建一个新的查询并执行以下 SQL 语句将记录添加到`Inventory`表中:

```cs
USE [AutoLot]
GO
SET IDENTITY_INSERT [dbo].[Inventory] ON
GO
INSERT INTO [dbo].[Inventory] ([Id], [MakeId], [Color], [PetName]) VALUES (1, 1, N'Black', N'Zippy')
INSERT INTO [dbo].[Inventory] ([Id], [MakeId], [Color], [PetName]) VALUES (2, 2, N'Rust', N'Rusty')
INSERT INTO [dbo].[Inventory] ([Id], [MakeId], [Color], [PetName]) VALUES (3, 3, N'Black', N'Mel')
INSERT INTO [dbo].[Inventory] ([Id], [MakeId], [Color], [PetName]) VALUES (4, 4, N'Yellow', N'Clunker')
INSERT INTO [dbo].[Inventory] ([Id], [MakeId], [Color], [PetName]) VALUES (5, 5, N'Black', N'Bimmer')
INSERT INTO [dbo].[Inventory] ([Id], [MakeId], [Color], [PetName]) VALUES (6, 5, N'Green', N'Hank')
INSERT INTO [dbo].[Inventory] ([Id], [MakeId], [Color], [PetName]) VALUES (7, 5, N'Pink', N'Pinky')
INSERT INTO [dbo].[Inventory] ([Id], [MakeId], [Color], [PetName]) VALUES (8, 6, N'Black', N'Pete')
INSERT INTO [dbo].[Inventory] ([Id], [MakeId], [Color], [PetName]) VALUES (9, 4, N'Brown', N'Brownie')SET IDENTITY_INSERT [dbo].[Inventory] OFF
GO

```

#### 向客户表中添加测试记录

要向`Customers`表添加记录，创建一个新的查询并执行以下 SQL 语句:

```cs
USE [AutoLot]
GO
SET IDENTITY_INSERT [dbo].[Customers] ON
INSERT INTO [dbo].[Customers] ([Id], [FirstName], [LastName]) VALUES (1, N'Dave', N'Brenner')
INSERT INTO [dbo].[Customers] ([Id], [FirstName], [LastName]) VALUES (2, N'Matt', N'Walton')
INSERT INTO [dbo].[Customers] ([Id], [FirstName], [LastName]) VALUES (3, N'Steve', N'Hagen')
INSERT INTO [dbo].[Customers] ([Id], [FirstName], [LastName]) VALUES (4, N'Pat', N'Walton')
INSERT INTO [dbo].[Customers] ([Id], [FirstName], [LastName]) VALUES (5, N'Bad', N'Customer')
SET IDENTITY_INSERT [dbo].[Customers] OFF

```

#### 向订单表中添加测试记录

现在将数据添加到您的`Orders`表中。创建一个新查询，输入以下 SQL，然后单击 Run(或按 F5 键):

```cs
USE [AutoLot]
GO
SET IDENTITY_INSERT [dbo].[Orders] ON
INSERT INTO [dbo].[Orders] ([Id], [CustomerId], [CarId]) VALUES (1, 1, 5)
INSERT INTO [dbo].[Orders] ([Id], [CustomerId], [CarId]) VALUES (2, 2, 1)
INSERT INTO [dbo].[Orders] ([Id], [CustomerId], [CarId]) VALUES (3, 3, 4)
INSERT INTO [dbo].[Orders] ([Id], [CustomerId], [CarId]) VALUES (4, 4, 7)
SET IDENTITY_INSERT [dbo].[Orders] OFF

```

#### 向 CreditRisks 表添加测试记录

最后一步是向`CreditRisks`表添加数据。创建一个新查询，输入以下 SQL，然后单击 Run(或按 F5 键):

```cs
USE [AutoLot]
GO
SET IDENTITY_INSERT [dbo].[CreditRisks] ON
INSERT INTO [dbo].[CreditRisks] ([Id], [FirstName], [LastName], [CustomerId]) VALUES (1, N'Bad', N'Customer', 5)
SET IDENTITY_INSERT [dbo].[CreditRisks] OFF

```

至此，`AutoLot`数据库完成！当然，这与真实世界的应用数据库相去甚远，但是它将满足您对本章的需求，并将被添加到实体框架核心章节中。既然您已经有了一个要测试的数据库，那么您可以深入研究 ADO.NET 数据提供者工厂模型的细节了。

## ADO.NET 数据提供者工厂模型

那个。NET 核心数据提供者工厂模式允许您使用通用的数据访问类型构建一个单一的代码库。为了理解数据提供者工厂实现，从表 [21-1](#Tab1) 中回忆一下，数据提供者中的类都是从`System.Data.Common`名称空间中定义的相同基类中派生出来的。

*   `DbCommand`:所有命令类的抽象基类

*   `DbConnection`:所有连接类的抽象基类

*   `DbDataAdapter`:所有数据适配器类的抽象基类

*   `DbDataReader`:所有数据读取器类的抽象基类

*   `DbParameter`:所有参数类的抽象基类

*   `DbTransaction`:所有交易类的抽象基类

每一个。NET Core 兼容的数据提供程序包含一个从`System.Data.Common.DbProviderFactory`派生的类类型。这个基类定义了几个检索特定于提供程序的数据对象的方法。以下是`DbProviderFactory`的成员:

```cs
public abstract class DbProviderFactory
{
..public virtual bool CanCreateDataAdapter { get;};
..public virtual bool CanCreateCommandBuilder { get;};
  public virtual DbCommand CreateCommand();
  public virtual DbCommandBuilder CreateCommandBuilder();
  public virtual DbConnection CreateConnection();
  public virtual DbConnectionStringBuilder
    CreateConnectionStringBuilder();
  public virtual DbDataAdapter CreateDataAdapter();
  public virtual DbParameter CreateParameter();
  public virtual DbDataSourceEnumerator
    CreateDataSourceEnumerator();
}

```

为了获得数据提供者的`DbProviderFactory`派生类型，每个提供者都提供了一个静态属性，用于返回正确的类型。要返回 SQL Server 版本的`DbProviderFactory`，请使用以下代码:

```cs
// Get the factory for the SQL data provider.
DbProviderFactory sqlFactory =
  Microsoft.Data.SqlClient.SqlClientFactory.Instance;

```

为了使程序更加通用，您可以创建一个`DbProviderFactory`工厂，根据应用的`appsettings.json`文件中的设置返回一个特定风格的`DbProviderFactory`。您将很快学会如何做到这一点；目前，一旦获得了数据提供者的工厂，就可以获得相关的特定于提供者的数据对象(例如，连接、命令和数据读取器)。

### 完整的数据提供者工厂示例

作为一个完整的例子，创建一个新的 C#控制台应用项目(名为`DataProviderFactory`)，它打印出`AutoLot`数据库的汽车库存。对于这个初始示例，您将直接在控制台应用中硬编码数据访问逻辑(为了保持简单)。随着本章的深入，你会看到更好的方法。

首先向项目文件中添加一个新的`ItemGroup`以及`Microsoft.Extensions.Configuration.Json`、`System.Data.Common`、`System.Data.Odbc`、`System.Data.OleDb`和`Microsoft.Data.SqlClient`包。

```cs
dotnet add DataProviderFactory package Microsoft.Data.SqlClient
dotnet add DataProviderFactory package System.Data.Common
dotnet add DataProviderFactory package System.Data.Odbc
dotnet add DataProviderFactory package System.Data.OleDb
dotnet add DataProviderFactory package Microsoft.Extensions.Configuration.Json

```

定义`PC`编译器常量(如果您使用的是 Windows 操作系统)。

```cs
<PropertyGroup>
  <DefineConstants>PC</DefineConstants>
</PropertyGroup>

```

接下来，添加一个名为`DataProviderEnum.cs`的新文件，并将代码更新如下:

```cs
namespace DataProviderFactory
{
  //OleDb is Windows only and is not supported in .NET Core
  enum DataProviderEnum
  {
    SqlServer,
#if PC
    OleDb,
#endif
    Odbc
  }
}

```

将名为`appsettings.json`的新 JSON 文件添加到项目中，并将其内容更新为以下内容(根据您的特定环境更新连接字符串):

```cs
{
  "ProviderName": "SqlServer",
  //"ProviderName": "OleDb",
  //"ProviderName": "Odbc",
  "SqlServer": {
    // for localdb use @"Data Source=(localdb)\mssqllocaldb;Integrated Security=true; Initial Catalog=AutoLot"
    "ConnectionString": "Data Source=.,5433;User Id=sa;Password=P@ssw0rd;Initial Catalog=AutoLot"
  },
  "Odbc": {
    // for localdb use @"Driver={ODBC Driver 17 for SQL Server};Server=(localdb)\mssqllocaldb;Database=AutoLot;Trusted_Connection=Yes";
    "ConnectionString": "Driver={ODBC Driver 17 for SQL Server};Server=localhost,5433; Database=AutoLot;UId=sa;Pwd=P@ssw0rd;"
  },
  "OleDb": {
    // if localdb use @"Provider=SQLNCLI11;Data Source=(localdb)\mssqllocaldb;Initial Catalog=AutoLot;Integrated Security=SSPI"),
    "ConnectionString": "Provider=SQLNCLI11;Data Source=.,5433;User Id=sa;Password=P@ssw0rd; Initial Catalog=AutoLot;"
  }
}

```

通知 MSBuild 在每次构建时将 JSON 文件复制到输出目录。通过添加以下内容来更新项目文件:

```cs
<ItemGroup>
  <None Update="appsettings.json">
    <CopyToOutputDirectory>Always</CopyToOutputDirectory>
  </None>
</ItemGroup>

```

Note

`CopyToOutputDirectory`是区分空白的。确保所有内容都在一行上，并且单词*和*之间没有空格。

现在您已经有了一个合适的`appsettings.json`，您可以使用.NETCore配置。首先将`Program.cs`顶部的`using`语句更新为以下内容:

```cs
using System;
using System.Data.Common;
using System.Data.Odbc;
#if PC
  using System.Data.OleDb;
#endif
using System.IO;
using Microsoft.Data.SqlClient;
using Microsoft.Extensions.Configuration;

```

清除`Program.cs`文件中的所有代码，并添加以下内容:

```cs
using System;
using System.Data.Common;
using System.Data.Odbc;
#if PC
  using System.Data.OleDb;
#endif
using System.IO;
using Microsoft.Data.SqlClient;
using Microsoft.Extensions.Configuration;
using DataProviderFactory;

Console.WriteLine("***** Fun with Data Provider Factories *****\n");
var (provider, connectionString) = GetProviderFromConfiguration();
DbProviderFactory factory = GetDbProviderFactory(provider);
// Now get the connection object.
using (DbConnection connection = factory.CreateConnection())
{
  if (connection == null)
  {
    Console.WriteLine($"Unable to create the connection object");
    return;
  }

  Console.WriteLine($"Your connection object is a: {connection.GetType().Name}");
  connection.ConnectionString = connectionString;
  connection.Open();

  // Make command object.
  DbCommand command = factory.CreateCommand();
  if (command == null)
  {
    Console.WriteLine($"Unable to create the command object");
    return;
  }

  Console.WriteLine($"Your command object is a: {command.GetType().Name}");
  command.Connection = connection;
  command.CommandText =
    "Select i.Id, m.Name From Inventory i inner join Makes m on m.Id = i.MakeId ";

  // Print out data with data reader.
  using (DbDataReader dataReader = command.ExecuteReader())
  {
    Console.WriteLine($"Your data reader object is a: {dataReader.GetType().Name}");
    Console.WriteLine("\n***** Current Inventory *****");
    while (dataReader.Read())
    {
      Console.WriteLine($"-> Car #{dataReader["Id"]} is a {dataReader["Name"]}.");
    }
  }
}
Console.ReadLine();

```

接下来，将下面的代码添加到`Program.cs`文件的末尾。这些方法读取配置，将`DataProviderEnum`设置为正确的值，获取连接字符串，并返回`DbProviderFactory`的一个实例:

```cs
static DbProviderFactory GetDbProviderFactory(DataProviderEnum provider)
  => provider switch
{
  DataProviderEnum.SqlServer => SqlClientFactory.Instance,
  DataProviderEnum.Odbc => OdbcFactory.Instance,
#if PC
  DataProviderEnum.OleDb => OleDbFactory.Instance,
#endif
  _ => null
};

static (DataProviderEnum Provider, string ConnectionString)
  GetProviderFromConfiguration()
{
  IConfiguration config = new ConfigurationBuilder()
    .SetBasePath(Directory.GetCurrentDirectory())
    .AddJsonFile("appsettings.json", true, true)
    .Build();
  var providerName = config["ProviderName"];
  if (Enum.TryParse<DataProviderEnum>
    (providerName, out DataProviderEnum provider))
  {
    return (provider,config[$"{providerName}:ConnectionString"]);
  };
  throw new Exception("Invalid data provider value supplied.");
}

```

请注意，出于诊断目的，您使用反射服务来打印基础连接、命令和数据读取器的名称。如果您运行这个应用，您将在打印到控制台的`AutoLot`数据库的`Inventory`表中找到以下当前数据:

```cs
***** Fun with Data Provider Factories *****
Your connection object is a: SqlConnection
Your command object is a: SqlCommand
Your data reader object is a: SqlDataReader

***** Current Inventory *****
-> Car #1 is a VW.
-> Car #2 is a Ford.
-> Car #3 is a Saab.
-> Car #4 is a Yugo.
-> Car #9 is a Yugo.
-> Car #5 is a BMW.
-> Car #6 is a BMW.
-> Car #7 is a BMW.
-> Car #8 is a Pinto.

```

现在修改`settings`文件来指定一个不同的提供者。除了特定于类型的信息之外，代码将获取相关的连接字符串并产生与以前相同的输出。

当然，根据你使用 ADO.NET 的经验，你可能有点不确定连接、命令和数据读取器对象实际上是做什么的。暂时不要考虑细节(毕竟，这一章还有好几页呢！).至此，知道您可以使用 point 数据提供者工厂模型来构建一个可以以声明方式使用各种数据提供者的单一代码库就足够了。

### 数据提供者工厂模型的一个潜在缺点

尽管这是一个强大的模型，但是您必须确保代码库只使用通过抽象基类成员对所有提供程序通用的类型和方法。因此，在创作您的代码库时，您只能使用由`DbConnection`、`DbCommand`和其他类型的`System.Data.Common`名称空间公开的成员。

考虑到这一点，您可能会发现这种一般化的方法会阻止您直接访问特定 DBMS 的一些附加功能。如果您必须能够调用基础提供者的特定成员(例如，`SqlConnection`)，您可以使用显式强制转换来实现，如下例所示:

```cs
if (connection is SqlConnection sqlConnection)
{
  // Print out which version of SQL Server is used.
  WriteLine(sqlConnection.ServerVersion);
}

```

然而，当这样做时，您的代码库变得有点难以维护(并且不太灵活)，因为您必须添加许多运行时检查。尽管如此，如果您需要以最灵活的方式构建 doing 数据访问库，数据提供者工厂模型为您提供了一个很好的机制。

Note

Entity Framework Core 及其对依赖注入的支持极大地简化了构建需要访问不同数据源的数据访问库。

有了第一个例子，你现在可以深入了解与 ADO.NET 合作的细节。

## 深入研究连接、命令和数据读取器

如前面的示例所示，ADO.NET 允许您使用数据提供程序的连接、命令和数据读取器对象与数据库进行交互。现在，您将创建一个扩展示例来更深入地了解 ADO.NET 的这些对象。

在前面演示的示例中，当您想要连接到数据库并使用数据读取器对象读取记录时，需要执行以下步骤:

1.  分配、配置和打开您的连接对象。

2.  分配和配置命令对象，将连接对象指定为构造函数参数或使用`Connection`属性。

3.  在配置的命令类上调用`ExecuteReader()`。

4.  使用数据读取器的`Read()`方法处理每条记录。

首先，创建一个名为 AutoLot 的新控制台应用项目。DataReader 并添加`Microsoft.Data.SqlClient`包。下面是`Program.cs`内的完整代码(分析随后):

```cs
using System;
using Microsoft.Data.SqlClient;

Console.WriteLine("***** Fun with Data Readers *****\n");

// Create and open a connection.
using (SqlConnection connection = new SqlConnection())
{
  connection.ConnectionString =
    @" Data Source=.,5433;User Id=sa;Password=P@ssw0rd;Initial Catalog=AutoLot";
    connection.Open();
   // Create a SQL command object.
  string sql =
    @"Select i.id, m.Name as Make, i.Color, i.Petname
          FROM Inventory i
          INNER JOIN Makes m on m.Id = i.MakeId";
  SqlCommand myCommand = new SqlCommand(sql, connection);

  // Obtain a data reader a la ExecuteReader().
  using (SqlDataReader myDataReader = myCommand.ExecuteReader())
  {
    // Loop over the results.
    while (myDataReader.Read())
    {
      Console.WriteLine($"-> Make: {myDataReader["Make"]}, PetName: {myDataReader ["PetName"]}, Color: {myDataReader["Color"]}.");
    }
  }
}
Console.ReadLine();

```

### 使用连接对象

使用数据提供者的第一步是使用 connection 对象(您记得，它是从`DbConnection`派生的)与数据源建立会话。。NET Core 连接对象带有格式化的*连接字符串*；该字符串包含许多名称-值对，用分号分隔。您可以使用这些信息来标识要连接的计算机的名称、所需的安全设置、该计算机上的数据库名称以及其他特定于数据提供程序的信息。

正如您可以从前面的代码中推断的那样，`Initial Catalog`名称指的是您想要与之建立会话的数据库。`Data Source`名称标识维护数据库的机器的名称。我使用的是`".,5433"`，它指的是主机(句点，与使用“localhost”相同)，端口 5433 是 Docker 容器映射到 SQL Server 端口的端口。如果您使用的是不同的实例，那么您可以将属性定义为`machinename,port\instance`。例如，`MYSERVER\SQLSERVER2019`表示`MYSERVER`是运行 SQL Server 的服务器的名称，默认端口正在使用，而`SQLSERVER2019`是实例的名称。如果机器是本地的，您可以使用句点(`.`)或标记(`localhost`)作为服务器名称。如果 SQL Server 实例是默认实例，则不使用实例名称。例如，如果您在 Microsoft SQL Server 安装上创建了`AutoLot`，并将其设置为本地计算机上的默认实例，那么您将使用`"Data Source=localhost"`。

除此之外，您可以提供任意数量的表示安全凭证的令牌。如果`Integrated Security`设置为`true`，则当前 Windows 帐户凭证用于验证和授权。

建立连接字符串后，可以调用`Open()`来建立与 DBMS 的连接。除了`ConnectionString`、`Open()`和`Close()`成员之外，连接对象还提供了许多成员，允许您配置关于连接的附加设置，比如超时设置和事务信息。表 [21-4](#Tab4) 列出了`DbConnection`基类的一些(但不是全部)成员。

表 21-4。

`DbConnection`类型的成员

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

成员

 | 

生命的意义

 |
| --- | --- |
| `BeginTransaction()` | 您使用此方法开始数据库事务。 |
| `ChangeDatabase()` | 您可以使用此方法在打开的连接上更改数据库。 |
| `ConnectionTimeout` | 此只读属性返回建立连接时，在终止连接并生成错误之前等待的时间(默认值取决于提供程序)。如果您想更改默认值，请在连接字符串中指定一个`Connect Timeout`段(例如`Connect Timeout=30`)。 |
| `Database` | 此只读属性获取由 connection 对象维护的数据库的名称。 |
| `DataSource` | 此只读属性获取由 connection 对象维护的数据库的位置。 |
| `GetSchema()` | 该方法返回一个包含来自数据源的模式信息的`DataTable`对象。 |
| `State` | 这个只读属性获取连接的当前状态，由`ConnectionState`枚举表示。 |

`DbConnection`类型的属性本质上通常是只读的，只有当您想要在运行时获得连接的特征时才有用。当需要重写默认设置时，必须更改连接字符串本身。例如，以下连接字符串将`connection timeout`设置从默认值(SQL Server 为 15 秒)设置为 30 秒:

```cs
using(SqlConnection connection = new SqlConnection())
{
  connection.ConnectionString =
    @" Data Source=.,5433;User Id=sa;Password=P@ssw0rd;Initial Catalog=AutoLot;Connect Timeout=30";
  connection.Open();
}

```

下面的代码输出关于它传递给它的`SqlConnection`的细节:

```cs
static void ShowConnectionStatus(SqlConnection connection)
{
  // Show various stats about current connection object.
  Console.WriteLine("***** Info about your connection *****");
  Console.WriteLine($@"Database location:
    {connection.DataSource}");
  Console.WriteLine($"Database name: {connection.Database}");
  Console.WriteLine($@"Timeout:
    {connection.ConnectionTimeout}");
  Console.WriteLine($"Connection state:
    {connection.State}\n");
}

```

虽然这些属性中的大多数都是不言自明的，但是`State`属性值得特别一提。您可以将`ConnectionState`枚举的任何值赋给该属性，如下所示:

```cs
public enum ConnectionState
{
  Broken,
  Closed,
  Connecting,
  Executing,
  Fetching,
  Open
}

```

然而，唯一有效的`ConnectionState`值是`ConnectionState.Open`、`ConnectionState.Connecting`和`ConnectionState.Closed`(该枚举的其余成员保留供将来使用)。此外，关闭连接总是安全的，即使连接状态当前是`ConnectionState.Closed`。

#### 使用 ConnectionStringBuilder 对象

以编程方式处理连接字符串可能很麻烦，因为它们通常被表示为字符串文字，这很难维护，而且很容易出错。那个。符合 NET Core 的数据提供者支持*连接字符串生成器对象*，它允许您使用强类型属性建立名称-值对。考虑以下对当前`code`的更新:

```cs
var connectionStringBuilder = new SqlConnectionStringBuilder
{
  InitialCatalog = "AutoLot",
  DataSource = ".,5433",
  UserID = "sa",
  Password = "P@ssw0rd",
  ConnectTimeout = 30
};
  connection.ConnectionString =
    connectionStringBuilder.ConnectionString;

```

在这个迭代中，您创建一个`SqlConnectionStringBuilder`的实例，相应地设置属性，并使用`ConnectionString`属性获得内部字符串。另请注意，您使用了该类型的默认构造函数。如果您愿意，还可以通过传入现有连接字符串作为起点来创建数据提供程序的连接字符串生成器对象的实例(当您从外部源动态读取这些值时，这可能会很有帮助)。一旦使用初始字符串数据对对象进行了合并，就可以使用相关属性更改特定的名称-值对。

### 使用命令对象

既然您已经更好地理解了 connection 对象的角色，下一步工作就是检查如何向相关数据库提交 SQL 查询。`SqlCommand`类型(从`DbCommand`派生而来)是 SQL 查询、表名或存储过程的面向对象表示。使用`CommandType`属性指定命令的类型，该属性可以从`CommandType`枚举中获取任何值，如下所示:

```cs
public enum CommandType
{
  StoredProcedure,
  TableDirect,
  Text // Default value.
}

```

当您创建一个命令对象时，您可以将 SQL 查询建立为一个构造函数参数，或者直接使用`CommandText`属性。此外，在创建命令对象时，需要指定要使用的连接。同样，您可以通过构造函数参数或使用`Connection`属性来实现。考虑以下代码片段:

```cs
// Create command object via ctor args.
string sql =
    @"Select i.id, m.Name as Make, i.Color, i.Petname
         FROM Inventory i
         INNER JOIN Makes m on m.Id = i.MakeId";
SqlCommand myCommand = new SqlCommand(sql, connection);
// Create another command object via properties.
SqlCommand testCommand = new SqlCommand();
testCommand.Connection = connection;
testCommand.CommandText = sql;

```

要知道，在这一点上，您实际上并没有将 SQL 查询提交给`AutoLot`数据库，而是准备了命令对象的状态以备将来使用。表 [21-5](#Tab5) 突出显示了`DbCommand`类型的一些附加成员。

表 21-5。

`DbCommand`类型的成员

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

成员

 | 

生命的意义

 |
| --- | --- |
| `CommandTimeout` | 获取或设置在终止尝试并生成错误之前执行命令时等待的时间。默认值为 30 秒。 |
| `Connection` | 获取或设置此`DbCommand`实例使用的`DbConnection`。 |
| `Parameters` | 获取用于参数化查询的`DbParameter`对象的集合。 |
| `Cancel()` | 取消命令的执行。 |
| `ExecuteReader()` | 执行 SQL 查询并返回数据提供者的`DbDataReader`对象，该对象提供对查询结果的只进、只读访问。 |
| `ExecuteNonQuery()` | 执行 SQL 非查询(例如，插入、更新、删除或创建表)。 |
| `ExecuteScalar()` | 一个轻量级版本的`ExecuteReader()`方法，它是专门为单独查询设计的(例如，获取记录计数)。 |
| `Prepare()` | 在数据源上创建命令的准备(或编译)版本。您可能知道，*准备好的查询*执行起来稍微快一些，当您需要多次执行相同的查询(通常每次使用不同的参数)时会很有用。 |

### 使用数据读取器

建立活动连接和 SQL 命令后，下一步是向数据源提交查询。正如您可能猜到的，您有许多方法可以做到这一点。`DbDataReader`类型(实现了`IDataReader`)是从数据存储中获取信息的最简单快捷的方式。回想一下，数据读取器表示只读、只进的数据流，一次返回一条记录。鉴于此，数据读取器只有在向基础数据存储提交 SQL 选择语句时才有用。

当您需要快速迭代大量数据并且不需要维护内存中的表示时，数据读取器非常有用。例如，如果您请求将一个表中的 20，000 条记录存储在一个文本文件中，那么将这些信息保存在一个`DataSet`中会占用大量内存(因为一个`DataSet`同时将整个查询结果保存在内存中)。

一个更好的方法是创建一个数据读取器，尽可能快地旋转每条记录。但是，请注意，数据读取器对象(与数据适配器对象不同，您将在后面研究数据适配器对象)会保持与其数据源的打开连接，直到您显式关闭该连接。

您通过调用`ExecuteReader()`从命令对象获得数据读取器对象。数据读取器表示它从数据库中读取的当前记录。数据读取器有一个索引器方法(例如，C#中的`[]`语法),允许您访问当前记录中的一列。您可以通过名称或从零开始的整数来访问该列。

数据读取器的以下使用利用了`Read()`方法来确定何时到达记录的末尾(使用一个`false`返回值)。对于从数据库中读取的每个传入记录，使用类型索引器打印出每辆汽车的品牌、昵称和颜色。还要注意，一旦处理完记录，就调用`Close()`，这释放了连接对象。

```cs
...
// Obtain a data reader via ExecuteReader().
using(SqlDataReader myDataReader = myCommand.ExecuteReader())
{
  // Loop over the results.
  while (myDataReader.Read())
  {
    WriteLine($"-> Make: { myDataReader["Make"]}, PetName: { myDataReader["PetName"]}, Color: { myDataReader["Color"]}.");
  }
}
ReadLine();

```

在前面的代码片段中，您重载了数据读取器对象的索引器，以接受一个`string`(表示列的名称)或一个`int`(表示列的序号位置)。因此，您可以用下面的更新清理当前的阅读器逻辑(并避免硬编码的字符串名称)(注意`FieldCount`属性的使用):

```cs
while (myDataReader.Read())
{
  for (int i = 0; i < myDataReader.FieldCount; i++)
  {
    Console.Write(i != myDataReader.FieldCount - 1
      ? $"{myDataReader.GetName(i)} = {myDataReader.GetValue(i)}, "
      : $"{myDataReader.GetName(i)} = {myDataReader.GetValue(i)} ");
  }
  Console.WriteLine();
}

```

如果您在此时编译并运行您的项目，您应该会在`AutoLot`数据库的`Inventory`表中看到所有汽车的列表。

```cs
***** Fun with Data Readers *****

***** Info about your connection *****
Database location: .,5433
Database name: AutoLot
Timeout: 30
Connection state: Open

id = 1, Make = VW, Color = Black, Petname = Zippy
id = 2, Make = Ford, Color = Rust, Petname = Rusty
id = 3, Make = Saab, Color = Black, Petname = Mel
id = 4, Make = Yugo, Color = Yellow, Petname = Clunker
id = 5, Make = BMW, Color = Black, Petname = Bimmer
id = 6, Make = BMW, Color = Green, Petname = Hank
id = 7, Make = BMW, Color = Pink, Petname = Pinky
id = 8, Make = Pinto, Color = Black, Petname = Pete
id = 9, Make = Yugo, Color = Brown, Petname = Brownie

```

#### 使用数据读取器获取多个结果集

数据读取器对象可以使用单个命令对象获得多个结果集。例如，如果您想获得来自`Inventory`表的所有行，以及来自`Customers`表的所有行，您可以使用分号分隔符指定这两个 SQL `Select`语句，如下所示:

```cs
    sql += ";Select * from Customers;";

```

Note

开头的分号不是错别字。使用多个语句时，它们必须用分号分隔。因为最初的语句不包含，所以在第二个语句的开头添加了一个。

获得数据读取器后，可以使用`NextResult()`方法迭代每个结果集。请注意，您总是自动返回第一个结果集。因此，如果您想要读取每个表的行，您可以构建以下迭代结构:

```cs
do
{
  while (myDataReader.Read())
  {
    for (int i = 0; i < myDataReader.FieldCount; i++)
    {
      Console.Write(i != myDataReader.FieldCount - 1
        ? $"{myDataReader.GetName(i)} = {myDataReader.GetValue(i)}, "
        : $"{myDataReader.GetName(i)} = {myDataReader.GetValue(i)} ");
    }
    Console.WriteLine();
  }
  Console.WriteLine();
} while (myDataReader.NextResult());

```

此时，您应该更清楚数据读取器对象为表带来的功能。永远记住，数据读取器只能处理 SQL `Select`语句；您不能使用它们通过`Insert`、`Update`或`Delete`请求来修改现有的数据库表。修改现有数据库需要对命令对象进行额外的调查。

## 使用创建、更新和删除查询

`ExecuteReader()`方法提取数据读取器对象，该对象允许您使用只进、只读信息流来检查 SQL `Select`语句的结果。但是，当您想要提交导致给定表修改的 SQL 语句(或任何其他非查询 SQL 语句，如创建表或授予权限)时，您可以调用命令对象的`ExecuteNonQuery()`方法。这个方法根据命令文本的格式执行插入、更新和删除操作。

Note

从技术上讲，*非查询*是一个不返回结果集的 SQL 语句。因此，`Select`语句是查询，而`Insert`、`Update`和`Delete`语句不是查询。鉴于此，`ExecuteNonQuery()`返回一个代表受影响的行数的`int`，而不是一组新的记录。

到目前为止，本章中的所有数据库交互示例都只打开了连接，并使用它们来检索数据。这只是使用数据库的一部分；除非数据访问框架也完全支持创建、读取、更新和删除(CRUD)功能，否则它没有多大用处。接下来，您将学习如何使用对`ExecuteNonQuery()`的调用来做到这一点。

首先创建一个名为 AutoLot 的新 C#类库项目。dal(*AutoLot 数据访问层*的简称)，删除默认的类文件，将`Microsoft.Data.SqlClient`包添加到项目中。

在构建将执行数据操作的类之前，我们将首先创建一个 C#类，它表示来自`Inventory`表的记录及其相关的`Make`信息。

### 创建 Car 和 CarViewModel 类

现代数据访问库使用类(通常称为*模型或实体*)来表示和传输数据库中的数据。此外，可以使用类来表示数据的视图，该视图将两个或更多的表组合在一起，使数据更有意义。实体类用于处理数据库目录(用于更新语句)，视图模型类用于以有意义的方式显示数据。在下一章中，您将看到这些概念是像实体框架核心这样的对象关系映射器(ORM)的基础，但是现在，您只需创建一个模型(针对原始库存行)和一个视图模型(将库存行与`Makes`表中的相关数据结合起来)。向您的项目添加一个名为`Models`的新文件夹，并添加两个名为`Car.cs`和`CarViewModel.cs`的新文件。将代码更新为以下内容:

```cs
//Car.cs
namespace AutoLot.Dal.Models
{
  public class Car
  {
    public int Id { get; set; }
    public string Color { get; set; }
    public int MakeId { get; set; }
    public string PetName { get; set; }
    public byte[] TimeStamp {get;set;}
  }
}

//CarViewModel.cs
namespace AutoLot.Dal.Models
{
  public class CarViewModel : Car
  {
    public string Make { get; set; }
  }
}

```

Note

如果您不熟悉 SQL Server `TimeStamp`数据类型(在 C#中，它映射到一个`byte[]`),此时不必担心。只知道它用于行级并发检查，会被实体框架核心覆盖。

这些类将很快被使用。

### 添加 InventoryDal 类

接下来，添加一个名为`DataOperations`的新文件夹。在这个新文件夹中，添加一个名为`InventoryDal.cs`的新类，并将该类更改为`public`。这个类将定义各种成员来与`AutoLot`数据库的`Inventory`表交互。最后，导入以下名称空间:

```cs
using System;
using System.Collections.Generic;
using System.Data;
using AutoLot.Dal.Models;
using Microsoft.Data.SqlClient;

```

#### 添加构造函数

创建一个接受字符串参数(`connectionString`)并将该值赋给类级变量的构造函数。接下来，创建一个无参数的构造函数，将一个默认的连接字符串传递给另一个构造函数。这使调用代码能够更改默认的连接字符串。相关代码如下:

```cs
namespace AuoLot.Dal.DataOperations
{
  public class InventoryDal
  {
    private readonly string _connectionString;
    public InventoryDal() : this(
      @"Data Source=.,5433;User Id=sa;Password=P@ssw0rd;Initial Catalog=AutoLot")
    {
    }
    public InventoryDal(string connectionString)
      => _connectionString = connectionString;
  }
}

```

#### 打开和关闭连接

接下来，添加一个类级变量来保存数据访问代码将使用的连接。同样，添加两个方法，一个打开连接(`OpenConnection()`)，另一个关闭连接(`CloseConnection()`)。在`CloseConnection()`方法中，检查连接的状态，如果没有关闭，那么在连接上调用`Close()`。代码清单如下:

```cs
private SqlConnection _sqlConnection = null;
private void OpenConnection()
{
  _sqlConnection = new SqlConnection
  {
    ConnectionString = _connectionString
  };
  _sqlConnection.Open();
}
private void CloseConnection()
{
  if (_sqlConnection?.State != ConnectionState.Closed)
  {
    _sqlConnection?.Close();
  }
}

```

为了简洁起见，`InventoryDal`类中的大多数方法不会使用`try` / `catch`块来处理可能的异常，也不会抛出自定义异常来报告执行中的各种问题(例如，格式错误的连接字符串)。如果你要构建一个工业级的数据访问库，你绝对会想要使用结构化异常处理技术(如第 [7](07.html) 章所述)来解决任何运行时异常。

##### 添加 IDisposable

将`IDisposable`接口添加到类定义中，如下所示:

```cs
public class InventoryDal : IDisposable
{
...
}

```

接下来，实现一次性模式，在`SqlConnection`对象上调用`Dispose`。

```cs
bool _disposed = false;
protected virtual void Dispose(bool disposing)
{
  if (_disposed)
  {
    return;
  }
  if (disposing)
  {
    _sqlConnection.Dispose();
  }
  _disposed = true;
}
public void Dispose()
{
  Dispose(true);
  GC.SuppressFinalize(this);
}

```

#### 添加选择方法

首先，结合您已经知道的关于`Command`对象、`DataReader`和通用集合的知识，从`Inventory`表中获取记录。正如您在本章前面所看到的，数据提供者的数据读取器对象允许使用只读、只进机制和`Read()`方法来选择记录。在这个例子中，`DataReader`上的`CommandBehavior`属性被设置为当阅读器关闭时自动关闭连接。`GetAllInventory()`方法返回一个`List<CarViewModel>`来表示`Inventory`表中的所有数据。

```cs
public List<CarViewModel> GetAllInventory()
{
  OpenConnection();
  // This will hold the records.
  List<CarViewModel> inventory = new List<CarViewModel>();

  // Prep command object.
  string sql =
    @"SELECT i.Id, i.Color, i.PetName,m.Name as Make
          FROM Inventory i
          INNER JOIN Makes m on m.Id = i.MakeId";
  using SqlCommand command =
    new SqlCommand(sql, _sqlConnection)
    {
      CommandType = CommandType.Text
    };
  command.CommandType = CommandType.Text;
  SqlDataReader dataReader =
    command.ExecuteReader(CommandBehavior.CloseConnection);
  while (dataReader.Read())
  {
    inventory.Add(new CarViewModel
    {
      Id = (int)dataReader["Id"],
      Color = (string)dataReader["Color"],
      Make = (string)dataReader["Make"],
      PetName = (string)dataReader["PetName"]
    });
  }
  dataReader.Close();
  return inventory;
}

```

下一个选择方法基于`CarId`获得单个`CarViewModel`。

```cs
public CarViewModel GetCar(int id)
{
  OpenConnection();
  CarViewModel car = null;
  //This should use parameters for security reasons
  string sql =
   $@"SELECT i.Id, i.Color, i.PetName,m.Name as Make
          FROM Inventory i
          INNER JOIN Makes m on m.Id = i.MakeId
          WHERE i.Id = {id}";
  using SqlCommand command =
    new SqlCommand(sql, _sqlConnection)
    {
      CommandType = CommandType.Text
    };
  SqlDataReader dataReader =
    command.ExecuteReader(CommandBehavior.CloseConnection);
  while (dataReader.Read())
  {
    car = new CarViewModel
    {
      Id = (int) dataReader["Id"],
      Color = (string) dataReader["Color"],
      Make = (string) dataReader["Make"],
      PetName = (string) dataReader["PetName"]
    };
  }
  dataReader.Close();
  return car;
}

```

Note

像这里所做的那样，接受用户输入到原始 SQL 语句中通常是一种不好的做法。在本章的后面，这段代码将被更新以使用参数。

#### 插入一辆新车

向`Inventory`表中插入一条新记录非常简单，只需格式化 SQL `Insert`语句(基于用户输入)，打开连接，使用命令对象调用`ExecuteNonQuery()`，然后关闭连接。您可以通过向名为`InsertAuto()`的`InventoryDal`类型添加一个公共方法来看到这一点，该方法采用三个参数映射到`Inventory`表的不相同列(`Color`、`Make`和`PetName`)。您可以使用这些参数来格式化字符串类型，以便插入新记录。最后，使用您的`SqlConnection`对象来执行 SQL 语句。

```cs
public void InsertAuto(string color, int makeId, string petName)
{
  OpenConnection();
  // Format and execute SQL statement.
  string sql = $"Insert Into Inventory (MakeId, Color, PetName) Values ('{makeId}', '{color}', '{petName}')";
  // Execute using our connection.
  using (SqlCommand command = new SqlCommand(sql, _sqlConnection))
  {
    command.CommandType = CommandType.Text;
    command.ExecuteNonQuery();
  }
  CloseConnection();
}

```

前面的方法为`Car`取三个值，只要调用代码以正确的顺序传递这些值，它就能工作。一个更好的方法是使用`Car`来创建一个强类型方法，确保所有的属性都以正确的顺序传递到方法中。

##### 创建强类型 InsertCar()方法

向您的`InventoryDal`类添加另一个将`Car`作为参数的`InsertAuto()`方法，如下所示:

```cs
public void InsertAuto(Car car)
{
  OpenConnection();
  // Format and execute SQL statement.
  string sql = "Insert Into Inventory (MakeId, Color, PetName) Values " +
    $"('{car.MakeId}', '{car.Color}', '{car.PetName}')";

  // Execute using our connection.
  using (SqlCommand command = new SqlCommand(sql, _sqlConnection))
  {
    command.CommandType = CommandType.Text;
    command.ExecuteNonQuery();
  }
  CloseConnection();
}

```

### 添加删除逻辑

删除现有记录就像插入新记录一样简单。与您为`InsertAuto()`创建代码时不同，这次您将了解一个重要的`try` / `catch`作用域，该作用域处理尝试删除`Customers`表中某个人当前订购的汽车的可能性。外键的默认`INSERT`和`UPDATE`选项默认防止删除链接表中的相关记录。当这种情况发生时，抛出一个`SqlException`。真正的程序会智能地处理错误；然而，在这个示例中，您只是抛出了一个新的异常。将以下方法添加到`InventoryDal`类类型中:

```cs
public void DeleteCar(int id)
{
  OpenConnection();
  // Get ID of car to delete, then do so.
  string sql = $"Delete from Inventory where Id = '{id}'";
  using (SqlCommand command = new SqlCommand(sql, _sqlConnection))
  {
    try
    {
      command.CommandType = CommandType.Text;
      command.ExecuteNonQuery();
    }
    catch (SqlException ex)
    {
      Exception error = new Exception("Sorry! That car is on order!", ex);
      throw error;
    }
  }
  CloseConnection();
}

```

### 添加更新逻辑

当涉及到更新`Inventory`表中现有记录的行为时，您必须决定的第一件事是您希望允许调用者更改什么，是汽车的颜色、昵称、品牌，还是所有这些。给予调用者完全灵活性的一种方法是定义一个方法，该方法采用一个`string`类型来表示任何类型的 SQL 语句，但这充其量也是有风险的。

理想情况下，您希望有一组允许调用者以多种方式更新记录的方法。但是，对于这个简单的数据访问库，您将定义一个方法，允许调用者更新给定汽车的昵称，如下所示:

```cs
public void UpdateCarPetName(int id, string newPetName)
{
  OpenConnection();
  // Get ID of car to modify the pet name.
  string sql = $"Update Inventory Set PetName = '{newPetName}' Where Id = '{id}'";
  using (SqlCommand command = new SqlCommand(sql, _sqlConnection))
  {
    command.ExecuteNonQuery();
  }
  CloseConnection();
}

```

### 使用参数化命令对象

目前，`InventoryDal`类型的插入、更新和删除逻辑对每个 SQL 查询使用硬编码的字符串。使用*参数化查询*，SQL 参数是对象，而不是简单的文本块。以更加面向对象的方式处理 SQL 查询有助于减少打字错误的数量(给定强类型属性)；另外，参数化查询的执行速度通常比文字 SQL 字符串快得多，因为它们只被解析一次(而不是每次 SQL 字符串被分配给`CommandText`属性)。参数化查询还有助于防范 SQL 注入攻击(一个众所周知的数据访问安全问题)。

为了支持参数化查询，ADO.NET 命令对象维护单个参数对象的集合。默认情况下，这个集合是空的，但是您可以插入任意数量的参数对象，这些对象映射到 SQL 查询中的一个*占位符参数*。当您想要将 SQL 查询中的参数与 command 对象的 parameters 集合中的成员相关联时，您可以在 SQL 文本参数前面加上符号`@`(至少在使用 Microsoft SQL Server 时是这样；并非所有 DBMSs 都支持这种表示法)。

#### 使用 DbParameter 类型指定参数

在构建参数化查询之前，您需要熟悉`DbParameter`类型(它是提供者的特定参数对象的基类)。该类维护许多属性，这些属性允许您配置参数的名称、大小和数据类型，以及其他特征，包括参数的行进方向。表 [21-6](#Tab6) 描述了`DbParameter`型的一些关键特性。

表 21-6。

`DbParameter`类型的主要成员

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

财产

 | 

生命的意义

 |
| --- | --- |
| `DbType` | 获取或设置参数的本机数据类型，表示为 CLR 数据类型 |
| `Direction` | 获取或设置参数是仅输入、仅输出、双向还是返回值参数 |
| `IsNullable` | 获取或设置参数是否接受空值 |
| `ParameterName` | 获取或设置`DbParameter`的名称 |
| `Size` | 获取或设置数据的最大参数大小(以字节为单位)；这仅对文本数据有用 |
| `Value` | 获取或设置参数的值 |

现在让我们看看如何通过修改`InventoryDal`方法来使用参数，从而填充一个命令对象的`DBParameter`兼容对象的集合。

#### 更新 GetCar 方法

在构建 SQL 字符串来检索汽车数据时，`GetCar()`方法的最初实现使用了 C#字符串插值法。要更新这个方法，用适当的值创建一个`SqlParameter`的实例，如下所示:

```cs
SqlParameter param = new SqlParameter
{
  ParameterName = "@carId",
  Value = id,
  SqlDbType = SqlDbType.Int,
  Direction = ParameterDirection.Input
};

```

`ParameterName`值必须与 SQL 查询中使用的名称匹配(接下来您将更新它)，类型必须与数据库列类型匹配，方向取决于参数是用于将数据*发送到查询`ParameterDirection.Input`的*中，还是用于从查询(`ParameterDirection.Output`)返回数据*。参数也可以定义为输入/输出或返回值(例如，来自存储过程)。*

接下来，更新 SQL 字符串以使用参数名(`"@carId"`)而不是 C#字符串插值构造(`"{id}"`)。

```cs
string sql =
  @"SELECT i.Id, i.Color, i.PetName,m.Name as Make
        FROM Inventory i
        INNER JOIN Makes m on m.Id = i.MakeId
        WHERE i.Id = @CarId";

```

最后的更新是将新参数添加到 command 对象的`Parameters`集合中。

```cs
command.Parameters.Add(param);

```

#### 更新 DeleteCar 方法

同样，`DeleteCar()`方法的最初实现使用了 C#字符串插值。要更新这个方法，用适当的值创建一个`SqlParameter`的实例，如下所示:

```cs
SqlParameter param = new SqlParameter
{
  ParameterName = "@carId",
  Value = id,
  SqlDbType = SqlDbType.Int,
  Direction = ParameterDirection.Input
};

```

接下来，更新 SQL 字符串以使用参数名(`"@carId"`)。

```cs
string sql = "Delete from Inventory where Id = @carId";

```

最后的更新是将新参数添加到 command 对象的`Parameters`集合中。

```cs
command.Parameters.Add(param);

```

#### 更新 UpdateCarPetName 方法

这个方法需要两个参数，一个是汽车`Id`的，另一个是新`PetName`的。第一个参数的创建与前两个示例一样(除了不同的变量名)，第二个参数创建一个映射到数据库`NVarChar`类型的参数(来自`Inventory`表的`PetName`字段类型)。请注意，设置了一个`Size`值。重要的是，该大小要与数据库字段大小相匹配，以免在执行命令时出现问题。

```cs
SqlParameter paramId = new SqlParameter
{
  ParameterName = "@carId",
  Value = id,
  SqlDbType = SqlDbType.Int,
  Direction = ParameterDirection.Input
};
SqlParameter paramName = new SqlParameter
{
  ParameterName = "@petName",
  Value = newPetName,
  SqlDbType = SqlDbType.NVarChar,
  Size = 50,
  Direction = ParameterDirection.Input
};

```

接下来，更新 SQL 字符串以使用参数。

```cs
string sql = $"Update Inventory Set PetName = @petName Where Id = @carId";

```

最后的更新是将新参数添加到 command 对象的`Parameters`集合中。

```cs
command.Parameters.Add(paramId);
command.Parameters.Add(paramName);

```

#### 更新 internauto 方法

添加以下版本的`InsertAuto()`方法来利用参数对象:

```cs
public void InsertAuto(Car car)
{
  OpenConnection();
  // Note the "placeholders" in the SQL query.
  string sql = "Insert Into Inventory" +
    "(MakeId, Color, PetName) Values" +
    "(@MakeId, @Color, @PetName)";

  // This command will have internal parameters.
  using (SqlCommand command = new SqlCommand(sql, _sqlConnection))
  {
    // Fill params collection.
    SqlParameter parameter = new SqlParameter
    {
      ParameterName = "@MakeId",
      Value = car.MakeId,
      SqlDbType = SqlDbType.Int,
      Direction = ParameterDirection.Input
    };
    command.Parameters.Add(parameter);

    parameter = new SqlParameter
    {
      ParameterName = "@Color",
      Value = car.Color,
      SqlDbType = SqlDbType. NVarChar,
      Size = 50,
      Direction = ParameterDirection.Input
    };
    command.Parameters.Add(parameter);

    parameter = new SqlParameter
    {
      ParameterName = "@PetName",
      Value = car.PetName,
      SqlDbType = SqlDbType. NVarChar,
      Size = 50,
      Direction = ParameterDirection.Input
    };
    command.Parameters.Add(parameter);

    command.ExecuteNonQuery();
    CloseConnection();
  }
}

```

虽然构建参数化查询通常需要更多代码，但最终结果是以更方便的方式以编程方式调整 SQL 语句，并获得更好的整体性能。当您想要触发存储过程时，它们也非常有用。

### 执行存储过程

回想一下，*存储过程*是存储在数据库中的 SQL 代码的命名块。您可以构造存储过程，使它们返回一组行或标量数据类型，或者执行任何其他有意义的操作(例如，插入、更新或删除记录)；您也可以让它们接受任意数量的可选参数。最终结果是一个行为类似于典型方法的工作单元，除了它位于数据存储而不是二进制业务对象上。目前，`AutoLot`数据库定义了一个名为`GetPetName`的存储过程。

现在考虑下面的`InventoryDal`类型的最后一个方法，它调用您的存储过程:

```cs
public string LookUpPetName(int carId)
{
  OpenConnection();
  string carPetName;

  // Establish name of stored proc.
  using (SqlCommand command = new SqlCommand("GetPetName", _sqlConnection))
  {
    command.CommandType = CommandType.StoredProcedure;

    // Input param.
    SqlParameter param = new SqlParameter
    {
      ParameterName = "@carId",
      SqlDbType = SqlDbType.Int,
      Value = carId,
      Direction = ParameterDirection.Input
    };
    command.Parameters.Add(param);

    // Output param.
    param = new SqlParameter
    {
      ParameterName = "@petName",
      SqlDbType = SqlDbType.NVarChar,
      Size = 50,
      Direction = ParameterDirection.Output
    };
    command.Parameters.Add(param);

    // Execute the stored proc.
    command.ExecuteNonQuery();

    // Return output param.
    carPetName = (string)command.Parameters["@petName"].Value;
    CloseConnection();
  }
  return carPetName;
}

```

调用存储过程的一个重要方面是要记住，命令对象可以表示 SQL 语句(默认)或存储过程的名称。当你想通知一个命令对象它将调用一个存储过程时，你传入该过程的名称(作为一个构造函数参数或者通过使用`CommandText`属性)并且必须将`CommandType`属性设置为值`CommandType.StoredProcedure`。(如果您未能做到这一点，您将会收到一个运行时异常，因为默认情况下命令对象需要一个 SQL 语句。)

接下来，请注意，`@petName`参数的`Direction`属性被设置为`ParameterDirection.Output`。和前面一样，将每个参数对象添加到命令对象的参数集合中。

在存储过程通过调用`ExecuteNonQuery()`完成之后，您可以通过研究命令对象的参数集合和相应的转换来获得输出参数的值。

```cs
// Return output param.
carPetName = (string)command.Parameters["@petName"].Value;

```

至此，您已经有了一个极其简单的数据访问库，可以用它来构建一个显示和编辑数据的客户机。您还没有研究如何构建图形用户界面，所以接下来您将从新的控制台应用测试您的数据库。

## 创建基于控制台的客户端应用

向`AutoLot.Dal`解决方案添加一个新的控制台应用(名为`AutoLot.Client`)并添加一个对`AutoLot.Dal`项目的引用。完成此任务的`dotnet` CLI 命令如下(假设您的解决方案名为`Chapter21_AllProjects.sln`):

```cs
dotnet new console -lang c# -n AutoLot.Client -o .\AutoLot.Client -f net5.0
dotnet sln .\Chapter21_AllProjects.sln add .\AutoLot.Client
dotnet add AutoLot.Client package Microsoft.Data.SqlClient
dotnet add AutoLot.Client reference AutoLot.Dal

```

如果使用 Visual Studio，右击您的解决方案并选择“添加➤新项目”。将新项目设置为启动项目(通过在解决方案资源管理器中右击该项目并选择“设置为启动项目”)。这将在 Visual Studio 中调试时运行您的新项目。如果您使用的是 Visual Studio 代码，您需要导航到`AutoLot.Test`目录并使用`dotnet run`运行项目(当时间到了的时候)。

清除`Program.cs`中生成的代码，并将下面的`using`语句添加到`Program.cs`的顶部:

```cs
using System;
using System.Linq;
using AutoLot.Dal;
using AutoLot.Dal.Models;
using AutoLot.Dal.DataOperations;
using System.Collections.Generic;

```

用下面的代码替换`Main()`方法来练习`AutoLot.Dal`:

```cs
InventoryDal dal = new InventoryDal();
List<CarViewModel> list = dal.GetAllInventory();
Console.WriteLine(" ************** All Cars ************** ");
Console.WriteLine("Id\tMake\tColor\tPet Name");
foreach (var itm in list)
{
  Console.WriteLine($"{itm.Id}\t{itm.Make}\t{itm.Color}\t{itm.PetName}");
}
Console.WriteLine();
CarViewModel car = dal.GetCar(list.OrderBy(x=>x.Color).Select(x => x.Id).First());
Console.WriteLine(" ************** First Car By Color ************** ");
Console.WriteLine("CarId\tMake\tColor\tPet Name");
Console.WriteLine($"{car.Id}\t{car.Make}\t{car.Color}\t{car.PetName}");

try
{
  //This will fail because of related data in the Orders table
  dal.DeleteCar(5);
  Console.WriteLine("Car deleted.");
}
catch (Exception ex)
{
  Console.WriteLine($"An exception occurred: {ex.Message}");
}
dal.InsertAuto(new Car { Color = "Blue", MakeId = 5, PetName = "TowMonster" });
list = dal.GetAllInventory();
var newCar = list.First(x => x.PetName == "TowMonster");
Console.WriteLine(" ************** New Car ************** ");
Console.WriteLine("CarId\tMake\tColor\tPet Name");

Console.WriteLine($"{newCar.Id}\t{newCar.Make}\t{newCar.Color}\t{newCar.PetName}");
dal.DeleteCar(newCar.Id);
var petName = dal.LookUpPetName(car.Id);
Console.WriteLine(" ************** New Car ************** ");
Console.WriteLine($"Car pet name: {petName}");
Console.Write("Press enter to continue...");
Console.ReadLine();

```

## 了解数据库事务

让我们通过了解数据库事务的概念来结束对 ADO.NET 的研究。简单地说，一个*事务*是一组数据库操作，它们作为一个整体单元成功*或失败*。如果其中一个操作失败，所有其他操作都将回滚，就像什么都没发生过一样。可以想象，事务对于确保表数据的安全性、有效性和一致性非常重要。

当数据库操作涉及与多个表或多个存储过程(或数据库原子的组合)进行交互时，事务非常重要。典型的交易示例涉及在两个银行账户之间转移货币资金的过程。例如，如果您要将 500 美元从您的储蓄账户转入您的支票账户，则应以交易方式执行以下步骤:

1.  银行应该从你的储蓄账户中取出 500 美元。

2.  银行应该在你的支票账户上加 500 美元。

如果钱从储蓄账户中取出，但没有转到支票账户(因为银行方面的一些错误),这将是一件非常糟糕的事情，因为那样你将损失 500 美元！但是，如果这些步骤被打包到一个数据库事务中，DBMS 会确保所有相关步骤作为一个单元发生。如果事务的任何部分失败，整个操作将*回滚*到原始状态。另一方面，如果所有步骤都成功了，事务就会被*提交*。

Note

您可能在阅读交易文献时熟悉缩写 ACID。这代表了一个适当的事务的四个关键属性:*原子的*(全有或全无)、*一致的*(数据在整个事务中保持稳定)、*隔离的*(事务不干扰其他操作)、以及*持久的*(事务被保存和记录)。

事实证明。NET 核心平台支持多种方式的交易。本章将研究您的 ADO.NET 数据提供者的事务对象(在`Microsoft.Data.SqlClient`的情况下，是`SqlTransaction`)。

除了内置的事务支持之外。NET 基本类库，可以使用数据库管理系统的 SQL 语言。例如，您可以编写一个使用`BEGIN TRANSACTION`、`ROLLBACK`和`COMMIT`语句的存储过程。

### ADO.NET 事务对象的主要成员

我们将使用的所有事务都实现了`IDbTransaction`接口。回想一下本章开始时，`IDbTransaction`将一些成员定义如下:

```cs
public interface IDbTransaction : IDisposable
{
  IDbConnection Connection { get; }
  IsolationLevel IsolationLevel { get; }

  void Commit();
  void Rollback();
}

```

注意`Connection`属性，它返回对启动当前事务的连接对象的引用(正如您将看到的，您从给定的连接对象中获得一个事务对象)。当每个数据库操作成功时，调用`Commit()`方法。这样做将导致每个挂起的更改都保留在数据存储中。相反，如果出现运行时异常，您可以调用`Rollback()`方法，通知 DBMS 忽略任何挂起的更改，保持原始数据不变。

Note

transaction 对象的`IsolationLevel`属性允许您指定一个事务应该如何积极地防范其他并行事务的活动。默认情况下，事务在提交之前是完全隔离的。

除了由`IDbTransaction`接口定义的成员之外，`SqlTransaction`类型还定义了一个名为`Save()`的额外成员，它允许您定义*保存点*。这个概念允许您将失败的事务回滚到指定的点，而不是回滚整个事务。本质上，当您使用`SqlTransaction`对象调用`Save()`时，您可以指定一个友好的字符串名字对象。当您调用`Rollback()`时，您可以指定这个相同的名字作为参数来执行有效的*部分回滚*。不带参数调用`Rollback()`会导致所有挂起的更改回滚。

## 将交易方法添加到库存

现在让我们看看如何以编程方式处理 ADO.NET 事务。首先打开您之前创建的`AutoLot.Dal`代码库项目，并将一个名为`ProcessCreditRisk()`的新公共方法添加到`InventoryDal`类中，以处理感知的信用风险。该方法将查找一个客户，将他们添加到`CreditRisks`表中，然后通过在末尾添加“(信用风险)”来更新他们的姓氏。

```cs
public void ProcessCreditRisk(bool throwEx, int customerId)
{
  OpenConnection();
  // First, look up current name based on customer ID.
  string fName;
  string lName;
  var cmdSelect = new SqlCommand(
    "Select * from Customers where Id = @customerId",
    _sqlConnection);
  SqlParameter paramId = new SqlParameter
  {
    ParameterName = "@customerId",
    SqlDbType = SqlDbType.Int,
    Value = customerId,
    Direction = ParameterDirection.Input
  };
  cmdSelect.Parameters.Add(paramId);
  using (var dataReader = cmdSelect.ExecuteReader())
  {
    if (dataReader.HasRows)
    {
      dataReader.Read();
      fName = (string) dataReader["FirstName"];
      lName = (string) dataReader["LastName"];
    }
    else
    {
      CloseConnection();
      return;
    }
  }
  cmdSelect.Parameters.Clear();
// Create command objects that represent each step of the operation.
  var cmdUpdate = new SqlCommand(
    "Update Customers set LastName = LastName + ' (CreditRisk) ' where Id = @customerId",
    _sqlConnection);
  cmdUpdate.Parameters.Add(paramId);
  var cmdInsert = new SqlCommand(
    "Insert Into CreditRisks (CustomerId,FirstName, LastName) Values( @CustomerId, @FirstName, @LastName)",
    _sqlConnection);
  SqlParameter parameterId2 = new SqlParameter
  {
    ParameterName = "@CustomerId",
    SqlDbType = SqlDbType.Int,
    Value = customerId,
    Direction = ParameterDirection.Input
  };
  SqlParameter parameterFirstName = new SqlParameter

  {
    ParameterName = "@FirstName",
    Value = fName,
    SqlDbType = SqlDbType.NVarChar,
    Size = 50,
    Direction = ParameterDirection.Input
  };
  SqlParameter parameterLastName = new SqlParameter
  {
    ParameterName = "@LastName",
    Value = lName,
    SqlDbType = SqlDbType.NVarChar,
    Size = 50,
    Direction = ParameterDirection.Input
  };

  cmdInsert.Parameters.Add(parameterId2);
  cmdInsert.Parameters.Add(parameterFirstName);
  cmdInsert.Parameters.Add(parameterLastName);
  // We will get this from the connection object.
  SqlTransaction tx = null;
  try
  {
    tx = _sqlConnection.BeginTransaction();
    // Enlist the commands into this transaction.
    cmdInsert.Transaction = tx;
    cmdUpdate.Transaction = tx;
    // Execute the commands.
    cmdInsert.ExecuteNonQuery();
    cmdUpdate.ExecuteNonQuery();
    // Simulate error.
    if (throwEx)
    {
      throw new Exception("Sorry!  Database error! Tx failed...");
    }
    // Commit it!
    tx.Commit();
  }
  catch (Exception ex)
  {
    Console.WriteLine(ex.Message);
    // Any error will roll back transaction.  Using the new conditional access operator to check for null.
    tx?.Rollback();
  }
  finally
  {
    CloseConnection();
  }
}

```

这里，您使用一个传入的`bool`参数来表示当您试图处理违规的客户时是否会抛出一个任意的异常。这允许您模拟会导致数据库事务失败的意外情况。显然，您在这里这样做只是为了说明的目的；真正的数据库事务方法不会允许调用者心血来潮地强迫逻辑失败！

注意，您使用两个`SqlCommand`对象来表示您将开始的事务中的每一步。在根据传入的`customerID`参数获得客户的名字和姓氏之后，可以使用`BeginTransaction()`从连接对象中获得一个有效的`SqlTransaction`对象。接下来，也是最重要的，您必须通过将`Transaction`属性分配给您刚刚获得的事务对象来*登记每个命令对象*。如果您没有这样做，`Insert` / `Update`逻辑将不会在事务上下文中。

在每个命令上调用`ExecuteNonQuery()`之后，当(且仅当)参数`bool`的值为`true`时，抛出异常。在这种情况下，所有挂起的数据库操作都将回滚。如果您没有抛出异常，那么一旦您调用了`Commit()`，这两个步骤都将被提交给数据库表。

### 测试您的数据库事务

选择您添加到 customers 表中的一个客户(例如，Dave Benner，`Id` = 1)。接下来，在自动 Lot 中添加一个新方法到`Program.cs`。客户项目名为`FlagCustomer()`。

```cs
void FlagCustomer()
{
  Console.WriteLine("***** Simple Transaction Example *****\n");

  // A simple way to allow the tx to succeed or not.
  bool throwEx = true;
  Console.Write("Do you want to throw an exception (Y or N): ");
  var userAnswer = Console.ReadLine();
  if (string.IsNullOrEmpty(userAnswer) || userAnswer.Equals("N",StringComparison.OrdinalIgnoreCase))
  {
    throwEx = false;
  }
  var dal = new InventoryDal();
  // Process customer 1 – enter the id for the customer to move.
  dal.ProcessCreditRisk(throwEx, 1);
  Console.WriteLine("Check CreditRisk table for results");
  Console.ReadLine();
}

```

如果您要运行您的程序并选择抛出一个异常，您会发现客户的姓是*，而不是`Customers`表中的*，因为整个事务已经回滚。但是，如果您没有抛出异常，您会发现客户的姓氏在`Customers`表中被更新，并被添加到`CreditRisks`表中。

## 使用 ADO.NET 执行批量复制

在需要将大量记录加载到数据库中的情况下，目前显示的方法效率相当低。SQL Server 有一个名为*批量复制*的特性，它是专门为这个场景设计的，在 ADO.NET 中用`SqlBulkCopy`类包装。本章的这一节将介绍如何使用 ADO.NET 来实现这一点。

### 探索 SqlBulkCopy 类

`SqlBulkCopy`类有一个方法`WriteToServer()`(和异步版本`WriteToServerAsync()`)，它处理记录列表并将数据写入数据库，比编写一系列`insert`语句并用`Command`对象运行它们更有效。`WriteToServer`重载使用一个`DataTable`、一个`DataReader`或一个`DataRow`数组。为了与本章的主题保持一致，您将使用`DataReader`版本。为此，您需要创建一个定制的数据读取器。

### 创建自定义数据读取器

您希望您的自定义数据读取器是通用的，并保存您要导入的模型列表。首先在名为`BulkImport`的`AutoLot.Dal`项目中创建一个新文件夹；在文件夹中，创建一个名为`IMyDataReader.cs`的实现`IDataReader`的新接口类，并将代码更新如下:

```cs
using System.Collections.Generic;
using System.Data;

namespace AutoLot.Dal.BulkImport
{
  public interface IMyDataReader<T> : IDataReader
  {
    List<T> Records { get; set; }
  }
}

```

接下来是实现自定义数据读取器的任务。正如您已经看到的，数据读取器有许多活动部件。对你来说好消息是，对于`SqlBulkCopy`，你只需要实现其中的一小部分。创建一个名为`MyDataReader.cs`的新类，并添加以下`using`语句:

```cs
using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Reflection;

```

接下来，将类更新为 public 和 sealed 并实现`IMyDataReader`。添加一个构造函数来接收记录并设置属性。

```cs
public sealed class MyDataReader<T> : IMyDataReader<T>
{
  public List<T> Records { get; set; }
  public MyDataReader(List<T> records)
  {
    Records = records;
  }
}

```

让 Visual Studio 或 Visual Studio 代码为您实现所有方法(或从下面复制它们)，您就有了自定义数据读取器的起点。表 [21-7](#Tab7) 详细说明了这种情况下需要实现的唯一方法。

表 21-7。

`IDataReader`的关键方法为`SqlBulkCopy`

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

方法

 | 

生命的意义

 |
| --- | --- |
| `Read` | 获取下一条记录；如果有另一条记录，则返回`true`,如果在列表末尾，则返回`false` |
| `FieldCount` | 获取数据源中的字段总数 |
| `GetValue` | 根据序号位置获取字段的值 |
| `GetSchemaTable` | 获取目标表的架构信息 |

从`Read()`方法开始，如果读取器在列表的末尾，则返回`false`，如果读取器不在列表的末尾，则返回`true`(并增加一个类级计数器)。添加一个类级变量来保存`List<T>`的当前索引，并更新`Read()`方法，如下所示:

```cs
public class MyDataReader<T> : IMyDataReader<T>
{
...
  private int _currentIndex = -1;
  public bool Read()
  {
    if (_currentIndex + 1 >= Records.Count)
    {
      return false;
    }
    _currentIndex++;
    return true;
  }
}

```

`get`方法和`FieldCount`方法中的每一种都需要对要加载的特定模型有深入的了解。`GetValue()`方法的一个例子(使用`CarViewModel`)如下:

```cs
public object GetValue(int i)
{
  Car currentRecord = Records[_currentIndex] as Car;
  return i switch
  {
    0 => currentRecord.Id,
    1 => currentRecord.MakeId,
    2 => currentRecord.Color,
    3 => currentRecord.PetName,
    4 => currentRecord.TimeStamp,
    _ => string.Empty,
  };
}

```

数据库只有四个表，但这意味着您仍然有四种不同的数据读取器。想象一下，如果您有一个包含更多表的真正的生产数据库！你可以使用反射(在第 17 章中介绍)和对象 LINQ(在第 13 章中介绍)做得更好。

添加`readonly`变量来保存模型的`PropertyInfo`值，并添加一个字典来保存 SQL Server 中表的字段位置和名称。更新构造函数以获取泛型类型的属性并初始化`Dictionary`。添加的代码如下:

```cs
private readonly PropertyInfo[] _propertyInfos;
private readonly Dictionary<int, string> _nameDictionary;

public MyDataReader(List<T> records)
{
  Records = records;
  _propertyInfos = typeof(T).GetProperties();
  _nameDictionary = new Dictionary<int,string>();
}

```

接下来，更新构造函数以获取一个`SQLConnection`以及模式的字符串和记录将要插入的表的表名，并为值添加类级别的变量。

```cs
private readonly SqlConnection _connection;
private readonly string _schema;
private readonly string _tableName;
public MyDataReader(List<T> records, SqlConnection connection, string schema, string tableName)
{
  Records = records;
  _propertyInfos = typeof(T).GetProperties();
  _nameDictionary = new Dictionary<int, string>();

  _connection = connection;
  _schema = schema;
  _tableName = tableName;
}

```

接下来实现`GetSchemaTable()`方法。这将检索关于目标表的 SQL Server 信息。

```cs
public DataTable GetSchemaTable()
{
  using var schemaCommand = new SqlCommand($"SELECT * FROM {_schema}.{_tableName}", _connection);
  using var reader = schemaCommand.ExecuteReader(CommandBehavior.SchemaOnly);
  return reader.GetSchemaTable();
}

```

更新构造函数以使用`SchemaTable`来构造字典，该字典按照数据库顺序包含目标表的字段。

```cs
public MyDataReader(List<T> records, SqlConnection connection, string schema, string tableName)
{
...
  DataTable schemaTable = GetSchemaTable();
  for (int x = 0; x<schemaTable?.Rows.Count;x++)
  {
    DataRow col = schemaTable.Rows[x];
    var columnName = col.Field<string>("ColumnName");
    _nameDictionary.Add(x,columnName);
  }
}

```

现在，可以使用反射的信息一般地实现以下方法:

```cs
public int FieldCount => _propertyInfos.Length;
public object GetValue(int i)
  => _propertyInfos
      .First(x=>x.Name.Equals(_nameDictionary[i],StringComparison.OrdinalIgnoreCase))
      .GetValue(Records[_currentIndex]);

```

这里列出了必须存在(但未实现)的其余方法，以供参考:

```cs
public string GetName(int i) => throw new NotImplementedException();
public int GetOrdinal(string name) => throw new NotImplementedException();
public string GetDataTypeName(int i) => throw new NotImplementedException();
public Type GetFieldType(int i) => throw new NotImplementedException();
public int GetValues(object[] values) => throw new NotImplementedException();
public bool GetBoolean(int i) => throw new NotImplementedException();
public byte GetByte(int i) => throw new NotImplementedException();
public long GetBytes(int i, long fieldOffset, byte[] buffer, int bufferoffset, int length)
  => throw new NotImplementedException();
public char GetChar(int i) => throw new NotImplementedException();
public long GetChars(int i, long fieldoffset, char[] buffer, int bufferoffset, int length)
   => throw new NotImplementedException();
public Guid GetGuid(int i) => throw new NotImplementedException();
public short GetInt16(int i) => throw new NotImplementedException();
public int GetInt32(int i) => throw new NotImplementedException();
public long GetInt64(int i) => throw new NotImplementedException();
public float GetFloat(int i) => throw new NotImplementedException();
public double GetDouble(int i)  => throw new NotImplementedException();
public string GetString(int i) => throw new NotImplementedException();
public decimal GetDecimal(int i) => throw new NotImplementedException();
public DateTime GetDateTime(int i) => throw new NotImplementedException();
public IDataReader GetData(int i) => throw new NotImplementedException();
public bool IsDBNull(int i) => throw new NotImplementedException();
object IDataRecord.this[int i] => throw new NotImplementedException();
object IDataRecord.this[string name] => throw new NotImplementedException();
public void Close() => throw new NotImplementedException();
public DataTable GetSchemaTable() => throw new NotImplementedException();
public bool NextResult() => throw new NotImplementedException();
public int Depth { get; }
public bool IsClosed { get; }
public int RecordsAffected { get; }

```

### 执行批量复制

在`BulkImport`文件夹中添加一个名为`ProcessBulkImport.cs`的新`public static`类。将以下`using`语句添加到文件的顶部:

```cs
using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using Microsoft.Data.SqlClient;

```

添加处理打开和关闭连接的代码(类似于`InventoryDal`类中的代码)，如下所示:

```cs
private const string ConnectionString =
  @"Data Source=.,5433;User Id=sa;Password=P@ssw0rd;Initial Catalog=AutoLot";
private static SqlConnection _sqlConnection = null;

private static void OpenConnection()
{
  _sqlConnection = new SqlConnection
  {
    ConnectionString = ConnectionString
  };
  _sqlConnection.Open();
}

private static void CloseConnection()
{
  if (_sqlConnection?.State != ConnectionState.Closed)
  {
    _sqlConnection?.Close();
  }
}

```

`SqlBulkCopy`类需要名称(和模式，如果不同于`dbo`)来处理记录。创建新的`SqlBulkCopy`实例(传入连接对象)后，设置`DestinationTableName`属性。然后，创建一个新的定制数据读取器实例，保存要批量复制的列表，并调用`WriteToServer()`。这里显示了`ExecuteBulkImport`方法:

```cs
public static void ExecuteBulkImport<T>(IEnumerable<T> records, string tableName)
{
  OpenConnection();
  using SqlConnection conn = _sqlConnection;
  SqlBulkCopy bc = new SqlBulkCopy(conn)
  {
    DestinationTableName = tableName
  };
  var dataReader = new MyDataReader<T>(records.ToList(),_sqlConnection, "dbo",tableName);    try
  {
    bc.WriteToServer(dataReader);
  }
  catch (Exception ex)
  {
    //Should do something here
  }
  finally
  {
    CloseConnection();
  }
}

```

### 测试批量副本

回到`AutoLot.Client`项目，向`Program.cs`添加以下`using`语句:

```cs
using AutoLot.Dal.BulkImport;
using SystemCollections.Generic;

```

给`Program.cs`添加一个新方法，名为`DoBulkCopy()`。创建一个`Car`对象的列表，并将该列表(以及表的名称)传递给`ExecuteBulkImport()`方法。其余代码显示批量复制的结果。

```cs
void DoBulkCopy()
{
  Console.WriteLine(" ************** Do Bulk Copy ************** ");
  var cars = new List<Car>
  {
    new Car() {Color = "Blue", MakeId = 1, PetName = "MyCar1"},
    new Car() {Color = "Red", MakeId = 2, PetName = "MyCar2"},
    new Car() {Color = "White", MakeId = 3, PetName = "MyCar3"},
    new Car() {Color = "Yellow", MakeId = 4, PetName = "MyCar4"}
  };
  ProcessBulkImport.ExecuteBulkImport(cars, "Inventory");
  InventoryDal dal = new InventoryDal();
  List<CarViewModel> list = dal.GetAllInventory();
  Console.WriteLine(" ************** All Cars ************** ");
  Console.WriteLine("CarId\tMake\tColor\tPet Name");
  foreach (var itm in list)
  {
    Console.WriteLine(
      $"{itm.Id}\t{itm.Make}\t{itm.Color}\t{itm.PetName}");
  }
  Console.WriteLine();
}

```

虽然添加四辆新车并不能展示使用`SqlBulkCopy`类所涉及的工作的价值，但是想象一下试图加载*数千条*记录。我曾经和客户这样做过，加载时间只有几秒钟，而遍历每条记录需要几个小时！就像所有的东西一样。NET Core，这只是您工具箱中的另一个工具，在最有意义的时候使用。

## 摘要

ADO.NET 是本地的数据访问技术。NET 核心平台。在这一章中，你从学习数据提供者的角色开始，数据提供者本质上是几个抽象基类(在`System.Data.Common`名称空间中)和接口类型(在`System.Data`名称空间中)的具体实现。您还看到了使用 ADO.NET 数据提供者工厂模型构建提供者中立的代码库是可能的。

您还了解了如何使用连接对象、事务对象、命令对象和数据读取器对象来选择、更新、插入和删除记录。此外，还记得 command 对象支持内部参数集合，您可以使用它为 SQL 查询增加一些类型安全性；事实证明，这些在触发存储过程时也非常有用。

接下来，您学习了如何用事务保护您的数据操作代码，并通过使用 ADO.NET 使用`SqlBulkCopy`类将大量数据加载到 SQL Server 来结束这一章。