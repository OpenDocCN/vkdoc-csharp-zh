# 29.介绍 ASP.NET 核心

本书的最后一节介绍了 ASP.NET 核心，这是使用 C#和。NET 核心。这一章介绍了 ASP.NET 核心和对以前版本的 web 开发框架 ASP.NET 的一些改变。

在了解了 ASP.NET 核心中实现的 MVC 模式的基础知识之后，您将开始构建两个能够协同工作的应用程序。第一个应用程序，一个 ASP.NET 核心 RESTful 服务，将在第 [30](30.html) 章完成。第二个是使用模型-视图-控制器模式的 ASP.NET 核心 web 应用程序，将在第 [31 章](31.html)中完成。自动手枪。达尔和奥托洛特。你在第 23 章[中完成的模型项目将作为两个应用程序的数据访问层。](23.html)

## 快速回顾

微软在 2007 年发布了 ASP.NET MVC，取得了巨大的成功。该框架基于模型-视图-控制器模式，为对 WebForms 感到沮丧的开发人员提供了一个答案，web forms 本质上是 HTTP 上一个有漏洞的抽象。WebForms 的创建是为了帮助客户机-服务器开发人员转移到 Web 上，在这方面它相当成功。然而，随着开发人员越来越习惯于 web 开发，许多人希望对呈现的输出进行更多的控制，消除视图状态，并遵循经过验证的 web 应用程序设计模式。有了这些目标，ASP.NET MVC 就诞生了。

### 介绍 MVC 模式

模型-视图-控制器(MVC)模式自 20 世纪 70 年代就已经存在，最初是作为 Smalltalk 中使用的模式而创建的。这种模式最近死灰复燃，用许多不同的语言实现，包括 Java (Spring Framework)、Ruby (Ruby on Rails)和。NET(ASP.NET MVC)。

#### 模型

*模型*是你的应用的数据。数据通常由普通的旧 CLR 对象(POCOs)表示。视图模型由一个或多个模型组成，并且是专门为数据消费者设计的。考虑模型和视图模型的一种方式是将它们与数据库表和数据库视图相关联。

从学术上讲，模型应该非常干净，不包含验证或任何其他业务规则。实际上，模型是否包含验证逻辑或其他业务规则完全取决于所使用的语言和框架，以及特定的应用程序需求。例如，EF Core 包含许多数据注释，这些注释既是形成数据库表的机制，也是在 ASP.NET Core web 应用程序中进行验证的手段。在本书中(以及在我的专业工作中)，示例集中在减少代码的重复，这将数据注释和验证放在它们最有意义的地方。

#### 景色

*视图*是应用程序的用户界面。视图接受命令并将这些命令的结果呈现给用户。视图应该尽可能的轻量级，并且不实际处理任何工作，而是将所有工作交给控制器。

#### 控制器

*控制器*是应用程序的大脑。控制器通过动作方法接受来自用户(通过视图)或客户机(通过 API 调用)的命令/请求，并适当地处理它们。然后，操作的结果被返回给用户或客户端。控制器应该是轻量级的，并利用其他组件或服务来处理请求的细节。这促进了关注点的分离，并增加了可测试性和可维护性。

### ASP.NET 核心和 MVC 模式

ASP.NET 核心能够创建许多类型的网络应用和服务。其中两个选项是使用 MVC 模式的 web 应用程序和 RESTful 服务。如果你使用过 ASP.NET 的“经典”，它们分别类似于 ASP.NET 的 MVC 和 ASP.NET 的 Web API。MVC web 应用程序和 API 应用程序类型共享模式的“模型”和“控制器”部分，而 MVC web 应用程序也实现“视图”来完成 MVC 模式。

## ASP.NET 核心和。净核心

正如实体框架核心是实体框架 6 的完全重写，ASP.NET 核心是流行的 ASP.NET 框架的重写。重写 ASP.NET 不是一件小事，但为了消除对`System.Web`的依赖，这是必要的。消除这种依赖性使 ASP.NET 应用程序能够在 Windows 之外的操作系统和 Internet 信息服务(IIS)之外的其他 web 服务器上运行，包括自托管。这为 ASP.NET 核心应用程序使用名为 Kestrel 的跨平台、轻量级、快速和开源的 web 服务器打开了大门。Kestrel 提供了跨所有平台的统一开发体验。

Note

Kestrel 最初基于 LibUV，但是从 ASP.NET 核心 2.1 开始，它现在基于托管套接字。

和 EF Core 一样，ASP.NET Core 也正在 GitHub 上开发，作为一个完全开源的项目(`https://` [`github.com/aspnet`](http://github.com/aspnet) )。它也被设计成一个 NuGet 包的模块化系统。开发人员只安装特定应用程序所需的功能，从而最小化应用程序的占用空间，减少开销，并降低安全风险。其他改进包括简化的启动、内置的依赖注入、更简洁的配置系统和可插拔的中间件。

### 一个框架，多种用途

ASP.NET 核心中有许多变化和改进，您将在本节的其余章节中看到。除了跨平台能力，另一个重要的变化是 web 应用程序框架的统一。ASP.NET 核心将 ASP.NET MVC、ASP.NET Web API 和 Razor Pages 包含在一个开发框架中。开发 web 应用程序和服务。NET 框架提供了几种选择，包括 WebForms、MVC、Web API、Windows Communication Foundation(WCF)和 WebMatrix。它们都有积极和消极的一面；有些是密切相关的，其他的则大不相同。所有可用的选择意味着开发人员必须了解每一个选择，以便为手头的任务选择合适的一个，或者只选择一个并希望最好的。

借助 ASP.NET 核心，您可以构建使用 Razor 页面、模型-视图-控制器模式、RESTful 服务的应用程序，以及使用 Angular 和 React 等 JavaScript 框架的 SPA 应用程序。虽然 UI 呈现会随着 MVC、Razor Pages 和 JavaScript 框架之间的选择而变化，但是底层开发框架在所有选择中都是相同的。之前的两个选择是 WebForms 和 WCF，它们没有被引入 ASP.NET 核心系统。

Note

由于所有的独立框架都在同一个屋檐下，ASP.NET MVC 和 ASP.NET Web API 的前身已经正式退役。在本书中，为了简单起见，我仍然将使用模型-视图-控制器模式的 ASP.NET 核心 web 应用程序称为 MVC，将 ASP.NET RESTful 服务称为 Web API。

## 来自 MVC/Web API 的 ASP.NET 核心特性

许多让开发人员使用 ASP.NET MVC 和 ASP.NET Web API 的设计目标和特性在 ASP.NET 核心中仍然受到支持(并得到了改进)。下面列出了其中的一些(但不是全部):

*   约定胜于配置

*   控制器和动作

*   模型绑定

*   模型验证

*   选择途径

*   过滤

*   布局和剃刀视图

这些将在接下来的章节中介绍，除了布局和 Razor 视图，它们将在第 [31](31.html) 章中介绍。

### 约定胜于配置

ASP.NET MVC 和 ASP.NET Web API 通过引入某些约定减少了必要的配置量。当遵循这些约定时，会减少手动(或模板化)配置的数量，但也要求开发人员了解这些约定以便利用它们。两个主要的约定包括命名约定和目录结构。

#### 命名规格

对于 MVC 和 API 应用程序，ASP.NET 核心有多种命名约定。例如，除了从`Controller`(或`ControllerBase`)派生之外，控制器通常以`Controller`后缀命名(例如`HomeController`)。通过路由访问时，`Controller`后缀会被删除。当查找控制器的视图时，控制器名称减去后缀就是开始搜索的位置。这种删除后缀的惯例在 ASP.NET 核心中重复出现。在接下来的章节中会有很多例子。

另一个命名约定用于视图位置和选择。默认情况下，一个动作方法(在 MVC 应用程序中)将呈现与该方法同名的视图。编辑器和显示模板以它们在视图中呈现的类命名。如果您的应用程序需要，可以更改这些默认值。所有这些都将在 AutoLot 时进一步探讨。构建 Mvc 应用程序。

#### 目录结构

要成功构建 ASP.NET 核心 web 应用程序和服务，您必须了解几个文件夹约定。

##### 控制器文件夹

按照惯例，`Controllers`文件夹是 ASP.NET 核心 MVC 和 API 实现(以及路由引擎)期望放置应用程序控制器的地方。

##### 视图文件夹

`Views`文件夹是存储应用程序视图的地方。每个控制器在以控制器名称命名的主`Views`文件夹下有自己的文件夹(减去`Controller`后缀)。默认情况下，操作方法将在其控制器的文件夹中呈现视图。例如，`Views/Home`文件夹保存了`HomeController`控制器类的所有视图。

###### 共享文件夹

在`Views`下面有一个特殊的文件夹叫做`Shared`。所有控制器及其操作方法都可以访问该文件夹。搜索以控制器命名的文件夹后，如果找不到视图，则在`Shared`文件夹中搜索视图。

##### wwwroot 文件夹(ASP。网络核心)

对 ASP.NET MVC 的一个改进是为 ASP.NET 核心 web 应用程序创建了一个名为`wwwroot`的特殊文件夹。在 ASP.NET MVC 中，JavaScript 文件、图像、CSS 和其他客户端内容与所有其他文件夹混合在一起。在 ASP.NET 核心中，客户端都包含在`wwwroot`文件夹下。当使用 ASP.NET 核心时，编译文件与客户端文件的这种分离显著地清理了项目结构。

### 控制器和动作

就像 ASP.NET MVC 和 ASP.NET Web API 一样，控制器和动作方法是 ASP.NET 核心 MVC 或 API 应用程序的核心。

#### 控制器类

如前所述，ASP.NET 核心统一了 ASP.NET mv C5 和 ASP.NET Web API。这种统一还将 MVC5 和 Web API 2.2 中的`Controller`、`ApiController`和`AsyncController`基类合并成一个新类`Controller`，它有自己的基类，名为`ControllerBase`。ASP.NET 核心 web 应用控制器继承自`Controller`类，而 ASP.NET 核心服务控制器继承自`ControllerBase`类(将在下一章介绍)。

`Controller`类为 web 应用程序提供了许多助手方法。表 [29-1](#Tab1) 列出了最常用的方法。

表 29-1

由`Controller`类提供的一些助手方法

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

助手方法

 | 

生命的意义

 |
| --- | --- |
| `ViewDataTempDataViewBag` | 通过`ViewDataDictionary`、`TempDataDictionary`和动态`ViewBag`传输向视图提供数据。 |
| `View` | 返回一个`ViewResult`(从`ActionResult`派生而来)作为 HTTP 响应。默认为与操作方法同名的视图，可以选择指定特定的视图。所有选项都允许指定一个强类型的`view model`并发送给`View`。视图包含在第 [31 章](31.html)中。 |
| `PartialView` | 向响应管道返回一个`PartialViewResult`。部分视图包含在第 [31 章](31.html)中。 |
| `ViewComponent` | 向响应管道返回一个`ViewComponentResult`。在第 31 章[中有涉及。](31.html) |
| `Json` | 返回一个包含一个序列化为 JSON 的对象的`JsonResult`作为响应。 |
| `OnActionExecuting` | 在操作方法执行之前执行。 |
| `OnActionExecutionAsync` | `OnActionExecuting`的异步版本。 |
| `OnActionExecuted` | 在操作方法执行后执行。 |

#### ControllerBase 类

除了返回 HTTP 状态代码的帮助方法之外，`ControllerBase`类还为 ASP.NET 核心 web 应用程序和服务提供了核心功能。表 [29-2](#Tab2) 列出了`ControllerBase`中的一些核心功能，表 [29-3](#Tab3) 涵盖了一些返回 HTTP 状态码的帮助器方法。

表 29-3

由`ControllerBase`类提供的一些 HTTP 状态代码帮助器方法

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

助手方法

 | 

HTTP 状态代码操作结果

 | 

状态代码

 |
| --- | --- | --- |
| `NoContent` | `NoContentResult` | `204` |
| `Ok` | `OkResult` | `200` |
| `NotFound` | `NotFoundResult` | `404` |
| `BadRequest` | `BadRequestResult` | `400` |
| `CreatedCreatedAtActionCreatedAtRoute` | `CreatedResultCreatedAtActionResultCreateAtRouteResult` | `201` |
| `AcceptedAcceptedAtActionAcceptedAtRoute` | `AcceptedResultAcceptedAtActionResultAcceptedAtRouteResult` | `202` |

表 29-2

由`ControllerBase`类提供的一些助手方法

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

助手方法

 | 

生命的意义

 |
| --- | --- |
| `HttpContext` | 返回当前正在执行的动作的`HttpContext`。 |
| `Request` | 返回当前正在执行的动作的`HttpRequest`。 |
| `Response` | 返回当前正在执行的动作的`HttpResponse`。 |
| `RouteData` | 返回当前执行动作的`RouteData`(路由将在本章后面介绍)。 |
| `ModelState` | 返回与模型绑定和验证相关的模型状态(这两个问题将在本章后面讨论)。 |
| `Url` | 返回`IUrlHelper`的实例，提供对 ASP.NET 核心 MVC 应用程序和服务的构建 URL 的访问。 |
| `User` | 返回`ClaimsPrincipal`用户。 |
| `Content` | 向响应返回一个`ContentResult`。重载允许添加内容类型和编码定义。 |
| `File` | 向响应返回一个`FileContentResult`。 |
| `Redirect` | 通过返回一个`RedirectResult`将用户重定向到另一个 URL 的一系列方法。 |
| `LocalRedirect` | 仅当 URL 是本地的时，将用户重定向到另一个 URL 的一系列方法。比一般的`Redirect`方法更安全。 |
| `RedirectToActionRedirectToPageRedirectToRoute` | 重定向到另一个动作方法、Razor 页面或命名路由的一系列方法。本章稍后将介绍路由。 |
| `TryUpdateModel` | 显式模型绑定(将在本章后面介绍)。 |
| `TryValidateModel` | 显式模型验证(将在本章后面介绍)。 |

#### 行动

动作是控制器上返回`IActionResult`(或者异步操作的`Task<IActionResult>`)或者实现`IActionResult`的类的方法，比如`ActionResult`或者`ViewResult`。在接下来的章节中将会详细介绍这些操作。

### 模型绑定

模型绑定是 ASP.NET 核心使用在 HTTP Post 调用中提交的名称-值对为模型赋值的过程。要绑定到引用类型，名称-值对来自表单值或请求正文，引用类型必须有一个公共的默认构造函数，并且要绑定的属性必须是公共的和可写的。当赋值时，隐式类型转换(例如使用`int`设置`string`属性值)在适用的地方被使用。如果类型转换不成功，该属性将被标记为错误。在更详细地讨论绑定之前，理解`ModelState`字典及其在绑定(和验证)过程中的作用是很重要的。

#### 模型状态字典

`ModelState`字典包含每个被绑定属性的一个条目和模型本身的一个条目。如果在模型绑定期间出现错误，绑定引擎会将错误添加到属性的字典条目中，并设置`ModelState.IsValid = false`。如果所有匹配的属性都被成功分配，绑定引擎将设置`ModelState.IsValid = true`。

Note

模型验证也设置了`ModelState`字典条目，发生在模型绑定之后。隐式和显式模型绑定都会自动调用模型验证。下一节将介绍验证。

##### 将自定义错误添加到模型状态字典中

除了由绑定引擎添加的属性和错误之外，还可以将自定义错误添加到`ModelState`字典中。可以在属性级别或整个模型中添加错误。要添加属性的特定错误(例如，`Car`实体的`PetName`属性)，请使用以下命令:

```cs
ModelState.AddModelError("PetName","Name is required");

```

要为整个模型添加一个错误，使用`string.Empty`作为属性名，如下所示:

```cs
ModelState.AddModelError(string.Empty, $"Unable to create record: {ex.Message}");

```

#### 隐式模型绑定

当要绑定的模型是动作方法的参数时，会发生隐式模型绑定。它对复杂类型使用反射和递归，将模型的可写属性名与发布到 action 方法的名称-值对中包含的名称进行匹配。如果存在名称匹配，绑定器将使用名称-值对中的值来尝试设置属性值。如果名称-值对中有多个名称匹配，则使用第一个匹配名称的值。如果找不到名称，该属性将设置为默认值。名称-值对的搜索顺序如下:

*   来自 HTTP Post 方法的表单值(包括 JavaScript AJAX posts)

*   请求体(用于 API 控制器)

*   通过 ASP.NET 核心路由提供的路由值(对于简单类型)

*   查询字符串值(对于简单类型)

*   上传的文件(针对`IFormFile`类型)

例如，下面的方法将尝试设置`Car`类型的所有属性。如果绑定过程没有错误地完成，`ModelState.IsValid`属性返回`true`。

```cs
[HttpPost]
public ActionResult Create(Car entity)
{
  if (ModelState.IsValid)
  {
    //Save the data;
  }
}

```

#### 显式模型绑定

显式模型绑定是通过调用`TryUpdateModelAsync()`来执行的，传递被绑定类型的实例和要绑定的属性列表。如果模型绑定失败，该方法返回`false`并以与隐式模型绑定相同的方法设置`ModelState`错误。当使用显式模型绑定时，被绑定的类型不是 action 方法的参数。例如，您可以这样编写前面的`Create()`方法，并使用显式模型绑定:

```cs
[HttpPost]
public async Task<IActionResult> Create()
{
  var vm = new Car();
  if (await TryUpdateModelAsync(vm,"",
     c=>c.Color,c=>c.PetName,c=>c.MakeId, c=>c.TimeStamp))
  {
    //do something important
  }
}

```

#### 绑定属性

HTTP Post 方法中的`Bind`属性允许您限制参与模型绑定的属性，或者为名称-值对中的名称设置前缀。限制可以绑定的属性有助于减少过度发布攻击的威胁。如果一个`Bind`属性被放置在一个引用参数上，那么在`Include`列表中列出的字段是唯一将通过模型绑定被分配的字段。如果没有使用`Bind`属性，所有字段都是可绑定的。

在下面的`Create()`动作方法示例中，`Car`实例上的所有字段都可以用于模型绑定，因为没有使用`Bind`属性:

```cs
[HttpPost]
[ValidateAntiForgeryToken]
public IActionResult Create(Car car)
{
  if (ModelState.IsValid)
  {
    //Add the record
  }
    //Allow the user to retry
}

```

假设您的业务需求指定只允许更新`Create()`方法中的`PetName`和`Color`字段。添加`Bind`属性(如下例所示)会限制参与绑定的属性，并指示模型绑定器忽略其余的属性。

```cs
[HttpPost]
[ValidateAntiForgeryToken]
public ActionResult Create(
[Bind(nameof(Car.PetName),nameof(Car.Color))]Car car)
{
  if (ModelState.IsValid)
  {
    //Save the data;
  }
    //Allow the user to retry

}

```

`Bind`属性也可以用来指定属性名的前缀。如果名称-值对的名称在发送给 action 方法时添加了前缀，那么`Bind`属性用于通知`ModelBinder`如何将名称映射到类型的属性。以下示例为名称设置前缀，并允许绑定所有属性:

```cs
[HttpPost]
[ValidateAntiForgeryToken]
public ActionResult Create(
[Bind(Prefix="MakeList")]Car car)
{
  if (ModelState.IsValid)
  {
    //Save the data;
  }
}

```

#### 控制 ASP.NET 核心中的模型绑定源

绑定源可以通过动作参数上的一组属性来控制。也可以创建定制的模型绑定；然而，这超出了本书的范围。表 [29-4](#Tab4) 列出了可用于控制模型绑定的属性。

表 29-4

控制模型绑定源

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

属性

 | 

生命的意义

 |
| --- | --- |
| `BindingRequired` | 如果无法发生绑定，将会添加模型状态错误，而不只是将属性设置为其默认值。 |
| `BindNever` | 告诉模型绑定器永远不要绑定到这个参数。 |
| `FromHeaderFromQueryFromRouteFromForm` | 用于指定要应用的确切绑定源(头、查询字符串、路由参数或表单值)。 |
| `FromServices` | 使用依赖注入绑定类型(将在本章后面介绍)。 |
| `FromBody` | 从请求体绑定数据。基于请求的内容(例如，JSON、XML 等)选择格式化程序。).最多只能有一个用`FromBody`属性修饰的参数。 |
| `ModelBinder` | 用于覆盖默认模型绑定器(用于自定义模型绑定)。 |

### 模型验证

模型验证在模型绑定(显式和隐式)之后立即发生。由于转换问题，模型绑定会向`ModelState`数据字典添加错误，而验证会基于业务规则向`ModelState`数据字典添加错误。业务规则的示例包括必填字段、具有最大允许长度的字符串或在特定允许范围内的日期。

验证规则是通过内置或自定义的验证属性设置的。表 [29-5](#Tab5) 列出了一些内置的验证属性。请注意，有几个还兼作数据注释，用于形成 EF 核心实体。

表 29-5

一些内置的验证属性

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

属性

 | 

生命的意义

 |
| --- | --- |
| `CreditCard` | 对信用卡号执行 Luhn-10 检查 |
| `Compare` | 验证模型匹配中的两个属性 |
| `EmailAddress` | 验证属性是否具有有效的电子邮件格式 |
| `Phone` | 验证属性是否具有有效的电话号码格式 |
| `Range` | 验证属性是否在指定的范围内 |
| `RegularExpression` | 验证属性是否与指定的正则表达式匹配 |
| `Required` | 验证属性是否有值 |
| `StringLength` | 验证属性没有超过最大长度 |
| `Url` | 验证属性是否具有有效的 URL 格式 |
| `Remote` | 通过调用服务器上的操作方法来验证客户端上的输入 |

还可以开发定制的验证属性，但不在本书中讨论。

### 选择途径

路由是 ASP.NET 核心如何将 HTTP 请求匹配到应用中的控制器和动作(可执行的*端点*)，而不是将 URL 匹配到项目文件结构的旧 Web 表单过程。它还提供了一种基于这些端点从应用程序内部创建 URL 的机制。MVC 或 Web API 风格的应用程序中的端点由控制器、动作(仅限 MVC)、HTTP 动词和可选值(称为*路由值*)组成。

Note

路由也适用于 Razor pages、SignalR、gRPC 服务等。这本书涵盖了 MVC 和 Web API 风格的控制器。

ASP.NET 核心使用路由中间件来匹配传入请求的 URL，并生成响应中发出的 URL。中间件注册在`Startup`类中，端点添加在`Startup`类中，或者通过路由属性添加，这两个都将在本章后面介绍。

#### URL 模式和路由令牌

路由端点由 URL 模式和文字组成，URL 模式包含可变占位符(称为*标记*，文字放入一个有序集合中，称为*路由表*。每个条目定义一个不同的 URL 模式来匹配。占位符可以是自定义变量，也可以来自预定义列表。表 [29-6](#Tab6) 列出了保留的路由名称。

表 29-6

为 MVC 和 API 应用程序保留路由令牌

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

代币

 | 

生命的意义

 |
| --- | --- |
| `Area` | 定义路线的 MVC 区域 |
| `Controller` | 定义控制器(减去控制器后缀) |
| `Action` | 定义 MVC 应用程序中的动作名称 |

除了保留的令牌之外，路由还可以包含映射(模型绑定)到动作方法参数的自定义令牌。

##### 路由和 ASP.NET 核心 RESTful 服务

为 ASP.NET 服务定义路由时，未指定操作方法。相反，一旦找到控制器，要执行的操作方法就基于请求的 HTTP 谓词和分配给操作方法的 HTTP 谓词。稍后会有更多内容。

#### 传统路由

传统路由在`Startup`类的`UseEndpoints()`方法中构建路由表。`MapControllerRoute()`方法将端点添加到路由表中。方法为 URL 模式中的变量指定名称、URL 模式和任何默认值。在下面的代码示例中，预定义的`{controller}`和`{action}`占位符引用一个控制器和包含在该控制器中的动作方法。占位符`{id}`是自定义的，并被转换为动作方法的参数(名为`id`)。向路由令牌添加问号表示它是可选的。

```cs
app.UseEndpoints(endpoints =>
{
  endpoints.MapControllerRoute(
    name: "default",
    template: "{controller=Home}/{action=Index}/{id?}");
});

```

当请求 URL 时，会对照路由表进行检查。如果匹配，则执行位于该应用程序端点的代码。由该路由提供服务的一个示例 URL 是`Car/Delete/5`。这将调用`CarController`上的`Delete()`动作方法，将 5 传递给`id`参数。

缺省值指定如何为不包含所有已定义组件的 URL 填充空格。在前面的代码中，如果 URL 中没有指定任何内容(例如`http://localhost:5001`，那么路由引擎将调用`HomeController`类的`Index()`操作方法，而不使用`id`参数。缺省值是渐进的，这意味着它们可以从右到左被排除。但是，路线部分不能跳过。输入一个像`http://localhost:60466/Delete/5`这样的网址将无法通过`{controller}/{action}/{id}`模式。

路由引擎将尝试根据控制器、操作、自定义令牌和 HTTP 谓词来查找第一条路由。如果路由引擎不能确定最佳路径，它将抛出一个`AmbiguousMatchException`。

请注意，路由模板不包含协议或主机名。路由引擎在创建路由时会自动预先考虑正确的信息，并使用 HTTP 谓词、路径和参数来确定正确的应用程序端点。例如，如果您的站点在 [`https://www.skimedic.com`](https://www.skimedic.com) 上运行，协议(`HTTPS`)和主机名( [`www.skimedic.com`](http://www.skimedic.com) )会在创建时自动添加到路由前面(例如 [`https://www.skimedic.com/Car/Delete/5`](https://www.skimedic.com/Car/Delete/5) )。对于传入的请求，路由引擎使用 URL 的`Car/Delete/5`部分。

##### 命名路线

路由名称可以用作在应用程序中生成 URL 的简写。在之前的常规回合中，端点被赋予名称`default`。

#### 属性路由

在属性路由中，路由是使用控制器及其动作方法上的 C#属性来定义的。这可以导致更精确的路由，但也会增加配置量，因为每个控制器和动作都需要指定路由信息。

例如，以下面的代码片段为例。`Index()`动作方法上的四个`Route`属性等同于前面定义的相同路线。`Index()`动作方法是应用端点为 [`mysite.com`](http://mysite.com) 、 [`mysite.com/Home`](http://mysite.com/Home) 、 [`mysite.com/Home/Index`](http://mysite.com/Home/Index) 或 [`mysite.com/Home/Index/5`](http://mysite.com/Home/Index/5) 。

```cs
public class HomeController : Controller
{
  [Route("/")]
  [Route("/Home")]
  [Route("/Home/Index")]
  [Route("/Home/Index/{id?}")]
  public IActionResult Index(int? id)
  {
    ...
  }
}

```

传统路由和属性路由的主要区别在于，传统路由覆盖应用程序，而属性路由覆盖带有`Route`属性的控制器。如果不使用常规路由，每个控制器都需要定义路由，否则将无法访问。例如，如果路由表中没有定义默认路由，则无法发现以下代码，因为控制器没有配置任何路由:

```cs
public class CarController : Controller
{
  public IActionResult Delete(int id)
  {
    ...
  }
}

```

Note

常规和属性路由可以一起使用。如果默认控制器路由设置在`UseEndpoints()`(如在传统路由示例中)，前面的控制器将通过路由表定位。

当在控制器级别添加路线时，动作方法源自该基本路线。例如，下面的控制器路线*涵盖了* `Delete()` *(以及任何其他)动作方法*:

```cs
[Route("[controller]/[action]/{id?}")]
public class CarController : Controller
{
  public IActionResult Delete(int id)
  {
    ...
  }
}

```

Note

在属性路由中使用方括号(`[]`)来区分内置令牌，而不是传统路由中使用的花括号(`{}`)。自定义标记仍然使用花括号。

如果一个动作方法需要重新启动路由模式，在路由前加上一个正斜杠(`/`)。例如，如果删除方法应该遵循 URL 模式 [`mysite.com/Delete/Car/5`](http://mysite.com/Delete/Car/5) ，则配置操作如下:

```cs
[Route("[controller]/[action]/{id?}")]
public class CarController : Controller
{
  [Route("/[action]/[controller]/{id}")]
  public IActionResult Delete(int id)
  {
    ...
  }
}

```

路由还可以对路由值进行硬编码，而不是使用令牌替换。下面的代码将产生与前面的代码示例相同的结果:

```cs
[Route("[controller]/[action]/{id?}")]
public class CarController : Controller
{
  [Route("/Delete/Car/{id}")]
  public IActionResult Delete(int id)
  {
    ...
  }
}

```

##### 命名路线

也可以为路线指定名称。这就创建了一种简单的方法，只需使用名称就可以重定向到特定的路由。例如，以下路由属性的名称为`GetOrderDetails`:

```cs
[HttpGet("{orderId}", Name = "GetOrderDetails")]

```

#### 路由和 HTTP 动词

您可能已经注意到，这两种路由模板定义方法都没有定义 HTTP 动词。这是因为路由引擎(在 MVC 和 API 风格的应用程序中)结合使用路由模板*和 HTTP 动词*来选择适当的应用程序端点。

##### Web 应用程序(MVC)路由中的 HTTP 谓词

当使用 MVC 模式构建 web 应用程序时，通常会有两个应用程序端点匹配特定的路由模板。这些实例中的鉴别器是 HTTP 动词。例如，如果`CarController`包含两个名为`Delete()`的动作方法，并且它们都匹配路由模板，那么选择执行哪个方法是基于请求中使用的动词。第一个`Delete()`方法是用`HttpGet`属性修饰的，将在传入请求是 get 请求时执行。第二个`Delete()`方法用`HttpPost`属性修饰，将在传入请求是 post 时执行。

```cs
[Route("[controller]/[action]/{id?}")]
public class CarController : Controller
{
  [HttpGet]
  public IActionResult Delete(int id)
  {
    ...
  }
  [HttpPost]
  public IActionResult Delete(int id, Car recordToDelete)
  {
    ...
  }
}

```

也可以使用 HTTP 动词属性而不是`Route`属性来修改路由。例如，下面显示了添加到两个`Delete()`方法的路由模板中的可选`id`路由令牌:

```cs
[Route("[controller]/[action] ")]
public class CarController : Controller
{
  [HttpGet("{id?}")]
  public IActionResult Delete(int? id)
  {
    ...
  }
  [HttpPost("{id}")]
  public IActionResult Delete(int id, Car recordToDelete)
  {
    ...
  }
}

```

也可以使用 HTTP 动词重新启动路由；只需在模板化的路线前加一个正斜杠(`/`)，如下例所示:

```cs
[HttpGet("/[controller]/[action]/{makeId}/{makeName}")]
public IActionResult ByMake(int makeId, string makeName)
{
  ViewBag.MakeName = makeName;
  return View(_repo.GetAllBy(makeId));
}

```

Note

如果 action 方法没有用 HTTP verb 属性修饰，它默认为 get 方法。但是，在 MVC web 应用程序中，未标记的动作方法也可以响应 post 请求。因此，用正确的动词属性显式标记所有动作方法被认为是最佳实践。

##### API 服务路由

用于 MVC 风格应用程序的路由定义和用于 RESTful 服务的路由定义之间的一个显著区别是，服务路由定义不指定动作方法。操作方法是根据请求的 HTTP 动词(和可选的内容类型)而不是名称来选择的。下面的代码展示了一个 API 控制器，它有四个方法，都匹配同一个路由模板。请注意 HTTP 动词属性:

```cs
[Route("api/[controller]")]
[ApiController]
public class CarController : ControllerBase
{
  [HttpGet("{id}")]
  public IActionResult GetCarsById(int id)
  {
    ...
  }
  [HttpPost]
  public IActionResult CreateANewCar(Car entity)
  {
    ...
  }
  [HttpPut("{id}")]
  public IActionResult UpdateAnExistingCar(int id, Car entity)
  {
    ...
  }
  [HttpDelete("{id}")]
  public IActionResult DeleteACar(int id, Car entity)
  {
    ...
  }
}

```

如果一个动作方法没有 HTTP 动词属性，它将被视为 get 请求的应用程序端点。如果路由请求匹配，但没有具有正确动词属性的操作方法，服务器将返回 404(未找到)。

Note

如果名称以 *Get* 、 *Put* 、 *Delete* 或 *Post* 开头，ASP.NET Web API 允许您省略方法的 HTTP 动词。这个惯例通常被认为是一个坏主意，并已在 ASP.NET 核心删除。如果一个动作方法没有指定 HTTP 谓词，它将被使用 HTTP Get 调用。

API 控制器的最后一个端点选择器是可选的`Consumes`属性，它指定端点接受的内容类型。该请求必须使用匹配的内容类型头，否则将返回 415 不支持的媒体类型错误。以下两个示例端点都在同一个控制器中，它们区分了 JSON 和 XML:

```cs
[HttpPost]
[Consumes("application/json")]
public IActionResult PostJson(IEnumerable<int> values) =>
  Ok(new { Consumes = "application/json", Values = values });

[HttpPost]
[Consumes("application/x-www-form-urlencoded")]
public IActionResult PostForm([FromForm] IEnumerable<int> values) =>
  Ok(new { Consumes = "application/x-www-form-urlencoded", Values = values });

```

#### 使用路由重定向

路由的另一个优点是你不再需要为你站点中的其他页面硬编码 URL。路由条目用于匹配传入的请求以及构建 URL。构建 URL 时，会根据当前请求的值添加方案、主机和端口。

### 过滤

ASP.NET 核心中的过滤器在请求处理管道的特定阶段之前或之后运行代码。有用于授权和缓存的内置过滤器，以及用于分配客户过滤器的选项。表 [29-7](#Tab7) 列出了可以添加到管道中的过滤器类型，按照它们的执行顺序列出。

表 29-7

ASP.NET 核心中可用的过滤器

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

过滤器

 | 

生命的意义

 |
| --- | --- |
| 授权过滤器 | 首先运行并确定用户是否有权处理当前请求。 |
| 资源筛选器 | 在授权筛选器之后立即运行，并且可以在管道的其余部分完成之后运行。在模型绑定之前运行。 |
| 动作过滤器 | 在执行操作之前和/或执行操作之后立即运行。可以改变传递给操作的值和从操作返回的结果。 |
| 异常过滤器 | 用于将全局策略应用于写入响应正文之前发生的未处理异常。 |
| 结果过滤器 | 成功执行操作结果后立即运行代码。对于围绕视图或格式化程序执行的逻辑很有用。 |

#### 授权过滤器

授权过滤器与 ASP.NET 核心身份系统配合使用，以防止对用户无权使用的控制器或操作的访问。不建议构建自定义授权过滤器，因为内置的`AuthorizeAttribute`和`AllowAnonymousAttribute`通常在使用 ASP.NET 核心身份时提供足够的覆盖范围。

#### 资源筛选器

before 代码在授权筛选器之后和任何其他筛选器之前执行，after 代码在所有其他筛选器之后执行。这使得资源筛选器能够缩短整个响应管道。资源过滤器的一个常见用户是用于缓存。如果响应在缓存中，过滤器可以跳过管道的其余部分。

#### 动作过滤器

before 代码在 action 方法执行之前立即执行，after 代码在 action 方法执行之后立即执行。动作过滤器可以短路动作方法和被动作过滤器包装的任何过滤器(执行和包装的顺序将很快介绍)。

#### 异常过滤器

异常过滤器在应用程序中实现横切错误处理。它们没有 before 或 after 事件，但是它们处理控制器创建、模型绑定、动作过滤器或动作方法中任何未处理的异常。

#### 结果过滤器

结果过滤器包装动作方法的`IActionResult`的执行。一个常见的场景是使用结果过滤器将头信息添加到 HTTP 响应消息中。

## ASP.NET 核心的新功能

除了支持 ASP.NET MVC 和 ASP.NET Web API 的基本功能之外，该团队还能够在以前的框架上添加许多新功能和改进。除了框架和控制器的统一之外，还有一些额外的改进和创新:

*   内置依赖注入。

*   云就绪、基于环境的配置系统。

*   轻量级、高性能和模块化的 HTTP 请求管道。

*   整个框架基于细粒度的 NuGet 包。

*   现代客户端框架和开发工作流的集成。

*   标签助手介绍。

*   视图组件介绍。

*   性能的巨大提高。

### 内置依赖注入

依赖注入(DI)是一种支持对象间松散耦合的机制。参数被定义为接口，而不是直接创建依赖对象或将特定的实现传递给类和/或方法。这样，接口的任何实现都可以传递到类或方法和类中，极大地增加了应用程序的灵活性。

DI 支持是重写 ASP.NET 核心的主要原则之一。不仅仅是`Startup`类(本章后面会讲到)通过依赖注入接受所有的配置和中间件服务，您的定制类也可以(并且应该)被添加到服务容器中，以注入到应用程序的其他部分。当一个项目被配置到 ASP.NET 核心 DI 容器中时，有三个生命周期选项，如表 [29-8](#Tab8) 所示。

表 29-8

服务的终身选项

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

终身期权

 | 

提供的功能

 |
| --- | --- |
| `Transient` | 在需要的时候创建*。* |
| `Scoped` | 为每个请求创建一次。推荐用于实体框架`DbContext`对象。 |
| `Singleton` | 在第一次请求时创建一次，然后在对象的生存期内重用。相对于将类作为单例实现，这是推荐的方法。 |

DI 容器中的条目可以被注入到类构造函数和方法以及 Razor 视图中。

Note

如果你想使用一个不同的依赖注入容器，ASP.NET 核心就是考虑到这种灵活性而设计的。查阅文档，了解如何插入不同的容器: [`https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection`](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection) 。

### 环境意识

ASP.NET 核心应用程序通过一个`IWebHostEnvironment`实例了解其执行环境，包括主机环境变量和文件位置。表 [29-9](#Tab9) 显示了通过该接口可用的属性。

表 29-9

IWebHostEnvironment 属性

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

财产

 | 

提供的功能

 |
| --- | --- |
| `ApplicationName` | 获取或设置应用程序的名称。默认为入口程序集的名称。 |
| `ContentRootPath` | 获取或设置包含应用程序内容文件的目录的绝对路径。 |
| `ContentRootFileProvider` | 获取或设置一个指向`ContentRootPath`的`IFileProvider`。 |
| `EnvironmentName` | 获取或设置环境的名称。设置为环境变量`ASPNETCORE_ENVIRONMENT`的值。 |
| `WebRootFileProvider` | 获取或设置一个指向`WebRootPath`的`IFileProvider`。 |
| `WebRootPath` | 获取或设置包含 web 可服务的应用程序内容文件的目录的绝对路径。 |

除了访问相关的文件路径，`IWebHostEnvironment`用于确定运行时环境。

#### 确定运行时环境

ASP.NET 核心自动读取名为`ASPNETCORE_ENVIRONMENT`的环境变量的值来设置运行时环境。如果未设置变量`ASPNETCORE_ENVIRONMENT`，ASP.NET 核心将该值设置为`Production`。通过`IWebHostEnvironment`上的`EnvironmentName`属性可以访问该值集。

在开发 ASP.NET 核心应用程序时，通常使用设置文件或命令行来设置此变量。下游环境(试运行、生产等。)通常使用标准的操作系统环境变量。

您可以自由地使用环境的任何名称或者由静态类`Environments`提供的三个名称。

```cs
public static class Environments
{
  public static readonly string Development = "Development";
  public static readonly string Staging = "Staging";
  public static readonly string Production = "Production";
}

```

`HostEnvironmentEnvExtensions`类在`IHostEnvironment`上提供了扩展方法，用于处理环境名称属性。表 [29-10](#Tab10) 列出了可用的便利方法。

表 29-10

HostEnvironmentEnvExtensions 方法

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

方法

 | 

提供的功能

 |
| --- | --- |
| `IsProduction` | 如果环境变量设置为`Production`(不区分大小写)，则返回 true |
| `IsStaging` | 如果环境变量设置为`Staging`(不区分大小写)，则返回 true |
| `IsDevelopment` | 如果环境变量设置为`Development`(不区分大小写)，则返回 true |
| `IsEnvironment` | 如果环境变量与传递给方法的字符串匹配，则返回 true(不区分大小写) |

以下是使用环境设置的一些示例:

*   确定要加载哪些配置文件

*   设置调试、错误和日志记录选项

*   加载特定于环境的 JavaScript 和 CSS 文件

在构建自动 Lot 的过程中，您将会看到其中的每一项。Api 和 AutoLot。下两章将讨论 Mvc 应用程序。

### 应用程序配置

以前版本的 ASP.NET 使用`web.config`文件来配置服务和应用，开发者通过`System.Configuration`类访问配置设置。当然，*网站的所有*配置设置，而不仅仅是特定应用程序的设置，都被转储到`web.config`文件中，使得它(可能)变得复杂混乱。

ASP.NET 核心引入了一个大大简化的配置系统。默认情况下，它基于简单的 JSON 文件，这些文件将配置设置保存为名称-值对。配置的默认文件是`appsettings.json`文件。初始版本的`appsettings.json`文件(由 ASP.NET 核心 web 应用程序和 API 服务模板创建)仅包含日志记录的配置信息以及限制主机的设置，如下所示:

```cs
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  },
  "AllowedHosts": "*"
}

```

该模板还创建了一个`appsettings.Development.json`文件。配置系统与运行时环境感知协同工作，以基于运行时环境加载附加的配置文件。这是通过指示配置系统在`appSettings.json`文件之后加载一个名为`appsettings.{environmentname}.json`的文件来实现的。在开发下运行时，`appsettings.Development.json`文件在初始设置文件之后加载。如果环境正在升级，则加载`appsettings.Staging.json`文件。值得注意的是，当加载多个文件时，两个文件中出现的任何设置都会被最后加载的文件覆盖；它们不是相加的。

所有配置值都可以通过一个`IConfiguration`实例来访问，该实例可以通过 ASP.NET 核心依赖注入系统获得。

#### 正在检索设置

一旦构建好配置，就可以使用传统的`Get`系列方法来访问设置，比如`GetSection()`、`GetValue()`等等。

```cs
Configuration.GetSection("Logging")

```

还有一个获取应用程序连接字符串的快捷方式。

```cs
Configuration.GetConnectionString("AutoLot")

```

本书的其余部分将会用到更多的配置特性。

### 部署 ASP.NET 核心应用程序

以前版本的 ASP.NET 应用程序只能部署到使用 IIS 的 Windows 服务器上。ASP.NET 核心可以以多种方式部署到多个操作系统，包括在 web 服务器之外。高级选项如下:

*   在使用 IIS 的 Windows 服务器(包括 Azure)上

*   在 IIS 之外的 Windows 服务器(包括 Azure 应用服务)上

*   在使用 Apache 或 NGINX 的 Linux 服务器上

*   在 Docker 容器中的 Windows 或 Linux 上

这种灵活性允许组织决定对组织最有意义的部署平台，包括流行的基于容器的部署模型(如使用 Docker)，而不是局限于 Windows 服务器。

### 轻量级和模块化的 HTTP 请求管道

遵循…的原则。净核心，你必须选择在 ASP.NET 核心的一切。默认情况下，应用程序中不会加载任何内容。这使得应用程序尽可能地轻量级，提高性能并最小化表面区域和潜在风险。

## 创建和配置解决方案

现在，您已经了解了 ASP.NET 核心的一些主要概念，是时候开始构建 ASP.NET 核心应用程序了。可以使用 Visual Studio 或命令行创建 ASP.NET 核心项目。这两个选项都将在接下来的两节中讨论。

### 使用 Visual Studio

Visual Studio 具有 GUI 的优势，可以引导您完成创建解决方案和项目、添加 NuGet 包以及创建项目间引用的过程。

#### 创建解决方案和项目

首先在 Visual Studio 中创建新项目。从“创建新项目”对话框中选择 C#模板 ASP.NET 核心 Web 应用程序。在“配置你的新项目”对话框中，输入 **AutoLot。项目名称为 Api** ，解决方案名称为 **AutoLot** ，如图 [29-1](#Fig1) 所示。

![img/340876_10_En_29_Chapter/340876_10_En_29_Fig1_HTML.jpg](img/340876_10_En_29_Chapter/340876_10_En_29_Fig1_HTML.jpg)

图 29-1

创建自动 Lot。Api 项目和自动 Lot 解决方案

在下一个屏幕上，选择 ASP.NET 核心 Web API 模板。NET 核心和 ASP.NET 核心 5.0。保留高级复选框的默认设置，如图 [29-2](#Fig2) 所示。

![img/340876_10_En_29_Chapter/340876_10_En_29_Fig2_HTML.jpg](img/340876_10_En_29_Chapter/340876_10_En_29_Fig2_HTML.jpg)

图 29-2

选择 ASP.NET 核心 Web API 模板

接下来，向解决方案添加另一个 ASP.NET 核心 web 应用程序。选择 ASP.NET 核心 Web 应用程序(模型-视图-控制器)模板。确保。在顶部的选择框中选择了 NET Core 和 ASP.NET Core 5.0；保留高级复选框的默认值。

最后，添加一个 C#类库(。NET Core)添加到项目中，并将其命名为 AutoLot.Services，编辑项目文件，将`TargetFramework`设置为`net5.0`，如下所示:

```cs
<PropertyGroup>
  <TargetFramework>net5.0</TargetFramework>
</PropertyGroup>

```

#### 加入自动 Lot。模型和自动 Lot。木豆

该解决方案需要第 [23 章](23.html)中完整的数据访问层。您可以将文件复制到当前的解决方案目录中，也可以将它们留在原处。无论哪种方式，您都需要在解决方案资源管理器中右键单击您的解决方案名称，选择添加➤现有项目，并导航到`AutoLot.Models.csproj`文件并选择它。对自动 Lot 重复上述步骤。Dal 项目。

Note

虽然项目添加到解决方案的顺序在技术上并不重要，但 Visual Studio 将保留 AutoLot 之间的引用。模型和自动 Lot。如果首先添加模型项目，则为 Dal。

#### 添加项目引用

通过在解决方案资源管理器中右击项目名称并为每个项目选择“添加➤项目引用”,添加以下项目引用。

AutoLot。Api 和 AutoLot。Mvc 引用了以下内容:

*   AutoLot。模型

*   汽车旅馆

*   AutoLot。服务

AutoLot。服务参考了以下内容:

*   AutoLot。模型

*   汽车旅馆

#### 添加 NuGet 包

需要附加的 NuGet 包来完成应用程序。

去自动售货机。Api 项目，添加以下包:

*   `AutoMapper`

*   `System.Text.Json`

*   `Swashbuckle.AspNetCore.Annotations`

*   `Swashbuckle.AspNetCore.Swagger`

*   `Swashbuckle.AspNetCore.SwaggerGen`

*   `Swashbuckle.AspNetCore.SwaggerUI`

*   `Microsoft.VisualStudio.Web.CodeGeneration.Design`

*   `Microsoft.EntityFrameworkCore.SqlServer`

Note

在 ASP.NET 核心 5.0 API 模板中，`Swashbuckle.AspNetCore`已经被引用。列出的`Swashbuckle`包增加了基本实现之外的功能。

去自动售货机。Mvc 项目，添加以下包:

*   `AutoMapper`

*   `System.Text.Json`

*   `LigerShark.WebOptimizer.Core`

*   `Microsoft.Web.LibraryManager.Build`

*   `Microsoft.VisualStudio.Web.CodeGeneration.Design`

*   `Microsoft.EntityFrameworkCore.SqlServer`

去自动售货机。服务项目，添加以下包:

*   `Microsoft.Extensions.Hosting.Abstractions`

*   `Microsoft.Extensions.Options`

*   `Serilog.AspNetCore`

*   `Serilog.Enrichers.Environment`

*   `Serilog.Settings.Configuration`

*   `Serlog.Sinks.Console`

*   `Serilog.Sinks.File`

*   `Serilog.Sinks.MSSqlServer`

*   `System.Text.Json`

### 使用命令行

如本书前面所示。NET 核心项目和解决方案可以使用命令行创建。打开提示符并导航到您希望解决方案所在的目录。

Note

列出的命令使用 Windows 目录分隔符。如果您使用的是非 Windows 操作系统，请根据需要调整分隔符。

以下命令创建自动放样解决方案并添加现有自动放样。模型和自动 Lot。Dal 项目融入解决方案:

```cs
rem create the solution
dotnet new sln -n AutoLot
rem add autolot dal to solution
dotnet sln AutoLot.sln add ..\Chapter_23\AutoLot.Models
dotnet sln AutoLot.sln add ..\Chapter_23\AutoLot.Dal

```

创建自动 Lot。服务项目，将其添加到解决方案中，添加 NuGet 包，并添加项目引用。

```cs
rem create the class library for the application services and add it to the solution
dotnet new classlib -lang c# -n AutoLot.Services -o .\AutoLot.Services -f net5.0
dotnet sln AutoLot.sln add AutoLot.Services

dotnet add AutoLot.Services package Microsoft.Extensions.Hosting.Abstractions
dotnet add AutoLot.Services package Microsoft.Extensions.Options
dotnet add AutoLot.Services package Serilog.AspNetCore
dotnet add AutoLot.Services package Serilog.Enrichers.Environment
dotnet add AutoLot.Services package Serilog.Settings.Configuration
dotnet add AutoLot.Services package Serilog.Sinks.Console
dotnet add AutoLot.Services package Serilog.Sinks.File
dotnet add AutoLot.Services package Serilog.Sinks.MSSqlServer
dotnet add AutoLot.Services package System.Text.Json

dotnet add AutoLot.Services reference ..\Chapter_23\AutoLot.Models
dotnet add AutoLot.Services reference ..\Chapter_23\AutoLot.Dal

```

创建自动 Lot。Api 项目，将其添加到解决方案中，添加 NuGet 包，并添加项目引用。

```cs
dotnet new webapi -lang c# -n AutoLot.Api -au none -o .\AutoLot.Api -f net5.0
dotnet sln AutoLot.sln add AutoLot.Api

dotnet add AutoLot.Api package AutoMapper
dotnet add AutoLot.Api package Swashbuckle.AspNetCore
dotnet add AutoLot.Api package Swashbuckle.AspNetCore.Annotations
dotnet add AutoLot.Api package Swashbuckle.AspNetCore.Swagger
dotnet add AutoLot.Api package Swashbuckle.AspNetCore.SwaggerGen
dotnet add AutoLot.Api package Swashbuckle.AspNetCore.SwaggerUI
dotnet add AutoLot.Api package Microsoft.VisualStudio.Web.CodeGeneration.Design
dotnet add AutoLot.Api package Microsoft.EntityFrameworkCore.SqlServer
dotnet add AutoLot.Api package System.Text.Json

dotnet add AutoLot.Api reference ..\Chapter_23\AutoLot.Dal
dotnet add AutoLot.Api reference ..\Chapter_23\AutoLot.Models
dotnet add AutoLot.Api reference AutoLot.Services

```

创建自动 Lot。Api 项目，将其添加到解决方案中，添加 NuGet 包，并添加项目引用。

```cs
dotnet new mvc -lang c# -n AutoLot.Mvc -au none -o .\AutoLot.Mvc -f net5.0
dotnet sln AutoLot.sln add AutoLot.Mvc

rem add project references
dotnet add AutoLot.Mvc reference ..\Chapter_23\AutoLot.Models
dotnet add AutoLot.Mvc reference ..\Chapter_23\AutoLot.Dal
dotnet add AutoLot.Mvc reference AutoLot.Services

rem add packages
dotnet add AutoLot.Mvc package AutoMapper
dotnet add AutoLot.Mvc package System.Text.Json
dotnet add AutoLot.Mvc package LigerShark.WebOptimizer.Core
dotnet add AutoLot.Mvc package Microsoft.Web.LibraryManager.Build
dotnet add AutoLot.Mvc package Microsoft.EntityFrameworkCore.SqlServer
dotnet add AutoLot.Mvc package Microsoft.VisualStudio.Web.CodeGeneration.Design

```

这就完成了使用命令行的设置。如果你不需要 Visual Studio GUI 来帮助你，它会更有效。

## 运行 ASP.NET 核心应用程序

以前版本的 ASP.NET web 应用程序总是使用 IIS(或 IIS Express)运行。借助 ASP.NET 核心，应用程序通常使用 Kestrel web 服务器运行，并可选择使用 IIS、Apache、Nginx 等。通过 Kestrel 和其他 web 服务器之间的反向代理。这不仅背离了严格使用 IIS 来改变部署模型，而且还改变了开发的可能性。在开发过程中，您现在可以通过以下方式运行您的应用程序:

*   从 Visual Studio，使用 IIS Express

*   在 Visual Studio 中，使用 Kestrel

*   在命令提示符下使用。NET CLI，使用 Kestrel

*   从 Visual Studio 代码，使用 Kestrel，从运行菜单

*   在 Visual Studio 代码的终端窗口中，使用。NET CLI 和 Kestrel

### 配置启动设置

`launchsettings.json`文件(位于解决方案资源管理器的 Properties 节点下)配置应用程序如何在开发中运行，包括在 Kestrel 和 IIS Express 下。此处列出了`launchsettings.json`文件以供参考(您的 IIS Express 端口会有所不同):

```cs
{
  "$schema": "http://json.schemastore.org/launchsettings.json",
  "iisSettings": {
    "windowsAuthentication": false,
    "anonymousAuthentication": true,
    "iisExpress": {
      "applicationUrl": "http://localhost:42788",
      "sslPort": 44375
    }
  },
  "profiles": {
    "IIS Express": {
      "commandName": "IISExpress",
      "launchBrowser": true,
      "launchUrl": "swagger",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "AutoLot.Api": {
      "commandName": "Project",
      "dotnetRunMessages": "true",
      "launchBrowser": true,
      "launchUrl": "swagger",
      "applicationUrl": "https://localhost:5001;http://localhost:5000",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}

```

### 使用 Visual Studio

`iisSettings`部分定义了使用 IIS Express 作为 web 服务器运行应用程序的设置。需要注意的最重要的设置是定义端口的`applicationUrl`和定义运行时环境的`environmentVariables`块。在调试模式下运行时，此设置将取代任何机器环境设置。第二个概要文件(`AutoLot.Mvc`或`AutoLot.Api`，取决于您正在使用的项目)定义了使用 Kestrel 作为 web 服务器运行应用程序时的设置。该配置文件定义了`applicationUrl`和端口，以及环境。

Visual Studio 中的 Run 命令允许选择 IIS Express 或 Kestrel，如图 [29-3](#Fig3) 所示。一旦选择了一个概要文件，您就可以通过按 F5(调试模式)、按 Ctrl+F5(与“调试”菜单中的“启动而不调试”相同)或单击绿色的运行箭头(与“调试”菜单中的“启动调试”相同)来运行项目。

![img/340876_10_En_29_Chapter/340876_10_En_29_Fig3_HTML.jpg](img/340876_10_En_29_Chapter/340876_10_En_29_Fig3_HTML.jpg)

图 29-3

可用的 Visual Studio 调试配置文件

Note

从 Visual Studio 运行应用程序时，不再支持“编辑并继续”。

### 使用命令行或 Visual Studio 代码终端窗口

要从命令行或 VSC 终端运行，导航到应用程序的`csproj`文件所在的目录。输入以下命令，使用 Kestrel 作为 web 服务器启动您的应用程序:

```cs
dotnet run

```

若要结束该过程，请按 Ctrl+C。

#### 调试时更改代码

从命令行运行时，代码可以更改，但不会反映在运行的 app 中。要在运行的应用程序中反映更改，请输入以下命令:

```cs
dotnet watch run

```

该命令的更新在启动应用程序的同时运行文件监视器。当在任何项目(或引用的项目)文件中检测到更改时，应用程序将自动停止，然后重新启动。新的 ASP.NET 核心 5，任何连接的浏览器窗口也将重新加载。它不完全是“编辑并继续”,但它是一个很好的开发解决方案。

### 使用 Visual Studio 代码(VS 代码)

若要从 Visual Studio 代码运行项目，请打开解决方案所在的文件夹。当你按下 F5(或者点击 Run)，VS 代码会提示你选择要运行的项目(AutoLot。Api 或 AutoLot。Mvc)，然后创建一个运行配置并把它放在一个名为`launch.json`的文件中。VS 代码也使用`launchsettings.json`文件进行端口配置。

#### 调试时更改代码

从 VS 代码运行时，代码可以更改，但不会在运行的 app 中体现出来。要在运行的应用程序中反映更改，请从终端运行`dotnet watch run`命令。

### 调试 ASP.NET 核心应用程序

从 Visual Studio 或 Visual Studio 代码运行应用程序时，调试按预期工作。当从命令行运行时，必须先连接到正在运行的进程，然后才能调试应用程序。在 Visual Studio 和 Visual Studio 代码中做到这一点很容易。

#### 使用 Visual Studio 附加

启动您的应用程序(使用`dotnet run`或`dotnet watch run`)后，在 Visual Studio 中选择调试➤附加到进程。当“附加到进程”对话框出现时，根据您的应用程序名称过滤进程，如图 [29-4](#Fig4) 所示。

![img/340876_10_En_29_Chapter/340876_10_En_29_Fig4_HTML.jpg](img/340876_10_En_29_Chapter/340876_10_En_29_Fig4_HTML.jpg)

图 29-4

附加到正在运行的应用程序以便在 Visual Studio 中进行调试

一旦附加到正在运行的进程，就可以在 Visual Studio 中设置断点，调试就可以按预期进行了。您不能编辑并继续；您必须从进程中分离，更改才能反映在您正在运行的应用程序中。

#### 用 Visual Studio 代码附加

启动应用程序后(使用`dotnet run`或`dotnet watch run`，选择。NET Core Attach 代替。点击 VS 代码中的绿色运行箭头，启动 NET Core(web)，如图 [29-5](#Fig5) 所示。

![img/340876_10_En_29_Chapter/340876_10_En_29_Fig5_HTML.jpg](img/340876_10_En_29_Chapter/340876_10_En_29_Fig5_HTML.jpg)

图 29-5

附加到正在运行的应用程序以在 Visual Studio 代码中进行调试

当您单击“运行”按钮时，系统会提示您选择要附加的进程。选择您的应用程序。现在，您可以按预期设置断点。

使用 Visual Studio 代码的优势在于，一旦它被附加(并使用`dotnet watch run`)你就可以在运行时更新你的代码(无需分离)，你的更改将会反映在你的应用中。

### 更新自动 Lot。Api 端口

你可能已经注意到了。Api 和 AutoLot。Mvc 为其 IIS Express 配置文件指定了不同的端口，但两者都将其 Kestrel 端口配置为 5000 (HTTP)和 5001 (HTTPS)。当你尝试一起运行应用程序时，这会导致问题。更新自动 Lot。Api 端口到 5020 (HTTP)和 5021 (HTTPS)，就像这样:

```cs
    "AutoLot.Api": {
      "commandName": "Project",
      "launchBrowser": true,
      "launchUrl": "api/values",
      "applicationUrl": "https://localhost:5021;http://localhost:5020",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }

```

## 创建和配置 WebHost

与经典的 ASP.NET MVC 或 ASP.NET Web API 应用程序不同，ASP.NET 核心应用程序非常简单。创建和配置一个`WebHost`的. NET 核心控制台应用程序。`WebHost`的创建和随后的配置将应用程序设置为监听(和响应)HTTP 请求。`WebHost`是在`Program.cs`文件的`Main()`方法中创建的。然后在`Startup.cs`文件中为您的应用程序配置`WebHost`。

### Program.cs 文件

打开自动 Lot 中的`Program.cs`类。Api 应用程序，并检查这里显示的内容，以供参考:

```cs
namespace AutoLot.Api
{
  public class Program
  {
    public static void Main(string[] args)
    {
            CreateHostBuilder(args).Build().Run();
    }

    public static IHostBuilder CreateHostBuilder(string[] args) =>
        Host.CreateDefaultBuilder(args)
                .ConfigureWebHostDefaults(webBuilder =>
                {
                    webBuilder.UseStartup<Startup>();
                });
  }
}

```

`CreateDefaultBuilder()`方法将最典型的应用程序设置压缩到一个方法调用中。它配置应用程序(使用环境变量和`appsettings` JSON 文件)，配置默认的日志记录提供者，并设置依赖注入容器。这种设置是由 API 和 MVC 风格的应用程序的 ASP.NET 核心模板提供的。

下一个方法(`ConfigureWebHostDefaults()`)也是元方法，增加了对 Kestrel、IIS 和附加配置的支持。最后一步是设置特定于应用程序的配置类，在本例中(按照惯例)命名为`Startup`。最后一步是使用`Run()`方法来激活 web 主机。

除了`WebHost`之外，前面的代码还创建了`IConfiguration`实例，并将其添加到依赖注入容器中。

### Startup.cs 文件

`Startup`类配置应用程序如何处理 HTTP 请求和响应，配置任何需要的服务，并向依赖注入容器添加服务。类名可以是任何东西，只要它匹配`CreateHostBuilder()`方法配置中的`UseStartup<T>()`行，但是约定是命名类`Startup`。

#### 可用于启动的服务

启动过程需要访问框架和环境服务及值，这些由框架注入到类中。表 [29-11](#Tab11) 中列出了`Startup`类可用于配置应用的五种服务。

表 29-11

启动时可用的服务

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

服务

 | 

提供的功能

 |
| --- | --- |
| `IApplicationBuilder` | 定义一个类，该类提供配置应用程序请求管道的机制。 |
| `IWebHostEnvironment` | 提供有关运行应用程序的 web 宿主环境的信息。 |
| `ILoggerFactory` | 用于配置日志记录系统，并从已注册的日志记录提供程序创建日志程序实例。 |
| `IServiceCollection` | 指定服务描述符集合的协定。这是依赖注入框架的一部分。 |
| `IConfiguration` | 应用程序配置的实例，在`Program`类的`Main`方法中创建。 |

构造函数接受一个`IConfiguration`的实例和一个`IWebHostEnvironment` / `IHostEnvironment`的可选实例。`ConfigureServices()`方法在`Configure()`方法获取`IServiceCollection`实例之前运行。`Configure()`方法必须接受`IApplicationBuilder`的一个实例，但是也可以接受`IWebHostEnvironment` / `IHostEnvironment`、`ILoggerFactory`以及添加到`ConfigureServices()`中依赖注入容器的任何接口的实例。每个组件都将在接下来的章节中讨论。

#### 构造函数

构造函数获取由`Program.cs`文件中的`Host.CreateDefaultBuilder`方法创建的`IConfiguration`接口的实例，并将其分配给`Configuration`属性，以便在类中的其他地方使用。构造函数也可以获取`IWebHostEnvironment`和/或`ILoggerFactory`的一个实例，尽管它们没有被添加到默认模板中。

将`IWebHostEnvironment`的参数添加到构造函数中，并将其赋给一个局部类级变量。这在`ConfigureServices()`方法中是需要的。对两个自动驾驶仪都这样做。Api 和 AutoLot。Mvc 应用程序。

```cs
private readonly IWebHostEnvironment _env;
public Startup(
  IConfiguration configuration, IWebHostEnvironment env)
{
  _env = env;
  Configuration = configuration;
}

```

#### ConfigureServices 方法

`ConfigureServices()`方法用于配置应用程序所需的任何服务，并将它们插入依赖注入容器。这包括支持 MVC 应用程序和 API 服务所需的服务。

##### AutoLot。美国石油学会(American Petroleum Institute)

AutoLot API 的`ConfigureServices()`方法在默认情况下只配置了一个服务，该服务添加了对控制器的支持。在这个元方法的背后是一系列附加的服务，包括路由、授权、模型绑定以及本章已经讨论过的所有非 UI 项目。

```cs
public void ConfigureServices(IServiceCollection services)
{
  services.AddControllers();
}

```

可以扩展`AddControllers()`方法。一个例子是配置 JSON 处理。ASP.NET 核心的缺省值是 camel case JSON(首字母小写，每个后续单词字符大写，如" **c** ar **R** epo ")。这与大多数用于 web 开发的非微软框架相匹配。然而，ASP.NET·帕斯卡的早期版本对所有东西都进行了封装。对于许多期待 Pascal 大小写的应用程序来说，camel 大小写的改变是一个突破性的改变。要将应用程序的 JSON 处理改回 Pascal 大小写(并更好地格式化 JSON)，请将`AddControllers()`方法更新为:

```cs
public void ConfigureServices(IServiceCollection services)
{
  services.AddControllers()
    .AddJsonOptions(options =>
    {
      options.JsonSerializerOptions.PropertyNamingPolicy = null;
      options.JsonSerializerOptions.WriteIndented = true;
    });
}

```

下一次更新需要将下面的`using`语句添加到`Startup.cs`类中:

```cs
using AutoLot.Dal.EfStructures;
using AutoLot.Dal.Initialization;
using AutoLot.Dal.Repos;
using AutoLot.Dal.Repos.Interfaces;
using Microsoft.EntityFrameworkCore;

```

API 服务需要访问数据访问层中的`ApplicationDbContext`和 repos。内置支持将 EF 核心添加到 ASP.NET 核心应用中。将以下代码添加到`Startup`类的`ConfigureServices()`方法中:

```cs
var connectionString = Configuration.GetConnectionString("AutoLot");
services.AddDbContextPool<ApplicationDbContext>(
  options => options.UseSqlServer(connectionString,
  sqlOptions => sqlOptions.EnableRetryOnFailure()));

```

第一行从设置文件中获取连接字符串(稍后将详细介绍)。下一行将一个`ApplicationDbContext`实例池添加到 DI 容器中。与连接池非常相似，`ApplicationDbContexts`的池可以通过让预初始化的实例等待使用来提高性能。当需要一个上下文时，就从池中加载它。当它被用完时，它被清理掉任何使用的残留物，并被放回水池。

下一个更新是将 repos 添加到 DI 容器中。将以下代码添加到`ConfigureServices()`方法中配置`ApplicationDbContext`的代码之后:

```cs
services.AddScoped<ICarRepo, CarRepo>();
services.AddScoped<ICreditRiskRepo, CreditRiskRepo>();
services.AddScoped<ICustomerRepo, CustomerRepo>();
services.AddScoped<IMakeRepo, MakeRepo>();
services.AddScoped<IOrderRepo, OrderRepo>();

```

###### 将连接字符串添加到应用程序设置

将`appsettings.development.json`文件更新如下，这将连接字符串添加到数据库中。请确保包含分隔各部分的逗号，并更新连接字符串以匹配您的环境。

```cs
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  },
  "ConnectionStrings": {
    "AutoLot": "Server=.,5433;Database=AutoLotFinal;User ID=sa;Password=P@ssw0rd;"
  }
}

```

如前所述，每个配置文件都以一个环境命名。这允许将特定于环境的值分离到不同的文件中。将名为`appsettings.production.json`的新文件添加到项目中，并将其更新为以下内容:

```cs
{
  "ConnectionStrings": {
    "AutoLot": "ITSASECRET"
  }
}

```

这使得真正的连接字符串不受源代码控制，并允许在部署过程中替换标记(`ITSASECRET`)。

##### AutoLot。手动音量调节

MVC 风格的 web 应用程序的`ConfigureServices()`方法增加了 API 应用程序的基本服务以及对呈现视图的支持。MVC 风格的应用程序不调用`AddControllers()`，而是调用`AddControllersWithViews()`，如下所示:

```cs
public void ConfigureServices(IServiceCollection services)
{
  services.AddControllersWithViews();
}

```

将以下`using`语句添加到`Startup.cs`类中:

```cs
using AutoLot.Dal.EfStructures;
using AutoLot.Dal.Initialization;
using AutoLot.Dal.Repos;
using AutoLot.Dal.Repos.Interfaces;
using Microsoft.EntityFrameworkCore;

```

web 应用程序也需要使用数据访问层。将以下代码添加到`Startup`类的`ConfigureServices()`方法中:

```cs
var connectionString = Configuration.GetConnectionString("AutoLot");
services.AddDbContextPool<ApplicationDbContext>(
  options => options.UseSqlServer(connectionString,
  sqlOptions => sqlOptions.EnableRetryOnFailure()));
services.AddScoped<ICarRepo, CarRepo>();
services.AddScoped<ICreditRiskRepo, CreditRiskRepo>();
services.AddScoped<ICustomerRepo, CustomerRepo>();
services.AddScoped<IMakeRepo, MakeRepo>();
services.AddScoped<IOrderRepo, OrderRepo>();

```

Note

MVC web 应用程序将使用数据访问层和 API 来与数据交互，以演示这两种机制。

###### 将连接字符串添加到应用程序设置

将`appsettings.development.json`文件更新为以下内容:

```cs
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  },
  "ConnectionStrings": {
    "AutoLot": "Server=.,5433;Database=AutoLotFinal;User ID=sa;Password=P@ssw0rd;"
  }
}

```

#### 该配置方法

`Configure()`方法用于设置应用程序来响应 HTTP 请求。这个方法在和`ConfigureServices()`方法之后执行*，这意味着添加到 DI 容器中的任何东西也可以被注入到`Configure()`方法中。*

API 风格的应用程序和 MVC 风格的应用程序在处理 HTTP 管道请求和响应的配置上有所不同。

##### AutoLot。美国石油学会(American Petroleum Institute)

默认模板检查环境，如果它被设置为开发，那么`UseDeveloperExceptionPage()`中间件被添加到处理管道中。这提供了调试信息，您可能不希望在生产中公开这些信息。

然后调用`UseHttpsRedirection()`将所有流量重定向到 HTTPS(而不是 HTTP)。然后添加对`app.UseRouting()`、`app.UseAuthorization()`和`app.UseEndpoints()`的调用。下面列出了整个方法:

```cs
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
  if (env.IsDevelopment())
  {
    //If in development environment, display debug info
    app.UseDeveloperExceptionPage();
    //Original code
    app.UseSwagger();
    app.UseSwaggerUI(c => c.SwaggerEndpoint("/swagger/v1/swagger.json", "AutoLot.Api v1"));
  }

  //redirect http traffic to https
  app.UseHttpsRedirection();
  //opt-in to routing
  app.UseRouting();
  //enable authorization checks
  app.UseAuthorization();
  //opt-in to using endpoint routing
  //use attribute routing on controllers
  app.UseEndpoints(endpoints =>
  {
    endpoints.MapControllers();
  });
}

```

我们将对此进行的更改是当系统在开发中运行时初始化数据库。将`ApplicationDbContext`作为参数添加到方法中，并从 AutoLot.Dal 调用`InitializeData()`。更新后的代码如下所示:

```cs
public void Configure(
  IApplicationBuilder app,
  IWebHostEnvironment env,
  ApplicationDbContext context)
{
  if (env.IsDevelopment())
  {
    //If in development environment, display debug info
    app.UseDeveloperExceptionPage();
    //Initialize the database
   if (Configuration.GetValue<bool>(“RebuildDataBase”))
    {
      SampleDataInitializer.InitializeData(context);
    }
  }
  ...
}

```

现在，用`RebuildDataBase`属性更新`appsettings.development.json`(现在将节点设置为`false`)。

```cs
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  },
  "RebuildDataBase": false,
  "ConnectionStrings": {
    "AutoLot": "Server=db;Database=AutoLotPresentation;User ID=sa;Password=P@ssw0rd;"
  }
}

```

##### AutoLot。手动音量调节

web 应用程序的`Configure()`方法比 API 方法要复杂一些。此处列出了完整的方法，稍后将进行讨论:

```cs
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
  if (env.IsDevelopment())
  {
    app.UseDeveloperExceptionPage();
  }
  else
  {
    app.UseExceptionHandler("/Home/Error");
    app.UseHsts();
  }
  app.UseHttpsRedirection();
  app.UseStaticFiles();
  app.UseRouting();
  app.UseAuthorization();
  app.UseEndpoints(endpoints =>
  {
    endpoints.MapControllerRoute(
      name: "default",
      pattern: "{controller=Home}/{action=Index}/{id?}");
  });
}

```

该方法还检查环境，如果设置为`development`，则添加中间件`DeveloperExceptionPage`。如果环境不是开发，那么通用的`ExceptionHandler`中间件以及 HTTP 严格传输安全协议(HSTS)将被添加到管道中。

回到主执行路径，像它的 API 对应物一样，添加了对`app.UseHttpsRedirection()`的调用。下一步是用`app.UseStaticFiles()`添加对静态文件的支持。作为一种安全措施，可以选择支持静态文件。如果你的 app 不需要它们(比如 API)，那么就不要添加支持，它们不可能是安全隐患。添加了路由、授权和端点中间件。

将`ApplicationDbContext`作为参数添加到方法中，并从 AutoLot.Dal 调用`InitializeData()`。更新后的代码如下所示:

```cs
public void Configure(
  IApplicationBuilder app,
  IWebHostEnvironment env,
  ApplicationDbContext context)
{
  if (env.IsDevelopment())
  {
    //If in development environment, display debug info
    app.UseDeveloperExceptionPage();
    //Initialize the database
   if (Configuration.GetValue<bool>(“RebuildDataBase”))
    {
      SampleDataInitializer.InitializeData(context);
    }
  }
  ...
}

```

现在，用`RebuildDataBase`属性更新`appsettings.development.json`(现在将节点设置为`false`)。

```cs
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  },
  "RebuildDataBase": false,
  "ConnectionStrings": {
    "AutoLot": "Server=db;Database=AutoLotPresentation;User ID=sa;Password=P@ssw0rd;"
  }
}

```

在`UseEndpoints()`方法中，默认模板设置常规路由。我们将关闭它，并在整个应用程序中使用属性路由。注释掉(或删除)对`MapControllerRoute()`的调用，并替换为`MapControllers()`，如下所示:

```cs
app.UseEndpoints(endpoints =>
{
  endpoints.MapControllers();
});

```

下一个变化是将路线属性添加到自动 Lot 中的`HomeController`。Mvc 应用。首先，将控制器/动作模式添加到控制器本身:

```cs
[Route("[controller]/[action]")]
public class HomeController : Controller
{
  ...
}

```

接下来，将三条路线添加到`Index()`方法中，这样当没有指定动作或者没有指定控制器或动作时，它就是默认动作。此外，将`HttpGet`属性放在方法上，将它显式声明为“get”动作:

```cs
[Route("/")]
[Route("/[controller]")]
[Route("/[controller]/[action]")]
[HttpGet]
public IActionResult Index()
{
  return View();
}

```

### 记录

作为启动和配置过程的一部分，基本日志被添加到依赖注入容器中。`ILogger<T>`是日志基础设施使用的日志接口，非常简单。日志记录的主力是`LoggerExtensions`类，其方法定义如下:

```cs
public static class LoggerExtensions
{
  public static void LogDebug(this ILogger logger, EventId eventId,
    Exception exception, string message, params object[] args)
  public static void LogDebug(this ILogger logger, EventId eventId, string message, params object[] args)
  public static void LogDebug(this ILogger logger, Exception exception, string message, params object[] args)
  public static void LogDebug(this ILogger logger, string message, params object[] args)

  public static void LogTrace(this ILogger logger, EventId eventId,
    Exception exception, string message, params object[] args)
  public static void LogTrace(this ILogger logger, EventId eventId, string message, params object[] args)
  public static void LogTrace(this ILogger logger, Exception exception, string message, params object[] args)
  public static void LogTrace(this ILogger logger, string message, params object[] args)

  public static void LogInformation(this ILogger logger, EventId eventId,
    Exception exception, string message, params object[] args)
  public static void LogInformation(this ILogger logger, EventId eventId, string message, params object[] args)
  public static void LogInformation(this ILogger logger, Exception exception, string message, params object[] args)
  public static void LogInformation(this ILogger logger, string message, params object[] args)

  public static void LogWarning(this ILogger logger, EventId eventId,
    Exception exception, string message, params object[] args)
  public static void LogWarning(this ILogger logger, EventId eventId, string message, params object[] args)
  public static void LogWarning(this ILogger logger, Exception exception, string message, params object[] args)
  public static void LogWarning(this ILogger logger, string message, params object[] args)

  public static void LogError(this ILogger logger, EventId eventId,
    Exception exception, string message, params object[] args)
  public static void LogError(this ILogger logger, EventId eventId, string message, params object[] args)
  public static void LogError(this ILogger logger, Exception exception, string message, params object[] args)
  public static void LogError(this ILogger logger, string message, params object[] args)

  public static void LogCritical(this ILogger logger, EventId eventId,
    Exception exception, string message, params object[] args)
  public static void LogCritical(this ILogger logger, EventId eventId, string message, params object[] args)
  public static void LogCritical(this ILogger logger, Exception exception, string message, params object[] args)
  public static void LogCritical(this ILogger logger, string message, params object[] args)

  public static void Log(this ILogger logger, LogLevel logLevel, string message, params object[] args)
  public static void Log(this ILogger logger, LogLevel logLevel, EventId eventId, string message, params object[] args)
  public static void Log(this ILogger logger, LogLevel logLevel,
    Exception exception, string message, params object[] args)
  public static void Log(this ILogger logger, LogLevel logLevel, EventId eventId,
    Exception exception, string message, params object[] args)
}

```

ASP.NET 核心的一个强大特性是管道整体的可扩展性，特别是日志记录。只要新的框架能够与日志模式集成，默认日志记录器就可以与另一个日志框架交换。Serilog 是一个与 ASP.NET 核心集成的框架。接下来的部分将介绍如何创建基于 Serilog 的日志记录基础设施，以及如何配置 ASP.NET 核心应用程序来使用新的日志记录代码。

#### IAppLogging 接口

首先在 AutoLot 中添加名为`Logging`的新目录。服务项目。在这个目录中，添加一个名为`IAppLogging<T>`的新接口。更新此接口中的代码以匹配以下内容:

```cs
using System;
using System.Runtime.CompilerServices;

namespace AutoLot.Services.Logging
{
  public interface IAppLogging<T>
  {
    void LogAppError(Exception exception, string message,
      [CallerMemberName] string memberName = "",
      [CallerFilePath] string sourceFilePath = "",
      [CallerLineNumber] int sourceLineNumber = 0);

    void LogAppError(string message,
      [CallerMemberName] string memberName = "",
      [CallerFilePath] string sourceFilePath = "",
      [CallerLineNumber] int sourceLineNumber = 0);

    void LogAppCritical(Exception exception, string message,
      [CallerMemberName] string memberName = "",
      [CallerFilePath] string sourceFilePath = "",
      [CallerLineNumber] int sourceLineNumber = 0);

    void LogAppCritical(string message,
      [CallerMemberName] string memberName = "",
      [CallerFilePath] string sourceFilePath = "",
      [CallerLineNumber] int sourceLineNumber = 0);

    void LogAppDebug(string message,
      [CallerMemberName] string memberName = "",
      [CallerFilePath] string sourceFilePath = "",
      [CallerLineNumber] int sourceLineNumber = 0);

    void LogAppTrace(string message,
      [CallerMemberName] string memberName = "",
      [CallerFilePath] string sourceFilePath = "",
      [CallerLineNumber] int sourceLineNumber = 0);

    void LogAppInformation(string message,
      [CallerMemberName] string memberName = "",
      [CallerFilePath] string sourceFilePath = "",
      [CallerLineNumber] int sourceLineNumber = 0);

    void LogAppWarning(string message,
      [CallerMemberName] string memberName = "",
      [CallerFilePath] string sourceFilePath = "",
      [CallerLineNumber] int sourceLineNumber = 0);
  }
}

```

属性`CallerMemberName`、`CallerFilePath`和`CallerLineNumber`检查调用堆栈，从调用代码中获取它们的命名值。例如，如果调用`LogAppWarning()`的代码行在名为`MyClassFile.cs`的文件中的`DoWork()`函数中，并且位于第 36 行，那么调用:

```cs
_appLogger.LogAppWarning(“A warning”);

```

被转换成等价的:

```cs
_appLogger.LogAppWarning(“A warning”,”DoWork”,”c:/myfilepath/MyClassFile.cs”,36);

```

如果值被传入方法调用，则使用传入的值，而不是属性中的值。

#### 应用程序类

`AppLogging`类实现了`IAppLogging`接口。添加一个名为`AppLogging`的新类，并将`using`语句更新如下:

```cs
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using Serilog.Context;

```

公开类并实现`IAppLogging<T>`。添加一个接受`ILogger<T>`(ASP.NET 内核直接支持的接口)实例和`IConfiguration`实例的构造函数。在构造函数中，访问配置以从设置文件中检索应用程序名称。所有这三项(`ILogger<T>`、`IConfiguration`和应用程序名称)都需要保存在类级变量中。

```cs
namespace AutoLot.Services.Logging
{
  public class AppLogging<T> : IAppLogging<T>
  {
    private readonly ILogger<T> _logger;
    private readonly IConfiguration _config;
    private readonly string _applicationName;

    public AppLogging(ILogger<T> logger, IConfiguration config)
    {
      _logger = logger;
      _config = config;
      _applicationName = config.GetValue<string>("ApplicationName");
    }
  }
}

```

Serilog 通过将属性推送到`LogContext`上，支持将属性添加到标准日志记录过程中。添加一个内部方法来推送`MemberName`、`FilePath`、`LineNumber`和`ApplicationName`属性。

```cs
internal List<IDisposable> PushProperties(
  string memberName,
  string sourceFilePath,
  int sourceLineNumber)
{
  List<IDisposable> list = new List<IDisposable>
  {
    LogContext.PushProperty("MemberName", memberName),
    LogContext.PushProperty("FilePath", sourceFilePath),
    LogContext.PushProperty("LineNumber", sourceLineNumber),
    LogContext.PushProperty("ApplicationName", _applicationName)
  };
  return list;
}

```

每个方法实现都遵循相同的过程。第一步是调用`PushProperties()`方法来添加额外的属性，然后调用由`ILogger<T>`上的`LoggerExtensions`公开的适当的日志记录方法。这里列出了所有实现的接口方法:

```cs
public void LogAppError(Exception exception, string message,
  [CallerMemberName] string memberName = "",
  [CallerFilePath] string sourceFilePath = "",
  [CallerLineNumber] int sourceLineNumber = 0)
{
  var list = PushProperties(memberName, sourceFilePath, sourceLineNumber);
  _logger.LogError(exception, message);
  foreach (var item in list)
  {
    item.Dispose();
  }
}

public void LogAppError(string message,
  [CallerMemberName] string memberName = "",
  [CallerFilePath] string sourceFilePath = "",
  [CallerLineNumber] int sourceLineNumber = 0)
{
  var list = PushProperties(memberName, sourceFilePath, sourceLineNumber);
  _logger.LogError(message);
  foreach (var item in list)
  {
    item.Dispose();
  }
}

public void LogAppCritical(Exception exception, string message,
  [CallerMemberName] string memberName = "",
  [CallerFilePath] string sourceFilePath = "",
  [CallerLineNumber] int sourceLineNumber = 0)
{
  var list = PushProperties(memberName, sourceFilePath, sourceLineNumber);
  _logger.LogCritical(exception, message);
  foreach (var item in list)
  {
    item.Dispose();
  }
}

public void LogAppCritical(string message,
  [CallerMemberName] string memberName = "",
  [CallerFilePath] string sourceFilePath = "",
  [CallerLineNumber] int sourceLineNumber = 0)
{
  var list = PushProperties(memberName, sourceFilePath, sourceLineNumber);
  _logger.LogCritical(message);
  foreach (var item in list)
  {
    item.Dispose();
  }
}

public void LogAppDebug(string message,
  [CallerMemberName] string memberName = "",
  [CallerFilePath] string sourceFilePath = "",
  [CallerLineNumber] int sourceLineNumber = 0)
{
  var list = PushProperties(memberName, sourceFilePath, sourceLineNumber);
  _logger.LogDebug(message);
  foreach (var item in list)
  {
    item.Dispose();
  }
}

public void LogAppTrace(string message,
  [CallerMemberName] string memberName = "",
  [CallerFilePath] string sourceFilePath = "",
  [CallerLineNumber] int sourceLineNumber = 0)
{
  var list = PushProperties(memberName, sourceFilePath, sourceLineNumber);
  _logger.LogTrace(message);
  foreach (var item in list)
  {
    item.Dispose();
  }
}

public void LogAppInformation(string message,
  [CallerMemberName] string memberName = "",
  [CallerFilePath] string sourceFilePath = "",
  [CallerLineNumber] int sourceLineNumber = 0)
{
  var list = PushProperties(memberName, sourceFilePath, sourceLineNumber);
  _logger.LogInformation(message);
  foreach (var item in list)
  {
    item.Dispose();
  }
}

public void LogAppWarning(string message,
  [CallerMemberName] string memberName = "",
  [CallerFilePath] string sourceFilePath = "",
  [CallerLineNumber] int sourceLineNumber = 0)
{
  var list = PushProperties(memberName, sourceFilePath, sourceLineNumber);
  _logger.LogWarning(message);
  foreach (var item in list)
  {
    item.Dispose();
  }
}

```

#### 日志记录配置

通过向 AutoLot 的`Logging`目录添加一个名为`LoggingConfiguration`的新类，开始用 Serilog 替换默认日志程序。服务项目。将`using`语句更新为以下内容，并创建`public`和`static`类，如下所示:

```cs
using System;
using System.Collections.Generic;
using System.Data;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Serilog;
using Serilog.Events;
using Serilog.Sinks.MSSqlServer;

namespace AutoLot.Services.Logging
{
  public static class LoggingConfiguration
  {
  }
}

```

Serilog 使用接收器写入不同的日志记录目标。我们将用于登录 ASP.NET 核心应用程序的目标是文本文件、数据库和控制台。文本文件和数据库接收器需要配置、文本文件接收器的输出模板和数据库接收器的字段列表。

要设置文件模板，创建以下静态`readonly`字符串:

```cs
private static readonly string OutputTemplate =
  @"[{Timestamp:yy-MM-dd HH:mm:ss} {Level}]{ApplicationName}:{SourceContext}{NewLine}Message:{Message}{NewLine}in method {MemberName} at {FilePath}:{LineNumber}{NewLine}{Exception}{NewLine}";

```

SQL Server 接收器需要一个使用`SqlColumn`类型标识的列列表。添加以下代码来配置数据库列:

```cs
private static readonly ColumnOptions ColumnOptions = new ColumnOptions
{
  AdditionalColumns = new List<SqlColumn>
  {
    new SqlColumn {DataType = SqlDbType.VarChar, ColumnName = "ApplicationName"},
    new SqlColumn {DataType = SqlDbType.VarChar, ColumnName = "MachineName"},
    new SqlColumn {DataType = SqlDbType.VarChar, ColumnName = "MemberName"},
    new SqlColumn {DataType = SqlDbType.VarChar, ColumnName = "FilePath"},
    new SqlColumn {DataType = SqlDbType.Int, ColumnName = "LineNumber"},
    new SqlColumn {DataType = SqlDbType.VarChar, ColumnName = "SourceContext"},
    new SqlColumn {DataType = SqlDbType.VarChar, ColumnName = "RequestPath"},
    new SqlColumn {DataType = SqlDbType.VarChar, ColumnName = "ActionName"},
  }
};

```

用 Serilog 替换默认日志程序是一个三步的过程。第一步是清除现有的提供者，第二步是将 Serilog 添加到`HostBuilder`中，第三步是完成 Serilog 的配置。添加一个名为`ConfigureSerilog()`的新方法，它是对`IHostBuilder`的扩展方法。

```cs
public static IHostBuilder ConfigureSerilog(this IHostBuilder builder)
{
  builder
    .ConfigureLogging((context, logging) => { logging.ClearProviders(); })
    .UseSerilog((hostingContext, loggerConfiguration) =>
  {
    var config = hostingContext.Configuration;
    var connectionString = config.GetConnectionString("AutoLot").ToString();
    var tableName = config["Logging:MSSqlServer:tableName"].ToString();
    var schema = config["Logging:MSSqlServer:schema"].ToString();
    string restrictedToMinimumLevel =
      config["Logging:MSSqlServer:restrictedToMinimumLevel"].ToString();
    if (!Enum.TryParse<LogEventLevel>(restrictedToMinimumLevel, out var logLevel))
    {
      logLevel = LogEventLevel.Debug;
    }
    LogEventLevel level = (LogEventLevel)Enum.Parse(typeof(LogEventLevel), restrictedToMinimumLevel);
    var sqlOptions = new MSSqlServerSinkOptions
    {
      AutoCreateSqlTable = false,
      SchemaName = schema,
      TableName = tableName,
    };
    if (hostingContext.HostingEnvironment.IsDevelopment())
    {
      sqlOptions.BatchPeriod = new TimeSpan(0, 0, 0, 1);
      sqlOptions.BatchPostingLimit = 1;
    }
    loggerConfiguration
      .Enrich.FromLogContext()
      .Enrich.WithMachineName()
      .WriteTo.File(
        path: "ErrorLog.txt",
        rollingInterval: RollingInterval.Day,
        restrictedToMinimumLevel: logLevel,
        outputTemplate: OutputTemplate)
      .WriteTo.Console(restrictedToMinimumLevel: logLevel)
      .WriteTo.MSSqlServer(
        connectionString: connectionString,
        sqlOptions,
        restrictedToMinimumLevel: level,
        columnOptions: ColumnOptions);
  });
  return builder;
}

```

一切就绪后，是时候用 Serilog 替换默认日志了。

##### 应用程序设置更新

自动 Lot 的所有应用程序设置文件(`appsettings.json`、`appsettings.development.json`和`appsettings.production`)的`Logging`部分。Api 和 AutoLot。Dal 项目必须用新的日志信息更新，并添加应用程序名称。

打开`appsettings.json`文件，将 JSON 更新为以下内容，确保为`ApplicationName`节点使用正确的项目名称，并更新连接字符串以匹配您的配置:

```cs
//appsettings.json
{
  "Logging": {
    "MSSqlServer": {
      "schema": "Logging",
      "tableName": "SeriLogs",
      "restrictedToMinimumLevel": "Warning"
    }
  },
  "ApplicationName": "AutoLot.Api",
  "AllowedHosts": "*"
}

//appsettings.development.json
{
  "Logging": {
    "MSSqlServer": {
      "schema": "Logging",
      "tableName": "SeriLogs",
      "restrictedToMinimumLevel": "Warning"
    }
  },
  "RebuildDataBase": false,
  "ApplicationName": "AutoLot.Api - Dev",
  "ConnectionStrings": {
    "AutoLot": "Server=.,5433;Database=AutoLot;User ID=sa;Password=P@ssw0rd;"
  }
}

//appsettings.production.json
{
  "Logging": {
    "MSSqlServer": {
      "schema": "Logging",
      "tableName": "SeriLogs",
      "restrictedToMinimumLevel": "Warning"
    }
  },
  "RebuildDataBase": false,
  "ApplicationName": "AutoLot.Api - Prod",
  "ConnectionStrings": {
    "AutoLot": "It's a secret"
  }
}

```

##### Program.cs 更新

将以下`using`语句添加到两个自动 Lot 中的`Program.cs`文件中。Api 和 AutoLot。Mvc 项目:

```cs
using AutoLot.Services.Logging;

```

接下来，将两个项目中的`CreateHostBuilder()`方法更新为:

```cs
public static IHostBuilder CreateHostBuilder(string[] args) =>
  Host.CreateDefaultBuilder(args)
          .ConfigureWebHostDefaults(webBuilder =>
          {
            webBuilder.UseStartup<Startup>();
          }).ConfigureSerilog();

```

##### Startup.cs 更新

将以下`using`语句添加到两个自动 Lot 中的`Startup.cs`文件中。Api 和 AutoLot。Mvc 项目:

```cs
using AutoLot.Services.Logging;

```

接下来，需要将新的日志记录接口添加到依赖注入容器中。将以下内容添加到两个项目的`ConfigureServices()`方法中:

```cs
services.AddScoped(typeof(IAppLogging<>), typeof(AppLogging<>));

```

##### 控制器更新

下一个变化是将对`ILogger`的任何引用更新为`IAppLogging`。从自动手枪中的`WeatherForecastController`开始。Api 项目。将下面的`using`语句添加到类中:

```cs
using AutoLot.Services.Logging;

```

接下来，更新`ILogger<T> IAppLogging<T>`。

```cs
[ApiController]
[Route("[controller]")]
public class WeatherForecastController : ControllerBase
{
...
  private readonly IAppLogging<WeatherForecastController> _logger;
  public WeatherForecastController(IAppLogging<WeatherForecastController> logger)
  {
    _logger = logger;
  }
...
}

```

现在更新自动 Lot 中的`HomeController`。Mvc 项目。将下面的`using`语句添加到类中:

```cs
using AutoLot.Services.Logging;

```

接下来，更新`ILogger<T> IAppLogging<T>`。

```cs
[Route("[controller]/[action]")]
public class HomeController : Controller
{
  private readonly IAppLogging<HomeController> _logger;
  public HomeController(IAppLogging<HomeController> logger)
  {
    _logger = logger;
  }
...
}

```

然后，只需像这样简单地调用记录器，就可以在每个控制器中完成日志记录:

```cs
//WeatherForecastController.cs (AutoLot.Api)
[HttpGet]
public IEnumerable<WeatherForecast> Get()
{
  _logger.LogAppWarning("This is a test");
...
}

//HomeController.cs (AutoLot.Mvc)
[Route("/")]
[Route("/[controller]")]
[Route("/[controller]/[action]")]
[HttpGet]
public IActionResult Index()
{
  _logger.LogAppWarning("This is a test");
  return View();
}

```

#### 测试日志框架

有了 Serilog 之后，是时候测试应用程序的日志记录了。如果您使用的是 Visual Studio，请设置 AutoLot。Mvc 应用程序作为启动应用程序(在解决方案资源管理器中右击，选择“设为启动项目”，然后单击绿色的运行箭头，或按 F5)。如果使用的是 Visual Studio 代码，打开终端窗口(Ctrl+`)，导航到`AutoLot.Mvc`目录，输入`dotnet run`。

使用 Visual Studio，浏览器将自动启动到`Home/Index`视图(您将看到“欢迎/了解使用 ASP.NET 核心构建应用”)。如果您正在使用 Visual Studio 代码，您将需要打开一个浏览器并导航到`https://localhost:5001`。一旦浏览器加载完毕，您就可以关闭它，因为登录调用是在主页加载时进行的。使用 VS 关闭浏览器将会停止调试。若要停止使用 VS 代码进行调试，请在终端窗口中按 Ctrl+C。

在项目目录中，您会看到一个名为`ErrorLogYYYYMMDD.txt`的文件。在该文件中，您将看到一个类似如下的条目:

```cs
[YY-MM-DD hh:mm:ss Warning]AutoLot.Mvc - Dev:AutoLot.Mvc.Controllers.HomeController
Message:This is a test
in method Index at D:\Projects\Books\csharp9-wf\Code\New\Chapter_29\AutoLot.Mvc\Controllers\HomeController.cs:30

```

测试自动测试中的记录代码。Api 项目，将该项目设置为启动应用程序(VS)或导航到 AutoLot。终端窗口中的 Api 目录(VCS)。按 F5 或输入`dotnet run`并导航至`https://localhost:44375/swagger/index.html`。这将加载 API 应用程序的 Swagger 页面，如图 [29-6](#Fig6) 所示。

![img/340876_10_En_29_Chapter/340876_10_En_29_Fig6_HTML.jpg](img/340876_10_En_29_Chapter/340876_10_En_29_Fig6_HTML.jpg)

图 29-6

AutoLot 的初始 Swagger 页面。美国石油学会(American Petroleum Institute)

点击`WeatherForecast`条目的获取按钮。这将打开一个屏幕，显示该操作方法的详细信息，包括一个“尝试”选项，如图 [29-7](#Fig7) 所示。

![img/340876_10_En_29_Chapter/340876_10_En_29_Fig7_HTML.jpg](img/340876_10_En_29_Chapter/340876_10_En_29_Fig7_HTML.jpg)

图 29-7

天气预报控制器的 Get 方法的详细信息

点击“尝试”按钮后，点击执行按钮(图 [29-8](#Fig8) )，顾名思义，执行对端点的调用。

![img/340876_10_En_29_Chapter/340876_10_En_29_Fig8_HTML.jpg](img/340876_10_En_29_Chapter/340876_10_En_29_Fig8_HTML.jpg)

图 29-8

执行天气预报控制器的 Get 方法的详细信息

在自动售货机里。Api 项目目录下，你会再次看到一个名为`ErrorLogYYYYMMDD.txt`的文件。在该文件中，您会发现类似于以下内容的条目:

```cs
[YY-MM-DD hh:mm:ss Warning]AutoLot.Api - Dev:AutoLot.Api.Controllers.WeatherForecastController
Message:This is a test
in method Get at D:\Projects\Books\csharp9-wf\Code\New\Chapter_29\AutoLot.Api\Controllers\WeatherForecastController.cs:30

```

Note

ASP.NET 核心 5 中新增的 Swagger 在 API 模板中是默认启用的。斯瓦格将在下一章详细讨论。

## 摘要

本章介绍了 ASP.NET 核心，是涵盖 ASP.NET 核心的一系列章节中的第一章。本章首先简要回顾了 ASP.NET 的历史，然后介绍了 ASP.NET 核心中的经典 ASP.NET MVC 和 ASP.NET Web API 的特性。

接下来的部分将研究 ASP.NET 核心中的新特性以及它们是如何工作的。然后，在了解了运行和调试 ASP.NET 核心应用程序的不同方法后，您用两个 ASP.NET 核心项目、一个应用程序服务的公共库和 AutoLot 数据访问层(来自第 [23 章](23.html))建立了解决方案。最后，在这两个项目中，您用 Serilog 替换了默认的 ASP.NET 岩心记录器。

在下一章中，您将完成自动 Lot。Api 应用程序。