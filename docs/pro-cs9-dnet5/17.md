# 17.类型反射、后期绑定和基于属性的编程

如第 [16](16.html) 章所示，组件是部署的基本单位。净核心宇宙。使用 Visual Studio 的集成对象浏览器(以及许多其他 ide)，您可以检查项目引用的程序集集合中的类型。此外，像`ildasm.exe`这样的外部工具允许您查看给定的底层 CIL 代码、类型元数据和程序集清单。网芯二进制。除了设计时对。NET 核心程序集，您也能够通过编程方式*使用`System.Reflection`名称空间获得相同的信息。为此，本章的首要任务是界定反思的作用和必要性。NET 核心元数据。*

 *本章的剩余部分研究了几个密切相关的主题，它们依赖于反射服务。例如，您将了解. NET 核心客户端如何使用动态加载和后期绑定来激活它在编译时不了解的类型。您还将了解如何将自定义元数据插入到您的。NET 核心程序集使用系统提供的和自定义的属性。为了将所有这些(看似深奥的)主题放在适当的位置，本章最后演示了如何构建几个可以插入可扩展控制台应用程序的“管理单元对象”。

## 类型元数据的必要性

使用元数据完整描述类型(类、接口、结构、枚举和委托)的能力是。NET 核心平台。很多。NET 核心技术，如对象序列化，需要能够在运行时发现类型的格式。此外，跨语言的互操作性、众多的编译器服务和 IDE 的智能感知能力都依赖于对类型的具体描述。

回想一下，`ildasm.exe`实用程序允许您查看程序集的类型元数据。在生成的`CarLibrary.il`文件中(来自第[章第 16 节](16.html)，导航到`METAINFO`部分查看所有卡莉图库的元数据。这里有一小段:

```
// ==== M E T A I N F O ===

// ===========================================================
// ScopeName : CarLibrary.dll
// MVID      : {598BC2B8-19E9-46EF-B8DA-672A9E99B603}
// ===========================================================
// Global functions
// -------------------------------------------------------
//
// Global fields
// -------------------------------------------------------
//
// Global MemberRefs
// -------------------------------------------------------
//
// TypeDef #1
// -------------------------------------------------------
//   TypDefName: CarLibrary.Car
//   Flags     : [Public] [AutoLayout] [Class] [Abstract] [AnsiClass] [BeforeFieldInit]
//   Extends   : [TypeRef] System.Object
//   Field #1
//   -------------------------------------------------------
//     Field Name: value__
//     Flags     : [Private]
//     CallCnvntn: [FIELD]
//     Field type:  String
//

```

如您所见。NET 核心类型元数据很冗长(实际的二进制格式要简洁得多)。事实上，如果我要列出代表`CarLibrary.dll`程序集的整个元数据描述，它将跨越几页。考虑到这种行为是对纸张的严重浪费，让我们来看一下`CarLibrary.dll`程序集的一些关键元数据描述。

Note

不要太在意每一段。NET 核心元数据。更重要的是。NET Core 元数据非常具有描述性，列出了在给定代码库中找到的每个内部定义(和外部引用)的类型。

### 查看 EngineStateEnum 枚举的(部分)元数据

当前程序集中定义的每个类型都使用一个`TypeDef #n`标记进行记录(其中`TypeDef`是*类型定义*的缩写)。如果所描述的类型使用在单独的。NET 核心程序集，引用的类型使用一个`TypeRef #n`标记来记录(其中`TypeRef`是*类型引用*的缩写)。`TypeRef`标记是一个指针(如果你愿意的话)，指向外部程序集中被引用类型的完整元数据定义。简单地说，。NET Core 元数据是一组清楚地标记所有类型定义(`TypeDef` s)和引用类型(`TypeRef` s)的表，所有这些都可以使用`ildasm.exe`来检查。

就`CarLibrary.dll`而言，一个`TypeDef`是`CarLibrary.EngineStateEnum`枚举的元数据描述(你的数字可能不同；`TypeDef`编号基于 C#编译器处理文件的顺序)。

```
// TypeDef #2
// -------------------------------------------------------
//   TypDefName: CarLibrary.EngineStateEnum
//   Flags     : [Public] [AutoLayout] [Class] [Sealed] [AnsiClass]
//   Extends   : [TypeRef] System.Enum
//   Field #1
//   -------------------------------------------------------
//     Field Name: value__
//     Flags     : [Public] [SpecialName] [RTSpecialName]
//     CallCnvntn: [FIELD]
//     Field type:  I4
//
//   Field #2
//   -------------------------------------------------------
//     Field Name: EngineAlive
//     Flags     : [Public] [Static] [Literal] [HasDefault]
//     DefltValue: (I4) 0
//     CallCnvntn: [FIELD]
//     Field type:  ValueClass CarLibrary.EngineStateEnum
//
...

```

这里，`TypDefName`标记用于建立给定类型的名称，在本例中是自定义的`CarLibrary.EngineStateEnum`枚举。`Extends`元数据标记用于记录给定。NET 核心类型(在本例中是引用类型，`System.Enum`)。枚举的每个字段都用`Field #n`标记。为了简洁起见，我只简单地列出了部分元数据。

Note

虽然看起来像是一个错别字，`TypDefName`并没有人们所期望的“e”。

### 查看汽车类型的(部分)元数据

下面是`Car`类的部分转储，说明了以下内容:

*   如何定义字段？网络核心元数据

*   方法是如何通过？网络核心元数据

*   中如何表示自动属性。网络核心元数据

```
// TypeDef #1
// -------------------------------------------------------
//   TypDefName: CarLibrary.Car
//   Flags     : [Public] [AutoLayout] [Class] [Abstract] [AnsiClass] [BeforeFieldInit]
//   Extends   : [TypeRef] System.Object
//   Field #1
//   -------------------------------------------------------
//     Field Name: <PetName>k__BackingField
//     Flags     : [Private]
//     CallCnvntn: [FIELD]
//     Field type:  String
...

  Method #1
-------------------------------------------------------
    MethodName: get_PetName
    Flags      : [Public] [HideBySig] [ReuseSlot] [SpecialName]
    RVA        : 0x000020d0
    ImplFlags  : [IL] [Managed]
    CallCnvntn: [DEFAULT]
    hasThis
    ReturnType: String
    No arguments.

...

//   Method #2
//   -------------------------------------------------------
//     MethodName: set_PetName
//     Flags     : [Public] [HideBySig] [ReuseSlot] [SpecialName]
//     RVA       : 0x00002058
//     ImplFlags : [IL] [Managed]
//     CallCnvntn: [DEFAULT]
//     hasThis
//     ReturnType: Void
//     1 Arguments
//       Argument #1:  String
//     1 Parameters
//       (1) ParamToken : Name : value flags: [none]
...

//   Property #1
//   -------------------------------------------------------
//     Prop.Name : PetName
//     Flags     : [none]
//     CallCnvntn: [PROPERTY]
//     hasThis
//     ReturnType: String
//     No arguments.
//     DefltValue:
//     Setter    : set_PetName
//     Getter    : get_PetName
//     0 Others
...

```

首先，请注意，`Car`类元数据标记了该类型的基类(`System.Object`)，并包括描述该类型如何构造的各种标志(例如，`[Public]`、`[Abstract]`等等)。方法(如`Car`的构造函数)由它们的参数、返回值和名称来描述。

请注意自动属性是如何产生编译器生成的私有支持字段(名为`<PetName>k__BackingField`)和两个编译器生成的方法(在读写属性的情况下)的，在本例中，这两个方法名为`get_PetName()`和`set_PetName()`。最后，实际属性被映射到内部的`get` / `set`方法。NET Core 元数据`Getter` / `Setter`令牌。

### 检查 TypeRef

回想一下，程序集的元数据将不仅描述内部类型的集合(`Car`、`EngineStateEnum`等)。)以及内部类型引用的任何外部类型。例如，假设`CarLibrary.dll`已经定义了两个枚举，您可以为`System.Enum`类型找到一个`TypeRef`块，如下所示:

```
// TypeRef #19
// -------------------------------------------------------
// Token:             0x01000013
// ResolutionScope:   0x23000001
// TypeRefName:       System.Enum

```

### 记录定义程序集

`CarLibrary.il`文件还允许您查看。使用`Assembly`标记描述程序集本身的. NET 核心元数据。以下是`CarLibrary.dll`货单的部分转储:

```
// Assembly
// -------------------------------------------------------
//   Token: 0x20000001
//   Name : CarLibrary
//   Public Key    :
//   Hash Algorithm : 0x00008004
//   Version: 1.0.0.1
//   Major Version: 0x00000001
//   Minor Version: 0x00000000
//   Build Number: 0x00000000
//   Revision Number: 0x00000001
//   Locale: <null>
//   Flags : [none] (00000000)

```

### 记录引用的程序集

除了`Assembly`令牌和一组`TypeDef`和`TypeRef`块之外。NET Core 元数据还利用`AssemblyRef #n`标记来记录每个外部程序集。鉴于每个人。NET Core 程序集引用了`System.Runtime`基类库程序集，您为`System.Runtime`程序集找到了一个`AssemblyRef`，如下面的代码所示:

```
// AssemblyRef #1 (23000001)
// -------------------------------------------------------
//   Token: 0x23000001
//   Public Key or Token: b0 3f 5f 7f 11 d5 0a 3a
//   Name: System.Runtime
//   Version: 5.0.0.0
//   Major Version: 0x00000005
//   Minor Version: 0x00000000
//   Build Number: 0x00000000
//   Revision Number: 0x00000000
//   Locale: <null>
//   HashValue Blob:
//   Flags: [none] (00000000) 

```

### 记录字符串文字

最后一个有趣的地方是。NET Core 元数据是这样一个事实，即代码库中的每个字符串都记录在`User Strings`标记下。

```
// User Strings
// -------------------------------------------------------
// 70000001 : (23) L"CarLibrary Version 2.0!"
// 70000031 : (13) L"Quiet time..."
// 7000004d : (11) L"Jamming {0}"
// 70000065 : (32) L"Eek! Your engine block exploded!"
// 700000a7 : (34) L"Ramming speed! Faster is better..."

```

Note

如最后一个元数据列表所示，请始终注意，所有字符串都清楚地记录在程序集元数据中。如果您使用字符串来表示密码、信用卡号或其他敏感信息，这可能会带来巨大的安全后果。

您脑海中的下一个问题可能是(在最好的情况下)“我如何在我的应用程序中利用这些信息？”或者(在最坏的情况下)“我为什么要关心元数据？”为了回应这两种观点，请允许我介绍。NET 核心反射服务。请注意，在本章结束之前，接下来几页中介绍的主题的有用性可能有点让人摸不着头脑。所以，坚持住。

Note

您还会发现一些由`METAINFO`部分显示的`CustomAttribute`标记，它记录了代码库中应用的属性。你将会了解到。NET 核心属性。

## 理解反射

在。NET 核心宇宙，*反射*是运行时类型发现的过程。使用反射服务，您可以使用友好的对象模型以编程方式获得由`ildasm.exe`生成的相同元数据信息。例如，通过反射，您可以获得包含在给定的`*.dll`或`*.exe`程序集内的所有类型的列表，包括由给定类型定义的方法、字段、属性和事件。您还可以动态地发现给定类型支持的接口集、方法的参数以及其他相关细节(基类、命名空间信息、清单数据等)。).

像任何名称空间一样，`System.Reflection`(在`System.Runtime.dll`中定义)包含几个相关的类型。表 [17-1](#Tab1) 列出了一些你应该熟悉的核心项目。

表 17-1。

*系统成员的抽样。反射*名称空间

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

类型

 | 

生命的意义

 |
| --- | --- |
| `Assembly` | 此抽象类包含允许您加载、调查和操作程序集的成员。 |
| `AssemblyName` | 这个类允许您发现程序集标识背后的许多细节(版本信息、区域性信息等)。). |
| `EventInfo` | 这个抽象类保存给定事件的信息。 |
| `FieldInfo` | 这个抽象类保存给定字段的信息。 |
| `MemberInfo` | 这是一个抽象基类，定义了`EventInfo`、`FieldInfo`、`MethodInfo`和`PropertyInfo`类型的通用行为。 |
| `MethodInfo` | 这个抽象类包含给定方法的信息。 |
| `Module` | 这个抽象类允许您访问多文件程序集中的给定模块。 |
| `ParameterInfo` | 这个类保存给定参数的信息。 |
| `PropertyInfo` | 这个抽象类保存给定属性的信息。 |

了解如何利用`System.Reflection`名称空间以编程方式读取。NET 核心元数据，您需要首先接受`System.Type`类。

### 系统。类型类别

`System.Type`类定义了可用于检查类型元数据的成员，其中许多成员从`System.Reflection`名称空间返回类型。例如，`Type.GetMethods()`返回一组`MethodInfo`对象，`Type.GetFields()`返回一组`FieldInfo`对象，依此类推。`System.Type`曝光的全套成员相当膨胀；然而，表 [17-2](#Tab2) 提供了由`System.Type`支持的成员的部分快照(参见。NET 核心文档以了解全部详细信息)。

表 17-2。

选择*系统的成员。类型*

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

成员

 | 

生命的意义

 |
| --- | --- |
| `IsAbstract``IsArray``IsClass``IsCOMObject``IsEnum``IsGenericTypeDefinition``IsGenericParameter``IsInterface``IsPrimitive``IsNestedPrivate``IsNestedPublic``IsSealed``IsValueType` | 这些属性(以及其他属性)允许您发现您所引用的`Type`的一些基本特征(例如，如果它是一个抽象实体、一个数组、一个嵌套类等等。). |
| `GetConstructors()``GetEvents()``GetFields()``GetInterfaces()``GetMembers()``GetMethods()``GetNestedTypes()``GetProperties()` | 这些方法(以及其他方法)允许您获得一个表示项目(接口、方法、属性等)的数组。)你感兴趣。每个方法返回一个相关的数组(例如，`GetFields()`返回一个`FieldInfo`数组，`GetMethods()`返回一个`MethodInfo`数组，等等)。).请注意，这些方法都有单数形式(例如，`GetMethod()`、`GetProperty()`等)。)允许您按名称检索特定的项，而不是所有相关项的数组。 |
| `FindMembers()` | 该方法根据搜索条件返回一个`MemberInfo`数组。 |
| `GetType()` | 这个静态方法返回一个给定字符串名称的`Type`实例。 |
| `InvokeMember()` | 该方法允许给定项目的“后期绑定”。在本章的后面你会学到后期绑定。 |

### 使用系统获取类型引用。Object.GetType()

您可以通过多种方式获得`Type`类的实例。然而，有一件事你不能做，那就是使用`new`关键字直接创建一个`Type`对象，因为`Type`是一个抽象类。关于您的第一个选择，回想一下`System.Object`定义了一个名为`GetType()`的方法，它返回一个代表当前对象元数据的`Type`类的实例。

```
// Obtain type information using a SportsCar instance.
SportsCar sc = new SportsCar();
Type t = sc.GetType();

```

显然，只有当您知道要反射的类型(在本例中为`SportsCar`)的编译时知识，并且当前在内存中有该类型的实例时，这种方法才有效。考虑到这个限制，像`ildasm.exe`这样的工具不通过直接调用每种类型的`System.Object.GetType()`来获取类型信息应该是有意义的，因为`ildasm.exe`不是针对你的定制程序集编译的。

### 使用 typeof()获取类型引用

获取类型信息的下一种方法是使用 C# `typeof`操作符，如下所示:

```
// Get the type using typeof.
Type t = typeof(SportsCar);

```

与`System.Object.GetType()`不同，`typeof`操作符非常有用，因为您不需要首先创建一个对象实例来提取类型信息。然而，你的代码库必须仍然有你感兴趣的类型的编译时知识，因为`typeof`期望类型的强类型名称。

### 使用系统获取类型引用。Type.GetType()

为了以更灵活的方式获得类型信息，您可以调用`System.Type`类的静态`GetType()`成员，并指定您感兴趣的类型的完全限定字符串名称。使用这种方法，你不需要*而不是*知道你从中提取元数据的类型，因为`Type.GetType()`取了一个无所不在的`System.String`的实例。

Note

当我说您在调用`Type.GetType()`时不需要编译时知识时，我指的是这个方法可以接受任何字符串值(而不是强类型变量)。当然，您仍然需要知道“stringified”格式的类型名！

`Type.GetType()`方法已被重载，允许您指定两个布尔参数，其中一个控制如果找不到类型是否应该抛出异常，另一个确定字符串的大小写。为了说明这一点，请思考以下几点:

```
// Obtain type information using the static Type.GetType() method
// (don't throw an exception if SportsCar cannot be found and ignore case).
Type t = Type.GetType("CarLibrary.SportsCar", false, true);

```

在前面的例子中，请注意您传递到`GetType()`中的字符串没有提到包含该类型的程序集。在这种情况下，假设该类型是在当前执行的程序集中定义的。但是，当您想要获取外部程序集中某个类型的元数据时，字符串参数的格式是使用该类型的完全限定名，后跟一个逗号，再后跟包含该类型的程序集的友好名称(没有任何版本信息的程序集名称)，如下所示:

```
// Obtain type information for a type within an external assembly.
Type t = Type.GetType("CarLibrary.SportsCar, CarLibrary");

```

同样，要知道传入`Type.GetType()`的字符串可能会指定一个加号(`+`)来表示一个*嵌套类型*。假设您想要获取嵌套在名为`JamesBondCar`的类中的枚举(`SpyOptions`)的类型信息。为此，您应该编写以下代码:

```
// Obtain type information for a nested enumeration
// within the current assembly.
Type t = Type.GetType("CarLibrary.JamesBondCar+SpyOptions");

```

## 构建自定义元数据查看器

为了说明反射的基本过程(以及`System.Type`的用处)，让我们创建一个名为 MyTypeViewer 的控制台应用程序项目。这个程序将显示`System.Runtime.dll`中任何类型的方法、属性、字段和支持的接口的详细信息(除了一些其他感兴趣的点)。NET 核心应用程序自动访问此核心框架类库)或 MyTypeViewer 本身内的类型。一旦创建了应用程序，一定要导入`System`、`System.Reflection`和`System.Linq`名称空间。

```
// Need to import this namespace to do any reflection!
using System;
using System.Linq;
using System.Reflection;

```

### 反思方法

几个静态方法将被添加到`Program`类中，每个方法接受一个`System.Type`参数并返回`void`。首先是`ListMethods()`，它(正如您可能猜到的那样)打印由传入类型定义的每个方法的名称。注意`Type.GetMethods()`如何返回一个`System.Reflection.MethodInfo`对象的数组，可以用一个标准的`foreach`循环来枚举，如下所示:

```
// Display method names of type.
static void ListMethods(Type t)
{
  Console.WriteLine("***** Methods *****");
  MethodInfo[] mi = t.GetMethods();
  foreach(MethodInfo m in mi)
  {
    Console.WriteLine("->{0}", m.Name);
  }
  Console.WriteLine();
}

```

这里，您只是使用`MethodInfo.Name`属性打印方法的名称。正如您可能猜到的，`MethodInfo`有许多额外的成员，允许您确定方法是静态的、虚拟的、泛型的还是抽象的。同样，`MethodInfo`类型允许您获得方法的返回值和参数集。您将很快完善`ListMethods()`的实现。

如果愿意，还可以构建一个合适的 LINQ 查询来枚举每个方法的名称。回想一下第 [13](13.html) 章，对象的 LINQ 允许你构建强类型查询，这些查询可以应用于内存中的对象集合。一个好的经验法则是，无论何时发现循环或决策编程逻辑块，都可以利用相关的 LINQ 查询。例如，您可以用 LINQ 重写前面的方法，如下所示:

```
using System.Linq;
static void ListMethods(Type t)
{
  Console.WriteLine("***** Methods *****");
  var methodNames = from n in t.GetMethods() select n.Name;
  foreach (var name in methodNames)
  {
    Console.WriteLine("->{0}", name);
  }
  Console.WriteLine();
}

```

### 反思字段和属性

`ListFields()`的实现也差不多。唯一值得注意的区别是对`Type.GetFields()`的调用和由此产生的`FieldInfo`数组。同样，为了简单起见，使用 LINQ 查询只打印出每个字段的名称。

```
// Display field names of type.
static void ListFields(Type t)
{
  Console.WriteLine("***** Fields *****");
  var fieldNames = from f in t.GetFields() select f.Name;
  foreach (var name in fieldNames)
  {
    Console.WriteLine("->{0}", name);
  }
  Console.WriteLine();
}

```

显示类型属性的逻辑是相似的。

```
// Display property names of type.
static void ListProps(Type t)
{
  Console.WriteLine("***** Properties *****");
  var propNames = from p in t.GetProperties() select p.Name;
  foreach (var name in propNames)
  {
    Console.WriteLine("->{0}", name);
  }
  Console.WriteLine();
}

```

### 反思实现的接口

接下来，您将编写一个名为`ListInterfaces()`的方法，该方法将打印传入类型支持的任何接口的名称。这里唯一有趣的一点是对`GetInterfaces()`的调用返回了一个`System.Type`的数组！鉴于接口确实是类型，这应该是有意义的。

```
// Display implemented interfaces.
static void ListInterfaces(Type t)
{
  Console.WriteLine("***** Interfaces *****");
  var ifaces = from i in t.GetInterfaces() select i;
  foreach(Type i in ifaces)
  {
    Console.WriteLine("->{0}", i.Name);
  }
}

```

Note

要知道大多数的`System.Type` ( `GetMethods()`，`GetInterfaces()`等的“get”方法。)已被重载，以允许您从`BindingFlags`枚举中指定值。这提供了对应该搜索什么的更高级别的控制(例如，仅静态成员、仅公共成员、包括私有成员等)。).有关详细信息，请参考文档。

### 展示各种零碎的东西

最后但同样重要的是，您有一个最终的 helper 方法，它将简单地显示各种统计信息(指示类型是否是泛型、基类是什么、类型是否是密封的，等等)。)关于传入类型。

```
// Just for good measure.
static void ListVariousStats(Type t)
{
  Console.WriteLine("***** Various Statistics *****");
  Console.WriteLine("Base class is: {0}", t.BaseType);
  Console.WriteLine("Is type abstract? {0}", t.IsAbstract);
  Console.WriteLine("Is type sealed? {0}", t.IsSealed);
  Console.WriteLine("Is type generic? {0}", t.IsGenericTypeDefinition);
  Console.WriteLine("Is type a class type? {0}", t.IsClass);
  Console.WriteLine();
}

```

### 添加顶级语句

`Program.cs`文件的顶层语句提示用户输入类型的全限定名。一旦获得这个字符串数据，就将它传递给`Type.GetType()`方法，并将提取的`System.Type`发送给每个助手方法。这个过程一直重复，直到用户按下 Q 来终止应用程序。

```
Console.WriteLine("***** Welcome to MyTypeViewer *****");
string typeName = "";

do
{
  Console.WriteLine("\nEnter a type name to evaluate");
  Console.Write("or enter Q to quit: ");

  // Get name of type.
  typeName = Console.ReadLine();

  // Does user want to quit?
  if (typeName.Equals("Q",StringComparison.OrdinalIgnoreCase))
  {
    break;
  }

  // Try to display type.
  try
  {
    Type t = Type.GetType(typeName);
    Console.WriteLine("");
    ListVariousStats(t);
    ListFields(t);
    ListProps(t);
    ListMethods(t);
    ListInterfaces(t);
  }
  catch
  {
    Console.WriteLine("Sorry, can't find type");
  }
} while (true);

```

至此，`MyTypeViewer.exe`准备试驾了。例如，运行您的应用程序并输入以下完全限定的名称(注意`Type.GetType()`需要区分大小写的字符串名称):

*   `System.Int32`

*   `System.Collections.ArrayList`

*   `System.Threading.Thread`

*   `System.Void`

*   `System.IO.BinaryWriter`

*   `System.Math`

*   `MyTypeViewer.Program`

例如，下面是指定`System.Math`时的部分输出:

```
***** Welcome to MyTypeViewer *****
Enter a type name to evaluate
or enter Q to quit: System.Math

***** Various Statistics *****
Base class is: System.Object
Is type abstract? True
Is type sealed? True
Is type generic? False
Is type a class type? True

***** Fields *****
->PI
->E

***** Properties *****

***** Methods *****
->Acos
->Asin
->Atan
->Atan2
->Ceiling
->Cos

...

```

### 反思静态类型

如果在前面的方法中输入了`System.Console`，那么在第一个帮助器方法中将会抛出一个异常，因为`t`的值将会是 null。不能使用`Type.GetType(typeName)`方法加载静态类型。相反，你必须使用另一种机制，来自`System.Type`的`typeof`函数。更新程序以处理`System.Console`的特殊情况，如下所示:

```
Type t = Type.GetType(typeName);
if (t == null && typeName.Equals("System.Console",
         StringComparison.OrdinalIgnoreCase))
{
  t = typeof(System.Console);
}

```

### 思考泛型类型

当您调用`Type.GetType()`来获取泛型类型的元数据描述时，您必须使用一种特殊的语法，包括一个“反勾”字符(```)，后跟一个表示该类型支持的类型参数数量的数值。例如，如果您想打印出`System.Collections.Generic.List<T>`的元数据描述，您需要将以下字符串传递到您的应用程序中:

```
System.Collections.Generic.List`1

```

这里，您使用的是`1`的数值，因为`List<T>`只有一个类型参数。然而，如果你想反映`Dictionary<TKey, TValue>`，提供值`2`，像这样:

```
System.Collections.Generic.Dictionary`2

```

### 反映方法参数和返回值

到目前为止，一切顺利！接下来，我们将对当前应用程序做一个小小的增强。具体来说，您将更新`ListMethods()` helper 函数，不仅列出给定方法的名称，还列出返回类型和传入参数类型。类型为这些任务提供了`ReturnType`属性和`GetParameters()`方法。在下面修改过的代码中，请注意，您正在使用嵌套的`foreach`循环(没有使用 LINQ)构建一个包含每个参数的类型和名称的字符串:

```
static void ListMethods(Type t)
{
  Console.WriteLine("***** Methods *****");
  MethodInfo[] mi = t.GetMethods();
  foreach (MethodInfo m in mi)
  {
    // Get return type.
    string retVal = m.ReturnType.FullName;
    string paramInfo = "( ";
    // Get params.
    foreach (ParameterInfo pi in m.GetParameters())
    {
      paramInfo += string.Format("{0} {1} ", pi.ParameterType, pi.Name);
    }
    paramInfo += " )";

    // Now display the basic method sig.
    Console.WriteLine("->{0} {1} {2}", retVal, m.Name, paramInfo);
  }
  Console.WriteLine();
}

```

如果您现在运行这个更新的应用程序，您会发现给定类型的方法更加详细。如果您输入您的好朋友`System.Object`作为程序的输入，将显示以下方法:

```
***** Methods *****
->System.Type GetType (  )
->System.String ToString (  )
->System.Boolean Equals ( System.Object obj  )
->System.Boolean Equals ( System.Object objA System.Object objB  )
->System.Boolean ReferenceEquals ( System.Object objA System.Object objB  )
->System.Int32 GetHashCode (  )

```

`ListMethods()`的当前实现很有帮助，因为您可以使用`System.Reflection`对象模型直接研究每个参数和方法返回类型。作为一个极端的捷径，请注意所有的`XXXInfo`类型(`MethodInfo`、`PropertyInfo`、`EventInfo`等)。)已经覆盖了`ToString()`以显示所请求项目的签名。因此，您也可以如下实现`ListMethods()`(再次使用 LINQ，您只需选择所有`MethodInfo`对象，而不仅仅是`Name`值):

```
static void ListMethods(Type t)
{
  Console.WriteLine("***** Methods *****");
  var methodNames = from n in t.GetMethods() select n;
  foreach (var name in methodNames)
  {
    Console.WriteLine("->{0}", name);
  }
  Console.WriteLine();
}

```

有趣的东西，是吧？显然，`System.Reflection`名称空间和`System.Type`类允许你反映类型的许多其他方面，而不仅仅是`MyTypeViewer`当前显示的内容。正如您所希望的，您可以获得类型的事件，获得给定成员的任何泛型参数的列表，并收集许多其他细节。

尽管如此，此时您已经创建了一个(有点功能的)对象浏览器。这个特定示例的主要限制是，除了当前程序集(`MyTypeViewer`)或基类库中始终被引用的程序集(如`mscorlib.dll`)之外，您无法进行反射。这就引出了一个问题“我如何构建可以加载(并反射)编译时未引用的程序集的应用程序？”很高兴你问了。

## 动态加载程序集

有时您需要以编程方式动态加载程序集，即使清单中没有该程序集的记录。正式来说，按需加载外部程序集的行为被称为*动态加载*。

`System.Reflection`定义一个名为`Assembly`的类。使用此类，您可以动态加载程序集，以及发现有关程序集本身的属性。使用`Assembly`类型，您可以动态加载程序集，也可以加载位于任意位置的程序集。从本质上讲，`Assembly`类提供了允许您以编程方式从磁盘加载程序集的方法。

为了演示动态加载，创建一个名为 ExternalAssemblyReflector 的新控制台应用程序项目。您的任务是构造代码，提示输入要动态加载的程序集的名称(不含任何扩展名)。您将把`Assembly`引用传递到一个名为`DisplayTypes()`的 helper 方法中，该方法将简单地打印它包含的每个类、接口、结构、枚举和委托的名称。代码非常简单。

```
using System;
using System.Reflection;
using System.IO; // For FileNotFoundException definition.

Console.WriteLine("***** External Assembly Viewer *****");
string asmName = "";
Assembly asm = null;
do
{
  Console.WriteLine("\nEnter an assembly to evaluate");
  Console.Write("or enter Q to quit: ");
  // Get name of assembly.
  asmName = Console.ReadLine();
  // Does user want to quit?
  if (asmName.Equals("Q",StringComparison.OrdinalIgnoreCase))
  {
    break;
  }

  // Try to load assembly.
  try
  {
    asm = Assembly.LoadFrom(asmName);
    DisplayTypesInAsm(asm);
  }
  catch
  {
    Console.WriteLine("Sorry, can't find assembly.");
  }
} while (true);

static void DisplayTypesInAsm(Assembly asm)
{
  Console.WriteLine("\n***** Types in Assembly *****");
  Console.WriteLine("->{0}", asm.FullName);
  Type[] types = asm.GetTypes();
  foreach (Type t in types)
  {
    Console.WriteLine("Type: {0}", t);
  }
  Console.WriteLine("");
}

```

如果您想通过`CarLibrary.dll`进行反射，您需要将`CarLibrary.dll`二进制文件(来自上一章)复制到 ExternalAssemblyReflector 应用程序的项目目录(如果使用 Visual Studio 代码)或`\bin\Debug\net5.0`(如果使用 Visual Studio)目录，以运行该程序。出现提示时，输入 **CarLibrary** (扩展名可选)，输出如下:

```
***** External Assembly Viewer *****
Enter an assembly to evaluate
or enter Q to quit: CarLibrary

***** Types in Assembly *****
->CarLibrary, Version=1.0.0.1, Culture=neutral, PublicKeyToken=null
Type: CarLibrary.MyInternalClass
Type: CarLibrary.EngineStateEnum
Type: CarLibrary.MusicMedia
Type: CarLibrary.Car
Type: CarLibrary.MiniVan
Type: CarLibrary.SportsCar

```

`LoadFrom`方法也可以获取您想要查看的程序集的绝对路径(例如，`C:\MyApp\MyAsm.dll`)。使用此方法，您可以传入控制台应用程序项目的完整路径。因此，如果`CarLibrary.dll`位于`C:\MyCode`下，您可以输入 **C:\MyCode\CarLibrary** (注意扩展名是可选的)。

## 反思框架程序集

`Assembly.Load()`方法有几个重载。一种变体允许您指定区域性值(对于本地化程序集)，以及版本号和公钥标记值(对于框架程序集)。总的来说，标识一个组件的项目集被称为*显示名*。显示名称的格式是以逗号分隔的名称-值对字符串，以程序集的友好名称开头，后跟可选的限定符(可以按任何顺序出现)。下面是要遵循的模板(可选项目出现在括号中):

```
Name (,Version = major.minor.build.revision) (,Culture = culture token) (,PublicKeyToken= public key token)

```

当你创建一个显示名时，约定`PublicKeyToken=null`表明需要绑定和匹配一个非强名称的程序集。此外，`Culture=""`表示匹配目标计算机的默认区域性。这里有一个例子:

```
// Load version 1.0.0.0 of CarLibrary using the default culture.
Assembly a =
  Assembly.Load("CarLibrary, Version=1.0.0.0, PublicKeyToken=null, Culture=\"\"");
// The quotes must be escaped with back slashes in C#

```

还要注意,`System.Reflection`名称空间提供了`AssemblyName`类型，这允许您在一个方便的对象变量中表示前面的字符串信息。通常，这个类与`System.Version`一起使用，后者是一个封装程序集版本号的面向对象包装器。一旦建立了显示名称，就可以将它传递给重载的`Assembly.Load()`方法，如下所示:

```
// Make use of AssemblyName to define the display name.
AssemblyName asmName;
asmName = new AssemblyName();
asmName.Name = "CarLibrary";
Version v = new Version("1.0.0.0");
asmName.Version = v;
Assembly a = Assembly.Load(asmName);

```

加载. NET Framework 程序集(不是。NET Core)，`Assembly.Load()`参数应该指定一个`PublicKeyToken`值。和。NET Core，它不是必需的，因为强命名的使用减少了。例如，假设您有一个名为 FrameworkAssemblyViewer 的新控制台应用程序项目，该项目引用了 Microsoft。EntityFrameworkCore 包。提醒一下，这都可以通过。NET 5 命令行界面(CLI)。

```
dotnet new console -lang c# -n FrameworkAssemblyViewer -o .\FrameworkAssemblyViewer -f net5.0
dotnet sln .\Chapter17_AllProjects.sln add .\FrameworkAssemblyViewer
dotnet add .\FrameworkAssemblyViewer package Microsoft.EntityFrameworkCore -v 5.0.0

```

回想一下，当您引用另一个程序集时，该程序集的副本被复制到引用项目的输出目录中。使用 CLI 构建项目。

```
dotnet build

```

随着项目的创建、`EntityFrameworkCode`的引用以及项目的构建，您现在可以加载并检查它了。鉴于该程序集中的类型数量相当大，下面的应用程序使用简单的 LINQ 查询，仅打印出公共枚举的名称:

```
using System;
using System.Linq;
using System.Reflection;

Console.WriteLine("***** The Framework Assembly Reflector App *****\n");

// Load Microsoft.EntityFrameworkCore.dll
var displayName =
  "Microsoft.EntityFrameworkCore, Version=5.0.0.0, Culture=\"\", PublicKeyToken=adb9793829ddae60";
  Assembly asm = Assembly.Load(displayName);
  DisplayInfo(asm);
  Console.WriteLine("Done!");
  Console.ReadLine();

private static void DisplayInfo(Assembly a)
{
  Console.WriteLine("***** Info about Assembly *****");
  Console.WriteLine($"Asm Name: {a.GetName().Name}" );
  Console.WriteLine($"Asm Version: {a.GetName().Version}");
  Console.WriteLine($"Asm Culture:
    {a.GetName().CultureInfo.DisplayName}");
  Console.WriteLine("\nHere are the public enums:");

  // Use a LINQ query to find the public enums.
  Type[] types = a.GetTypes();
  var publicEnums =
    from pe in types
    where pe.IsEnum && pe.IsPublic
    select pe;

  foreach (var pe in publicEnums)
  {
    Console.WriteLine(pe);
  }
}

```

此时，您应该理解如何使用`System.Reflection`名称空间的一些核心成员在运行时发现元数据。当然，我意识到尽管有“酷的因素”，你可能不需要在你工作的地方经常构建定制的对象浏览器。但是，请记住，反射服务是许多常见编程活动的基础，包括后期绑定。

## 了解后期绑定

简单地说，*后期绑定*是一种技术，在这种技术中，您可以创建给定类型的实例，并在运行时调用其成员，而无需硬编码编译时了解其存在。当您正在生成后期绑定到外部程序集中的类型的应用程序时，您没有理由设置对该程序集的引用；因此，调用方的清单没有程序集的直接列表。

乍一看，并不容易看出后期绑定的价值。的确，如果您可以“早期绑定”到一个对象(例如，添加一个程序集引用并使用 C# `new`关键字分配类型)，您应该选择这样做。出于一个原因，早期绑定允许您在编译时确定错误，而不是在运行时。尽管如此，后期绑定在您可能构建的任何可扩展应用程序中确实扮演着重要角色。在本章末尾的“构建可扩展的应用程序”一节中，您将有机会构建这样一个“可扩展的”程序在此之前，让我们检查一下`Activator`类的作用。

### 系统。活化剂类别

类是。网芯后期绑定流程。对于下一个例子，您只对`Activator.CreateInstance()`方法感兴趣，该方法用于通过后期绑定创建一个类型的实例。此方法已被重载多次，以提供很大的灵活性。`CreateInstance()`成员最简单的变体是接受一个有效的`Type`对象，该对象描述了您想要动态分配到内存中的实体。

创建一个名为 LateBindingApp 的新控制台应用程序项目，并通过 C# `using`关键字导入`System.IO`和`System.Reflection`名称空间。现在，更新`Program.cs`文件，如下所示:

```
using System;
using System.IO;
using System.Reflection;

// This program will load an external library,
// and create an object using late binding.
Console.WriteLine("***** Fun with Late Binding *****");
// Try to load a local copy of CarLibrary.
Assembly a = null;
try
{
  a = Assembly.LoadFrom("CarLibrary");
}
catch(FileNotFoundException ex)
{
  Console.WriteLine(ex.Message);
  return;
}
if(a != null)
{
  CreateUsingLateBinding(a);
}
Console.ReadLine();

static void CreateUsingLateBinding(Assembly asm)
{
  try
  {
    // Get metadata for the Minivan type.
    Type miniVan = asm.GetType("CarLibrary.MiniVan");

    // Create a Minivan instance on the fly.
    object obj = Activator.CreateInstance(miniVan);
    Console.WriteLine("Created a {0} using late binding!", obj);
  }
  catch(Exception ex)
  {
    Console.WriteLine(ex.Message);
  }
}

```

现在，在运行这个应用程序之前，您需要手动将`CarLibrary.dll`的副本放入这个新应用程序的项目文件夹(或者如果您使用 Visual Studio，则放入`bin\Debug\net5.0`文件夹)中。

Note

这个例子不要添加对`CarLibrary.dll`的引用！后期绑定的全部意义在于，您试图创建一个在编译时未知的对象。

注意，`Activator.CreateInstance()`方法返回一个`System.Object`，而不是一个强类型的`MiniVan`。因此，如果您在`obj`变量上应用点操作符，您将看不到`MiniVan`类的任何成员。乍一看，您可能认为可以通过显式强制转换来解决这个问题，如下所示:

```
// Cast to get access to the members of MiniVan?
// Nope! Compiler error!
object obj = (MiniVan)Activator.CreateInstance(minivan);

```

但是，因为您的程序没有添加对`CarLibrary.dll`的引用，所以您不能使用 C# `using`关键字来导入`CarLibrary`名称空间，因此，您不能在转换操作期间使用`MiniVan`类型！请记住，后期绑定的要点是创建没有编译时知识的对象实例。考虑到这一点，如何调用存储在`System.Object`引用中的`MiniVan`对象的底层方法呢？答案当然是通过使用反射。

### 调用不带参数的方法

假设您想要调用`MiniVan`的`TurboBoost()`方法。正如您所记得的，这个方法将把引擎的状态设置为“dead ”,并显示一个信息消息框。第一步是使用`Type.GetMethod()`为`TurboBoost()`方法获取一个`MethodInfo`对象。从产生的`MethodInfo`中，您可以使用`Invoke()`调用`MiniVan.TurboBoost`。`MethodInfo.Invoke()`要求您将所有参数发送给由`MethodInfo`表示的方法。这些参数由一组`System.Object`类型表示(因为给定方法的参数可以是任意数量的各种实体)。

鉴于`TurboBoost()`不需要任何参数，可以简单地通过`null`(意思是“这个方法没有参数”)。更新您的`CreateUsingLateBinding()`方法如下:

```
static void CreateUsingLateBinding(Assembly asm)
{
  try
  {
    // Get metadata for the Minivan type.
    Type miniVan = asm.GetType("CarLibrary.MiniVan");

    // Create the Minivan on the fly.
    object obj = Activator.CreateInstance(miniVan);
    Console.WriteLine($"Created a {obj} using late binding!");
    // Get info for TurboBoost.
    MethodInfo mi = miniVan.GetMethod("TurboBoost");

    // Invoke method ('null' for no parameters).
    mi.Invoke(obj, null);
  }
  catch(Exception ex)
  {
    Console.WriteLine(ex.Message);
  }
}

```

此时，您将在控制台中看到您的发动机爆炸的消息。

### 调用带参数的方法

当您想要使用后期绑定来调用需要参数的方法时，您应该将参数打包成一个松散类型的数组`object`。这个版本的`Car`类有一个无线电，并有以下方法:

```
  public void TurnOnRadio(bool musicOn, MusicMediaEnum mm)
      => MessageBox.Show(musicOn ? $"Jamming {mm}" : "Quiet time...");

```

这个方法有两个参数:一个布尔值表示汽车的音乐系统应该打开还是关闭，一个枚举表示音乐播放器的类型。回想一下，该枚举的结构如下:

```
public enum MusicMediaEnum
{
  musicCd,    // 0
  musicTape,  // 1
  musicRadio, // 2
  musicMp3    // 3
}

```

这里有一个`Program`类的新方法，它调用`TurnOnRadio()`。请注意，您正在使用`MusicMediaEnum`枚举的底层数值来指定一个“收音机”媒体播放器。

```
static void InvokeMethodWithArgsUsingLateBinding(Assembly asm)
{
  try
  {
    // First, get a metadata description of the sports car.
    Type sport = asm.GetType("CarLibrary.SportsCar");

    // Now, create the sports car.
    object obj = Activator.CreateInstance(sport);
    // Invoke TurnOnRadio() with arguments.
    MethodInfo mi = sport.GetMethod("TurnOnRadio");
    mi.Invoke(obj, new object[] { true, 2 });
  }
  catch (Exception ex)
  {
    Console.WriteLine(ex.Message);
  }
}

```

理想情况下，此时，您可以看到反射、动态加载和后期绑定之间的关系。可以肯定的是，反射 API 提供了许多超出这里所讨论的特性，但是如果您感兴趣的话，您应该准备好深入研究更多的细节。

同样，您可能仍然想知道*何时*您应该在您自己的应用程序中使用这些技术。本章的结论应该阐明这个问题；然而，下一个研究的主题是。净核心属性。

## 理解的作用。网络属性

如本章开头所述，. NET 核心编译器的一个作用是为所有定义和引用的类型生成元数据描述。除了任何程序集中包含的标准元数据之外。NET Core platform 为程序员提供了一种使用*属性*将附加元数据嵌入到程序集中的方法。简而言之，属性只不过是可以应用于给定类型(类、接口、结构等)的代码注释。)、成员(属性、方法等。)、程序集或模块。

。NET Core 属性是扩展抽象基类`System.Attribute`的类类型。当你探索。NET 核心命名空间，您会发现许多预定义的属性，您可以在您的应用程序中使用。此外，您可以自由构建定制属性，通过创建一个从`Attribute`派生的新类型来进一步限定您的类型的行为。

那个。NET Core 基本类库在各种命名空间中提供属性。表 [17-3](#Tab3) 给出了一些预定义属性的快照，但是*绝对*否意味着全部。

表 17-3。

预定义属性的微小样本

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

属性

 | 

生命的意义

 |
| --- | --- |
| `[CLSCompliant]` | 强制带批注的项目符合公共语言规范(CLS)的规则。回想一下，CLS 兼容的类型保证可以在所有。NET 核心编程语言。 |
| `[DllImport]` | 允许。NET 核心代码调用任何基于非托管 C 或 C++的代码库，包括底层操作系统的 API。 |
| `[Obsolete]` | 标记不推荐使用的类型或成员。如果其他程序员试图使用这样的项目，他们将收到一个编译器警告，描述他们的方法的错误。 |

请理解，当您在代码中应用属性时，嵌入的元数据基本上是无用的，直到另一个软件明确地反映了这些信息。如果不是这样，嵌入在程序集中的元数据的格式回复将被忽略，并且完全无害。

### 属性消费者

正如您所猜测的。NET Core Framework 附带了许多实用程序，它们确实在寻找各种属性。C#编译器(`csc.exe`)本身已经被预编程，以便在编译周期中发现各种属性的存在。例如，如果 C#编译器遇到了`[CLSCompliant]`属性，它将自动检查属性化的项，以确保它只公开符合 CLS 的构造。作为另一个例子，如果 C#编译器发现一个具有`[Obsolete]`属性的项，它将在 Visual Studio 错误列表窗口中显示一个编译器警告。

除了开发工具之外。NET 核心基本类库被预编程以反映特定的属性。第 [20 章](20.html)介绍 XML 和 JSON 序列化，两者都使用属性来控制序列化过程。

最后，您可以自由地构建应用程序，这些应用程序被编程为反映您自己的自定义属性以及。NET 核心基本类库。通过这样做，您基本上能够创建一组“关键字”,这些关键字被一组特定的程序集所理解。

### 在 C#中应用属性

为了演示在 C#中应用属性的过程，创建一个名为 applying attributes 的新控制台应用程序项目，并添加对`System.Text.Json`的引用。假设您想要构建一个名为`Motorcycle`的类，它可以持久化为 JSON 格式。如果您有一个不应该导出到 JSON 的字段，您可以应用`[JsonIgnore]`属性。

```
public class Motorcycle
{
  [JsonIgnore]
  public float weightOfCurrentPassengers;
  // These fields are still serializable.
  public bool hasRadioSystem;
  public bool hasHeadSet;
  public bool hasSissyBar;
}

```

Note

属性适用于“下一个”项目。

此时，不要关心对象序列化的实际过程(第 [20](20.html) 章讨论了细节)。请注意，当您想要应用一个属性时，属性的名称被夹在方括号中。

正如您可能猜到的那样，一个单一的项目可以有多个属性。假设您有一个遗留的 C#类类型(`HorseAndBuggy`)，它被认为有一个定制的 XML 名称空间。随着时间的推移，代码库已经发生了变化，该类现在被认为对于当前的开发已经过时。您可以用`[Obsolete]`属性来标记这个类，而不是从您的代码库中删除这个类定义(并冒着破坏现有软件的风险)。要将多个属性应用于单个项目，只需使用逗号分隔的列表，如下所示:

```
using System;
using System.Xml.Serialization;

namespace ApplyingAttributes
{
    [XmlRoot(Namespace = "http://www.MyCompany.com"), Obsolete("Use another vehicle!")]
    public class HorseAndBuggy
    {
        // ...
    }
}

```

或者，您也可以将多个属性应用于单个项目，方法是按如下方式堆叠每个属性:

```
[XmlRoot(Namespace = "http://www.MyCompany.com")]
[Obsolete("Use another vehicle!")]
public class HorseAndBuggy
{
  // ...
}

```

### C#属性速记符号

如果你在咨询。NET 核心文档，您可能已经注意到了`[Obsolete]`属性的实际类名是`ObsoleteAttribute`，而不是`Obsolete`。作为命名约定，所有。NET Core 属性(包括您可能自己创建的自定义属性)的后缀是`Attribute`标记。然而，为了简化应用属性的过程，C#语言不要求您键入`Attribute`后缀。考虑到这一点，下面的`HorseAndBuggy`类型的迭代与前面的相同(它只是涉及到更多的击键):

```
[SerializableAttribute]
[ObsoleteAttribute("Use another vehicle!")]
public class HorseAndBuggy
{
  // ...
}

```

要知道这是 C#提供的一种礼貌。不全是。NET 核心语言支持这种速记属性语法。

### 为属性指定构造函数参数

注意，`[Obsolete]`属性可以接受看起来像是构造函数的参数。如果您通过在代码编辑器中右键单击项目并选择 Go To Definition 菜单选项来查看`[Obsolete]`属性的正式定义，您会发现这个类确实提供了一个接收`System.String`的构造函数。

```
public sealed class ObsoleteAttribute : Attribute
{
  public ObsoleteAttribute(string message, bool error);
  public ObsoleteAttribute(string message);
  public ObsoleteAttribute();
  public bool IsError { get; }
  public string? Message { get; }
}

```

请理解，当您向属性提供构造函数参数时，属性是*而不是*分配到内存中的，直到参数被另一个类型或外部工具反射。在属性级别定义的字符串数据只是作为元数据的格式回复存储在程序集中。

### 作用中的过时属性

既然`HorseAndBuggy`已经被标记为过时，如果您要分配这种类型的实例:

```
using System;
using ApplyingAttributes;

Console.WriteLine("Hello World!");
HorseAndBuggy mule = new HorseAndBuggy();

```

您会发现会发出一个编译器警告。该警告特别是 CS0618，并且该消息包括传递到属性中的信息。

```
‘HorseAndBuggy’ is obsolete: ‘Use another vehicle!'

```

Visual Studio 和 Visual Studio 代码也有助于智能感知，它通过反射获取信息。图 [17-1](#Fig1) 显示了 Visual Studio 中`Obsolete`属性的结果，图 [17-2](#Fig2) 正在使用 Visual Studio 代码。注意，两者都使用了术语*弃用的*而不是*废弃的*。

![../images/340876_10_En_17_Chapter/340876_10_En_17_Fig2_HTML.jpg](../images/340876_10_En_17_Chapter/340876_10_En_17_Fig2_HTML.jpg)

图 17-2。

Visual Studio 代码中的实际属性

![../images/340876_10_En_17_Chapter/340876_10_En_17_Fig1_HTML.jpg](../images/340876_10_En_17_Chapter/340876_10_En_17_Fig1_HTML.jpg)

图 17-1。

Visual Studio 中的实际属性

理想情况下，在这一点上，你应该了解以下关键点。网络核心属性:

*   属性是从`System.Attribute`派生的类。

*   属性导致嵌入的元数据。

*   属性基本上是无用的，直到另一个代理反映出来。

*   在 C#中，使用方括号应用属性。

接下来，让我们看看如何构建自己的定制属性和一个定制软件来反映嵌入的元数据。

## 构建自定义属性

构建定制属性的第一步是创建一个从`System.Attribute`派生的新类。与本书通篇使用的汽车主题保持一致，假设您已经创建了一个名为 AttributedCarLibrary 的新 C#类库项目。

这个程序集将定义一些车辆，每个车辆都使用一个名为`VehicleDescriptionAttribute`的自定义属性进行描述，如下所示:

```
using System;
// A custom attribute.
public sealed class VehicleDescriptionAttribute :Attribute
{
  public string Description { get; set; }

  public VehicleDescriptionAttribute(string description)
    => Description = description;
  public VehicleDescriptionAttribute(){ }
}

```

如您所见，`VehicleDescriptionAttribute`维护了一段使用自动属性(`Description`)操作的字符串数据。除了这个类是从`System.Attribute`派生出来的这个事实之外，这个类的定义并没有什么独特之处。

Note

出于安全原因，将所有自定义属性设计为密封的被认为是. NET 核心最佳实践。事实上，Visual Studio 和 Visual Studio 代码都提供了一个名为`Attribute`的代码片段，它将在您的代码窗口中搭建一个新的`System.Attribute`派生类。您可以通过键入代码段的名称并按 Tab 键来展开任何代码段。

### 应用自定义属性

鉴于`VehicleDescriptionAttribute`是从`System.Attribute`衍生而来的，你现在可以给你的车辆添加你认为合适的注释了。出于测试目的，将以下类添加到新的类库中:

```
//Motorcycle.cs
namespace AttributedCarLibrary
{
  // Assign description using a "named property."
  [Serializable]
  [VehicleDescription(Description = "My rocking Harley")]
  public class Motorcycle
  {
  }

//HorseAndBuggy.cs
namespace AttributedCarLibrary
{
  [Serializable]
  [Obsolete ("Use another vehicle!")]
  [VehicleDescription("The old gray mare, she ain't what she used to be...")]
  public class HorseAndBuggy
  {
  }
}

//Winnebago.cs
namespace AttributedCarLibrary

{
  [VehicleDescription("A very long, slow, but feature-rich auto")]
  public class Winnebago
  {
  }
}

```

### 命名属性语法

注意到,`Motorcycle`的描述被分配了一个描述，它使用了一个新的属性语法，称为*命名属性*。在第一个`[VehicleDescription]`属性的构造函数中，使用`Description`属性设置底层字符串数据。如果这个属性被一个外部代理反射，那么这个值就被输入到`Description`属性中(只有当这个属性提供了一个可写的。净核心财产)。

相比之下，`HorseAndBuggy`和`Winnebago`类型不使用命名属性语法，只是通过自定义构造函数传递字符串数据。在任何情况下，一旦编译了`AttributedCarLibrary`程序集，您就可以使用`ildasm.exe`来查看为您的类型注入的元数据描述。例如，下面显示了对`Winnebago`类的嵌入式描述:

```
// CustomAttribute #1
// -------------------------------------------------------
//   CustomAttribute Type: 06000005
//   CustomAttributeName: AttributedCarLibrary.VehicleDescriptionAttribute :: instance void .ctor(class System.String)
//   Length: 45
//   Value : 01 00 28 41 20 76 65 72  79 20 6c 6f 6e 67 2c 20 >  (A very long, <
//         : 73 6c 6f 77 2c 20 62 75  74 20 66 65 61 74 75 72 >slow, but feature<
//         : 65 2d 72 69 63 68 20 61  75 74 6f 00 00          >e-rich auto     <
//   ctor args: ("A very long, slow, but feature-rich auto")

```

### 限制属性使用

默认情况下，自定义属性可以应用于代码的任何方面(方法、类、属性等)。).因此，如果这样做有意义的话，您可以使用`VehicleDescription`来限定方法、属性或字段(等等)。

```
[VehicleDescription("A very long, slow, but feature-rich auto")]
public class Winnebago
{
  [VehicleDescription("My rocking CD player")]
  public void PlayMusic(bool On)
  {
    ...
  }
}

```

在某些情况下，这正是您需要的行为。但是，在其他时候，您可能希望构建一个只能应用于选定代码元素的自定义属性。如果您想要约束一个定制属性的范围，您将需要在您的定制属性的定义上应用`[AttributeUsage]`属性。`[AttributeUsage]`属性允许您从`AttributeTargets`枚举中提供值的任意组合(通过一个`OR`操作)，如下所示:

```
// This enumeration defines the possible targets of an attribute.
public enum AttributeTargets
{
  All, Assembly, Class, Constructor,
  Delegate, Enum, Event, Field, GenericParameter,
  Interface, Method, Module, Parameter,
  Property, ReturnValue, Struct
}

```

此外，`[AttributeUsage]`还允许您有选择地设置一个命名属性(`AllowMultiple`)，指定该属性是否可以在同一个项目上多次应用(默认为`false`)。同样，`[AttributeUsage]`允许您使用`Inherited`命名的属性(默认为`true`)来确定属性是否应该被派生类继承。

要确定`[VehicleDescription]`属性只能在一个类或结构上应用一次，可以按如下方式更新`VehicleDescriptionAttribute`定义:

```
// This time, we are using the AttributeUsage attribute
// to annotate our custom attribute.
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, Inherited = false)]
public sealed class VehicleDescriptionAttribute : System.Attribute
{
...
}

```

这样，如果开发人员试图在类或结构之外的任何东西上应用`[VehicleDescription]`属性，他们会收到一个编译时错误。

## 程序集级属性

也可以使用`[assembly:]`标签将属性应用于给定程序集中的所有类型。例如，假设您希望确保程序集中定义的每个公共类型的每个公共成员都符合 CLS 标准。为此，只需在任何 C#源代码文件的顶部添加下面的程序集级属性。请注意，所有程序集或模块级属性都必须在任何命名空间范围之外列出！我建议向您的项目添加一个名为`AssemblyAttributes.cs`(不是`AssemblyInfo.cs`，因为它是自动生成的)的新文件，并将您的程序集级属性放在那里。

Note

使用单独的文件没有技术上的原因；这纯粹是为了你的代码的可支持性。将程序集属性放在一个单独的文件中可以清楚地表明您的项目使用程序集级属性以及它们的位置。

如果将程序集级或模块级属性添加到项目中，下面是一个推荐的文件布局:

```
// List "using" statements first.
using System;

// Now list any assembly- or module-level attributes.
// Enforce CLS compliance for all public types in this
// assembly.
[assembly: CLSCompliant(true)]

```

如果您现在添加了一点 CLS 规范之外的代码(比如一个无符号数据的暴露点)，您将会收到一个编译器警告。

```
// Ulong types don't jibe with the CLS.
public class Winnebago
{
  public ulong notCompliant;
}

```

Note

中有两个重要的变化。NET 核心。首先是`AssemblyInfo.cs`文件现在是从项目属性中自动生成的，不建议定制。第二个(也是相关的)变化是许多先前的汇编级属性(`Version`、`Company`等)。)已被替换为项目文件中的属性。

### 将项目文件用于部件属性

如第 [16 章](16.html)与`InternalsVisibleToAttribute`所示，装配属性也可以添加到项目文件中。有一个问题，只有单字符串参数属性可以这样使用。对于可以在项目属性中的 Package 选项卡上设置的属性来说，也是如此。

Note

在撰写本文时，MSBuild GitHub repo 上正在积极讨论增加非字符串参数支持的功能。这将允许使用项目文件而不是`*.cs`文件来添加`CLSCompliant`属性。

继续设置一些属性(比如`Authors`、`Description`)，方法是在 Solution Explorer 中右键单击项目，选择 properties，然后单击 Package。同样，像你在第 16 章中做的那样添加`InternalsVisibleToAttribute`。您的项目文件现在看起来将如下所示:

```
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net5.0</TargetFramework>
    <Authors>Philip Japikse</Authors>
    <Company>Apress</Company>
    <Description>This is a simple car library with attributes</Description>
  </PropertyGroup>
  <ItemGroup>
    <AssemblyAttribute Include="System.Runtime.CompilerServices.InternalsVisibleToAttribute">
      <_Parameter1>CSharpCarClient</_Parameter1>
    </AssemblyAttribute>
  </ItemGroup>
</Project>

```

编译完项目后，导航到`\obj\Debug\net5.0`目录，并查找`AttributedCarLibrary.AssemblyInfo.cs`文件。打开它，您将看到这些属性(不幸的是，这种格式可读性不强):

```
using System;
using System.Reflection;

[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("CSharpCarClient")]
[assembly: System.Reflection.AssemblyCompanyAttribute("Philip Japikse")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyDescriptionAttribute("This is a sample car library with attributes")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0")]
[assembly: System.Reflection.AssemblyProductAttribute("AttributedCarLibrary")]
[assembly: System.Reflection.AssemblyTitleAttribute("AttributedCarLibrary")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

```

关于汇编属性的最后一句结束语是，如果您想自己管理流程，可以关闭`AssemblyInfo.cs`类的生成。

## 使用早期绑定反映属性

请记住，在另一个软件反映出它的值之前，一个属性是毫无用处的。一旦发现了给定的属性，该软件就可以采取任何必要的行动。现在，像任何应用程序一样，这个“软件的另一部分”可以使用早期绑定或晚期绑定来发现自定义属性的存在。如果您想利用早期绑定，您将需要客户端应用程序有一个正在讨论的属性的编译时定义(在本例中为`VehicleDescriptionAttribute`)。鉴于`AttributedCarLibrary`程序集已经将这个自定义属性定义为一个公共类，早期绑定是最好的选择。

为了演示反射自定义属性的过程，向解决方案添加一个名为`VehicleDescriptionAttributeReader`的新 C#控制台应用程序项目。接下来，添加对`AttributedCarLibrary`项目的引用。使用 CLI，执行以下命令(每个命令必须各占一行):

```
dotnet new console -lang c# -n VehicleDescriptionAttributeReader -o .\VehicleDescriptionAttributeReader -f net5.0
dotnet sln .\Chapter17_AllProjects.sln add .\VehicleDescriptionAttributeReader
dotnet add VehicleDescriptionAttributeReader reference .\AttributedCarLibrary

```

用以下代码更新`Program.cs`文件:

```
using System;
using AttributedCarLibrary;

Console.WriteLine("***** Value of VehicleDescriptionAttribute *****\n");
ReflectOnAttributesUsingEarlyBinding();
Console.ReadLine();

static void ReflectOnAttributesUsingEarlyBinding()
{
  // Get a Type representing the Winnebago.
  Type t = typeof(Winnebago);

  // Get all attributes on the Winnebago.
  object[] customAtts = t.GetCustomAttributes(false);

  // Print the description.
  foreach (VehicleDescriptionAttribute v in customAtts)
  {
    Console.WriteLine("-> {0}\n", v.Description);
  }
}

```

`Type.GetCustomAttributes()`方法返回一个对象数组，表示应用于由`Type`表示的成员的所有属性(布尔参数控制搜索是否应该沿着继承链向上扩展)。一旦获得了属性列表，迭代每个`VehicleDescriptionAttribute`类，并打印出`Description`属性获得的值。

## 使用后期绑定反射属性

前面的例子使用早期绑定来打印出`Winnebago`类型的车辆描述数据。这是可能的，因为`VehicleDescriptionAttribute`类类型被定义为`AttributedCarLibrary`程序集中的公共成员。还可以利用动态加载和后期绑定来反映属性。

将名为`VehicleDescriptionAttributeReaderLateBinding`的新项目添加到解决方案中，将其设置为启动项目，并将`AttributedCarLibrary.dll`复制到项目的文件夹中(如果使用 Visual Studio，则复制到`\bin\Debug\net5.0`)。现在，更新您的`Program`类，如下所示:

```
using System;
using System.Reflection;

Console.WriteLine("***** Value of VehicleDescriptionAttribute *****\n");
ReflectAttributesUsingLateBinding();
Console.ReadLine();

static void ReflectAttributesUsingLateBinding()
{
  try
  {
    // Load the local copy of AttributedCarLibrary.
    Assembly asm = Assembly.LoadFrom("AttributedCarLibrary");

    // Get type info of VehicleDescriptionAttribute.
    Type vehicleDesc =
      asm.GetType("AttributedCarLibrary.VehicleDescriptionAttribute");

    // Get type info of the Description property.
     PropertyInfo propDesc = vehicleDesc.GetProperty("Description");

    // Get all types in the assembly.
     Type[] types = asm.GetTypes();

    // Iterate over each type and obtain any VehicleDescriptionAttributes.
    foreach (Type t in types)
    {
      object[] objs = t.GetCustomAttributes(vehicleDesc, false);

      // Iterate over each VehicleDescriptionAttribute and print
      // the description using late binding.
      foreach (object o in objs)
      {
        Console.WriteLine("-> {0}: {1}\n", t.Name,
          propDesc.GetValue(o, null));
      }
    }
  }
  catch (Exception ex)
  {
    Console.WriteLine(ex.Message);
  }
}

```

如果您能够按照本章中的示例进行操作，这段代码应该(或多或少)是不言自明的。唯一有趣的地方是使用了`PropertyInfo.GetValue()`方法，该方法用于触发属性的访问器。以下是当前示例的输出:

```
***** Value of VehicleDescriptionAttribute *****
-> Motorcycle: My rocking Harley

-> HorseAndBuggy: The old gray mare, she ain't what she used to be...

-> Winnebago: A very long, slow, but feature-rich auto

```

## 正确看待反射、后期绑定和自定义属性

尽管您已经看到了这些技术的大量实例，但您可能仍然想知道何时在程序中使用反射、动态加载、后期绑定和自定义属性。可以肯定的是，这些主题可能看起来有点像编程的学术方面(这可能是也可能不是一件坏事，取决于你的观点)。为了帮助将这些主题映射到真实世界的情况，您需要一个可靠的示例。现在假设您在一个编程团队中，该团队正在构建一个具有以下需求的应用程序:

该产品必须使用额外的第三方工具进行扩展。

*可延伸*到底是什么意思？好吧，考虑一下 Visual Studio IDE。当开发该应用程序时，各种“挂钩”被插入到代码库中，以允许其他软件供应商将定制模块“嵌入”(或插入)到 IDE 中。显然，Visual Studio 开发团队没有办法设置对外部。NET 程序集(因此，没有早期绑定)，那么应用程序将如何提供所需的钩子呢？这里有一个解决这个问题的可能方法:

1.  首先，可扩展的应用程序必须提供某种输入机制，以允许用户指定要插入的模块(例如对话框或命令行标志)。这就需要*动态加载*。

2.  第二，可扩展的应用程序必须能够确定模块是否支持要插入到环境中的正确功能(例如一组必需的接口)。这就需要*反思*。

3.  最后，可扩展的应用程序必须获得对所需基础结构的引用(例如一组接口类型)，并调用成员来触发底层功能。这可能需要*后期绑定*。

简单地说，如果可扩展的应用程序已经被预编程为查询特定的接口，它能够在运行时确定该类型是否可以被激活。一旦通过了验证测试，所讨论的类型就可以支持为其功能提供多态结构的附加接口。这正是 Visual Studio 团队所采用的方法，不管您怎么想，这一点也不难！

## 构建可扩展的应用程序

在接下来的小节中，我将通过一个例子来说明构建一个可以通过外部程序集的功能来扩充的应用程序的过程。作为路线图，可扩展的应用程序需要以下组件:

*   `CommonSnappableTypes.dll`:此程序集包含将由每个管理单元对象使用的类型定义，并将由 Windows 窗体应用程序直接引用。

*   `CSharpSnapIn.dll`:用 C#写的一个管理单元，利用了`CommonSnappableTypes.dll`的类型。

*   `VBSnapIn.dll`:用 Visual Basic 编写的管理单元，利用了`CommonSnappableTypes.dll`的类型。

*   `MyExtendableApp.exe`:可以通过每个管理单元的功能扩展的控制台应用程序。

这个应用程序将使用动态加载、反射和后期绑定来动态获取它事先不知道的程序集的功能。

Note

您可能会想，“我的老板从来没有要求我构建一个控制台应用程序”，您可能是正确的！使用 C#构建的业务线应用程序通常属于智能客户端(WinForms 或 WPF)、web 应用程序/RESTful 服务(ASP.NET 核心)或无头流程(Azure 函数、Windows 服务等)的范畴。).我们使用控制台应用程序来关注示例中的特定概念，在本例中是动态加载、反射和后期绑定。在本书的后面，你将使用 ASP.NET 核心和 WPF 探索“真正的”面向用户的应用。

### 构建多项目可扩展应用解决方案

到目前为止，本书中的大多数应用程序都是独立的项目，只有少数例外(就像前一个)。这样做是为了让例子简单明了。然而，在现实世界的开发中，您通常会在一个解决方案中同时处理多个项目。

#### 使用 CLI 创建解决方案和项目

要开始使用 CLI，请输入以下命令来创建新的解决方案、类库和控制台应用程序以及项目引用:

```
dotnet new sln -n Chapter17_ExtendableApp

dotnet new classlib -lang c# -n CommonSnappableTypes -o .\CommonSnappableTypes -f net5.0
dotnet sln .\Chapter17_ExtendableApp.sln add .\CommonSnappableTypes

dotnet new classlib -lang c# -n CSharpSnapIn -o .\CSharpSnapIn -f net5.0
dotnet sln .\Chapter17_ExtendableApp.sln add .\CSharpSnapIn
dotnet add CSharpSnapin reference CommonSnappableTypes

dotnet new classlib -lang vb -n VBSnapIn -o .\VBSnapIn -f net5.0
dotnet sln .\Chapter17_ExtendableApp.sln add .\VBSnapIn
dotnet add VBSnapIn reference CommonSnappableTypes

dotnet new console -lang c# -n MyExtendableApp -o .\MyExtendableApp -f net5.0
dotnet sln .\Chapter17_ExtendableApp.sln add .\MyExtendableApp
dotnet add MyExtendableApp reference CommonSnappableTypes

```

##### 将后期生成事件添加到项目文件中

当构建项目时(无论是从 Visual Studio 还是从命令行)，都有可以挂接的事件。例如，我们希望在每次成功构建后，将两个管理单元程序集复制到控制台应用程序项目目录(用`dotnet run`调试时)和控制台应用程序输出目录(用 Visual Studio 调试时)。为此，我们将利用几个内置的宏。

将这个标记块复制到`CSharpSnapIn.csproj`和`VBSnapIn.vbproj`文件中，这将编译后的程序集复制到`MyExtendableApp`项目目录和输出目录(`MyExtendableApp\bin\debug\net5.0`):

```
<Target Name="PostBuild" AfterTargets="PostBuildEvent">
    <Exec Command="copy $(TargetPath) $(SolutionDir)MyExtendableApp\$(OutDir)$(TargetFileName) /Y 
copy $(TargetPath) $(SolutionDir)MyExtendableApp\$(TargetFileName) /Y" />
</Target>

```

现在，当构建每个项目时，它的程序集也被复制到`MyExtendableApp`的目标目录中。

#### 使用 Visual Studio 创建解决方案和项目

回想一下，默认情况下，Visual Studio 将该解决方案命名为在该解决方案中创建的第一个项目。但是，您可以很容易地更改解决方案的名称，如图 [17-3](#Fig3) 所示。

![../images/340876_10_En_17_Chapter/340876_10_En_17_Fig3_HTML.jpg](../images/340876_10_En_17_Chapter/340876_10_En_17_Fig3_HTML.jpg)

图 17-3。

创建 CommonSnappableTypes 项目和 ExtendableApp 解决方案

要创建 ExtendableApp 解决方案，首先选择“文件”“➤新建项目”以加载“新建项目”对话框。选择类库并输入名称 **CommonSnappableTypes** 。在点击确定之前，输入解决方案名称 **ExtendableApp** ，如图 [17-3](#Fig3) 所示。

若要将另一个项目添加到解决方案中，请在解决方案资源管理器中右键单击解决方案名称(ExtendableApp )(或单击“文件”“➤”“添加➤新项目”),然后选择“添加➤新项目”。当向现有解决方案中添加另一个项目时，添加新项目对话框现在略有不同；解决方案选项不再存在，所以您将只看到项目信息(名称和位置)。将类库项目命名为 CSharpSnapIn，然后单击“创建”。

接下来，从 CSharpSnapIn 项目添加对 CommonSnappableTypes 项目的引用。若要在 Visual Studio 中执行此操作，请右击 CSharpSnapIn 项目，然后选择“添加➤项目引用”。在“引用管理器”对话框中，从左侧选择“项目➤解决方案”(如果尚未选择)，然后选中“CommonSnappableTypes”旁边的框。

对引用 CommonSnappableTypes 项目的新 Visual Basic 类库(`VBSnapIn`)重复该过程。

要添加的最后一个项目是名为 MyExtendableApp 的. NET 核心控制台应用程序。添加对 CommonSnappableTypes 项目的引用，并将控制台应用程序设置为解决方案的启动项目。为此，在解决方案资源管理器中右键单击`MyExtendableApp`项目，并选择 Set as StartUp Project。

Note

如果右击 ExtendableApp 解决方案而不是其中一个项目，则显示的上下文菜单选项是“设置启动项目”。除了在单击“运行”时只执行一个项目之外，还可以设置多个项目来执行。这将在后面的章节中演示。

##### 设置项目生成依赖项

当 Visual Studio 获得运行解决方案的命令时，如果检测到任何更改，将生成启动项目和所有引用的项目。但是，任何未被引用的项目都是*而不是*构建的。这可以通过设置项目依赖关系来更改。为此，请在解决方案资源管理器中右击该解决方案，选择“项目生成顺序”，然后在出现的对话框中，选择“依赖项”选项卡，并将项目更改为 MyExtendableApp。

请注意，已经选择了 CommonSnappableTypes 项目，并且复选框被禁用。这是因为它是直接引用的。同时选中 CSharpSnapIn 和 VBSnapIn 项目复选框，如图 [17-4](#Fig4) 所示。

![../images/340876_10_En_17_Chapter/340876_10_En_17_Fig4_HTML.jpg](../images/340876_10_En_17_Chapter/340876_10_En_17_Fig4_HTML.jpg)

图 17-4。

访问项目构建顺序上下文菜单

现在，每次构建 MyExtendableApp 项目时，也会构建 CSharpSnapIn 和 VBSnapIn 项目。

##### 添加后期生成事件

打开 CSharpSnapIn 的项目属性(右击解决方案资源管理器并选择“属性”)，然后导航到“生成事件”页(C#)。单击编辑后期生成按钮，然后单击宏> >。在这里你可以看到可用的宏，它们都指向路径和/或文件名。在构建事件中使用这些宏的优点是它们是独立于机器的，并且在相对路径上工作。例如，我正在一个名为`c-sharp-wf\code\chapter17`的目录中工作。您可能正在使用不同的目录。通过使用宏，MSBuild 将总是使用相对于`*.csproj`文件的正确路径。

在 PostBuild 框中，输入以下内容(两行):

```
copy $(TargetPath) $(SolutionDir)MyExtendableApp\$(OutDir)$(TargetFileName) /Y
copy $(TargetPath) $(SolutionDir)MyExtendableApp\$(TargetFileName) /Y

```

对 VBSnapIn 项目执行相同的操作，只是属性页名为 Compile，您可以从这里单击 Build Events 按钮。

添加这些后期生成事件命令后，每次编译时，每个程序集都将被复制到 MyExtendableApp 的项目和输出目录中。

### 建设 CommonSnappableTypes.dll

在 CommonSnappableTypes 项目中，删除默认的`Class1.cs`文件，添加一个名为`IAppFunctionality.cs`的新接口文件，并将该文件更新为:

```
namespace CommonSnappableTypes
{
  public interface IAppFunctionality
  {
    void DoIt();
  }
}

```

添加名为`CompanyInfoAttribute.cs`的类文件，并将其更新为:

```
using System;
namespace CommonSnappableTypes
{
  [AttributeUsage(AttributeTargets.Class)]
  public sealed class CompanyInfoAttribute : System.Attribute
  {
    public string CompanyName { get; set; }
    public string CompanyUrl { get; set; }
  }
}

```

`IAppFunctionality`接口为可扩展应用程序使用的所有管理单元提供了一个多态接口。假设这个例子纯粹是说明性的，您提供一个名为`DoIt()`的方法。

`CompanyInfoAttribute`类型是一个定制属性，可以应用于任何想要嵌入到容器中的类类型。从这个类的定义可以看出，`[CompanyInfo]`允许管理单元的开发人员提供一些关于组件起点的基本细节。

### 构建 C#管理单元

在 CSharpSnapIn 项目中，删除`Class1.cs`文件并添加一个名为`CSharpModule.cs`的新文件。更新代码以匹配以下内容:

```
using System;
using CommonSnappableTypes;

namespace CSharpSnapIn
{
  [CompanyInfo(CompanyName = "FooBar", CompanyUrl = "www.FooBar.com")]
  public class CSharpModule : IAppFunctionality
  {
    void IAppFunctionality.DoIt()
    {
      Console.WriteLine("You have just used the C# snap-in!");
    }
  }
}

```

注意，当支持`IAppFunctionality`接口时，我选择了使用显式接口实现(参见第[章第 8](08.html) )。这不是必需的；然而，这个想法是，系统中唯一需要与这个接口类型直接交互的部分是宿主应用程序。通过显式实现这个接口，`DoIt()`方法不会直接从`CSharpModule`类型中暴露出来。

### 构建 Visual Basic 管理单元

转到 VBSnapIn 项目，删除`Class1.vb`文件并添加一个名为`VBSnapIn.vb`的新文件。代码(再次)故意简单。

```
Imports CommonSnappableTypes

<CompanyInfo(CompanyName:="Chucky's Software", CompanyUrl:="www.ChuckySoft.com")>
Public Class VBSnapIn
  Implements IAppFunctionality

  Public Sub DoIt() Implements CommonSnappableTypes.IAppFunctionality.DoIt
    Console.WriteLine("You have just used the VB snap in!")
  End Sub
End Class

```

请注意，在 Visual Basic 的语法中应用属性需要尖括号(`< >`)，而不是方括号(`[ ]`)。还要注意，`Implements`关键字用于实现给定类或结构的接口类型。

### 为 ExtendableApp 添加代码

最后要更新的项目是 C#控制台应用程序(`MyExtendableApp`)。在将 MyExtendableApp 控制台应用程序添加到解决方案中并将其设置为启动项目后，添加对 CommonSnappableTypes 项目的引用，但*不是*`CSharpSnapIn.dll`或`VBSnapIn.dll`项目。

首先将位于`Program.cs`类顶部的`using`语句更新为:

```
using System;
using System.Linq;
using System.Reflection;
using CommonSnappableTypes;

```

`LoadExternalModule()`方法执行以下任务:

*   将选定的程序集动态加载到内存中

*   确定程序集是否包含任何实现`IAppFunctionality`的类型

*   使用后期绑定创建类型

如果找到实现`IAppFunctionality`的类型，调用`DoIt()`方法，然后发送给`DisplayCompanyData()`方法，输出反射类型的附加信息。

```
static void LoadExternalModule(string assemblyName)
{
  Assembly theSnapInAsm = null;
  try
  {
    // Dynamically load the selected assembly.
    theSnapInAsm = Assembly.LoadFrom(assemblyName);
  }
  catch (Exception ex)
  {
    Console.WriteLine($"An error occurred loading the snapin: {ex.Message}");
    return;
  }

  // Get all IAppFunctionality compatible classes in assembly.
  var theClassTypes = theSnapInAsm
      .GetTypes()
      .Where(t => t.IsClass && (t.GetInterface("IAppFunctionality") != null))
      .ToList();
  if (!theClassTypes.Any())
  {
    Console.WriteLine("Nothing implements IAppFunctionality!");
  }

  // Now, create the object and call DoIt() method.
  foreach (Type t in theClassTypes)
  {
    // Use late binding to create the type.
    IAppFunctionality itfApp = (IAppFunctionality) theSnapInAsm.CreateInstance(t.FullName, true);
    itfApp?.DoIt();
    // Show company info.
    DisplayCompanyData(t);
  }
}

```

最后一项任务是显示由`[CompanyInfo]`属性提供的元数据。如下创建`DisplayCompanyData()`方法。注意这个方法只有一个`System.Type`参数。

```
static void DisplayCompanyData(Type t)
{
  // Get [CompanyInfo] data.
  var compInfo = t
    .GetCustomAttributes(false)
    .Where(ci => (ci is CompanyInfoAttribute));
  // Show data.
  foreach (CompanyInfoAttribute c in compInfo)
  {
    Console.WriteLine($"More info about {c.CompanyName} can be found at {c.CompanyUrl}");
  }
}

```

最后，将顶级语句更新为以下内容:

```
Console.WriteLine("***** Welcome to MyTypeViewer *****");
string typeName = "";
do
{
  Console.WriteLine("\nEnter a snapin to load");
  Console.Write("or enter Q to quit: ");

  // Get name of type.
  typeName = Console.ReadLine();

  // Does user want to quit?
  if (typeName.Equals("Q", StringComparison.OrdinalIgnoreCase))
  {
    break;
  }
  // Try to display type.
  try
  {
    LoadExternalModule(typeName);
  }
  catch (Exception ex)
  {
    Console.WriteLine("Sorry, can't find snapin");
  }
}
while (true);

```

太棒了！这就结束了示例应用程序。我希望您可以看到，本章中介绍的主题在现实世界中可以相当有帮助，并且不限于世界的工具构建者。

## 摘要

反射是健壮的 OO 环境的一个有趣的方面。在的世界里。NET 核心，反射服务的关键围绕着`System.Type`类和`System.Reflection`名称空间。正如您所看到的，反射是在运行时将一个类型放在放大镜下以理解给定项目的谁、什么、哪里、何时、为什么以及如何的过程。

后期绑定是创建一个类型的实例并调用其成员的过程，而事先不知道这些成员的具体名称。后期绑定通常是动态加载的直接结果，它允许你以编程的方式将. NET 核心程序集加载到内存中。正如本章的可扩展应用程序示例所示，这是工具构建者和工具消费者使用的一种强大技术。

本章还研究了基于属性的编程的作用。当您用属性修饰您的类型时，结果是基础程序集元数据的增加。*