# 八、使用接口

本章通过研究基于接口的编程主题，建立在您当前对面向对象开发的理解之上。在这里，您将学习如何定义和实现接口，并逐渐理解构建支持多种行为的类型的好处。在这个过程中，您将会看到几个相关的主题，比如获取接口引用、实现显式接口和构造接口层次结构。您还将研究几个在？NET 核心基本类库。还涵盖了 C# 8 中关于接口的新特性，包括默认接口方法、静态成员和访问修饰符。正如您将看到的，您的自定义类和结构可以自由地实现这些预定义的接口，以支持一些有用的行为，如对象克隆、对象枚举和对象排序。

## 了解接口类型

在本章开始，请允许我提供一个接口类型的正式定义，它随着 C# 8.0 的引入而改变。在 C# 8.0 之前，接口只不过是一组命名的*抽象成员*。回想一下第 6 章[中的抽象方法是纯协议，因为它们不提供默认的实现。接口定义的具体成员取决于它所建模的确切行为。换句话说，一个接口表达了一个给定的类或结构可能选择支持的*行为*。此外，正如你将在本章看到的，一个类或结构可以支持任意多的接口，从而支持(本质上)多种行为。](06.html)

C# 8.0 中引入的默认接口方法功能允许接口方法包含一个实现，该实现可能会也可能不会被实现类重写。本章后面会有更多的介绍。

正如您可能猜到的那样。NET Core 基本类库附带了许多预定义的接口类型，这些接口类型由各种类和结构实现。例如，正如您将在第 [21 章](21.html)中看到的，ADO.NET 提供了多个数据提供程序，允许您与特定的数据库管理系统进行通信。因此，在 ADO.NET 下，您有许多连接对象可供选择(`SqlConnection`、`OleDbConnection`、`OdbcConnection`等)。).此外，第三方数据库供应商(以及众多开源项目)提供。NET 库与大量其他数据库(MySQL、Oracle 等)进行通信。)，所有这些都包含实现这些接口的对象。

尽管每个连接类都有一个惟一的名称，在不同的名称空间中定义，并且(在某些情况下)捆绑在不同的程序集中，但是所有连接类都实现了一个名为`IDbConnection`的公共接口。

```cs
// The IDbConnection interface defines a common
// set of members supported by all connection objects.
public interface IDbConnection : IDisposable
{
   // Methods
   IDbTransaction BeginTransaction();
   IDbTransaction BeginTransaction(IsolationLevel il);
   void ChangeDatabase(string databaseName);
   void Close();
   IDbCommand CreateCommand();
   void Open();
   // Properties
   string ConnectionString { get; set;}
   int ConnectionTimeout { get; }
   string Database { get; }

   ConnectionState State { get; }
}

```

Note

按照惯例，。NET 接口名称的前缀是大写字母 *I* 。当您创建自己的自定义接口时，最好也这样做。

此时不要关心这些成员做什么的细节。简单地理解一下，`IDbConnection`接口定义了一组所有 ADO.NET 连接类共有的成员。鉴于此，可以保证每个连接对象都支持诸如`Open()`、`Close()`、`CreateCommand()`等成员。此外，由于接口成员总是抽象的，每个连接对象都可以以自己独特的方式自由实现这些方法。

在阅读本书的剩余部分时，您将会接触到。NET 核心基本类库。正如您将看到的，这些接口可以在您自己的定制类和结构上实现，以定义与框架紧密集成的类型。同样，一旦你理解了接口类型的有用性，你肯定会找到构建你自己的接口类型的理由。

### 接口类型与抽象基类

鉴于你在第 6 章中的工作，接口类型可能看起来有点像抽象基类。回想一下，当一个类被标记为抽象时，它*可以*定义任意数量的抽象成员来为所有派生类型提供多态接口。然而，即使一个类定义了一组抽象成员，它也可以自由定义任意数量的构造函数、字段数据、非抽象成员(带实现)等等。接口(在 C# 8.0 之前)只包含*的*成员定义。现在，有了 C# 8，接口可以包含成员定义(比如抽象成员)、具有默认实现的成员(比如虚方法)和静态成员。真正的区别只有两个:接口不能有非静态的构造函数，一个类可以实现多个接口。接下来我们将详细讨论第二点。

由抽象父类建立的多态接口有一个主要的限制，即只有*的* *派生类型*支持由抽象父类定义的成员。然而，在更大的软件系统中，开发多个除了`System.Object`之外没有公共父类的类层次结构是很常见的。假设抽象基类中的抽象成员只适用于派生类型，您就没有办法在不同的层次结构中配置类型来支持相同的多态接口。首先，创建一个名为 CustomInterfaces 的新控制台应用项目。将以下抽象类添加到项目中:

```cs
namespace CustomInterfaces
{
  public abstract class CloneableType
  {
    // Only derived types can support this
    // "polymorphic interface." Classes in other
    // hierarchies have no access to this abstract
   // member.
    public abstract object Clone();
  }
}

```

根据这个定义，只有扩展了`CloneableType`的成员才能支持`Clone()`方法。如果你创建了一组新的类，但没有扩展这个基类，你就不能获得这个多态接口。同样，回想一下 C# 不支持类的多重继承。因此，如果你想创造一个“是-a”`Car`和“是-a”`CloneableType`的`MiniVan`，你是无法做到的。

```cs
// Nope! Multiple inheritance is not possible in C#
// for classes.
public class MiniVan : Car, CloneableType
{
}

```

正如你可能猜到的那样，接口类型来帮忙了。定义接口后，它可以由任何类或结构、任何层次结构、任何命名空间或任何程序集(用任何。NET 核心编程语言)。如你所见，接口是高度多态的*。考虑标准。NET 核心接口命名为`ICloneable`，定义在`System`命名空间中。这个接口定义了一个名为`Clone()`的方法。*

```cs
public interface ICloneable
{
  object Clone();
}

```

如果你检查。NET 核心基础类库，你会发现很多看似不相关的类型(`System.Array`、`System.Data.SqlClient.SqlConnection`、`System.OperatingSystem`、`System.String`等。)都实现了这个接口。尽管这些类型没有共同的父类型(除了`System.Object`，但是您可以通过`ICloneable`接口类型对它们进行多态处理。

首先，清除`Program.cs`代码并添加以下内容:

```cs
using System;
using CustomInterfaces;

Console.WriteLine("***** A First Look at Interfaces *****\n");
CloneableExample();

```

接下来，将下面名为`CloneMe()`的局部函数添加到顶级语句中。该函数接受一个`ICloneable`接口参数，该参数接受实现该接口的任何对象。下面是功能代码:

```cs
static void CloneableExample()
{
  // All of these classes support the ICloneable interface.
  string myStr = "Hello";
  OperatingSystem unixOS =
    new OperatingSystem(PlatformID.Unix, new Version());

  // Therefore, they can all be passed into a method taking ICloneable.
  CloneMe(myStr);
  CloneMe(unixOS);
  static void CloneMe(ICloneable c)
  {
    // Clone whatever we get and print out the name.
    object theClone = c.Clone();
    Console.WriteLine("Your clone is a: {0}",
      theClone.GetType().Name);
  }
}

```

当您运行这个应用时，每个类的类名通过您从`System.Object`继承的`GetType()`方法打印到控制台。正如将在第 17 章[中详细解释的，这个方法允许你在运行时理解任何类型的组成。无论如何，上一个程序的输出如下所示:](17.html)

```cs
***** A First Look at Interfaces *****
Your clone is a: String
Your clone is a: OperatingSystem

```

抽象基类的另一个限制是*每个派生类型*必须与一组抽象成员竞争并提供一个实现。为了解决这个问题，回想一下你在第 6 章[中定义的形状层次。假设您在名为`GetNumberOfPoints()`的`Shape`基类中定义了一个新的抽象方法，它允许派生类型返回呈现形状所需的点数。](06.html)

```cs
namespace CustomInterfaces
{
  abstract class Shape
  {
...
    // Every derived class must now support this method!
   public abstract byte GetNumberOfPoints();
  }
}

```

显然，唯一有分数的职业是`Hexagon`。然而，有了这次更新，*每个*派生类(`Circle`、`Hexagon`和`ThreeDCircle`)现在都必须提供这个函数的具体实现，即使这样做毫无意义。同样，接口类型提供了一个解决方案。如果你定义了一个代表“拥有点”行为的接口，你可以简单地把它插入到`Hexagon`类型中，而不去碰`Circle`和`ThreeDCircle`。

Note

在我的记忆中，C# 8 中对接口的改变可能是对现有语言特性最重要的改变。如前所述，新的接口功能使它们更接近抽象类的功能，增加了一个类实现多个接口的能力。我的建议是在这些水域中小心行事，运用常识。仅仅因为你能做某事并不意味着你应该做。

## 定义自定义接口

现在，您已经更好地理解了接口类型的总体作用，让我们来看一个定义和实现定制接口的例子。从您在第 [6](06.html) 章创建的 Shapes 解决方案中复制`Shape.cs`、`Hexagon.cs`、`Circle.cs`和`ThreeDCircle.cs`文件。完成之后，将定义以形状为中心的类型的名称空间重命名为`CustomInterfaces`(只是为了避免在新项目中导入名称空间定义)。现在，在您的项目中插入一个名为`IPointy.cs`的新文件。

在语法层面，接口是使用 C# `interface`关键字定义的。与类不同，接口从不指定基类(甚至不指定`System.Object`；然而，正如你将在本章后面看到的，一个接口可以指定基本接口。在 C# 8.0 之前，接口成员从不指定访问修饰符(因为所有接口成员都是隐式公共和抽象的)。C# 8.0 中的新特性，私有、内部、受保护甚至静态成员也可以被定义。稍后将对此进行更多介绍。为了让球滚动起来，这里有一个用 C# 定义的自定义接口:

```cs
namespace CustomInterfaces
{
  // This interface defines the behavior of "having points."
  public interface IPointy
  {
    // Implicitly public and abstract.
    byte GetNumberOfPoints();
  }
}

```

C# 8 中的接口不能定义数据字段或非静态构造函数。因此，以下版本的`IPointy`将导致各种编译器错误:

```cs
// Ack! Errors abound!
public interface IPointy
{
  // Error! Interfaces cannot have data fields!
  public int numbOfPoints;
  // Error! Interfaces do not have nonstatic constructors!
  public IPointy() { numbOfPoints = 0;}
}

```

无论如何，这个初始的`IPointy`接口定义了一个方法。接口类型也能够定义任意数量的属性原型。例如，我们可以更新`IPointy`接口来使用一个读写属性(注释掉)和一个只读属性。`Points`属性取代了`GetNumberOfPoints()`方法。

```cs
// The pointy behavior as a read-only property.
public interface IPointy
{
  // Implicitly public and abstract.
  //byte GetNumberOfPoints();

  // A read-write property in an interface would look like:
  //string PropName { get; set; }

  // while a write-only property in an interface would be:
   byte Points { get; }
}

```

Note

接口类型也可以包含事件(见第 [12 章](12.html))和索引器(见第 [11 章](11.html))定义。

接口类型本身毫无用处，因为你不能像分配一个类或结构那样分配接口类型。

```cs
// Ack! Illegal to allocate interface types.
IPointy p = new IPointy(); // Compiler error!

```

在被类或结构实现之前，接口不会带来太多好处。这里，`IPointy`是一个表示“有积分”行为的接口。这个想法很简单:形状层次结构中的一些类有点(如`Hexagon`)，而另一些类(如`Circle`)没有点。

## 实现接口

当一个类(或结构)选择通过支持接口来扩展其功能时，它会在类型定义中使用逗号分隔的列表。请注意，直接基类必须是冒号运算符后列出的第一项。当您的类类型直接从`System.Object`派生时，您可以简单地列出该类支持的接口(或多个接口),因为如果您没有另外说明，C# 编译器将从`System.Object`扩展您的类型。与此相关的一点是，鉴于结构总是从`System.ValueType`派生而来(参见第[章第 4 节](04.html))，只需在结构定义后直接列出每个接口。思考下面的例子:

```cs
// This class derives from System.Object and
// implements a single interface.
public class Pencil : IPointy
{...}

// This class also derives from System.Object
// and implements a single interface.
public class SwitchBlade : object, IPointy
{...}

// This class derives from a custom base class
// and implements a single interface.
public class Fork : Utensil, IPointy
{...}

// This struct implicitly derives from System.ValueType and
// implements two interfaces.
public struct PitchFork : ICloneable, IPointy
{...}

```

要明白，对于不包含默认实现的接口项来说，实现接口是一个要么全有要么全无的命题。支持类型不能有选择地选择它将实现哪些成员。鉴于`IPointy`接口定义了一个只读属性，这并不是太大的负担。然而，如果你正在实现一个定义了 10 个成员的接口(比如前面显示的`IDbConnection`接口)，那么这个类型现在负责充实所有 10 个抽象成员的细节。

对于这个例子，插入一个名为`Triangle`的新类类型，它“是-a”`Shape`并支持`IPointy`。注意，只读`Points`属性的实现(使用表达式主体成员语法实现)只是返回正确的点数(三)。

```cs
using System;
namespace CustomInterfaces
{
  // New Shape derived class named Triangle.
  class Triangle : Shape, IPointy
  {
    public Triangle() { }
    public Triangle(string name) : base(name) { }
    public override void Draw()
    {
      Console.WriteLine("Drawing {0} the Triangle", PetName);
    }

    // IPointy implementation.
    //public byte Points
    //{
      //    get { return 3; }
    //}
    public byte Points => 3;
  }
}

```

现在，更新您现有的`Hexagon`类型来支持`IPointy`接口类型。

```cs
using System;
namespace CustomInterfaces
{
  // Hexagon now implements IPointy.
  class Hexagon : Shape, IPointy
  {
    public Hexagon(){ }
    public Hexagon(string name) : base(name){ }
    public override void Draw()
    {
      Console.WriteLine("Drawing {0} the Hexagon", PetName);
    }

    // IPointy implementation.
    public byte Points => 6;
  }
}

```

综上所述，图 [8-1](#Fig1) 所示的 Visual Studio 类图使用流行的“棒棒糖”符号说明了与`IPointy`兼容的类。再次注意，`Circle`和`ThreeDCircle`没有实现`IPointy`，因为这种行为对这些类没有意义。

![img/340876_10_En_8_Chapter/340876_10_En_8_Fig1_HTML.jpg](img/340876_10_En_8_Chapter/340876_10_En_8_Fig1_HTML.jpg)

图 8-1。

形状层次结构，现在带有接口

Note

若要在类设计器中显示或隐藏接口名称，请右键单击接口图标，然后选择折叠或展开选项。

## 在对象级别调用接口成员

既然已经有了一些支持`IPointy`接口的类，下一个问题就是如何与新功能交互。与给定接口提供的功能进行交互的最直接方式是直接从对象级别调用成员(假设接口成员没有显式实现；您可以在“实现显式接口”一节中找到更多的细节)。例如，考虑以下代码:

```cs
Console.WriteLine("***** Fun with Interfaces *****\n");
// Call Points property defined by IPointy.
Hexagon hex = new Hexagon();
Console.WriteLine("Points: {0}", hex.Points);
Console.ReadLine();

```

在这种情况下，这种方法工作得很好，假设您知道`Hexagon`类型已经实现了正在讨论的接口，因此有一个`Points`属性。但是，其他时候，您可能无法确定给定类型支持哪些接口。例如，假设您有一个包含 50 个`Shape`兼容类型的数组，其中只有一部分支持`IPointy`。显然，如果你试图在一个没有实现`IPointy`的类型上调用`Points`属性，你会收到一个错误。那么，如何动态地确定一个类或结构是否支持正确的接口呢？

在运行时确定类型是否支持特定接口的一种方法是使用显式强制转换。如果类型不支持请求的接口，您会收到一个`InvalidCastException`。若要妥善处理这种可能性，请使用结构化异常处理，如下例所示:

```cs
...
// Catch a possible InvalidCastException.
Circle c = new Circle("Lisa");
IPointy itfPt = null;
try
{
  itfPt = (IPointy)c;
  Console.WriteLine(itfPt.Points);
}
catch (InvalidCastException e)
{
  Console.WriteLine(e.Message);
}
Console.ReadLine();

```

虽然您可以使用`try` / `catch`逻辑并抱乐观态度，但是在调用接口成员之前确定支持哪些接口是最理想的。让我们看看这样做的两种方法。

### 获取接口引用:as 关键字

你可以通过使用第 [6](06.html) 章中介绍的`as`关键字来确定一个给定的类型是否支持一个接口。如果对象可以被视为指定的接口，则返回一个对相关接口的引用。如果没有，您将收到一个`null`参考。因此，在继续之前，一定要检查`null`值。

```cs
...
// Can we treat hex2 as IPointy?
Hexagon hex2 = new Hexagon("Peter");
IPointy itfPt2 = hex2 as IPointy;
if(itfPt2 != null)
{
  Console.WriteLine("Points: {0}", itfPt2.Points);
}
else
{
   Console.WriteLine("OOPS! Not pointy...");
}
Console.ReadLine();

```

注意，当你使用`as`关键字时，你不需要使用`try` / `catch`逻辑；如果引用不是`null`，那么您知道您正在调用一个有效的接口引用。

### 获取接口引用:is 关键字(更新于 7.0)

你也可以使用关键字`is`检查一个实现的接口(也在第 [6](06.html) 章中首次讨论)。如果有问题的对象与指定的接口不兼容，则返回值`false`。如果在语句中提供变量名，则该类型被赋给该变量，从而消除了进行类型检查和强制转换的需要。前面的示例在此处更新:

```cs
Console.WriteLine("***** Fun with Interfaces *****\n");
...
if(hex2 is IPointy itfPt3)
{
  Console.WriteLine("Points: {0}", itfPt3.Points);
}
else
{
  Console.WriteLine("OOPS! Not pointy...");
}
 Console.ReadLine();

```

## 默认实现(新 8.0)

如前所述，C# 8.0 增加了接口方法和属性拥有默认实现的能力。添加一个名为`IRegularPointy`的新接口来表示一个规则形状的多边形。代码如下所示:

```cs
namespace CustomInterfaces
{
  interface IRegularPointy : IPointy
  {
    int SideLength { get; set; }
    int NumberOfSides { get; set; }
    int Perimeter => SideLength * NumberOfSides;
  }
}

```

向项目中添加一个名为`Square.cs`的新类，继承`Shape`基类，并实现`IRegularPointy`接口，如下所示:

```cs
namespace CustomInterfaces
{
  class Square: Shape,IRegularPointy
  {
    public Square() { }
    public Square(string name) : base(name) { }
    //Draw comes from the Shape base class
    public override void Draw()
    {
      Console.WriteLine("Drawing a square");
    }

    //This comes from the IPointy interface
    public byte Points => 4;
    //These come from the IRegularPointy interface
    public int SideLength { get; set; }
    public int NumberOfSides { get; set; }
    //Note that the Perimeter property is not implemented
  }
}

```

这里我们无意中引入了在接口中使用默认实现的第一个“陷阱”。在`IRegularPointy`接口上定义的`Perimeter`属性没有在`Square`类中定义，这使得它不能从`Square`的实例中访问。要查看实际情况，创建一个`Square`类的新实例，并将相关值输出到控制台，如下所示:

```cs
Console.WriteLine("\n***** Fun with Interfaces *****\n");
...
var sq = new Square("Boxy")
  {NumberOfSides = 4, SideLength = 4};
sq.Draw();
//This won’t compile
//Console.WriteLine($"{sq.PetName} has {sq.NumberOfSides} of length {sq.SideLength} and a perimeter of {sq.Perimeter}");

```

相反，`Square`实例必须被显式地转换为`IRegularPointy`接口(因为这是实现所在的地方)，然后才能访问`Perimeter`属性。将代码更新为以下内容:

```cs
Console.WriteLine($"{sq.PetName} has {sq.NumberOfSides} of length {sq.SideLength} and a perimeter of {((IRegularPointy)sq).Perimeter}");

```

解决这个问题的一个选择是始终对类型的接口进行编码。将`Square`实例的定义从`Square`改为`IRegularPointy`，如下所示:

```cs
IRegularPointy sq = new Square("Boxy") {NumberOfSides = 4, SideLength = 4};

```

这种方法的问题是`Draw()`方法和`PetName`属性没有在接口上定义，导致编译错误。

虽然这是一个微不足道的例子，但它确实展示了默认接口的一个问题。在您的代码中使用该特性之前，请确保您衡量了调用代码必须知道实现存在于何处的含义。

## 静态构造函数和成员(新 8.0)

C# 8.0 中接口的另一个新增功能是拥有静态构造函数和成员的能力，它们的功能与类定义中的静态成员相同，但都是在接口上定义的。用一个示例静态属性和一个静态构造函数更新`IRegularPointy`接口。

```cs
interface IRegularPointy : IPointy
{
  int SideLength { get; set; }
  int NumberOfSides { get; set; }
  int Perimeter => SideLength * NumberOfSides;

  //Static members are also allowed in C# 8
  static string ExampleProperty { get; set; }

  static IRegularPointy() => ExampleProperty = "Foo";
}

```

静态构造函数必须是无参数的，并且只能访问静态属性和方法。若要访问接口静态属性，请将以下代码添加到顶级语句中:

```cs
Console.WriteLine($"Example property: {IRegularPointy.ExampleProperty}");
IRegularPointy.ExampleProperty = "Updated";
Console.WriteLine($"Example property: {IRegularPointy.ExampleProperty}");

```

请注意，静态属性必须从接口而不是实例变量中调用。

## 作为参数的接口

假设接口是有效的类型，你可以构造将接口作为参数的方法，如本章前面的`CloneMe()`方法所示。对于当前的例子，假设您已经定义了另一个名为`IDraw3D`的接口。

```cs
namespace CustomInterfaces
{
  // Models the ability to render a type in stunning 3D.
  public interface IDraw3D
  {
    void Draw3D();
  }
}

```

接下来，假设您的三个形状中的两个(`ThreeDCircle`和`Hexagon`)已经被配置为支持这个新行为。

```cs
// Circle supports IDraw3D.
class ThreeDCircle : Circle, IDraw3D
{
...
  public void Draw3D()
    =>  Console.WriteLine("Drawing Circle in 3D!"); }
}

// Hexagon supports IPointy and IDraw3D.
class Hexagon : Shape, IPointy, IDraw3D
{
...
  public void Draw3D()
    => Console.WriteLine("Drawing Hexagon in 3D!");
}

```

图 [8-2](#Fig2) 展示了更新后的 Visual Studio 类图。

![img/340876_10_En_8_Chapter/340876_10_En_8_Fig2_HTML.jpg](img/340876_10_En_8_Chapter/340876_10_En_8_Fig2_HTML.jpg)

图 8-2。

更新的形状层次结构

如果您现在定义了一个将`IDraw3D`接口作为参数的方法，那么您可以有效地发送任何实现`IDraw3D`的对象。如果试图传入不支持必要接口的类型，则会收到编译时错误。考虑在您的`Program`类中定义的以下方法:

```cs
// I'll draw anyone supporting IDraw3D.
static void DrawIn3D(IDraw3D itf3d)
{
  Console.WriteLine("-> Drawing IDraw3D compatible type");
  itf3d.Draw3D();
}

```

您现在可以测试`Shape`数组中的一个项目是否支持这个新接口，如果支持，就将其传递给`DrawIn3D()`方法进行处理。

```cs
Console.WriteLine("***** Fun with Interfaces *****\n");
Shape[] myShapes = { new Hexagon(), new Circle(),
  new Triangle("Joe"), new Circle("JoJo") } ;
for(int i = 0; i < myShapes.Length; i++)
{
  // Can I draw you in 3D?
  if (myShapes[i] is IDraw3D s)
  {
    DrawIn3D(s);
  }
}

```

下面是更新后的应用的输出。注意，只有`Hexagon`对象在 3D 中打印出来，因为`Shape`数组的其他成员没有实现`IDraw3D`接口。

```cs
***** Fun with Interfaces *****
...
-> Drawing IDraw3D compatible type
Drawing Hexagon in 3D!

```

## 作为返回值的接口

接口也可以用作方法返回值。例如，您可以编写一个方法，该方法采用一组`Shape`对象，并返回对第一个支持`IPointy`的项的引用。

```cs
// This method returns the first object in the
// array that implements IPointy.
static IPointy FindFirstPointyShape(Shape[] shapes)
{
  foreach (Shape s in shapes)
  {
    if (s is IPointy ip)
    {
      return ip;
    }
  }
  return null;
}

```

您可以按如下方式与此方法交互:

```cs
Console.WriteLine("***** Fun with Interfaces *****\n");
// Make an array of Shapes.
Shape[] myShapes = { new Hexagon(), new Circle(),
                 new Triangle("Joe"), new Circle("JoJo")};

// Get first pointy item.
IPointy firstPointyItem = FindFirstPointyShape(myShapes);
// To be safe, use the null conditional operator.
Console.WriteLine("The item has {0} points",
  firstPointyItem?.Points);

```

## 接口类型数组

回想一下，同一个接口可以由许多类型实现，即使它们不在同一个类层次结构中，并且没有超过`System.Object`的公共父类。这可以产生一些强大的编程结构。例如，假设您已经在您当前的项目中开发了三个新的类类型来建模厨房用具(通过`Knife`和`Fork`类)和另一个建模园艺设备(à la `PitchFork`)。这里显示了类的相关代码，更新后的类图如图 [8-3](#Fig3) 所示:

![img/340876_10_En_8_Chapter/340876_10_En_8_Fig3_HTML.jpg](img/340876_10_En_8_Chapter/340876_10_En_8_Fig3_HTML.jpg)

图 8-3。

回想一下，接口可以“插入”类层次结构中任何部分的任何类型

```cs
//Fork.cs
namespace CustomInterfaces
{
  class Fork : IPointy
  {
    public byte Points => 4;
  }
}
//PitchFork.cs
namespace CustomInterfaces
{
  class PitchFork : IPointy
  {
    public byte Points => 3;
  }
}
//Knife.cs.cs
namespace CustomInterfaces
{
  class Knife : IPointy
  {
    public byte Points => 1;
  }
}

```

如果您定义了`PitchFork`、`Fork`和`Knife`类型，那么您现在可以定义一个`IPointy`兼容对象的数组。假设这些成员都支持相同的接口，那么您可以遍历数组并将每一项视为一个`IPointy`兼容的对象，而不管类层次结构的总体多样性。

```cs
...
// This array can only contain types that
// implement the IPointy interface.
IPointy[] myPointyObjects = {new Hexagon(), new Knife(),
  new Triangle(), new Fork(), new PitchFork()};

foreach(IPointy i in myPointyObjects)
{
  Console.WriteLine("Object has {0} points.", i.Points);
}
Console.ReadLine();

```

为了强调这个例子的重要性，请记住:当你有一个给定接口的数组时，这个数组可以包含任何实现这个接口的类或结构。

## 自动使用实现接口

尽管基于接口的编程是一种强大的技术，但是实现接口可能需要大量的输入。鉴于接口是一组命名的抽象成员，您需要在支持行为的*每个*类型上键入*每个*接口方法的定义和实现。因此，如果您想要支持一个总共定义了五个方法和三个属性的接口，您需要考虑所有八个成员(否则您将会收到编译器错误)。

正如您所希望的那样，Visual Studio 和 Visual Studio 代码都支持各种工具，这些工具可以减轻实现接口的负担。通过一个简单的测试，将一个 final 类插入到当前名为`PointyTestClass`的项目中。当您向一个类类型添加一个像`IPointy`这样的接口(或者任何这样的接口)时，您可能已经注意到，当您完成输入接口名称时(或者当您将鼠标光标放在代码窗口中的接口名称上时)，Visual Studio 和 Visual Studio 代码都添加了一个灯泡，它也可以用 Ctrl+句点(.)组合键。当你点击灯泡时，会出现一个下拉列表，允许你实现接口(见图 [8-4](#Fig4) 和 [8-5](#Fig5) )。

![img/340876_10_En_8_Chapter/340876_10_En_8_Fig5_HTML.jpg](img/340876_10_En_8_Chapter/340876_10_En_8_Fig5_HTML.jpg)

图 8-5。

使用 Visual Studio 自动实现接口

![img/340876_10_En_8_Chapter/340876_10_En_8_Fig4_HTML.jpg](img/340876_10_En_8_Chapter/340876_10_En_8_Fig4_HTML.jpg)

图 8-4。

使用 Visual Studio 代码自动实现接口

注意，您有两个选择，第二个(显式接口实现)将在下一节中讨论。暂时选择第一个选项，您会看到 Visual Studio/Visual Studio 代码已经生成了存根代码供您更新。(注意默认实现抛出一个`System.NotImplementedException`，显然可以删除。)

```cs
namespace CustomInterfaces
{
  class PointyTestClass : IPointy
  {
    public byte Points => throw new NotImplementedException();
  }
}

```

Note

Visual Studio /Visual Studio 代码还支持提取接口重构，可从“快速操作”菜单的“提取接口”选项中获得。这允许您从现有的类定义中提取新的接口定义。例如，您可能正在编写一个类，这时您突然意识到可以将行为一般化到一个接口中(从而打开了替代实现的可能性)。

## 显式接口实现

如本章前面所示，一个类或结构可以实现任意数量的接口。考虑到这一点，您总是有可能实现包含相同成员的接口，因此有名称冲突要处理。为了说明解决此问题的各种方式，请创建一个名为 InterfaceNameClash 的新控制台应用项目。现在设计三个接口，表示实现类型可以将其输出呈现到的不同位置。

```cs
namespace InterfaceNameClash
{
  // Draw image to a form.
  public interface IDrawToForm
  {
    void Draw();
  }
}

namespace InterfaceNameClash
{
  // Draw to buffer in memory.
  public interface IDrawToMemory
  {
    void Draw();
  }
}

namespace InterfaceNameClash
{
  // Render to the printer.
  public interface IDrawToPrinter
  {
    void Draw();
  }
}

```

注意，每个接口都定义了一个名为`Draw()`的方法，具有相同的签名。如果您现在想要在名为`Octagon`的单个类类型上支持这些接口中的每一个，编译器将允许以下定义:

```cs
using System;
namespace InterfaceNameClash
{
  class Octagon : IDrawToForm, IDrawToMemory, IDrawToPrinter
  {
   public void Draw()
   {
      // Shared drawing logic.
      Console.WriteLine("Drawing the Octagon...");
    }
  }
}

```

尽管代码可以干净地编译，但是您可能会遇到一个问题。简单地说，提供`Draw()`方法的单一实现并不允许您根据从`Octagon`对象获得的接口采取独特的行动。例如，下面的代码将调用相同的`Draw()`方法，而不管您获得哪个接口:

```cs
using System;
using InterfaceNameClash;

Console.WriteLine("***** Fun with Interface Name Clashes *****\n");
// All of these invocations call the
// same Draw() method!
Octagon oct = new Octagon();

// Shorthand notation if you don't need
// the interface variable for later use.
((IDrawToPrinter)oct).Draw();

// Could also use the "is" keyword.
if (oct is IDrawToMemory dtm)
{
  dtm.Draw();
}

Console.ReadLine();

```

显然，将图像呈现到窗口所需的代码与将图像呈现到网络打印机或内存区域所需的代码完全不同。当您实现几个具有相同成员的接口时，您可以使用*显式接口实现*语法来解决这种名称冲突。考虑以下对`Octagon`类型的更新:

```cs
class Octagon : IDrawToForm, IDrawToMemory, IDrawToPrinter
{
   // Explicitly bind Draw() implementations
   // to a given interface.
   void IDrawToForm.Draw()
   {
     Console.WriteLine("Drawing to form...");
   }
   void IDrawToMemory.Draw()
   {
     Console.WriteLine("Drawing to memory...");
   }
   void IDrawToPrinter.Draw()
   {
     Console.WriteLine("Drawing to a printer...");
   }
}

```

如您所见，当显式实现接口成员时，一般模式可以分解为:

```cs
returnType InterfaceName.MethodName(params){}

```

请注意，使用此语法时，不需要提供访问修饰符；显式实现的成员自动是私有的。例如，以下是非法语法:

```cs
// Error! No access modifier!
public void IDrawToForm.Draw()
{
   Console.WriteLine("Drawing to form...");
}

```

因为显式实现的成员总是隐式私有的，所以这些成员在对象级别不再可用。事实上，如果您将点运算符应用于一个`Octagon`类型，您会发现 IntelliSense 不会向您显示任何`Draw()`成员。正如所料，您必须使用显式转换来访问所需的功能。顶层语句中的前一段代码已经使用了显式强制转换，因此它可以使用显式接口。

```cs
Console.WriteLine("***** Fun with Interface Name Clashes *****\n");
Octagon oct = new Octagon();

// We now must use casting to access the Draw()
// members.
IDrawToForm itfForm = (IDrawToForm)oct;
itfForm.Draw();

// Shorthand notation if you don't need
// the interface variable for later use.
((IDrawToPrinter)oct).Draw();

// Could also use the "is" keyword.
if (oct is IDrawToMemory dtm)
{
  dtm.Draw();
}
Console.ReadLine();

```

虽然当您需要解决名称冲突时，这种语法非常有用，但是您可以使用显式接口实现来简单地隐藏对象级别的更多“高级”成员。这样，当对象用户应用点运算符时，用户将只能看到该类型整体功能的一个子集。但是，那些需要更高级行为的人可以通过显式强制转换提取所需的接口。

## 设计接口层次结构

接口可以排列在接口层次结构中。像类层次结构一样，当一个接口扩展一个现有的接口时，它继承了由父类定义的抽象成员。在 C# 8 之前，派生接口从不继承真正的实现。相反，派生接口只是用额外的抽象成员扩展了它自己的定义。在 C# 8 中，派生接口继承了默认实现，扩展了定义，并可能添加新的默认实现。

当您希望在不破坏现有代码库的情况下扩展现有接口的功能时，接口层次结构会很有用。为了进行说明，创建一个名为 InterfaceHierarchy 的新控制台应用项目。现在，让我们设计一组新的以渲染为中心的接口，这样`IDrawable`就是家谱的根。

```cs
namespace InterfaceHierarchy
{
  public interface IDrawable
  {
    void Draw();
  }
}

```

鉴于`IDrawable`定义了一个基本的绘制行为，您现在可以创建一个派生接口，用修改后的格式来扩展这个接口。这里有一个例子:

```cs
namespace InterfaceHierarchy
{
  public interface IAdvancedDraw : IDrawable
  {
    void DrawInBoundingBox(int top, int left, int bottom, int right);
    void DrawUpsideDown();
  }
}

```

根据这种设计，如果一个类要实现`IAdvancedDraw`，那么它现在需要实现继承链中定义的每个成员(特别是`Draw()`、`DrawInBoundingBox()`和`DrawUpsideDown()`方法)。

```cs
using System;
namespace InterfaceHierarchy
{
  public class BitmapImage : IAdvancedDraw
  {
    public void Draw()
    {
      Console.WriteLine("Drawing...");
    }

    public void DrawInBoundingBox(int top, int left, int bottom, int right)
    {
      Console.WriteLine("Drawing in a box...");
    }

    public void DrawUpsideDown()
    {
      Console.WriteLine("Drawing upside down!");
    }
  }
}

```

现在，当您使用`BitmapImage`时，您可以在对象级别调用每个方法(因为它们都是`public`)，以及通过强制转换提取对每个支持的接口的引用。

```cs
using System;
using InterfaceHierarchy;

Console.WriteLine("***** Simple Interface Hierarchy *****");

// Call from object level.
BitmapImage myBitmap = new BitmapImage();
myBitmap.Draw();
myBitmap.DrawInBoundingBox(10, 10, 100, 150);
myBitmap.DrawUpsideDown();

// Get IAdvancedDraw explicitly.
if (myBitmap is IAdvancedDraw iAdvDraw)
{
  iAdvDraw.DrawUpsideDown();
}
Console.ReadLine();

```

### 默认实现的接口层次结构(新 8.0)

当接口层次结构还包括默认实现时，下游接口可以选择从基接口继承该实现，或者创建一个新的默认实现。将`IDrawable`接口更新如下:

```cs
public interface IDrawable
{
  void Draw();
  int TimeToDraw() => 5;
}

```

接下来，将顶级语句更新为以下内容:

```cs
Console.WriteLine("***** Simple Interface Hierarchy *****");
...
if (myBitmap is IAdvancedDraw iAdvDraw)
{
  iAdvDraw.DrawUpsideDown();
  Console.WriteLine($"Time to draw: {iAdvDraw.TimeToDraw()}");
}
Console.ReadLine();

```

这段代码不仅会编译，而且会为`TimeToDraw()`方法输出一个值 5。这是因为默认实现会自动结转到后代接口。将`BitMapImage`转换为`IAdvancedDraw`接口提供了对`TimeToDraw()`方法的访问，即使`BitMapImage`实例不能访问默认实现。要证明这一点，请输入以下代码并查看编译错误:

```cs
//This does not compile
myBitmap.TimeToDraw();

```

如果下游接口想要提供自己的默认实现，它必须隐藏上游实现。例如，如果`IAdvancedDraw TimeToDraw()`方法需要 15 个单位来绘制，则将接口更新为以下定义:

```cs
public interface IAdvancedDraw : IDrawable
{
  void DrawInBoundingBox(
    int top, int left, int bottom, int right);
  void DrawUpsideDown();
  new int TimeToDraw() => 15;
}

```

当然，`BitMapImage`类也可以自由实现`TimeToDraw()`方法。与`IAdvancedDraw TimeToDraw()`方法不同，这个类只需要 ***实现*** 方法，而不需要隐藏它。

```cs
public class BitmapImage : IAdvancedDraw
{
...
  public int TimeToDraw() => 12;
}

```

当将`BitmapImage`实例转换为`IAdvancedDraw`或`IDrawable`接口时，实例上的方法仍然被执行。将此代码添加到顶级语句中:

```cs
//Always calls method on instance:
Console.WriteLine("***** Calling Implemented TimeToDraw *****");
Console.WriteLine($"Time to draw: {myBitmap.TimeToDraw()}");
Console.WriteLine($"Time to draw: {((IDrawable) myBitmap).TimeToDraw()}");
Console.WriteLine($"Time to draw: {((IAdvancedDraw) myBitmap).TimeToDraw()}");

```

结果如下:

```cs
***** Simple Interface Hierarchy *****
...
***** Calling Implemented TimeToDraw *****
Time to draw: 12
Time to draw: 12
Time to draw: 12

```

### 接口类型的多重继承

与类类型不同，一个接口可以扩展多个基本接口，允许您设计一些强大而灵活的抽象。创建一个名为 MiInterfaceHierarchy 的新控制台应用项目。这是另一个接口集合，对各种渲染和形状抽象进行建模。注意，`IShape`接口同时扩展了`IDrawable`和`IPrintable`。

```cs
//IDrawable.cs
namespace MiInterfaceHierarchy
{
  // Multiple inheritance for interface types is A-okay.
  interface IDrawable
  {
    void Draw();
  }
}

//IPrintable.cs
namespace MiInterfaceHierarchy
{
  interface IPrintable
  {
    void Print();
    void Draw(); // <-- Note possible name clash here!
  }
}

//IShape.cs
namespace MiInterfaceHierarchy
{
  // Multiple interface inheritance. OK!
  interface IShape : IDrawable, IPrintable
  {
    int GetNumberOfSides();
  }
}

```

图 [8-6](#Fig6) 显示了当前的接口层次。

![img/340876_10_En_8_Chapter/340876_10_En_8_Fig6_HTML.jpg](img/340876_10_En_8_Chapter/340876_10_En_8_Fig6_HTML.jpg)

图 8-6。

与类不同，接口可以扩展多种接口类型

此时，百万美元的问题是“如果你有一个支持`IShape`的类，需要实现多少个方法？”答案是:视情况而定。如果你想提供一个简单的`Draw()`方法的实现，你只需要提供三个成员，如下面的`Rectangle`类型所示:

```cs
using System;

namespace MiInterfaceHierarchy
{
  class Rectangle : IShape
  {
    public int GetNumberOfSides() => 4;
    public void Draw() => Console.WriteLine("Drawing...");
    public void Print() => Console.WriteLine("Printing...");
  }
}

```

如果您希望每个`Draw()`方法都有特定的实现(在这种情况下最有意义)，您可以使用显式接口实现来解决名称冲突，如下面的`Square`类型所示:

```cs
namespace MiInterfaceHierarchy
{
  class Square : IShape
  {
    // Using explicit implementation to handle member name clash.
    void IPrintable.Draw()
    {
      // Draw to printer ...
    }
    void IDrawable.Draw()
    {
      // Draw to screen ...
    }
    public void Print()
    {
      // Print ...
    }

    public int GetNumberOfSides() => 4;
  }
}

```

理想情况下，此时您会对使用 C# 语法定义和实现自定义接口的过程感到更加舒适。老实说，基于接口的编程可能需要一段时间才能适应，所以如果你实际上仍然有点挠头，这是完全正常的反应。

但是，请注意，接口是。NET 核心框架。不管你开发的应用是什么类型(基于网络的，桌面图形用户接口，数据访问库，等等)。)，使用接口将是这个过程的一部分。总结一下到目前为止的情况，记住接口在以下情况下非常有用:

*   您有一个单一的层次结构，其中只有派生类型的子集支持一个公共行为。

*   您需要对一个常见的行为进行建模，这个行为存在于多个层次结构中，除了`System.Object`之外没有共同的父类。

既然您已经深入研究了构建和实现自定义接口的细节，本章的剩余部分将研究。NET 核心基本类库。正如您将看到，您可以实现标准。NET 核心接口，以确保它们无缝集成到框架中。

## IEnumerable 和 IEnumerator 接口

开始检查实现现有。NET 核心接口，我们先来看看`IEnumerable`和`IEnumerator`的作用。回想一下，C# 支持一个名为`foreach`的关键字，它允许你迭代任何数组类型的内容。

```cs
// Iterate over an array of items.
int[] myArrayOfInts = {10, 20, 30, 40};

foreach(int i in myArrayOfInts)
{
  Console.WriteLine(i);
}

```

虽然看起来只有数组类型可以使用这个构造，但事实是任何支持名为`GetEnumerator()`的方法的类型都可以被`foreach`构造求值。举例来说，首先创建一个名为 CustomEnumerator 的新控制台应用项目。接下来，将第 [7](07.html) 章的 SimpleException 示例中定义的`Car.cs`和`Radio.cs`文件复制到新项目中。确保将类的名称空间更新为`CustomEnumerator`。

现在，插入一个名为`Garage`的新类，它在一个`System.Array`中存储一组`Car`对象。

```cs
using System.Collections;

namespace CustomEnumerator
{
  // Garage contains a set of Car objects.
  public class Garage
  {
    private Car[] carArray = new Car[4];

    // Fill with some Car objects upon startup.
    public Garage()
    {
      carArray[0] = new Car("Rusty", 30);
      carArray[1] = new Car("Clunker", 55);
      carArray[2] = new Car("Zippy", 30);
      carArray[3] = new Car("Fred", 30);
    }
  }
}

```

理想情况下，使用`foreach`构造遍历`Garage`对象的子项会很方便，就像数据值数组一样。

```cs
using System;
using CustomEnumerator;

// This seems reasonable ...
Console.WriteLine("***** Fun with IEnumerable / IEnumerator *****\n");
Garage carLot = new Garage();

// Hand over each car in the collection?
foreach (Car c in carLot)
{
  Console.WriteLine("{0} is going {1} MPH",
    c.PetName, c.CurrentSpeed);
}
Console.ReadLine();

```

遗憾的是，编译器通知您,`Garage`类没有实现名为`GetEnumerator()`的方法。这个方法由隐藏在`System.Collections`名称空间中的`IEnumerable`接口形式化。

Note

在第 [10 章](10.html)中，你将学习泛型的角色和`System.Collections.Generic`名称空间。正如您将看到的，这个名称空间包含了`IEnumerable` / `IEnumerator`的通用版本，提供了一种更加类型安全的方式来迭代条目。

支持这种行为的类或结构宣称它们可以向调用者公开所包含的项目(在本例中，是关键字`foreach`本身)。这个标准接口的定义如下:

```cs
// This interface informs the caller
// that the object's items can be enumerated.
public interface IEnumerable
{
   IEnumerator GetEnumerator();
}

```

如您所见，`GetEnumerator()`方法返回了对另一个名为`System.Collections.IEnumerator`的接口的引用。该接口提供了允许调用者遍历兼容`IEnumerable`的容器所包含的内部对象的基础设施。

```cs
// This interface allows the caller to
// obtain a container's items.
public interface IEnumerator
{
   bool MoveNext ();  // Advance the internal position of the cursor.
   object Current { get;}  // Get the current item (read-only property).
   void Reset (); // Reset the cursor before the first member.
}

```

如果您想更新`Garage`类型来支持这些接口，您可以走很长的路，手动实现每个方法。虽然你当然可以自由地提供定制版本的`GetEnumerator()`、`MoveNext()`、`Current`和`Reset()`，但是有一个更简单的方法。由于`System.Array`类型(以及许多其他集合类)已经实现了`IEnumerable`和`IEnumerator`，您可以简单地将请求委托给`System.Array`，如下所示(注意，您需要将`System.Collections`名称空间导入到您的代码文件中):

```cs
using System.Collections;
...
public class Garage : IEnumerable
{
  // System.Array already implements IEnumerator!
  private Car[] carArray = new Car[4];

  public Garage()
  {
    carArray[0] = new Car("FeeFee", 200);
    carArray[1] = new Car("Clunker", 90);
    carArray[2] = new Car("Zippy", 30);
    carArray[3] = new Car("Fred", 30);
  }

  // Return the array object's IEnumerator.
  public IEnumerator GetEnumerator()
    => carArray.GetEnumerator();
}

```

在您更新了您的`Garage`类型之后，您可以在 C# `foreach`构造中安全地使用该类型。此外，鉴于`GetEnumerator()`方法已经被公开定义，对象用户也可以与`IEnumerator`类型交互。

```cs
// Manually work with IEnumerator.
IEnumerator carEnumerator = carLot.GetEnumerator();
carEnumerator.MoveNext();
Car myCar = (Car)i.Current;
Console.WriteLine("{0} is going {1} MPH", myCar.PetName, myCar.CurrentSpeed);

```

然而，如果您喜欢在对象级隐藏`IEnumerable`的功能，只需使用显式接口实现。

```cs
// Return the array object's IEnumerator.
IEnumerator IEnumerable.GetEnumerator()
  => return carArray.GetEnumerator();

```

通过这样做，偶然的对象用户将不会发现`Garage`的`GetEnumerator()`方法，而`foreach`构造将在必要时在后台获得接口。

### 用 yield 关键字构建迭代器方法

有一种替代方法可以通过*迭代器*构建与`foreach`循环一起工作的类型。简单地说，*迭代器*是一个成员，它指定了容器的内部项在被`foreach`处理时应该如何返回。举例来说，创建一个名为 CustomEnumeratorWithYield 的新控制台应用项目，并插入上一个示例中的`Car`、`Radio`和`Garage`类型(同样，将您的名称空间定义重命名为当前项目)。现在，对当前的`Garage`型进行如下改装:

```cs
public class Garage : IEnumerable
{
...
  // Iterator method.

  public IEnumerator GetEnumerator()
  {
    foreach (Car c in carArray)
    {
      yield return c;
    }
  }
}

```

注意，`GetEnumerator()`的这个实现使用内部`foreach`逻辑遍历子项，并使用`yield return`语法将每个`Car`返回给调用者。`yield`关键字用于指定返回给调用者的`foreach`结构的值。当到达`yield return`语句时，存储容器中的当前位置，下次调用迭代器时从这个位置重新开始执行。

迭代器方法不需要使用`foreach`关键字来返回其内容。也可以将这个迭代器方法定义如下:

```cs
public IEnumerator GetEnumerator()
{
   yield return carArray[0];
   yield return carArray[1];
   yield return carArray[2];
   yield return carArray[3];
}

```

在这个实现中，注意到`GetEnumerator()`方法在每次传递时都显式地向调用者返回一个新值。在这个例子中这样做没有什么意义，因为如果您要向`carArray`成员变量添加更多的对象，那么您的`GetEnumerator()`方法现在将会不同步。然而，当您想从一个方法返回本地数据以便用`foreach`语法处理时，这个语法会很有用。

#### 具有本地功能的保护子句(新 7.0)

在第一次迭代项目(或访问任何元素)之前，不会执行`GetEnumerator()`方法中的任何代码。这意味着如果在`yield`语句之前有一个异常，它不会在方法第一次被调用时抛出，而只会在第一个`MoveNext()`被调用时抛出。

为了测试这一点，将`GetEnumerator`方法更新为:

```cs
public IEnumerator GetEnumerator()
{
  //This will not get thrown until MoveNext() is called
  throw new Exception("This won't get called");
  foreach (Car c in carArray)
  {
    yield return c;
  }
}

```

如果你像这样调用这个函数并且不做任何其他事情，那么这个异常永远不会被抛出:

```cs
using System.Collections;
...
Console.WriteLine("***** Fun with the Yield Keyword *****\n");
Garage carLot = new Garage();
IEnumerator carEnumerator = carLot.GetEnumerator();

Console.ReadLine();

```

直到调用`MoveNext()`代码才会执行，并抛出异常。根据您的程序的需要，这可能非常好。但也可能不会。您的`GetEnumerator`方法可能有一个*保护子句*，它需要在方法第一次被调用时执行。例如，假设列表是从数据库中收集的。您可能想要检查数据库连接是否可以在方法被*调用*时打开，而不是在列表被迭代时打开。或者您可能想要检查`Iterator`方法的输入参数(接下来将介绍)的有效性。

从第 [4](04.html) 章回忆 C# 7 局部函数特性；局部函数是其他函数内部的私有函数。通过将`yield return`移动到从方法主体返回的局部函数中，顶级语句中的代码(在局部函数返回之前)会立即执行。调用`MoveNext()`时执行本地函数。

将方法更新为:

```cs
public IEnumerator GetEnumerator()
{
  //This will get thrown immediately
  throw new Exception("This will get called");

  return ActualImplementation();

  //this is the local function and the actual IEnumerator implementation
  IEnumerator ActualImplementation()
  {
    foreach (Car c in carArray)
    {
      yield return c;
    }
  }
}

```

通过将调用代码更新为以下代码来测试这一点:

```cs
Console.WriteLine("***** Fun with the Yield Keyword *****\n");
Garage carLot = new Garage();
try
{
  //Error at this time
  var carEnumerator = carLot.GetEnumerator();
}
catch (Exception e)
{
  Console.WriteLine($"Exception occurred on GetEnumerator");
}
Console.ReadLine();

```

随着对`GetEnumerator()`方法的更新，异常被立即抛出，而不是在调用`MoveNext()`时抛出。

### 构建命名迭代器

有趣的是，`yield`关键字在技术上可以用在任何方法中，不管它的名字是什么。这些方法(技术上称为*命名迭代器*)的独特之处还在于它们可以接受任意数量的参数。当构建一个命名迭代器时，要注意该方法将返回`IEnumerable`接口，而不是预期的`IEnumerator`兼容类型。举例来说，您可以将下面的方法添加到`Garage`类型中(使用局部函数来封装迭代功能):

```cs
public IEnumerable GetTheCars(bool returnReversed)
{
  //do some error checking here
  return ActualImplementation();

  IEnumerable ActualImplementation()
  {
    // Return the items in reverse.
    if (returnReversed)
    {
      for (int i = carArray.Length; i != 0; i--)
      {
        yield return carArray[i - 1];
      }
    }
    else
    {
      // Return the items as placed in the array.
      foreach (Car c in carArray)
      {
        yield return c;
      }
    }
  }
}

```

注意，如果传入参数的值为`true`，新方法允许调用者以顺序和逆序获取子项。现在，您可以与您的新方法进行如下交互(确保注释掉`GetEnumerator()`方法中的`throw new`异常语句):

```cs
Console.WriteLine("***** Fun with the Yield Keyword *****\n");
Garage carLot = new Garage();

// Get items using GetEnumerator().
foreach (Car c in carLot)
{
  Console.WriteLine("{0} is going {1} MPH",
    c.PetName, c.CurrentSpeed);
}

Console.WriteLine();

// Get items (in reverse!) using named iterator.
foreach (Car c in carLot.GetTheCars(true))
{
  Console.WriteLine("{0} is going {1} MPH",
    c.PetName, c.CurrentSpeed);
}
Console.ReadLine();

```

您可能同意，命名迭代器是有用的构造，因为单个定制容器可以定义多种方式来请求返回的集合。

因此，为了总结构建可枚举对象的内容，请记住，要让您的自定义类型使用 C# `foreach`关键字，容器必须定义一个名为`GetEnumerator()`的方法，该方法已经由`IEnumerable`接口类型形式化。此方法的实现通常通过简单地将它委托给持有子对象的内部成员来实现；然而，也可以使用`yield return`语法来提供多个“命名迭代器”方法。

## 可克隆的接口

您可能还记得第六章[中的](06.html)，`System.Object`定义了一个名为`MemberwiseClone()`的方法。这个方法用来获得当前对象的一个*浅拷贝*。对象用户不直接调用此方法，因为它是受保护的。然而，在*克隆*过程中，一个给定的对象可能会调用这个方法本身。举例来说，创建一个名为`CloneablePoint`的新控制台应用项目，它定义了一个名为`Point`的类。

```cs
using System;

namespace CloneablePoint
{
  // A class named Point.
  public class Point
  {
    public int X {get; set;}
    public int Y {get; set;}

    public Point(int xPos, int yPos) { X = xPos; Y = yPos;}
    public Point(){}

    // Override Object.ToString().
    public override string ToString() => $"X = {X}; Y = {Y}";
  }
}

```

给定你已经知道的引用类型和值类型(见第 [4 章](04.html)，你知道如果你把一个引用变量赋给另一个，你有两个引用指向内存中的同一个对象。因此，下面的赋值操作导致对堆上同一个`Point`对象的两次引用；使用任一引用的修改都会影响堆上的同一对象:

```cs
Console.WriteLine("***** Fun with Object Cloning *****\n");
// Two references to same object!
Point p1 = new Point(50, 50);
Point p2 = p1;
p2.X = 0;
Console.WriteLine(p1);
Console.WriteLine(p2);
Console.ReadLine();

```

当您想让您的自定义类型能够向调用者返回其自身的相同副本时，您可以实现标准的`ICloneable`接口。如本章开头所示，该类型定义了一个名为`Clone()`的方法。

```cs
public interface ICloneable
{
  object Clone();
}

```

显然，`Clone()`方法的实现因类而异。但是，基本功能是相同的:将成员变量的值复制到一个相同类型的新对象实例中，并将其返回给用户。为了说明这一点，请考虑下面对`Point`类的更新:

```cs
// The Point now supports "clone-ability."
public class Point : ICloneable
{
  public int X { get; set; }
  public int Y { get; set; }

  public Point(int xPos, int yPos) { X = xPos; Y = yPos; }
  public Point() { }

  // Override Object.ToString().
  public override string ToString() => $"X = {X}; Y = {Y}";

  // Return a copy of the current object.
  public object Clone() => new Point(this.X, this.Y);
}

```

这样，您可以创建`Point`类型的精确独立副本，如以下代码所示:

```cs
Console.WriteLine("***** Fun with Object Cloning *****\n");
...
// Notice Clone() returns a plain object type.
// You must perform an explicit cast to obtain the derived type.
Point p3 = new Point(100, 100);
Point p4 = (Point)p3.Clone();

// Change p4.X (which will not change p3.X).
p4.X = 0;

// Print each object.
Console.WriteLine(p3);
Console.WriteLine(p4);
Console.ReadLine();

```

虽然当前的`Point`实现符合要求，但是您可以稍微简化一下。因为`Point`类型不包含任何内部引用类型变量，您可以将`Clone()`方法的实现简化如下:

```cs
// Copy each field of the Point member by member.
public object Clone() => this.MemberwiseClone();

```

但是，请注意，如果`Point`包含任何引用类型成员变量，`MemberwiseClone()`将复制对这些对象的引用(即，*浅层复制*)。如果你想支持真正的*深度拷贝*，你需要在克隆过程中创建一个引用类型变量的新实例。接下来我们来看一个例子。

### 一个更复杂的克隆例子

现在假设`Point`类包含一个`PointDescription`类型的引用类型成员变量。这个类维护一个点的友好名称以及一个标识号，表示为一个`System.Guid`(一个全局唯一标识符【GUID】是一个统计上唯一的 128 位数字)。下面是实现过程:

```cs
using System;

namespace CloneablePoint
{
  // This class describes a point.
  public class PointDescription
  {
    public string PetName {get; set;}
    public Guid PointID {get; set;}

    public PointDescription()
    {
      PetName = "No-name";
      PointID = Guid.NewGuid();
    }
  }
}

```

对`Point`类本身的初始更新包括修改`ToString()`来说明这些新的状态数据，以及定义和创建`PointDescription`引用类型。为了让外界给`Point`起一个昵称，还需要更新传递给重载构造函数的参数。

```cs
public class Point : ICloneable
{
  public int X { get; set; }
  public int Y { get; set; }
  public PointDescription desc = new PointDescription();

  public Point(int xPos, int yPos, string petName)
  {
    X = xPos; Y = yPos;
    desc.PetName = petName;
  }
  public Point(int xPos, int yPos)
  {
    X = xPos; Y = yPos;
  }
  public Point() { }

  // Override Object.ToString().
  public override string ToString()
     => $"X = {X}; Y = {Y}; Name = {desc.PetName};\nID = {desc.PointID}\n";

  // Return a copy of the current object.
  public object Clone() => this.MemberwiseClone();
}

```

注意，您还没有更新您的`Clone()`方法。因此，当对象用户请求使用当前实现进行克隆时，将获得浅层(逐个成员)拷贝。举例来说，假设您已经更新了调用代码，如下所示:

```cs
Console.WriteLine("***** Fun with Object Cloning *****\n");
...
Console.WriteLine("Cloned p3 and stored new Point in p4");
Point p3 = new Point(100, 100, "Jane");
Point p4 = (Point)p3.Clone();

Console.WriteLine("Before modification:");
Console.WriteLine("p3: {0}", p3);
Console.WriteLine("p4: {0}", p4);
p4.desc.PetName = "My new Point";
p4.X = 9;

Console.WriteLine("\nChanged p4.desc.petName and p4.X");
Console.WriteLine("After modification:");
Console.WriteLine("p3: {0}", p3);
Console.WriteLine("p4: {0}", p4);
Console.ReadLine();

```

请注意，在下面的输出中，虽然值类型确实已经更改，但是内部引用类型保持相同的值，因为它们“指向”内存中相同的对象(具体来说，请注意这两个对象的昵称现在都是“My new Point”)。

```cs
***** Fun with Object Cloning *****
Cloned p3 and stored new Point in p4
Before modification:
p3: X = 100; Y = 100; Name = Jane;
ID = 133d66a7-0837-4bd7-95c6-b22ab0434509

p4: X = 100; Y = 100; Name = Jane;
ID = 133d66a7-0837-4bd7-95c6-b22ab0434509

Changed p4.desc.petName  and p4.X
After modification:
p3: X = 100; Y = 100; Name = My new Point;
ID = 133d66a7-0837-4bd7-95c6-b22ab0434509

p4: X = 9; Y = 100; Name = My new Point;
ID = 133d66a7-0837-4bd7-95c6-b22ab0434509

```

为了让您的`Clone()`方法对内部引用类型进行完整的深度复制，您需要配置由`MemberwiseClone()`返回的对象，以说明当前点的名称(`System.Guid`类型实际上是一个结构，因此数字数据确实被复制了)。下面是一个可能的实现:

```cs
// Now we need to adjust for the PointDescription member.
public object Clone()
{
  // First get a shallow copy.
  Point newPoint = (Point)this.MemberwiseClone();

  // Then fill in the gaps.
  PointDescription currentDesc = new PointDescription();
  currentDesc.PetName = this.desc.PetName;
  newPoint.desc = currentDesc;
  return newPoint;
}

```

如果您再次运行应用并查看输出(如下所示)，您会看到从`Clone()`返回的`Point`确实复制了它的内部引用类型成员变量(注意宠物名称现在对于`p3`和`p4`都是惟一的)。

```cs
***** Fun with Object Cloning *****
Cloned p3 and stored new Point in p4
Before modification:
p3: X = 100; Y = 100; Name = Jane;
ID = 51f64f25-4b0e-47ac-ba35-37d263496406

p4: X = 100; Y = 100; Name = Jane;
ID = 0d3776b3-b159-490d-b022-7f3f60788e8a

Changed p4.desc.petName  and p4.X
After modification:
p3: X = 100; Y = 100; Name = Jane;
ID = 51f64f25-4b0e-47ac-ba35-37d263496406

p4: X = 9; Y = 100; Name = My new Point;
ID = 0d3776b3-b159-490d-b022-7f3f60788e8a

```

总结一下克隆过程，如果你有一个只包含值类型的类或结构，使用`MemberwiseClone()`实现你的`Clone()`方法。但是，如果您有一个维护其他引用类型的自定义类型，您可能希望创建一个新的对象，该对象考虑每个引用类型成员变量以获得“深层副本”

## IComparable 接口

`System.IComparable`接口指定了一种行为，允许基于某个指定的键对对象进行排序。以下是正式的定义:

```cs
// This interface allows an object to specify its
// relationship between other like objects.
public interface IComparable
{
  int CompareTo(object o);
}

```

Note

这个接口的通用版本(`IComparable<T>`)提供了一种更加类型安全的方式来处理对象之间的比较。你将在第 10 章中研究泛型。

创建一个名为 ComparableCar 的新控制台应用项目，从第 [7](07.html) 章的 SimpleException 示例中复制`Car`和`Radio`类，并将每个文件的名称空间重命名为`ComparableCar`。通过添加一个新属性来表示每辆汽车的唯一 ID 和一个修改后的构造函数，从而更新`Car`类:

```cs
using System;
using System.Collections;

namespace ComparableCar
{
  public class Car
  {
...
    public int CarID {get; set;}
    public Car(string name, int currSp, int id)
    {
      CurrentSpeed = currSp;
      PetName = name;
      CarID = id;
    }
...
  }
}

```

现在假设您有一个如下的`Car`对象数组:

```cs
using System;
using ComparableCar;
Console.WriteLine("***** Fun with Object Sorting *****\n");

// Make an array of Car objects.
Car[] myAutos = new Car[5];
myAutos[0] = new Car("Rusty", 80, 1);
myAutos[1] = new Car("Mary", 40, 234);
myAutos[2] = new Car("Viper", 40, 34);
myAutos[3] = new Car("Mel", 40, 4);
myAutos[4] = new Car("Chucky", 40, 5);

Console.ReadLine();

```

`System.Array`类定义了一个名为`Sort()`的静态方法。当您对一组内部类型(`int`、`short`、`string`等)调用此方法时。)，您可以按数字/字母顺序对数组中的项目进行排序，因为这些固有的数据类型实现了`IComparable`。然而，如果您将一个`Car`类型的数组发送到`Sort()`方法中，情况会怎样呢？

```cs
// Sort my cars? Not yet!
Array.Sort(myAutos);

```

如果您运行这个测试，您会得到一个运行时异常，因为`Car`类不支持必要的接口。当您构建定制类型时，您可以实现`IComparable`来允许您的类型的数组被排序。当你充实了`CompareTo()`的细节后，将由你来决定订购操作的基线是什么。对于`Car`型，内部的`CarID`似乎是合乎逻辑的候选。

```cs
// The iteration of the Car can be ordered
// based on the CarID.
public class Car : IComparable
{
...
  // IComparable implementation.
  int IComparable.CompareTo(object obj)
  {
    if (obj is Car temp)
    {
      if (this.CarID > temp.CarID)
      {
        return 1;
      }
      if (this.CarID < temp.CarID)
      {
        return -1;
      }
      return 0;
    }
    throw new ArgumentException("Parameter is not a Car!");
  }
}

```

如您所见，`CompareTo()`背后的逻辑是根据特定的数据点，针对当前实例测试传入的对象。`CompareTo()`的返回值用于发现该类型是小于、大于还是等于与之比较的对象(见表 [8-1](#Tab1) )。

表 8-1。

比较返回值

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

返回值

 | 

描述

 |
| --- | --- |
| 任何小于零的数字 | 在排序顺序中，此实例位于指定对象之前。 |
| 零 | 此实例等于指定的对象。 |
| 任何大于零的数字 | 在排序顺序中，此实例位于指定对象之后。 |

假设 C# `int`数据类型(这只是`System.Int32`的简写)实现了`IComparable`，那么您可以简化前面的`CompareTo()`实现。您可以如下实现`Car`的`CompareTo()`:

```cs
int IComparable.CompareTo(object obj)
{
  if (obj is Car temp)
  {
    return this.CarID.CompareTo(temp.CarID);
  }
  throw new ArgumentException("Parameter is not a Car!");
}

```

在这两种情况下，为了让您的`Car`类型理解如何将自己与相似的对象进行比较，您可以编写以下用户代码:

```cs
// Exercise the IComparable interface.
// Make an array of Car objects.
...
// Display current array.
Console.WriteLine("Here is the unordered set of cars:");
foreach(Car c in myAutos)
{
  Console.WriteLine("{0} {1}", c.CarID, c.PetName);
}

// Now, sort them using IComparable!
Array.Sort(myAutos);
Console.WriteLine();

// Display sorted array.
Console.WriteLine("Here is the ordered set of cars:");
foreach(Car c in myAutos)
{
  Console.WriteLine("{0} {1}", c.CarID, c.PetName);
}
Console.ReadLine();

```

下面是前面代码清单的输出:

```cs
***** Fun with Object Sorting *****
Here is the unordered set of cars:
1 Rusty
234 Mary
34 Viper
4 Mel
5 Chucky

Here is the ordered set of cars:
1 Rusty
4 Mel
5 Chucky
34 Viper
234 Mary

```

### 使用 IComparer 指定多个排序顺序

在这个版本的`Car`类型中，您使用汽车的 ID 作为排序顺序的基础。另一种设计可能使用汽车的昵称作为排序算法的基础(按字母顺序列出汽车)。现在，如果你想构建一个既可以通过 ID *排序又可以通过昵称*排序的`Car`会怎么样呢？如果这是您感兴趣的行为类型，您需要与另一个名为`IComparer`的标准接口交朋友，该接口在`System.Collections`名称空间中定义如下:

```cs
// A general way to compare two objects.
interface IComparer
{
  int Compare(object o1, object o2);
}

```

Note

这个接口的通用版本(`IComparer<T>`)提供了一种更加类型安全的方式来处理对象之间的比较。你将在第 10 章中研究泛型。

与`IComparable`接口不同，`IComparer`通常是*而不是*在您试图排序的类型(即`Car`)上实现的。相反，您可以在任意数量的助手类上实现这个接口，每个助手类对应一个排序顺序(昵称、汽车 ID 等)。).目前，`Car`型已经知道如何根据内部汽车 ID 与其他汽车进行比较。因此，允许对象用户按昵称对一组`Car`对象进行排序将需要一个额外的实现`IComparer`的助手类。下面是代码(确保在代码文件中导入`System.Collections`名称空间):

```cs
using System;
using System.Collections;

namespace ComparableCar
{
  // This helper class is used to sort an array of Cars by pet name.
  public class PetNameComparer : IComparer
  {
    // Test the pet name of each object.
    int IComparer.Compare(object o1, object o2)
    {
      if (o1 is Car t1 && o2 is Car t2)
      {
        return string.Compare(t1.PetName, t2.PetName,
          StringComparison.OrdinalIgnoreCase);
      }
      else
      {
        throw new ArgumentException("Parameter is not a Car!");
      }
    }
  }
}

```

对象用户代码可以使用这个助手类。`System.Array`有几个重载的`Sort()`方法，其中一个恰好接受一个实现`IComparer`的对象。

```cs
...
// Now sort by pet name.
Array.Sort(myAutos, new PetNameComparer());

// Dump sorted array.
Console.WriteLine("Ordering by pet name:");
foreach(Car c in myAutos)
{
  Console.WriteLine("{0} {1}", c.CarID, c.PetName);
}
...

```

### 自定义属性和自定义排序类型

值得指出的是，当按照特定的数据点对`Car`类型进行排序时，可以使用定制的静态属性来帮助对象用户。假设`Car`类已经添加了一个名为`SortByPetName`的静态只读属性，该属性返回实现`IComparer`接口的对象实例(在本例中为`PetNameComparer`);一定要导入`System.Collections`。

```cs
// We now support a custom property to return
// the correct IComparer interface.
public class Car : IComparable
{
...
  // Property to return the PetNameComparer.
  public static IComparer SortByPetName
    => (IComparer)new PetNameComparer();}

```

对象用户代码现在可以使用强关联属性按昵称排序，而不是“必须知道”才能使用独立的`PetNameComparer`类类型。

```cs
// Sorting by pet name made a bit cleaner.
Array.Sort(myAutos, Car.SortByPetName);

```

理想情况下，在这一点上，你不仅理解如何定义和实现你自己的接口，而且理解它们的有用性。可以肯定的是，每个专业都有接口。NET 核心命名空间，在本书的剩余部分，您将继续使用各种标准接口。

## 摘要

一个接口可以被定义为一个命名的*抽象成员*的集合。通常认为接口是一个给定类型可以支持的行为。当两个或多个类实现同一个接口时，即使类型是在唯一的类层次结构中定义的，也可以用相同的方式对待每种类型(基于接口的多态性)。

C# 提供了关键字`interface`来允许你定义一个新的接口。如您所见，使用逗号分隔的列表，一个类型可以支持任意多的接口。此外，允许构建从多个基本接口派生的接口。

除了构建自定义接口之外。NET 核心库定义了几个标准(即框架提供的)接口。正如您所看到的，您可以自由地构建实现这些预定义接口的自定义类型，以获得一些理想的特征，如克隆、排序和枚举。*