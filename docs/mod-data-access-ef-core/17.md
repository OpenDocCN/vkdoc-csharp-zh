# 17.性能调整

本章提供了使用实体框架核心加速数据库访问的指导。

## 实体框架核心中性能优化的过程模型

与经典的实体框架一样，以下用于优化数据库访问性能的流程模型已经在实体框架核心中得到证明:

*   第一步是使用实体框架核心和 LINQ 实现所有数据访问，除了`UPDATE`、`DELETE`和`INSERT`批量操作。批量操作直接使用 SQL 或批量插入。
*   然后用真实的数据集测试应用程序。速度太慢的地方，分三个阶段优化。
    *   在阶段 1 中，使用了实体框架核心中的技巧，例如无跟踪、缓存、分页、改变加载策略(例如，急切加载或预加载而不是显式加载)，以及减少往返次数。
    *   如果这还不够，在第 2 阶段，将检查 LINQ 命令，并替换为优化更好的 SQL 命令或其他数据库结构，如视图、存储过程或表值函数(tvf)。通过实体框架核心继续访问它们。
    *   只有在阶段 3 中，实体框架核心才被用于访问 SQL 命令、视图、存储过程和 tvf 的`DataReader`和`Command`对象所取代。

## 您自己的性能测试的最佳实践

如果您正在执行性能测试以检查不同替代方案的速度，请考虑以下事项:

*   不要在 Visual Studio 中运行性能测试。调试器和可能激活的 IntelliTrace 功能会以不同的方式降低程序代码的速度，这取决于过程，并且您不会收到绝对正确或按比例正确的结果。
*   不要在图形用户界面(GUI)应用程序中运行性能测试，也不要进行任何控制台输出。为性能测试编写一个控制台应用程序，但是不要将任何内容打印到控制台，并且不要将控制台输出的时间包括在您的度量中。
*   每个测试重复几次，至少十次，计算平均值。有许多因素会影响结果(例如。NET 垃圾收集和 Windows 分页文件)。
*   不要将第一次运行(冷启动)包括在平均值中。实体框架核心和数据库管理系统的额外任务必须在第一次运行时完成(例如，启动数据库、建立连接、生成映射代码等等),这会伪造您的结果。如果你想得到十个有效结果，就做十一次。
*   在不同的系统上测试远程数据库管理系统(除非您的解决方案确实使用本地数据库)。
*   确保测试机器在测试过程中不执行任何其他重要的进程，并且网络不明显活跃(当其他人都在家时运行测试，或者设置您自己的网络！).

## 中各种数据访问技术的性能比较。网

当开发实体框架核心时，微软的目标是平台独立性和在经典的 ADO.NET 实体框架上提高性能。本章涵盖了许多性能测试场景中的一个。

图 [17-1](#Fig1) 显示实体框架核心 1.1。无跟踪模式下的. NET Framework 4.7 几乎与手动映射的`DataReader`一样快(换句话说，从`DataReader`复制到. NET 对象:`obj.x = Convert (dr ["x"])`)。

![A461790_1_En_17_Fig1_HTML.jpg](A461790_1_En_17_Fig1_HTML.jpg)

图 17-1

Performance comparison of various data access techniques in .NET

和。NET Core 2.0，无论是手动映射还是实体框架核心都比。NET 框架 4.7。有趣的是，实体框架核心的无跟踪模式大大受益于。NET Core 2.0，相当于在。网芯 2.0。

同样在跟踪模式下，实体框架核心比 ADO.NET 实体框架 6.x 更快

最快的测量(22 毫秒。NET Framework 4.7 或 21 毫秒。NET Core 2.0)来自于一个`DataReader`，但是数据集没有被映射到对象。

请注意以下关于此测量场景的内容:

*   数据库服务器在 Windows Server 2016 上运行 Microsoft SQL Server 2016(虚拟化)。如果数据库服务器没有被虚拟化，或者至少可以使用非虚拟化的硬盘空间，那么它的性能会更好。
*   客户端是 Windows 10 机器。
*   两台计算机通过 1GB 以太网连接。
*   执行的命令是一个简单的`SELECT`，没有连接或聚合操作符。
*   加载了 10，000 条记录。
*   结果记录由单个表中的 13 列组成。
*   数据类型有`int`、`smallint`、`nvarchar(30)`、`nvarchar(max)`、`bit`和`timestamp`。
*   显示的值是 100 次重复的平均值。
*   每种技术(冷启动)的第一次访问不包括在平均值中。

Note

当然，这只是众多可能的对比场景之一。由于性能取决于硬件、操作系统、软件版本，尤其是数据库模式，因此在这一点上记录进一步的性能比较没有意义。无论如何，您必须在您的特定场景中衡量性能。

## 优化对象分配

要分配相关对象，实体框架核心为您提供了两个选项。

*   通过对象引用的赋值(清单 [17-1](#Par34)
*   通过外键属性的赋值(清单 [17-2](#Par35)

```cs
  public static void ChangePilotUsingObjectAssignment()
  {
   CUI.Headline(nameof(ChangePilotUsingObjectAssignment));
   var flightNo = 102;
   var newPilotID = 123;

   using (var ctx = new WWWingsContext())
   {
    ctx.Log();
    Flight flight = ctx.FlightSet.Find(flightNo);
    Pilot newPilot = ctx.PilotSet.Find(newPilotID);
    flight.Pilot = newPilot;
    var count = ctx.SaveChanges();
    Console.WriteLine("Number of saved changes: " + count);
   }
  }

Listing 17-1Assignment via an Object Reference

```

```cs
  public static void ChangePilotUsingFK()
  {
   CUI.Headline(nameof(ChangePilotUsingFK));
   var flightNo = 102;
   var newPilotID = 123;

   using (var ctx = new WWWingsContext())
   {
    ctx.Log();
    Flight flight = ctx.FlightSet.Find(flightNo);
    flight.PilotId = newPilotID;
    var count = ctx.SaveChanges();
    Console.WriteLine("Number of saved changes: " + count);
   }

  }

Listing 17-2Assignment via a Foreign Key Property

```

使用外键属性会更有效一些，因为不必显式加载对象。实体框架核心发送给数据库的`UPDATE`命令在两种情况下看起来是一样的(见图 [17-2](#Fig2) )。

![A461790_1_En_17_Fig2_HTML.jpg](A461790_1_En_17_Fig2_HTML.jpg)

图 17-2

Output of Listing [17-2](#Par35)

如果要分配的对象已经在 RAM 中，您可以在两种语法形式之间进行选择。但是如果在 RAM 中只有要分配的对象的主键值，那么应该使用外键属性。这种情况在 web 应用程序和 web 服务中很常见，因为客户端只获得主键值。

Tip

外键属性在实体框架核心中是可选的。然而，赋值中的优化选项是除了实体类中的导航属性之外，还应该实现外键属性的一个很好的理由！

虽然没有外键属性，但是您可以通过使用实体框架核心中外键列的 shadow 属性来绕过加载对象(参见清单 [17-3](#Par40) )。然而，这个过程的缺点是外键列的名称必须在程序代码中作为字符串使用，这在输入时更麻烦，也更容易出错。

```cs
  public static void ChangePilotUsingFKShadowProperty()
  {
   CUI.Headline(nameof(ChangePilotUsingFKShadowProperty));
   var flightNo = 102;
   var neuerPilotNr = 123;
   using (var ctx = new WWWingsContext())
   {
    ctx.Log();
    Flight flight = ctx.FlightSet.Find(flightNo);
    ctx.Entry(flight).Property("PilotId").CurrentValue = neuerPilotNr;
    var count = ctx.SaveChanges();
    Console.WriteLine("Number of saved changes: " + count);
   }
  }
Listing 17-3Assignment via the Shadow Key Property of the Foreign Key Column

```

## 批量操作

Entity Framework Core 在其默认配置中不支持对多条记录进行批量操作，而是单独处理每条记录以进行删除和修改。本章讨论了对 1，000 条记录使用删除命令(`DELETE`)的主题。该信息也适用于使用`UPDATE`的批量数据变更。

### 单次删除

清单 [17-4](#Par44) 显示了一种从`Flight`表中删除主键的值大于 20，000 的所有记录的低效方法。必须首先将所有记录加载并具体化到。NET 对象。每个。然后，使用`Remove()`方法将. NET 对象标记为删除，当对每个对象执行`SaveChanges()`方法时，删除最终被实体框架核心上下文转换为`DELETE`命令。

所以，如果要删除 1000 个航班，就需要 1001 个命令(1 个`SELECT`和 1000 个`DELETE`命令)。在实现中，1000 个`DELETE`命令，一次一个，被发送到数据库管理系统，因为`SaveChanges()`方法出现在循环中每个单独的`Remove()`之后。

```cs
  public static void BulkDeleteEFCAPIwithoutBatching()
  {
   CUI.Headline(nameof(BulkDeleteEFCAPIwithoutBatching));
   var sw = new Stopwatch();
   sw.Start();
   int total = 0;
   using (var ctx = new WWWingsContext())
   {
    var min = 20000;
    var flightSet = ctx.FlightSet.Where(x => x.FlightNo >= min).ToList();
    foreach (Flight f in flightSet)
    {
     ctx.FlightSet.Remove(f);
     var count = ctx.SaveChanges();
     total += count;
    }
   }
   sw.Stop();
   Console.WriteLine("Number of DELETE statements: " + total);
   Console.WriteLine("Duration: " + sw.ElapsedMilliseconds);
  }
Listing 17-4Bulk Clear Without Batching with the Entity Framework Core API

```

### 批处理优化

在经典的实体框架中，在每个`Remove()`之后`SaveChanges()`是在循环中还是在循环之外并不重要。旧的 OR 映射器总是一次一个地将每个`DELETE`命令传输到数据库管理系统。在实体框架核心中，有批处理(见第[章第 10 节](10.html))来缓解这个问题。

清单 [17-5](#Par47) ，它在最后只执行`SaveChanges()`一次，因此不会导致 1000 次`DELETE`到数据库管理系统的往返，而是只有一次(见图 [17-3](#Fig3) )。总共只剩下两个往返行程(一个用于加载`SELECT`，一个用于 1000 个`DELETE`命令)。执行时间显著减少(见表 [17-1](#Tab1) )。

表 17-1

Execution Time

<colgroup><col align="left"> <col align="left"> <col align="left"></colgroup> 
| 方法 | 往返次数 | 执行时间 |
| :-- | :-- | :-- |
| 批量删除 1，000 条`Flight`记录，无需使用实体框架核心 API 进行批处理 | One thousand and one | 11110 秒 |
| 使用实体框架核心 API 批量删除 1，000 条`Flight`记录 | Two | 3395 秒 |

![A461790_1_En_17_Fig3_HTML.jpg](A461790_1_En_17_Fig3_HTML.jpg)

图 17-3

Here, 1,000 delete commands are transferred in one round-trip to the database management system

```cs
public static void BulkDeleteEFCAPIwithBatching()
{
 CUI.Headline(nameof(BulkDeleteEFCAPIwithBatching));
 int total = 0;
 var sw = new Stopwatch();
 sw.Start();
 using (var ctx = new WWWingsContext())
 {
  var min = 20000;
  var flightSet = ctx.FlightSet.Where(x => x.FlightNo >= min).ToList();
  foreach (Flight f in flightSet)
  {
   ctx.FlightSet.Remove(f);
  }
  total = ctx.SaveChanges();
 }
 sw.Stop();
 Console.WriteLine("Number of DELETE statements: " + total);
 Console.WriteLine("Duration: " + sw.ElapsedMilliseconds);
}
Listing 17-5Bulk Deleting Batching with the Entity Framework Core API

```

### 删除而不加载伪对象

即使使用批处理，这种操作仍然是低效的，因为最初所有记录都是在删除后才加载的。运行实体框架时，核心需要一个实体对象。

这里有一个技巧，在 RAM 中手动构造这样一个实体对象作为伪对象，并将其作为参数传递给`Remove()`(参见清单 [17-6](#Par52) )。这显著提高了性能(见表 [17-2](#Tab2) )。然而，这只有在以下两种情况下才有可能:

*   要删除的对象的主键是已知的。
*   没有通过`[ConcurrencyCheck]`运行的并发检查，没有`IsConcurrencyToken()`方法，也没有时间戳列。

```cs
public static void BulkDeleteEFCAPIusingPseudoObject()
{
 CUI.Headline(nameof(BulkDeleteEFCAPIusingPseudoObject));
 int total = 0;
 var sw = new Stopwatch();
 sw.Start();
 using (var ctx = new WWWingsContext())
 {
  for (int i = 20001; i < 21000; i++)
  {
   var f = new Flight() { FlightNo = i };
   ctx.FlightSet.Attach(f);
   ctx.FlightSet.Remove(f);
  }
 total = ctx.SaveChanges();
 }
 sw.Stop();
 Console.WriteLine("Number of DELETE statements: " + total);
 Console.WriteLine("Duration: " + sw.ElapsedMilliseconds);
}
Listing 17-6Bulk Deleting Batching with Entity Framework Core API Using Pseudo-Objects

```

表 17-2

Execution Time

<colgroup><col align="left"> <col align="left"> <col align="left"></colgroup> 
| 方法 | 往返次数 | 执行时间 |
| :-- | :-- | :-- |
| 批量删除 1，000 条`Flight`记录，无需使用实体框架核心 API 进行批处理 | One thousand and one | 11110 秒 |
| 使用实体框架核心 API 批量删除 1，000 条`Flight`记录 | Two | 3395 秒 |
| 使用伪对象通过实体框架核心 API 批量删除 1，000 条`Flight`记录 | one | 0.157 秒 |

### 使用经典 SQL 代替实体框架核心 API

通过迄今为止采取的措施，执行时间已经大大缩短，但时间仍然比必要的长得多。这里不使用实体框架核心 API，在要删除一组连续记录的情况下，发出一个简单的经典 SQL 命令要有效得多。

```cs
DELETE dbo.Flight where FlightNo >= 20000

```

您可以通过带有`Parameter`对象的 ADO.NET 命令以传统方式设置这个 SQL 命令(参见清单 [17-7](#Par52) )，或者更简洁地通过实体框架核心中的直接 SQL 支持(参见清单 [17-8](#Par52) )使用实体框架核心上下文的`Database`子对象中的`ExecuteSqlCommand()`方法来设置这个 SQL 命令。应该强调的是，基于`string.Format()`的通配符语法可以防止 SQL 注入攻击，如清单 [17-7](#Par58) 中的参数化所示。这里，字符串不是简单地放在一起，如语法所示，而是在内部生成 SQL 参数对象。

在这两种情况下，执行时间都减少到不到 40 ms，这并不奇怪，因为程序现在只需要建立一个数据库连接和传输一些字符。无法测量通过实体框架核心上下文或`Command`对象的传输之间的性能差异。

当然，这种方法的缺点是再次使用 SQL 字符串，对此没有编译器检查，因此存在语法和类型错误的风险，直到运行时才被注意到。

<colgroup><col align="left"> <col align="left"> <col align="left"></colgroup> 
| 方法 | 往返次数 | 执行时间 |
| :-- | :-- | :-- |
| 批量删除 1，000 条`Flight`记录，无需使用实体框架核心 API 进行批处理 | One thousand and one | 11110 秒 |
| 使用实体框架核心 API 批量删除 1，000 条`Flight`记录 | Two | 3395 秒 |
| 使用伪对象通过实体框架核心 API 批量删除 1，000 条`Flight`记录 | one | 0.157 秒 |
| 通过实体框架上下文使用 SQL 批量删除 1，000 条`Flight`记录 | one | 0.034 秒 |
| 通过带有参数的 ADO.NET 命令对象使用 SQL 批量删除 1000 条`Flight`记录 | one | 0.034 秒 |

```cs
public static void BulkDeleteADONETCommand()
  {
   CUI.Headline(nameof(BulkDeleteADONETCommand));
   int total = 0;
   var min = 20000;
   var sw = new Stopwatch();
   sw.Start();
   using (SqlConnection connection = new SqlConnection(Program.CONNSTRING))
   {
    connection.Open();
    SqlCommand command = new SqlCommand("DELETE dbo.Flight where FlightNo >= @min", connection);
    command.Parameters.Add(new SqlParameter("@min", min));
    total = command.ExecuteNonQuery();
   }
   sw.Stop();
   Console.WriteLine("Number of DELETE statements: " + total);
   Console.WriteLine("Duration: " + sw.ElapsedMilliseconds);
  }
Listing 17-7Bulk Delete with SQL via ADO.NET Command Object with a Parameter

```

```cs
public static void BulkDeleteEFCSQL()
{
 CUI.Headline(nameof(BulkDeleteEFCSQL));
 int total = 0;
 var min = 20000;
 var sw = new Stopwatch();
 sw.Start();
 using (var ctx = new WWWingsContext())
 {
  total = ctx.Database.ExecuteSqlCommand("DELETE dbo.Flight where FlightNo >= {0}", min);
 }
 sw.Stop();
 Console.WriteLine("Number of DELETE statements: " + total);
 Console.WriteLine("Duration: " + sw.ElapsedMilliseconds);
}
Listing 17-8Bulk Erase with SQL via Entity Framework Core Context

```

### 使用 EFPlus 进行质量删除的 Lambda 表达式

扩展组件 EFPlus(参见第 [20 章](20.html))允许基于 LINQ 命令在 lambda 表达式中公式化`UPDATE`和`DELETE`命令，这样可以避免容易出错的 SQL。

EFPlus 组件实现了名为`Update()`和`Delete()`的扩展方法。要实现这一点，使用`Z.EntityFramework.Plus`是必要的。

清单 [17-9](#Par63) 展示了如何在 LINQ 命令中使用`Delete()`。不幸的是，如图 [17-4](#Fig4) 所示，EFPlus 生成的 SQL 命令并不理想。他们总是使用嵌套的`SELECT`，尽管这不是必须的。从 EFPlus 作者的角度来看，这是最简单的实现，因为很容易使用现有的`SELECT`命令生成实体框架核心。执行结果与使用直接 SQL 命令的结果相同(见表 [17-3](#Tab3) )。

表 17-3

Execution Time

<colgroup><col align="left"> <col align="left"> <col align="left"></colgroup> 
| 方法 | 往返次数 | 执行时间 |
| :-- | :-- | :-- |
| 批量删除 1，000 条`Flight`记录，无需使用实体框架核心 API 进行批处理 | One thousand and one | 11110 秒 |
| 使用实体框架核心 API 批量删除 1，000 条`Flight`记录 | Two | 3395 秒 |
| 使用伪对象通过实体框架核心 API 批量删除 1，000 条`Flight`记录 | one | 157 秒 |
| 通过实体框架上下文使用 SQL 批量删除 1，000 条`Flight`记录 | one | 34 秒 |
| 通过带有参数的 ADO.NET 命令对象使用 SQL 批量删除 1000 条`Flight`记录 | one | 34 秒 |
| 使用 EFPlus 批量删除 1，000 条`Flight`记录 | one | 45 秒 |

![A461790_1_En_17_Fig4_HTML.jpg](A461790_1_En_17_Fig4_HTML.jpg)

图 17-4

SQL DELETE command that EFPlus sends to the database management system

```cs
public static void BulkDeleteEFPlus()
{
 CUI.Headline(nameof(BulkDeleteEFPlus));
 int min = 20000;
 int total = 0;
 var sw = new Stopwatch();
 sw.Start();
 using (var ctx = new WWWingsContext())
 {
  var count = ctx.FlightSet.Where(x => x.FlightNo >= min).Delete();
  Console.WriteLine("Number of DELETE statements: " + count);
 }
 sw.Stop();
 Console.WriteLine("Duration: " + sw.ElapsedMilliseconds);
 Timer_BulkDeleteEFPlus += sw.ElapsedMilliseconds;
}
Listing 17-9Mass Deletion with EFPlus

```

### 使用 EFPlus 批量更新

清单 [17-10](#Par65) 显示了使用扩展方法`Update()`的附加组件 EFPlus(参见第 [20 章](20.html))制定的`UPDATE`命令，该命令将从柏林出发的未来航班的免费座位数减少一个。图 [17-5](#Fig5) 显示了发送到数据库管理系统的 SQL `UPDATE`命令，其工作方式与`Delete()`相同。

![A461790_1_En_17_Fig5_HTML.jpg](A461790_1_En_17_Fig5_HTML.jpg)

图 17-5

SQL UPDATE command that EFPlus sends to the database management system

```cs
public static void BulkUpdateEFPlus()
{
 CUI.Headline(nameof(BulkUpdateEFPlus));
 using (var ctx = new WWWingsContext())
 {
  var count = ctx.FlightSet.Where(x => x.Departure == "Berlin" && x.Date >= DateTime.Now).Update(x => new Flight() { FreeSeats = (short)(x.FreeSeats - 1) });
  Console.WriteLine("Changed records: " + count);
 }
}
Listing 17-10Bulk Update with EFPlus

```

## 通过无跟踪实现性能优化

与它的前身 ADO.NET 实体框架一样，实体框架核心具有无跟踪模式，这大大加快了数据记录的加载速度。在新的实现中，微软通过添加上下文选项改进了该功能的实际应用。

图 [17-6](#Fig6) 中的性能测量显示，可选的无跟踪模式比标准跟踪模式提供了显著的速度优势——在传统的 ADO.NET 实体框架和新的实体框架核心中都是如此。在无跟踪模式下，实体框架核心可以在 46 毫秒内通过网络获取 10，000 条记录(来自一个表的 13 列，无连接、`int`、`smallint`、`nvarchar(30)`、`nvarchar (max)`、`bit`、`timestamp)`，并将它们在 RAM 中具体化为对象。这几乎和手动映射的 ADO.NET`DataReader`一样快(比如`obj.Name = Convert.ToString(dataReader["name"])`这样的自写代码行)。在正常跟踪模式下，读取记录需要两倍多一点的时间(100 毫秒)。

![A461790_1_En_17_Fig6_HTML.jpg](A461790_1_En_17_Fig6_HTML.jpg)

图 17-6

Performance comparison

相比之下，图 [17-6](#Fig6) 也显示了 Entity Framework 6.x，这里在跟踪模式下需要 263 ms。在 53 毫秒时，与非跟踪模式下的实体框架核心相比，只有微小的差异。微软因此相对于 Entity Framework 6.1.3 加速了 Entity Framework Core，尤其是跟踪模式。尽管如此，实体框架核心中的无跟踪模式也有好处。

### 激活无跟踪模式

在经典实体框架的第一个版本中，您必须使用属性`MergeOption`为每个实体类或每个查询设置无跟踪模式，并附加一行代码。从 Entity Framework 4.1 开始，您可以使用更加优雅的`AsNoTracking()`扩展方法在查询级别设置模式(参见清单 [17-11](#Par70) )。在实体框架核心中，只有`AsNoTracking()`用于此。

```cs
   CUI.Headline("No-Tracking mode");
   using (WWWingsContext ctx = new WWWingsContext())
   {
    var flightSet = ctx.FlightSet.AsNoTracking().ToList();
    var flight = flightSet[0];
    Console.WriteLine(flight + " object state: " + ctx.Entry(flight).State); // Detached
    flight.FreeSeats--;
    Console.WriteLine(flight + " object state: " + ctx.Entry(flight).State); // Detached
    int count = ctx.SaveChanges();
    Console.WriteLine($"Saved changes: {count}"); // 0
   }
Listing 17-11Activation of No-Tracking Mode with AsNoTracking( ) in Entity Framework 6.x and Entity Framework Core

```

无跟踪模式的结果如图 [17-7](#Fig7) 所示，输出列表 [17-11](#Par70) 。如果激活非跟踪模式，实体框架核心的更改跟踪功能将不再有效。在默认情况下，对象在加载后处于状态`Unchanged`，并且它们在改变后改变到状态`Modified`。当在无跟踪模式下加载时，它们在加载后是`Detached`，并且即使在改变后也保持如此。然后，`SaveChanges()`方法的执行不向数据库管理系统发送任何改变，因为实体框架核心没有注意到该改变。

![A461790_1_En_17_Fig7_HTML.jpg](A461790_1_En_17_Fig7_HTML.jpg)

图 17-7

Screen output from Listing [17-11](#Par70)

### 无跟踪模式几乎总是可行的

在任何情况下，不跟踪模式应该总是用于只显示数据的对象，不应该进行任何修改。但是，即使您想要修改单个对象，您也可以首先以非跟踪模式加载对象，然后再将它们附加到上下文类。因此，您只需更改对象——最好是在更改之前——并使用`Attach()`方法将它们添加到上下文中。这个方法同时存在于`DbContext`类和`dbSet<T>`类中。

`Attach()`方法将一个对象添加到实体框架核心变更跟踪中。物体由此从状态`Detached`转移到状态`Unchanged`。当然，只有实体类的实例可以传递给`Attach()`。如果您传递实体框架核心上下文不知道的类的实例，您将得到下面的错误消息:“找不到实体类型 xy。请确保该实体类型已添加到模型中。

清单 [17-12](#Par78) (以及图 [17-8](#Fig8) 中附带的屏幕输出)显示了`Attach()`方法在这三个场景中的使用:

*   `Attach()`是在实际变更之前执行的。在这种情况下，没有其他事情要做，因为实体框架核心识别出`Attach()`之后的所有变化，并将对象独立地从状态`Unchanged`转移到状态`Modified`。
*   如果在执行`Attach()`之前发生了变化，那么实体框架核心对发生的变化一无所知。因此，您必须随后向`ctx.Entry(obj).Property (f => f.Property).IsModified = true`登记变更。
*   如果您不知道对象的已更改属性(例如，因为更改发生在调用程序代码或另一个进程中)，或者将单个属性设置为`IsModified`太麻烦，您可以使用`ctx.Entry(Flight).State = EntityState.Modified`来设置整个对象的状态。

```cs
  public static void TrackingMode_NoTracking_Attach()
  {

   CUI.MainHeadline(nameof(TrackingMode_NoTracking_Attach));

   CUI.Headline("Attach() before change");

   using (WWWingsContext ctx = new WWWingsContext())
   {
    var flightSet = ctx.FlightSet.AsNoTracking().ToList();
    var flight = flightSet[0];
    Console.WriteLine(flight + " object state: " + ctx.Entry(flight).State); // Detached
    ctx.Attach(flight);
    Console.WriteLine(flight + " object state: " + ctx.Entry(flight).State); // Unchanged
    flight.FreeSeats--;
    Console.WriteLine(flight + " object state: " + ctx.Entry(flight).State); // Modified
    int count = ctx.SaveChanges();
    Console.WriteLine($"Saved changes: {count}"); // 0
   }

   CUI.Headline("Attach() after change (change state per property)");
   using (WWWingsContext ctx = new WWWingsContext())
   {
    var flightSet = ctx.FlightSet.AsNoTracking().ToList();
    var flight = flightSet[0];
    Console.WriteLine(flight + " object state: " + ctx.Entry(flight).State); // Detached
    flight.FreeSeats--;
    Console.WriteLine(flight + " object state: " + ctx.Entry(flight).State); // Detached
    ctx.Attach(flight);
    Console.WriteLine(flight + " object state: " + ctx.Entry(flight).State); // Unchanged
    // Register changed property at EFC
    ctx.Entry(flight).Property(f => f.FreeSeats).IsModified = true;
    Console.WriteLine(flight + " object state: " + ctx.Entry(flight).State); // Modified
    int count = ctx.SaveChanges();
    Console.WriteLine($"Saved changes: {count}"); // 1
   }

   CUI.Headline("Attach() after change (change state per object)");
   using (WWWingsContext ctx = new WWWingsContext())
   {
    var flightSet = ctx.FlightSet.AsNoTracking().ToList();
    var flight = flightSet[0];
    Console.WriteLine(flight + " object state: " + ctx.Entry(flight).State); // Detached
    flight.FreeSeats--;
    Console.WriteLine(flight + " object state: " + ctx.Entry(flight).State); // Detached
    ctx.Attach(flight);
    Console.WriteLine(flight + " object state: " + ctx.Entry(flight).State); // Unchanged
    ctx.Entry(flight).State = EntityState.Modified;
    Console.WriteLine(flight + " object state: " + ctx.Entry(flight).State); // Modified
    int count = ctx.SaveChanges();
    Console.WriteLine($"Saved changes: {count}"); // 1
   }

  }

Listing 17-12Using the Attach( ) Method

```

如图 [17-8](#Fig8) 所示，在所有三种情况下，`SaveChanges()`都会保存更改。然而，在幕后，这三个场景是有区别的。在前两个场景中，实体框架核心向数据库发送一个 SQL `UPDATE`命令，该命令只更新实际的`Free Spend`列。

```cs
exec sp_executesql N'SET NOCOUNT ON;
UPDATE [Flight] SET [FreeSeats] = @p0
WHERE [FlightNo] = @p1;

```

![A461790_1_En_17_Fig8_HTML.jpg](A461790_1_En_17_Fig8_HTML.jpg)

图 17-8

Output from Listing [17-12](#Par78)

然而，在第三个场景中，开发人员没有给出核心实体框架关于哪些属性实际上发生了变化的信息。实体框架核心不得不将所有属性的值发送回数据库，即使这些值在那里已经是已知的。

```cs
UPDATE [Flight] SET [AircraftTypeID] = @p0, [AirlineCode] = @p1, [CopilotId] = @p2, [FlightDate] = @p3, [Departure] = @p4, [Destination] = @p5, [FreeSeats] = @p6, [LastChange] = @p7, [Memo] = @p8, [NonSmokingFlight] = @p9, [PilotId] = @p10, [Price] = @p11, [Seats] = @p12, [Strikebound] = @p13
WHERE [FlightNo] = @p14 AND [Timestamp] = @p15;
SELECT [Timestamp], [Utilization]
FROM [Flight]
WHERE @@ROWCOUNT = 1 AND [FlightNo] = @p14;

```

Note

除了通过线路发送不必要的数据这一事实之外，更新所有列还会造成潜在的数据更改冲突。如果其他进程已经更改了部分记录，这些更改将无情地覆盖其他进程。因此，您应该始终确保实体框架核心知道已更改的列。如果对象的修改发生在调用者的`Attach()`方法之前，那么调用者必须提供相应的关于改变的属性的元信息。

### 可编辑数据网格中的无跟踪模式

当使用方法`Attach()`时，您可以在无跟踪模式下加载几乎所有的记录。图 [17-9](#Fig9) 和图 [17-10](#Fig10) 显示了通常的数据网格场景。用户可以加载(更多)数据并更改任何数据集。然后通过单击保存来保存更改。(见图 [17-12](#Fig12) )。

![A461790_1_En_17_Fig10_HTML.jpg](A461790_1_En_17_Fig10_HTML.jpg)

图 17-10

10,000 records loaded in no-tracking mode in 96 milliseconds

![A461790_1_En_17_Fig9_HTML.jpg](A461790_1_En_17_Fig9_HTML.jpg)

图 17-9

10,000 records loaded in tracking mode in 174 milliseconds

在这种情况下，完全没有必要浪费加载时跟踪模式的额外时间。使用`Attach()`来记录用户在实体框架上下文中工作的单个记录就足够了(参见清单 [17-13](#Par87) )。微软为 Windows 演示基金会(WPF)提供的 DataGrid 控件使用了`BeginningEdit()`事件。在事件处理程序中，`Attach()`将分离的对象转移到一个附加的对象(见图 [17-11](#Fig11) )，从而将该对象注册为实体框架上下文变更跟踪的一部分。

然而，在用`AsNoTracking()`加载之后，用`Attach(). Attach()`在一个循环中附加所有对象花费每个对象不到一毫秒的时间并不是一个好主意。当您将单个对象附加到它时，这一点并不明显。但总的来说，这样一个循环比在跟踪模式下直接加载所有对象要慢。所以如果你确定所有的对象都必须被改变，你应该在加载的时候使用跟踪模式。

```cs
  /// <summary>
  /// Called when starting to editing a flight in the grid
  /// </summary>
  private void C_flightDataGrid_BeginningEdit(object sender, DataGridBeginningEditEventArgs e)
  {
   // Access to the current edited Flight
   var flight = (Flight)e.Row.Item;

   if (flight.FlightNo > 0) // important so that new flights are not added before filling
   {
    // Attach may only be done if the object is not already attached!
    if (!ctx.FlightSet.Local.Any(x => x.FlightNo == flight.FlightNo))
    {
     ctx.FlightSet.Attach(flight);
     SetStatus($"Flight {flight.FlightNo} can now be edited!");
    }
   }
  }

Listing 17-13Attaching an Object to the Context When the User Starts Editing

```

![A461790_1_En_17_Fig11_HTML.png](A461790_1_En_17_Fig11_HTML.png)

图 17-11

The developer logs the object to be changed in the DataGrid to Attach( ) at the Entity Framework context when the change begins Note

只有当对象尚未连接到上下文实例时，才能执行`Attach()`。否则，将会出现运行时错误。对象是否已经连接到上下文，您不能询问对象本身。然而，`DbSet<T>`类有一个名为`Local`的属性，它包含了实体框架核心的本地缓存中的所有对象。要查询这个缓存，请使用`ctx.FlightSet.Local.Any (x => x.FlightNo == flight.FlightNo)`。

Warning

属性`Local`有一个方法`Clear()`。正如您所料，这不仅会清空实体框架核心上下文的缓存，还会将其中包含的所有对象置于`Deleted`状态，这将在下一个`SaveChanges()`删除它们！要真正只从缓存中删除对象，您必须将对象单独设置为状态`Detached`，如下所示:

```cs
    foreach (var f in ctx.FlightSet.Local.ToList ())
    {
     ctx.Entry (f) .State = EntityState.Detached;
    }

```

![A461790_1_En_17_Fig12_HTML.jpg](A461790_1_En_17_Fig12_HTML.jpg)

图 17-12

Saving changes although loaded in no-tracking mode

清单 [17-14](#Par92) 和清单 [17-15](#Par93) 显示了 XAML 代码和完整的代码隐藏类。

```cs
<Window x:Class="GUI.WPF.FlightGridNoTracking"
        xmlns:="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:GUI.WPF"
        xmlns:wpf="clr-namespace:ITVisions.WPF;assembly=ITV_DemoUtil"
        mc:Ignorable="d"
        Title="World Wide Wings - FlightGridNoTracking" Height="455.233" Width="634.884">

 <Window.Resources>
  <wpf:InverseBooleanConverter x:Key="InverseBooleanConverter"></wpf:InverseBooleanConverter>
 </Window.Resources>

 <Grid x:Name="LayoutRoot" Background="White">
  <DockPanel>

   <!--===================== Command Bar->
   <StackPanel Orientation="Horizontal" DockPanel.Dock="Top">
    <ComboBox Width="100" x:Name="C_City" ItemsSource="{Binding}">
     <ComboBoxItem  Content="All" IsSelected="True" />
     <ComboBoxItem  Content="Rome" />
     <ComboBoxItem Content="Paris" />
     <ComboBoxItem Content="New York/JFC" />
     <ComboBoxItem Content="Berlin" />
    </ComboBox>
    <ComboBox Width="100" x:Name="C_Count" >
     <ComboBoxItem Content="10" IsSelected="True" />
     <ComboBoxItem Content="100" IsSelected="True" />
     <ComboBoxItem Content="1000" IsSelected="True" />
     <ComboBoxItem Content="All" IsSelected="True" />
    </ComboBox>
    <ComboBox Width="100" x:Name="C_Mode" >
     <ComboBoxItem Content="Tracking" IsSelected="True" />
     <ComboBoxItem Content="NoTracking" IsSelected="False" />
    </ComboBox>
    <Button Width="100" x:Name="C_Test" Content="Test Connection" Click="C_Test_Click" ></Button>
    <Button Width="100" x:Name="C_Load" Content="Load" Click="C_Load_Click"></Button>
    <Button Width="100" x:Name="C_Save" Content="Save" Click="C_Save_Click"></Button>
   </StackPanel>
   <!-===================== Status Bar->
   <StatusBar DockPanel.Dock="Bottom">
    <Label x:Name="C_Status"></Label>
   </StatusBar>
   <!-===================== Datagrid->
   <DataGrid Name="C_flightDataGrid" AutoGenerateColumns="False" EnableRowVirtualization="True"  IsSynchronizedWithCurrentItem="True"  SelectedIndex="0" Height="Auto" BeginningEdit="C_flightDataGrid_BeginningEdit"  PreviewKeyDown="C_flightDataGrid_PreviewKeyDown" RowEditEnding="C_flightDataGrid_RowEditEnding">
    <DataGrid.Columns>
     <DataGridTextColumn Binding="{Binding Path=FlightNo}" Header="Flight No" Width="SizeToHeader" />
     <DataGridTextColumn Binding="{Binding Path=Departure}" Header="Departure" Width="SizeToHeader" />
     <DataGridTextColumn Binding="{Binding Path=Destination}" Header="Destination" Width="SizeToHeader" />
     <DataGridTextColumn Binding="{Binding Path=Seats}" Header="Seats" Width="SizeToHeader" />
     <DataGridTextColumn Binding="{Binding Path=FreeSeats}" Header="Free Seats" Width="SizeToHeader" />
     <DataGridCheckBoxColumn Binding="{Binding Path=NonSmokingFlight, Converter={StaticResource InverseBooleanConverter}}" Header="Non Smoking Flight" Width="SizeToHeader" />
     <DataGridTemplateColumn Header="Date" Width="100">
      <DataGridTemplateColumn.CellTemplate>
       <DataTemplate>
        <DatePicker SelectedDate="{Binding Path=Date}" />
       </DataTemplate>
      </DataGridTemplateColumn.CellTemplate>
     </DataGridTemplateColumn>
     <DataGridTextColumn Binding="{Binding Path=Memo}" Width="200" Header="Memo"  />
    </DataGrid.Columns>
   </DataGrid>

  </DockPanel>
 </Grid>
</Window>

Listing 17-14XAML Code FlightGridNoTracking.xaml (Project EFC_GUI)

```

```cs
using BO;
using DA;
using Microsoft.EntityFrameworkCore;
using System;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;

namespace GUI.WPF
{

 public partial class FlightGridNoTracking : Window
 {

  public FlightGridNoTracking()
  {
   InitializeComponent();
   this.Title = this.Title + "- Version: " + Assembly.GetExecutingAssembly().GetName().Version.ToString();
  }

  private void SetStatus(string s)
  {
   this.C_Status.Content = s;
  }

  WWWingsContext ctx;

  /// <summary>
  /// Load flights
  /// </summary>
  private void C_Load_Click(object sender, RoutedEventArgs e)
  {
   ctx = new WWWingsContext();
   // Clear grid
   this.C_flightDataGrid.ItemsSource = null;
   // Get departure
   string Ort = this.C_City.Text.ToString();
   // Show status
   SetStatus("Loading with " + this.C_Mode.Text + "...");

   // Prepare query
   var q = ctx.FlightSet.AsQueryable();
   if (this.C_Mode.Text == "NoTracking") q = q.AsNoTracking();
   if (Ort != "All") q = (from f in q where f.Departure == Ort select f);

   if (Int32.TryParse(this.C_Count.Text, out int count))
   {
    if (count>0) q = q.Take(count);
   }

   var sw = new Stopwatch();
   sw.Start();
   // Execute query
   var fluege = q.ToList();
   sw.Stop();

   // Databinding to grid
   this.C_flightDataGrid.ItemsSource = fluege; // Local is empty at NoTracking;

   // set state
   SetStatus(fluege.Count() + " loaded records using " + this.C_Mode.Text + ": " + sw.ElapsedMilliseconds + "ms!");
  }

  /// <summary>
  /// Save the changed flights
  /// </summary>
  private void C_Save_Click(object sender, RoutedEventArgs e)
  {
   // Get changes and ask
   var added = from x in ctx.ChangeTracker.Entries() where x.State == EntityState.Added select x;
   var del = from x in ctx.ChangeTracker.Entries() where x.State == EntityState.Deleted select x;
   var mod = from x in ctx.ChangeTracker.Entries() where x.State == EntityState.Modified select x;

   if (MessageBox.Show("Do you want to save the following changes?\n" + String.Format("Client: Changed: {0} New: {1} Deleted: {2}", mod.Count(), added.Count(), del.Count()), "Confirmation", MessageBoxButton.YesNo) == MessageBoxResult.No) return;

   string Ergebnis = "";

   // Save
   Ergebnis = ctx.SaveChanges().ToString();

   // Show status
   SetStatus("Number of saved changes: " + Ergebnis);
  }

  /// <summary>
  /// Called when starting to editing a flight in the grid
  /// </summary>
  private void C_flightDataGrid_BeginningEdit(object sender, DataGridBeginningEditEventArgs e)
  {
   // Access to the current edited Flight
   var flight = (Flight)e.Row.Item;

   if (flight.FlightNo > 0) // important so that new flights are not added before filling
   {
    // Attach may only be done if the object is not already attached!
    if (!ctx.FlightSet.Local.Any(x => x.FlightNo == flight.FlightNo))
    {
     ctx.FlightSet.Attach(flight);
     SetStatus($"Flight {flight.FlightNo} can now be edited!");
    }
   }
  }

  /// <summary>
  /// Called when deleting a flight in the grid
  /// </summary>
  private void C_flightDataGrid_PreviewKeyDown(object sender, KeyEventArgs e)
  {
   var flight = (Flight)((DataGrid)sender).CurrentItem;

   if (e.Key == Key.Delete)
   {
    // Attach may only be done if the object is not already attached!
    if (!ctx.FlightSet.Local.Any(x => x.FlightNo == flight.FlightNo))
    {
     ctx.FlightSet.Attach(flight);
    }

    ctx.FlightSet.Remove(flight);
    SetStatus($"Flight {flight.FlightNo} can be deleted!");
   }
  }

  /// <summary>
  /// Called when adding a flight in the grid
  /// </summary>
  private void C_flightDataGrid_RowEditEnding(object sender, DataGridRowEditEndingEventArgs e)
  {
   var flight = (Flight)e.Row.Item;
   if (!ctx.FlightSet.Local.Any(x => x.FlightNo == flight.FlightNo))
   {
    ctx.FlightSet.Add(flight);
    SetStatus($"Flight {flight.FlightNo} has bee added!");
   }
  }

  private void C_Test_Click(object sender, RoutedEventArgs e)
  {
   try
   {
    ctx = new WWWingsContext();
    var flight = ctx.FlightSet.FirstOrDefault();
    if (flight == null) MessageBox.Show("No flights :-(", "Test Connection", MessageBoxButton.OK, MessageBoxImage.Warning);
    else MessageBox.Show("OK!", "Test Connection", MessageBoxButton.OK, MessageBoxImage.Information);
   }
   catch (Exception ex)
   {
    MessageBox.Show("Error: " + ex.ToString(), "Test Connection", MessageBoxButton.OK, MessageBoxImage.Error);
   }

  }
 }
}

Listing 17-15Code-Behind Class FlightGridNoTracking.cs (Project EFC_GUI)

```

### QueryTrackingBehavior 和 AsTracking()

当使用实体框架和实体框架核心数据集读取数据时，无跟踪模式显著提高了性能。您在前面的章节中已经看到，几乎应该总是使用无跟踪模式。不幸的是，在经典的实体框架中，您必须记住在每个查询中使用`AsNoTracking()`。这不仅令人讨厌，而且很容易忘记。在传统的实体框架中，您需要额外的解决方案，例如访问`DbSet<T>`的抽象，它每次都会自动启用无跟踪模式。

在实体框架核心中，微软引入了一个更优雅的解决方案:你可以将整个实体框架核心上下文置于无跟踪模式。子对象`ChangeTracker`的类`Microsoft.EntityFrameworkCore.DbContext`中有枚举属性`QueryTrackingBehavior`。默认设置为`QueryTrackingBehavior.TrackAll`；换句话说，跟踪被激活。但是，如果您将其更改为`QueryTrackingBehavior.NoTracking`，所有查询都将以无跟踪模式执行，即使没有`AsNoTracking()`扩展方法。为了在跟踪模式下执行单个查询，对于非跟踪基本模式有一个新的扩展方法`AsTracking()`(参见清单 [17-16](#Par96) )。图 [17-13](#Fig13) 显示了输出。

![A461790_1_En_17_Fig13_HTML.jpg](A461790_1_En_17_Fig13_HTML.jpg)

图 17-13

Output of Listing [17-16](#Par96)

```cs
  public static void TrackingMode_QueryTrackingBehavior()
  {

   CUI.MainHeadline("Default setting: TrackAll. Use AsNoTracking()");
   using (WWWingsContext ctx = new WWWingsContext())
   {
    ctx.ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.TrackAll; // Standard
    var flightSet = ctx.FlightSet.AsNoTracking().ToList();
    var flight = flightSet[0];
    Console.WriteLine(flight + " object state: " + ctx.Entry(flight).State); // Detached
    flight.FreeSeats-;
    Console.WriteLine(flight + " object state: " + ctx.Entry(flight).State); // Modified
    int count = ctx.SaveChanges();
    Console.WriteLine($"Saved changes: {count}"); // 0
   }

   CUI.MainHeadline("Default setting: NoTracking.");
   using (WWWingsContext ctx = new WWWingsContext())
   {
    ctx.ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking; // NoTracking
    var flightSet = ctx.FlightSet.ToList();
    var flight = flightSet[0];
    Console.WriteLine(flight + " object state: " + ctx.Entry(flight).State); // Unchanged
    flight.FreeSeats-;
    Console.WriteLine(flight + " object state: " + ctx.Entry(flight).State); // Modified
    int count = ctx.SaveChanges();
    Console.WriteLine($"Saved changes: {count}"); // 0
   }

   CUI.MainHeadline("Default setting: NoTracking. Use AsTracking()");
   using (WWWingsContext ctx = new WWWingsContext())
   {
    ctx.ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking; // NoTracking
    var flightSet = ctx.FlightSet.AsTracking().ToList();
    var flight = flightSet[0];
    Console.WriteLine(flight + " object state: " + ctx.Entry(flight).State); // Unchanged
    flight.FreeSeats-;
    Console.WriteLine(flight + " object state: " + ctx.Entry(flight).State); // Modified
    int count = ctx.SaveChanges();
    Console.WriteLine($"Saved changes: {count}"); // 1
   }

  }

Listing 17-16Setting QueryTrackingBehavior and Using AsTracking( )

```

### 无跟踪模式的后果

除了缺少更改跟踪之外，无跟踪模式还有其他后果，如下所示:

*   对象不会加载到实体框架核心的一级缓存中。当再次访问对象时(例如用`DbSet<T>.Find()`)，它总是被数据库管理系统加载。
*   没有关系修复。关系修复是实体框架核心的一个特性，如果根据数据库，两个独立加载的对象属于同一个对象，那么它会将这两个对象连接起来。例如，假设`Pilot` 123 已经被加载。`Flight` 101 现在被加载，并且在其外键关系中`Pilot`的值为 123。实体框架核心将连接 RAM 中的`Flight` 101 和`Pilot` 123，以便您可以从`Flight`导航到`Pilot`，并且对于双向导航，从`Pilot`导航到`Flight`。
*   延迟加载不支持无跟踪，但是无论如何，延迟加载目前在实体框架核心中是不可用的。

### 最佳实践

新的默认`QueryTrackingBehavior.NoTracking`和新的扩展方法`AsTracking()`是实体框架核心中有意义的添加。但是在实践中已经看到了许多表现不佳的实体框架/实体框架核心应用程序，对我来说这还不够。`QueryTrackingBehavior.NoTracking`应该是标准的，以便所有开发人员得到高性能的查询执行。目前，在以`QueryTrackingBehavior.TrackAll`为标准设置的实体框架核心中，每个开发人员仍然需要记住设置`QueryTrackingBehavior.NoTracking`。最好在上下文类本身的构造函数中这样做，结果是，您将不再有跟踪查询的开销！

## 选择最佳装载策略

第 [9](09.html) 章讨论了实体框架核心可用于相关主数据或详细数据的加载策略(显式重新加载、快速加载和预加载)。不幸的是，我不能笼统地说什么是最好的装载策略。它总是取决于具体情况，而针对您的具体情况的最佳加载策略只能通过性能测试根据具体情况来确定。然而，一些总括声明仍然是可能的。

基本上，建议不要将连接的数据记录作为一个整体加载，如果它们不是绝对必要的，而是仅在实际需要时加载连接的数据集。它取决于潜在连接和已连接数据集的数量，以确定急切加载是否值得。

如果您知道需要连接的数据(例如，在数据导出的上下文中)，您应该选择立即加载或预加载。与使用`Include()`的急切加载相比，所示的预加载技巧在许多情况下可以显著提高性能。

如果您不确切知道是否需要链接的数据，那么在延迟加载和急切加载之间的选择通常是在瘟疫和霍乱之间的选择。通过额外的服务器往返，重新加载减慢了所有的速度，但是急切的加载减慢了更大的结果集的速度。然而，在大多数情况下，往返次数的增加比更大的结果集更不利于性能。

如果您不确定，不要将延迟加载或急切加载绑定到代码中，而是允许在运行时通过配置来控制它。因此，应用程序的操作者可以随着数据量的增加并根据应用程序的典型用户行为来调整应用程序。

## 贮藏

web 和桌面应用程序都有经常使用但很少在数据存储中更新的数据。在这些情况下，在 RAM 中基于时间的数据缓存是有用的。经典。NET 从 4.0 版本开始就有了组件`System.Runtime.Caching.dll`。一个`System.Runtime.Caching`的前兆已经出现了。NET 1.0 在 ASP.NET 的名称空间`System.WebCaching`中`System.Web.dll`。组件`System.Runtime.Caching.dll`引进于。另一方面，NET 4.0 可以在所有类型的应用程序中使用。`System.Runtime.Caching`本质上只提供一种缓存:`MemoryCache`用于 RAM 缓存。通过从基类`ObjectCache`派生，您可以开发其他缓存方法(例如，在专用缓存服务器上或在文件系统中)。Windows Server 的`AppFabric`的缓存特性是另一个缓存选项，但它不是基于`System.Runtime.Caching`的。

Note

。NET Core 用 NuGet 包`Microsoft.Extensions.Caching.Memory`代替`System.Runtime.Caching`。但是，`System.Runtime.Caching`现在是的 Windows 兼容包的一部分。净芯( [`https://blogs.msdn.microsoft.com/dotnet/2017/11/16/announcing-the-windows-compatibility-pack`](https://blogs.msdn.microsoft.com/dotnet/2017/11/16/announcing-the-windows-compatibility-pack) `-for-net-core`)，也可用于。NET 核心。

### 超高速缓冲存储系统

清单 [17-17](#Par112) 展示了一个结合实体框架核心使用`MemoryCache`的例子。首先，`GetFlights1()`检查出发航班的列表是否已经在缓存中。如果列表不存在，所有相关的航班都将加载一个新的实体框架上下文实例。对于这个数据集，`GetFlights1()`创建了一个名为`FlightSet`的缓存条目。带有`policy.AbsoluteExpiration = DateTime.Now.AddSeconds (5)`的程序代码确定缓存条目应该在五秒钟后过期。然后它会自动从 RAM 中消失。

当然，也可以为每个出发地点创建一个单独的缓存条目，在一个条目中缓存所有航班，然后从 RAM 中过滤它们。那么数据库访问的次数将会更少，但是 RAM 中也会有您可能不需要的数据。只有当数据量不太大时，才能考虑这一点。可以在应用程序配置文件(`app.config` / `web.config`)中设置多少 RAM 用于缓存，可以是绝对兆字节(`cacheMemoryLimitMegabytes`)或物理内存的百分比(`physicalMemoryLimitPercentage`)。也可以定义这些限值(`pollingInterval`)的检查间隔。作为通过应用程序配置文件定义这些参数的替代方法，可以将它们作为`NameValueCollection`传递给`MemoryCache`的构造函数。

清单 [17-17](#Par112) 中的`Demo_MemoryCache()`方法通过在 15 秒内每秒调用两次来测试`GetFlights1()`的操作。清单 [17-17](#Par112) 显示缓存解决方案按预期工作，每五秒钟重新加载一次航班。图 [17-14](#Fig14) 显示了输出。

![A461790_1_En_17_Fig14_HTML.jpg](A461790_1_En_17_Fig14_HTML.jpg)

图 17-14

Output to Listing [17-17](#Par112)

```cs
  public static void Demo_MemoryCache()
  {
   CUI.MainHeadline(nameof(Demo_MemoryCache));
   DateTime Start = DateTime.Now;
   do
   {
    var flightSet = GetFlight1("Rome");
    // you can process the flights here...
    Console.WriteLine("Processing " + flightSet.Count + " flights...");
    System.Threading.Thread.Sleep(500);
   } while ((DateTime.Now - Start).TotalSeconds < 60);

   CUI.Print("done!");
  }

  /// <summary>
  /// GetFlight with MemoryCache (5 sek)
  /// </summary>
  private static List<Flight> GetFlight1(string departure)
  {
   string cacheItemName = "FlightSet_" + departure;

   // Access to the cache entry
   System.Runtime.Caching.MemoryCache cache = System.Runtime.Caching.MemoryCache.Default;
   List<Flight> flightSet = cache[cacheItemName] as List<Flight>;
   if (flightSet == null) // Element is NOT in the cache
   {
    CUI.Print($"{DateTime.Now.ToLongTimeString()}: Cache missed", ConsoleColor.Red);
    using (var ctx = new WWWingsContext())
    {
     ctx.Log();
     // Load flights
     flightSet = ctx.FlightSet.Where(x => x.Departure == departure).ToList();
    }
    // Store flights in cache
    CacheItemPolicy policy = new CacheItemPolicy();
    policy.AbsoluteExpiration = DateTime.Now.AddSeconds(5);
    //or: policy.SlidingExpiration = new TimeSpan(0,0,0,5);
    cache.Set(cacheItemName, flightSet, policy);
   }
   else // Data is already in cache
   {
    CUI.Print($"{DateTime.Now.ToLongTimeString()}: Cache hit", ConsoleColor.Green);
   }
   return flightSet;
  }

Listing 17-17Timed Caching of Data Loaded with Entity Framework Using MemoryCache

```

Note

顺便说一下，`System.Runtime.` `Caching`可以做得更多，尤其是所谓的基于资源变化的缓存失效。例如，如果文件发生变化(`HostFileChangeMonitor`)或数据库表的内容发生变化(`SqlChangeMonitor`)，可以立即删除缓存条目(甚至在设置的缓存期到期之前)。

### 缓存管理器

像`GetFlights1()`这样的数据访问方法在每个应用中出现上百次甚至上千次。重复出现相同的程序代码来检查缓存条目的存在，并可能创建新的条目，这当然不是一个好的解决方案。

在清单 [17-18](#Par116) 中，任务更加简洁和整洁。`GetFlights2()`只包括调用`CacheManager`类实例的通用`Get()`方法。`CacheManager`在实例化期间接收以秒为单位的缓存持续时间。除了描述返回类型的类型参数之外，`Get()`方法还需要缓存条目名和对数据加载方法的引用。第三个和任何后续参数通过`Get()`传递给 load 方法。load 方法`GetFlights2Internal()`完全脱离了缓存方面，只负责用实体框架加载数据。也可以直接调用它，但这通常是不可取的。所以，这里也是“私”的。

```cs
public static void Demo_CacheManager()
  {
   CUI.MainHeadline(nameof(Demo_CacheManager));
   DateTime Start = DateTime.Now;
   do
   {
    var flightSet = GetFlight2("Rome");
    // you can process the flights here...
    Console.WriteLine("Processing " + flightSet.Count + " flights...");
    System.Threading.Thread.Sleep(500);
   } while ((DateTime.Now - Start).TotalSeconds < 60);
  }

  /// <summary>
  /// GetFlight with CacheManager (5 sek)
  /// </summary>
  private static List<Flight> GetFlight2(string departure)
  {
   string cacheItemName = "FlightSet_" + departure;
   var cm = new CacheManager<List<Flight>>(5);
   cm.CacheHitEvent += (text) => { CUI.Print($"{DateTime.Now.ToLongTimeString()}: Cache hit: " + text, ConsoleColor.Green); };
   cm.CacheMissEvent += (text) => { CUI.Print($"{DateTime.Now.ToLongTimeString()}: Cache missed: " + text, ConsoleColor.Red); };
   return cm.Get(cacheItemName, GetFlight2Internal, departure);
  }

  private static List<Flight> GetFlight2Internal(object[] param)
  {
   using (var ctx = new WWWingsContext())
   {
    ctx.Log();
    string departure = param[0] as string;
    // Load flights
    return ctx.FlightSet.Where(x => x.Departure == departure).ToList();
   }
  }

Listing 17-18Simplified Implementation of the Task Now with the CacheManager

```

然而，这个优雅的`CacheManager`类不是. NET Framework 类，而是一个自实现。这个类的完整源代码如清单 [17-20](#Par121) 所示。除了清单 [17-18](#Par116) 中使用的通用`Get()`方法，该方法需要一个类型参数和一个加载方法，您还可以使用另一个`Get()`重载直接从缓存中检索数据。如果数据不存在，你在这里得到零。用`Save()`也可以直接保存。`CacheManager`类的用户看不到底层库`System.Runtime.Caching`的任何东西。

就其本质而言，对于给定的任务，使用属性`SlidingExpiration`而不是`AbsoluteExpiration`听起来很诱人。然而，策略`leads.SlidingExpiration = new TimeSpan (0,0,0,5)`说数据在第一次加载后将永远不会被重新加载，因为`TimeSpan` (0，0，0，5)设置的 5 秒时间跨度指的是`SlidingExpiration`。最后一次访问，即在最后一次读取访问后仅五秒钟，高速缓存条目被移除。要强制重新加载，您必须在方法`Demo_CacheManager()`中将`Sleep()`的持续时间设置为 5000 或更高。

如果你想更简洁一点，你应该看看清单 [17-20](#Par121) ，它显示了一个带有匿名函数的变体。不再需要编写单独的加载方法；必要的代码完全嵌入在`GetFlights4()`中。得益于`Closure`技术，`Get()`不再需要获取`Departure`作为参数，因为嵌入在`GetFlights3()`中的匿名方法可以直接访问`GetFlights3()`方法的所有变量。

```cs
  public static void Demo_CacheManagerLambda()
  {
  CUI.MainHeadline(nameof(Demo_CacheManagerLambda));
   DateTime Start = DateTime.Now;
   do
   {
    var flightSet = GetFlight3("Rome");
    // you can process the flights here...
    Console.WriteLine("Processing " + flightSet.Count + " flights...");
    System.Threading.Thread.Sleep(500);

   } while ((DateTime.Now - Start).TotalSeconds < 60);
  }

  public static List<Flight> GetFlight3(string departure)
  {
   string cacheItemName = "FlightSet_" + departure;
   Func<string[], List<Flight>> getData = (a) =>
   {
    using (var ctx = new WWWingsContext())
    {
     // Load flights
     return ctx.FlightSet.Where(x => x.Departure == departure).ToList();
    }
   };

   var cm = new CacheManager<List<Flight>>(5);
   cm.CacheHitEvent += (text) => { CUI.Print($"{DateTime.Now.ToLongTimeString()}: Cache Hit: " + text, ConsoleColor.Green); };
   cm.CacheMissEvent += (text) => { CUI.Print($"{DateTime.Now.ToLongTimeString()}: Cache Miss: " + text, ConsoleColor.Red); };

   return cm.Get(cacheItemName, getData);
  }

Listing 17-19Variant for Using CacheManager with an Anonymous Function

```

```cs
using System;
using System.Collections.Generic;
using System.Runtime.Caching;

namespace ITVisions.Caching
{

 /// <summary>
 /// CacheManager for simplified caching with System.Runtime.Caching
 /// (C) Dr. Holger Schwichtenberg 2013-2017
 /// </summary>
 public class CacheManager
 {
  public static List<MemoryCache> AllCaches = new List<MemoryCache>();

  public static bool IsDebug = false;
  /// <summary>
  /// Default cache duration
  /// </summary>
  public static int DefaultCacheSeconds = 60 * 60; // 60 minutes

  /// <summary>
  /// Reduced cache duration in debug mode
  /// </summary>
  public static int DefaultCacheSeconds_DEBUG = 10; // 10 seconds
  /// <summary>
  /// Removes all entries from all caches
  /// </summary>
  public static void Clear()
  {
   MemoryCache.Default.Dispose();
   foreach (var c in AllCaches)
   {
    c.Dispose();
   }
  }

  /// <summary>
  /// Removes all entries with name part from all caches
  /// </summary>
  /// <param name="name"></param>
  public static void RemoveLike(string namepart)
  {
   foreach (var x in MemoryCache.Default)
   {
    if (x.Key.Contains(namepart)) MemoryCache.Default.Remove(x.Key);
   }
   foreach (var c in AllCaches)
   {
    foreach (var x in MemoryCache.Default)
    {
     if (x.Key.Contains(namepart)) MemoryCache.Default.Remove(x.Key);
    }
   }
  }
 }

 /// <summary>
 /// CacheManager for simplified caching with System.Runtime.Caching
 /// (C) Dr. Holger Schwichtenberg 2013-2017
 /// </summary>
 /// <typeparam name="T">type of cached data</typeparam>
 /// <example>
 /// public List<Datentyp> GetAll()
 /// {
 /// var cm = new CacheManager<List<Datentyp>>();
 /// return cm.Get("Name", GetAllInternal, "parameter");
 /// }
 /// public List<Datentyp> GetAllInternal(string[] value)
 /// {
 /// var q = (from x in Context.MyDbSet where x.Name == value select x);
 /// return q.ToList();
 /// }
 /// </example>
 public class CacheManager<T> where T : class
 {

  /// <summary>
  /// CacheHit or CassMiss
  /// </summary>
  public event Action<string> CacheEvent;
  /// <summary>
  /// triggered when requested data is in the cache
  /// </summary>
  public event Action<string> CacheHitEvent;
  /// <summary>
  /// triggered when requested data is not in the cache
  /// </summary>
  public event Action<string> CacheMissEvent;

  private readonly int _seconds = CacheManager.DefaultCacheSeconds;

  public MemoryCache Cache { get; set; } = MemoryCache.Default;

  /// <summary>
  /// Created CacheManager with MemoryCache.Default
  /// </summary>
  public CacheManager()
  {
   if (CacheManager.IsDebug || System.Diagnostics.Debugger.IsAttached)
   {
    this._seconds = CacheManager.DefaultCacheSeconds_DEBUG;
   }
   else
   {
    this._seconds = CacheManager.DefaultCacheSeconds;
   }
  }

  public CacheManager(int seconds) : this()
  {
   this._seconds = seconds;
  }

  /// <summary>
  /// Generated CacheManager with its own MemoryCache instance
  /// </summary>
  /// <param name="seconds">Gets or sets the maximum memory size, in megabytes, that an instance of a MemoryCache object can grow to.</param>
  /// <param name="cacheMemoryLimitMegabytes"></param>
  /// <param name="physicalMemoryLimitPercentage">Gets or sets the percentage of memory that can be used by the cache.</param>
  /// <param name="pollingInterval">Gets or sets a value that indicates the time interval after which the cache implementation compares the current memory load against the absolute and percentage-based memory limits that are set for the cache instance.</param>
  public CacheManager(int seconds, int cacheMemoryLimitMegabytes, int physicalMemoryLimitPercentage, TimeSpan pollingInterval)
  {
   var config = new System.Collections.Specialized.NameValueCollection();
   config.Add("CacheMemoryLimitMegabytes", cacheMemoryLimitMegabytes.ToString());
   config.Add("PhysicalMemoryLimitPercentage", physicalMemoryLimitPercentage.ToString());
   config.Add("PollingInterval", pollingInterval.ToString());
   Cache = new MemoryCache("CustomMemoryCache_" + Guid.NewGuid().ToString(), config);
   Console.WriteLine(Cache.PhysicalMemoryLimit);
   Console.WriteLine(Cache.DefaultCacheCapabilities);
   this._seconds = seconds;
  }

  /// <summary>
  /// Get element from cache. It will not load if it is not there!
  /// </summary>
  public T Get(string name)
  {
   object objAlt = Cache[name];
   return objAlt as T;
  }

  /// <summary>
  /// Get element from cache or data source. Name becomes the name of the generic type
  /// </summary>
  public T Get(Func<string[], T> loadDataCallback, params string[] args)
  {
   return Get(typeof(T).FullName, loadDataCallback, args);
  }

  /// <summary>
  /// Retrieves item from cache or data source using the load method.
  /// </summary>
  public T Get(string name, Func<string[], T> loadDataCallback, params string[] args)
  {
   string cacheInfo = name + " (" + Cache.GetCount() + " elements in cache. Duration: " + _seconds + "sec)";
   string action = "";
   object obj = Cache.Get(name);
   if (obj == null) // not in cache
   {
    action = "Cache miss";
    CacheMissEvent?.Invoke(cacheInfo);
    CUI.PrintVerboseWarning(action + ": " + cacheInfo);

    #region DiagnoseTemp
    string s = DateTime.Now + "################ CACHE MISS for: " + cacheInfo + ": " + loadDataCallback.ToString() + System.Environment.NewLine;
    int a = 0;
    var x = Cache.DefaultCacheCapabilities;
    foreach (var c in Cache)
    {
     a++;
     s += $"{a:00}: LIMIT: {Cache.PhysicalMemoryLimit}:" + c.Key + ": " + c.Value.ToString().Truncate(100) + System.Environment.NewLine;

    }

    Console.WriteLine(s);
    #endregion

    // load data now
    obj = loadDataCallback(args);
    // and store it in cache
    Save(name, obj as T);

   }
   else // found in cache
   {
    action = "Cache hit";
    CUI.PrintVerboseSuccess(action + ": " + cacheInfo);
    CacheHitEvent?.Invoke(cacheInfo);
   }

   // return data
   CacheEvent?.Invoke(action + " for " + cacheInfo);
   return obj as T;
  }

  /// <summary>
  /// Saves an object in the cache
  /// </summary>
  public void Save(string name, T obj)
  {
   if (obj == null) return;
   object objAlt = Cache[name];
   if (objAlt == null)
   {
    CacheItemPolicy policy = new CacheItemPolicy();
    policy.AbsoluteExpiration = DateTime.Now.AddSeconds(_seconds);
    policy.RemovedCallback = new CacheEntryRemovedCallback(this.RemovedCallback);
    Cache.Set(name, obj, policy);
   }
  }

  public void RemovedCallback(CacheEntryRemovedArguments arguments)
  {

  }

  /// <summary>
  /// Removes an entry with specific names from this cache
  /// </summary>
  /// <param name="name"></param>
  public void Remove(string name)
  {
   if (Cache.Contains(name)) Cache.Remove(name);
  }

  /// <summary>
  /// Removes all entries with specific name part from this cache
  /// </summary>
  public void RemoveLike(string namepart)
  {
   foreach (var x in Cache)
   {
    if (x.Key.Contains(namepart)) Cache.Remove(x.Key);
   }
  }
 }
}

Listing 17-20The Auxiliary Class CacheManager Simplifies the Use of System.Runtime.Caching

```

## 使用 EFPlus 的二级缓存

清单 [17-18](#Par116) 中显示的`CacheManager`是一个通用的解决方案，它不仅允许你缓存实体框架对象，还允许你缓存任何形式的数据。实体框架核心上的缓存甚至可以更优雅！对于实体框架核心，在附加库实体框架 Plus (EFPlus)和`EFSecondLevelCache.Core`中有一个特殊的缓存解决方案(参见第 [20 章](20.html))。

这些组件基于`System.MemoryCache.Runtime.Caching`实现了一个上下文无关的查询结果缓存。这种缓存称为二级缓存。这些额外的组件可以操作查询，以便实体框架核心将其结果具体化为对象，并将其不仅存储在上下文实例的一级缓存中，还存储在流程级别的二级缓存中。然后，另一个上下文实例可以在这个二级缓存中查找相同的查询，并传递存储在那里的对象，而不是来自数据库管理系统的新查询(参见图 [17-15](#Fig15) )。

![A461790_1_En_17_Fig15_HTML.png](A461790_1_En_17_Fig15_HTML.png)

图 17-15

How a second-level cache works Note

本节讨论`EFPlus. EFSecondLevelCache.Core`中的二级缓存在配置上更复杂，但也更灵活，因为除了主内存缓存(`MemoryCache`)，Redis 也可以作为缓存。

### 设置二级缓存

对于 EFPlus，不需要在上下文类中设置二级缓存。

### 使用二级缓存

清单 [17-21](#Par131) 展示了二级缓存在 EFPlus 中的应用。在`GetFlights4()`中，在 LINQ 查询中使用了`FromCache()`方法，以 NuGet 包`Microsoft.Extensions.Caching.Abstraction`中类型为`MemoryCacheEntryOptions`的对象的形式指定缓存持续时间(这里:五秒)。

或者，您可以集中设置缓存持续时间，然后省略`FromCache()`参数。

```cs
var options = new MemoryCacheEntryOptions() { AbsoluteExpiration = DateTime.Now.AddSeconds(5) };
QueryCacheManager.DefaultMemoryCacheEntryOptions = options;

```

注意`GetFlights4()`每次被调用时都会创建一个新的上下文实例，但是缓存仍然有效，如图 [17-16](#Fig16) 所示。

![A461790_1_En_17_Fig16_HTML.jpg](A461790_1_En_17_Fig16_HTML.jpg)

图 17-16

Output of Listing [17-21](#Par131)

不幸的是，与直接使用`MemoryCache`对象的解决方案不同，您无法获得对象是否来自缓存或何时查询数据库的信息，因为不幸的是，在这种情况下，EFPlus 的缓存管理器不会触发任何结果。因此，您可以通过实体框架日志记录(`ctx.Log()`)从数据库访问中获得缓存行为；参见第 [12 章](12.html))或通过外部探查器(例如，实体框架探查器或 SQL Server 探查器)。

```cs
  public static void Demo_SecondLevelCache()
  {
   CUI.MainHeadline(nameof(Demo_SecondLevelCache));
   DateTime Start = DateTime.Now;
   do
   {
    var flightSet = GetFlight4("Rome");
    // you can process the flights here...
    Console.WriteLine("Processing " + flightSet.Count + " flights...");
    System.Threading.Thread.Sleep(500);
   } while ((DateTime.Now - Start).TotalSeconds < 30);

   GetFlight4("Rome");
   GetFlight4("Rome");
   GetFlight4("Rome");
   GetFlight4("Paris");
   GetFlight4("Mailand");
   GetFlight4("Mailand");
   GetFlight4("Rome");
   GetFlight4("Paris");
  }

  /// <summary>
  /// Caching with EFPlus FromCache() / 5 seconds
  /// </summary>
  /// <param name="departure"></param>
  /// <returns></returns>
  public static List<Flight> GetFlight4(string departure)
  {
   using (var ctx = new WWWingsContext())
   {
    ctx.Log();

    var options = new MemoryCacheEntryOptions() { AbsoluteExpiration = DateTime.Now.AddSeconds(5) };
    // optional: QueryCacheManager.DefaultMemoryCacheEntryOptions = options;

    Console.WriteLine("Load flights from " + departure + "...");

    var flightSet = ctx.FlightSet.Where(x => x.Departure == departure).FromCache(options).ToList();
    Console.WriteLine(flightSet.Count + " Flights im RAM!");
    return flightSet;
   }
  }

Listing 17-21Second-Level Caching with EFPlus

```