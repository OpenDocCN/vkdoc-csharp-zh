# 11.遗留的讨论

这是这本书的最后一章。在这里你会看到一些有趣的讨论，学习一些常用术语。

有时，如果你的应用程序运行良好，可以变通一些广为接受的规则，但是当你继续编码和开发应用程序时，你会发现专家的建议有很大的价值。如果你听从他们的建议，你会明白一个简单的选择从长远来看会有很大的影响。本章简要讨论了其中的一些主题。

## 静态方法还是实例方法？

静态方法很容易使用。一个程序员新手可能会认为在他的程序中使用静态方法还是实例方法没有多大关系。他知道他可以在不实例化对象的情况下调用方法。他喜欢这个。当他看到一些非常有用的静态实用程序方法时，印象更加深刻。但是一个有经验的程序员经常发现很难理解他是否应该使用静态方法。在每一个可能的设计中，他可能会问:哪个更好？简而言之，没有放之四海而皆准的规则。我相信这纯粹取决于你使用的应用程序。让我们核实一下事实。

### 概述

还记得第 [6](06.html) 章的简单工厂(演示 1)吗？你之前看过代码了。为了便于您立即参考，我提供了一个来自 Visual Studio 的屏幕截图。注意图 [11-1](#Fig1) 中的箭头尖端。

![../images/513659_1_En_11_Chapter/513659_1_En_11_Fig1_HTML.jpg](../images/513659_1_En_11_Chapter/513659_1_En_11_Fig1_HTML.jpg)

图 11-1

第 [6](06.html) 章演示 1 中的 AnimalFactory 类

如果您对此进行调查，您会看到以下消息:

![../images/513659_1_En_11_Chapter/513659_1_En_11_Figa_HTML.jpg](../images/513659_1_En_11_Chapter/513659_1_En_11_Figa_HTML.jpg)

这是部分快照；我为你展开完整的信息:`CA1822 Member 'CreateAnimal' does not access instance data and can be marked as static.`

它还不停地说:

```
Active Members that do not access instance data or call instance methods can be marked as static. After you mark the methods as static, the compiler will emit non-virtual call sites to these members. This can give you a measurable performance gain for performance-sensitive code.

```

Note

当我将目标框架设置为。NET 5 或。NET 6。但是当我使用目标框架时，它是不可见的。NET 3.1。

我在第 [6](06.html) 章没有采纳这个建议。原因很明显:

*   不能用关键字`virtual`或`abstract`标记静态方法。

*   因此，您不能重写静态方法。所以，你也不能使用`override`关键字。

*   当您不能使用`override`关键字重定义一个方法时，您不会得到多态行为。

在第 [6](06.html) 章中，我增强了最初的实现，并将一些责任委托给子类，因为我想实现多态行为。当您认为您的应用程序可能需要做同样的事情时，最好将该方法设为非静态的。让我给你总结一下要点:

*   If you use a method that can get all information from its parameters and does not operate on any instance of a class, you can make the method static. For example, look into the following `MyUtility` class with static method `ShowGreaterNumber()` :

    ```
    class MyUtility
        {
            public static double ShowGreaterNumber(
                double firstNumber, double secondNumber)
            {
                return firstNumber >= secondNumber ? firstNumber : secondNumber;
            }
        }

    ```

    对我来说，把它用作`MyUtility.ShowGreaterNumber(24.7, 75.2)`是有意义的，这样可以打印 24.7 和 75.2 之间较大的数字。在打印 24.7 和 75.2 之间的最大值之前，没有必要创建一个`MyUtility`的实例。你可以参考内置的`Math`类来了解好的静态方法。比如用`Math.Max(2,3)`可以得到 3，或者用`Math.Abs(-2.52)`可以得到 2.52。

*   如果您不希望看到多态行为，或者您只关心应用程序的性能，您可以考虑将您的方法设为静态。

*   有时候你看到一部分代码，然后觉得静态方法对你更有意义。但是您已经看到，将来很可能需要增强您的程序，并且您将需要多态来使您的代码更加灵活。每当你有疑问的时候，选择一个非静态的方法而不是它的对应方法(例如，静态方法)。

## 学习设计模式

让我们乘坐时光机游览一下。使用这台机器让我带你回到软件开发的早期，了解那个时代的一个普遍问题:

没有标准来指导开发者如何设计应用程序。我们是独一无二的生物。因此，每个公司团队都遵循自己的编码风格。一个新成员加入这样一个团队。对于这个成员来说，理解当前的架构是一项艰巨的任务。因此，他不断向团队的高级成员寻求帮助，并请求他们解释现有的架构。他不停地问他们:为什么在这段代码中遵循这种特殊的设计？有经验的开发人员回答他的问题。他还解释了为什么在之前的团队会议中没有考虑到常见的替代方案。他还建议新成员重用现有的构造，以减少未来的开发工作。

你问:这有什么问题？其实没有问题，这是标准做法，即使在当今世界。但是从不同的角度考虑:假设有经验的人告诉新成员:我们遵循这个代码段的外观模式，或者我们遵循那个代码段的单例模式。如果新加入者已经知道这些编码模式，他的学习会有多容易？不仅如此——因为他知道这些编码风格，遵循一个已知的模式，他很容易更快地为团队做出贡献。我希望您对了解一些标准模式的重要性有所了解！

软件设计模式解决了这类问题，并为所有开发人员提供了一个公共平台。你可以把它们看作是该领域专家的经验记录。这些模式最初是为了重用而应用于面向对象的设计中。

### 设计模式简史

设计模式的最初想法来自建筑建筑师 Christopher Alexander，他是伯克利的教授。他面临许多性质相似的问题。所以，他用类似的方法解决了这些问题。

> *“每个模式都描述了一个在我们的环境中反复出现的问题，然后描述了该问题解决方案的核心，以这样一种方式，你可以使用这个解决方案一百万次，而不必以同样的方式做两次。”*
> 
> —克里斯托夫·亚历山大

他最初的想法是在一个规划良好的城镇中建造建筑物。后来，这些概念进入了软件工程社区。这个社区开始相信，尽管这些模式是针对建筑物和城镇描述的，但同样的概念也可以应用于面向对象的设计。所以，他们用物体和界面取代了墙和门的原始概念。想法是一样的:你可以用一个已知的解决方案来解决一个常见的问题。

这些概念通过像沃德·坎宁安和肯特·贝克这样的前沿软件开发人员开始流行起来。1994 年，通过一个名为程序设计模式语言(PLoP)关于设计模式的行业会议，设计模式的思想进入了面向对象软件开发的主流。它是由 Hillside Group 主办的，Jim Coplien 的论文“一种开发过程生成模式语言”是这一背景下的著名论文。

1994 年，Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 出版了《设计模式:可重用面向对象软件的元素》一书(Addison-Wesley，1994)。随着这本经典教材的推出，设计模式的思想变得非常流行。在这本书中，他们介绍了软件开发的 23 种设计模式。*这些作者被称为“四人帮”* *。我们通常称它们为* ***GoF*** 。他们谈论的模式是由软件开发人员的共同经验开发出来的。

值得注意的是，GoF 讨论了 C++环境中的设计模式。但是 C# 1.0 是 2002 年发布的，之后经历了各种变化。它发展迅速，在很短的时间内就跻身于世界顶级编程语言的行列，并且在今天的市场上，它总是需求量很大。在撰写本文时，C# 9.0 已在 Visual Studio 2019 中可用。因为设计模式的概念是通用的，所以它们总是有价值的。因此，练习基本的设计模式总是能让你成为更好的程序员，并帮助你“升级”自己。以下是一些需要记住的要点:

*   设计模式描述了软件设计问题的通用可重用解决方案。基本思想是，在开发软件时，你可以用相似的解决方案解决相似的问题。提议的解决方案经过了长时间的测试。

*   模式实际上是模板。他们向你建议如何解决问题。对模式的良好理解可以帮助你更快地实现最好的设计。

*   从 OOP 的角度来看，这些模式描述了如何创建对象和类，并定制它们来解决特定环境中的一般设计问题。

23 种 GoF 设计模式中的每一种都专注于特定的面向对象设计。他们每个人都可以描述使用的后果和权衡。GoF 根据它们的目的对这 23 种模式进行了分类，如下所示。

**A .创作模式**

这些模式抽象了实例化过程。您使系统独立于对象的组成、创建和表示方式。这里你会问:“我应该在应用程序中的什么地方放置‘new’关键字？”这个决定可以帮助您确定类的耦合程度。以下五种模式属于这一类别:

*   单一模式

*   原型模式

*   工厂方法模式

*   构建器模式

*   抽象工厂模式

**B .结构模式**

使用这些模式，您可以组合类和对象来形成一个相对较大的结构。通常使用继承或组合来对不同的接口或实现进行分组。在第 7 章中，你看到了优先选择对象组合而不是继承(反之亦然)会影响软件的灵活性。以下七种模式属于这一类别:

*   代理模式

*   轻量级模式

*   复合模式

*   桥接模式

*   立面图案

*   装饰图案

*   适配器模式

**C .行为模式**

这些模式关注算法和对象间的责任分配。在这里，您将注意力集中在对象的通信和它们的相互联系上。以下 11 种模式属于这一类别:

*   观察者模式

*   战略模式

*   模板方法模式

*   命令模式

*   迭代器模式

*   纪念品图案

*   状态模式

*   中介模式

*   责任链模式

*   访问者模式

*   解释程序模式

GoF 做了另一个基于范围的分类，即模式主要关注类还是对象。类模式处理类和子类。它们使用继承机制，所以在编译时是静态的。对象模式处理可以在运行时改变的对象。所以，对象模式是动态的。

要快速参考，您可以参考 GoF 推出的下表:

![../images/513659_1_En_11_Chapter/513659_1_En_11_Figb_HTML.jpg](../images/513659_1_En_11_Chapter/513659_1_En_11_Figb_HTML.jpg)

### 好消息来了！

您已经实现了一些模式！不仅如此，你实际上至少从每个类别中学到了一种模式。本书的第三部分帮助你理解它们:

*   在第 6 章中，你学习了工厂方法模式。其实你也学了简单工厂模式，这是这个模式的基础。

*   在第 7 章中，你学习了装饰模式。

*   在第 8 章中，你学习了模板方法模式。

*   在第 [9](09.html) 章中，你学习了 facade 模式。

*   等等！还有一个问题:第一部分的第 2 章为战略模式奠定了基础。

这些模式在 C#应用程序中非常常见。恭喜你！你走在正确的道路上。

### 问答环节

**11.1 类模式和对象模式** **有什么区别？**

回答:

一般来说，类模式侧重于静态关系，而对象模式侧重于动态关系。顾名思义，类模式关注于类及其子类，而对象模式关注于对象的关系。

下表是 GoF 名著中讨论的总结内容:

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
|   | 

班级模式

 | 

对象模式

 |
| --- | --- | --- |
| **创作** | 可以将对象创建推迟到它的子类 | 可以将对象创建推迟到另一个对象 |
| **结构性** | 侧重于类的组成(主要使用继承的概念) | 聚焦于物体的不同构成方式 |
| **行为** | 描述算法和执行流程。他们也使用继承机制。 | 描述不同的对象如何协同工作并完成一项任务。 |

11.2 我可以在一个应用程序中组合两个或多个模式吗？

回答:

是的，在现实世界中，这种类型的活动很常见。

这些模式依赖于特定的编程语言吗？

回答:

编程语言可以发挥重要作用。但基本思想是一样的；模式就像模板一样，给你一些如何解决问题的预先想法。假设您选择了 c 之类的其他语言，而不是任何面向对象的编程语言，在这种情况下，您可能需要实现核心的面向对象原则，如继承、多态、封装、抽象等等。因此，选择一种特定的语言是很重要的，因为它可能有一些专门的功能，可以使你的生活更容易。

11.4 我是否应该将数组和链表等常见的数据结构视为不同的设计模式？

回答:

GoF 明确排除了这些，称“*它们并不复杂* *，是针对整个应用程序或子系统的特定领域设计*它们可以编码在类中，并按原样重用。所以，在这种情况下，他们不是你要关心的。

**11.5 如果没有特定的模式 100%适合我的问题，我应该如何继续？**

回答:

毫无疑问，无限数量的问题无法用有限数量的模式来解决。但是如果你知道这些常见的模式和它们的权衡，你可以选择一个相近的匹配。最后，没有人阻止你使用你的模式来解决你自己的问题。但你必须应对风险，并需要考虑你的投资回报。

请记住，世界总是在变化，新的模式也在不断发展。为了理解新模式的必要性，您可能还需要理解为什么旧的/现有的模式不足以满足需求。这些模式试图为你打下坚实的基础。这些概念可以帮助你在职业生涯中顺利前进。

## 避免反模式

设计模式可以帮助你开发更好的应用程序。但是人们经常误用它们，导致反模式。

一个吸引人的解决方案经常会导致严重的问题。这里有一个常见的例子:一个开发人员在没有分析潜在缺陷的情况下实现了一个快速修复，以满足交付计划。现在考虑一下，如果客户因为快速修复而发现一个大错误，公司的声誉会受到什么影响。

反模式在类似的情况下提醒您，并帮助您采取预防措施。它们让你想起一句谚语:预防胜于治疗。

POINTS TO REMEMBER

反模式不仅警告常见错误，还建议更好的解决方案。有些解决方案在开始时可能并不吸引人，但从长远来看，它们会节省你的时间、精力和声誉。

### 反模式简史

毫无疑问，设计模式已经帮助了(并且仍在帮助)数百万程序员。然而，渐渐地，人们开始注意到过度使用这些模式带来的负面影响。例如:许多开发人员想要展示他们的专业知识，而没有真正评估在他们的特定领域中使用这些模式的后果。作为一个明显的副作用，模式被植入了错误的环境，低质量的软件被生产出来，最终对他们或他们的组织有很大的惩罚。

软件业需要关注类似错误的负面后果，最终反模式的思想得到了发展。许多专家开始在这一领域做出贡献，但是第一个结构良好的模型来自 Michael Akroyd 题为“*反模式:针对对象误用的疫苗”的演讲。*“这是 GoF 设计模式的对立面。维基百科称该术语是由计算机程序员[安德鲁·克尼格](https://en.wikipedia.org/wiki/Andrew_Koenig_%2528programmer%2529)在 1995 年创造的。

随着威廉·j·布朗、拉斐尔·c·马尔沃、海斯·w·麦考密克三世、托马斯·j·莫布雷的名著*反模式:重构软件、架构和危机中的项目*(罗伯特·益普生/威利，1998)，术语“反模式”开始流行起来。后来，斯科特·托马斯加入了他们的小组。他们说:

> *“因为反模式有如此多的贡献者，将反模式的最初想法分配给单一来源是不公平的。相反，反模式是补充设计模式运动的工作和扩展设计模式模型的自然步骤。”*

### 反模式的例子

以下是一些反模式及其背后的概念/思维模式的例子:

*   ***过度使用模式:*** 开发人员可能会不惜任何代价尝试使用模式，不管它是否合适。

*   ***神类:*** 用许多不相关的方法控制几乎一切的大物体。

*   ***不是这里发明的:*** 我是一家大公司，我想从零开始打造一切。虽然有一个由小公司开发的库，但我不会使用它。我将自己制作一切，一旦开发出来，我将利用我的品牌价值宣布:“*嘿，伙计们，我们在这里为你们提供终极图书馆，满足你们的每一个需求。”*

*   ***零表示空:*** 程序员可能会使用一些特殊的数字，比如-1 或者 999(或者任何类似的东西)，来表示一个不合适的整数值。当他在应用程序中将类似“09/09/9999”的日期视为空日期时，可以看到类似的例子。在这些情况下，如果用户需要这些值，他将不会得到这些值。

*   ***金锤:***X 先生相信技术 T 永远是最好的。所以，如果他需要开发一个新的系统(这需要新的学习)，他仍然会选择 T，即使它不合适。他想，“我已经够大了，也很忙。如果我能以某种方式用 t 来管理它，我就不需要再学习任何技术了。”

*   ***射信使:*** 你相信测试员“约翰”总是给你找硬缺陷，因为他不喜欢你。你说你已经有压力了，项目的截止日期也快到了。所以，你不希望他把自己卷入这个关键的阶段，以避免更多的缺陷。

*   ***瑞士军刀:*** 能满足顾客各种需求的产品的公司目标。或者，想象一下，一家公司试图制造一种可以治愈所有疾病的药物。或者，有人想设计一种软件，可以服务于具有不同需求的各种客户。对他来说，界面有多复杂并不重要。

*   *复制粘贴编程:*我需要解决一个问题，但是我已经有一段代码可以处理类似的情况。因此，我可以复制一份当前正在运行的旧代码，然后在需要时开始修改它。但是当你从现有的拷贝开始时，你基本上继承了所有与之相关的潜在缺陷。此外，如果将来需要修改原始代码，您需要在多个地方实现修改。这种做法违反了*不重复自己*的原则。

*   ***架构师不编码:*** 我是一名架构师。我的时间很宝贵。我将只展示路径或给出一个关于编码的伟大演讲。有足够多的实施者应该实施我的想法。*架构师打高尔夫*也是这个反模式的姐妹。

*   ***伪装的链接和广告:*** 这来自于一种心态，当用户点击一个链接或广告时，这种心态会愚弄用户并获得收入。顾客经常得不到他/她真正想要的东西。它通常被称为**黑暗图案**。

*   ***数字管理:*** 有人认为更高数量的提交，更高数量的代码行，或者更高数量的缺陷修复等。是伟大开发者的标志。

> *“用代码的行数来衡量编程进度，就像用重量来衡量飞机的建造进度。”*
> 
> —比尔·盖茨

### 反模式的类型

反模式可以属于不同的类别。甚至一个典型的反模式也可以属于多个类别。以下是一些常见的分类:

*   **架构反模式:**瑞士军刀就是这一类的例子。

*   **开发反模式:**神类和过度使用模式就是这一类的例子。

*   **管理反模式:**射杀信使可以属于这一类。

*   **组织反模式:**架构师不编码，架构师打高尔夫可以属于这一类。

*   **用户界面反模式:**例子包括伪装的链接和广告。

POINTS TO NOTE

*   您可以从不同的网站/来源了解各种反模式。例如，下面的维基百科链接谈到了各种反模式: [`https://en.wikipedia.org/wiki/Anti-pattern`](https://en.wikipedia.org/wiki/Anti-pattern)

*   您也可以在 [`http://wiki.c2.com/?AntiPatternsCatalog`](http://wiki.c2.com/%253FAntiPatternsCatalog) 获得反模式目录的详细列表以了解更多信息。

*   反模式的概念不限于面向对象编程。

### 问答环节

11.6 反模式和设计模式有什么关系？

回答:

当你使用设计模式时，你重用了在你之前的人的经验。当你开始仅仅为了使用而盲目地使用这些概念时，你就陷入了*重复使用循环解决方案*的陷阱。这可能会导致您在未来陷入糟糕的境地，然后您发现您的投资回报率(ROI)不断下降，但您的维护成本不断增加。简而言之，表面上简单而有吸引力的解决方案(或模式)可能会在将来给你带来更多的问题。

11.7 设计模式可能会变成反模式。这种理解正确吗？

回答:

是的，如果你在错误的环境中应用一个设计模式，它会带来比它所解决的问题更多的麻烦，最终它会变成一个反模式。所以，在你开始之前，确保你了解问题的性质和背景。例如，不恰当地使用 mediator 模式可能会导致 God 类反模式。

11.8 反模式仅与软件开发人员相关。这种理解正确吗？

回答:

不。您已经看到了各种类型的反模式。所以，反模式的用处不仅限于开发人员；它可能也适用于其他人。例如，它对经理和技术架构师也很有用。

11.9 即使你现在没有从反模式中获得太多好处，它们也能帮助你在将来以更少的维护成本轻松适应新的特性。这种理解正确吗？

回答:

是的。

**11.10 反模式的可能原因是什么？**

回答:

它们可能来自不同的来源或心态。下面列出了一些常见的某人可能会说(或想)的例子:

*   “我们需要尽快交付产品。”

*   “我们与客户的关系非常好。因此，目前我们不需要对未来的影响进行太多分析。”

*   “我是重用专家。我非常了解设计模式。”

*   “我们将使用最新的技术和功能来打动我们的客户。我们不需要关心传统系统。”

*   "更复杂的代码将反映我在这方面的专业知识."

**11.11 你能提到一些反模式的症状吗？**

回答:

在面向对象编程(OOP)中，最常见的症状是您的系统无法轻松采用新功能。此外，维护成本持续增加。您可能还会注意到，您已经失去了关键的面向对象功能，如继承、多态等。

除此之外，您可能会注意到以下部分或全部症状:

*   全局变量的使用

*   代码复制

*   有限/没有代码重用

*   一大类(神类)

*   存在大量无参数方法等。

**11.12 如果检测到反模式，有什么补救措施？**

回答:

你可能需要重构你的代码，找到一个更好的解决方案。例如，以下是一些避免以下反模式的解决方案:

*   *金锤:*你可以尝试通过一些适当的训练来教育 X 先生。

*   *零表示空:*你可以使用一个额外的*布尔*变量，这个变量对你来说更合理，可以正确地表示空值。

*   *数字管理:*如果你能明智地使用数字，数字就是好的。你不能仅仅根据一个程序员每周修复的缺陷数量来判断他/她的能力。质量也很重要。例如，修复简单的 UI 布局比修复系统中的严重内存泄漏要容易得多。考虑另一个例子。“更多的测试正在通过”并不意味着您的系统更加稳定，除非这些测试使用不同的代码路径/分支。

*   *拍摄信使:*欢迎测试员“John”并立即让他参与进来。不要把他当作你的对手。你可以正确地分析他的所有发现，并尽早修复真正的缺陷，以避免最后一刻的意外。

*   *复制粘贴编程:*不用去寻找快速的解决方案，你可以重构你的代码。你也可以把经常使用的方法进行日常维护，这样可以避免重复，更容易维护。

*   *架构师不编码:*让架构师参与实现阶段的某些部分。这对组织和他们自己都有帮助。这项活动可以让他们更清楚地了解产品的真正功能。说真的，他们应该重视你的努力。

**11.13 什么叫** **重构** **？**

回答:

在编码领域，术语“重构”意味着改进现有代码的设计，而不改变系统/应用程序的外部行为。这个过程有助于您获得可读性更好的代码。同时，这些代码应该更能适应新的需求(或者变更请求),并且更易于维护。

## 一些常用术语

仅仅从一个好的设计开始并不是开发者的责任。保持一个好的设计同样重要。如果我们专注于快速修复，而不维护最初的设计目标或架构，我们可能会遇到新的问题。

不恰当的设计会使应用程序变得僵化。即使您从一个好的设计开始，对该应用程序的持续快速修复也会使其效率低下。那么一个简单的改变可能需要很多努力。在最坏的情况下，你会看到**的脆弱性**问题。这是什么意思？简而言之:一个位置的一个小的变更会导致多个位置的变更，在最坏的情况下，您会发现其中一些区域与最初的变更请求毫无关系。

如果重用您或其他人以前开发的一些内置部分，您可以非常快速地开发应用程序。当入门级程序员听说重用时，他认为**继承**是他唯一可用的选择，但这不是真的。您已经看到，在许多情况下，对象**组合**提供了比继承更好的解决方案。但是，如果您引入的代码段依赖于许多其他东西，或者已经有潜在的错误，那么继承或组合的使用就变得次要了；你确实在损害质量。无法重用软件通常被称为**不动**。

**粘性**是 OOP 中另一个需要考虑的重要事情。[维基百科](https://en.wikipedia.org/wiki/Viscosity_%2528programming%2529)将其描述为开发者可以轻松地向系统添加保留设计的代码。在维护设计的时候，如果你能很容易的给你的程序添加新的代码，你的程序粘度就低。相反的是显而易见的:在一个高粘度的设计中，添加 hacks 是容易的，而不是努力保持原来的设计。你可以肯定地看到，通过使用这些黑客，你使你的系统更加僵化。这是粘度的一种形式，也称为设计粘度。

还有一种不同的形式叫做环境粘度。考虑这样一种情况，开发人员在主代码库进行变更之前使用了一个支柱构建。我说的支柱建筑是什么意思？让我给你举个例子:假设你的公司开发了一个有很多组件或模块的大型应用程序。我称它们为支柱。例如，如果应用程序可以发送电子邮件和传真，我们就有一个电子邮件支柱和一个传真支柱。由于这些组件很大，为了维护单独的组件，公司需要单独的团队。每个团队可以使用批处理文件编译一个特定的支柱，以确保支柱中的新变化不会破坏同一支柱/组件的其他部分。这是一个柱子建筑。所以，你可以把它看作是一个单模块的构建，或者一个单组件的构建。当完整的构建(即所有支柱的完整编译)是一项耗时的活动时，这是很有吸引力的，但是您需要尽快验证一个关键的修复。让我们举一个例子:你在发布你的软件之前发现了电子邮件的一个漏洞。让我们假设如果你只编译邮件专栏，大约需要 1 个小时。但是如果你触发一个完整的构建(将电子邮件、传真和其他支柱编译在一起)，需要将近 5 个小时。因此，为了维持您的交付时间表，您倾向于只运行电子邮件支柱构建。我相信我不需要告诉你，如果你在互连的模块上工作，依赖这种支柱构建是有风险的。这是因为除非你不触发完全构建，否则你不知道最后一分钟的修复是否会导致其他支柱断裂。

**内聚**和**耦合**是另外两个重要概念，是由[拉里·康斯坦丁](https://en.wikipedia.org/wiki/Larry_Constantine)在 20 世纪 60 年代末发明的。我们所说的凝聚力是什么意思？衔接的字典含义是相互联系或统一。在 OOP 中，当你设计一个类的时候，它测量类的方法和数据之间的关系的强度。如果你能记住第 [4](04.html) 章的单一责任原则(SRP ),对你来说会很容易。这些概念是联系在一起的，尽管内聚是一个更一般的概念。

相反的是耦合。维基百科说耦合是软件模块[和](https://en.wikipedia.org/wiki/Modular_programming)之间相互依赖的程度。所以，在 OOP 中，你可以说它是两个类之间相互依赖的度量。假设有两个独立的类，A 和 B。现在考虑 A 在它的一个方法中使用 B 对象的情况，或者你在 A 类构造函数中创建一个 B 类对象并对其进行处理。在这些情况下，A 和 B 是紧密耦合的。即使 B 是 A 的子类，使用 A 的方法，你也可以说它们是紧耦合的。记住，我们想要高**内聚**和低**耦合**。我用 Robert C. Martin 在“干净的代码博客”(你可以在 [`https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html`](https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html) )中的话来结束这一章:

> *“如果你思考这个(SRP)，你会意识到这只是定义内聚和耦合的另一种方式。我们希望增加因相同原因而变化的事物之间的凝聚力，我们希望减少因不同原因而变化的事物之间的耦合。”*

### 问答环节

**11.14 你在这本书中没有谈到 C#的最新特性。有什么具体原因吗？**

回答:

我们都知道，变化是软件行业唯一的“不变”。今天新的东西，明天就可能过时。是的，一些新功能很有趣。例如，在最新版本的 C#中，可以使用顶级语句执行没有`Main()`方法的程序。这些语句按照它们在文件中出现的顺序执行。例如，考虑以下代码:

```
using System;

namespace WithoutUsingTopLevelStatements
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}

```

在早期版本的 C#和。NET 中，`namespace`和`args`参数是可选的。现在进来了。NET 5，你可以有一个进一步简化的版本:

```
using System;

Console.WriteLine("Hello World!");

```

记住，要编译它，你必须使用 C# 9.0(目标框架。NET 5.0)；否则，您会看到以下内容:`Error CS8400 Feature 'top-level statements' is not available in C# 8.0.`

的确，这是一个很大的简化。这个特性对于脚本场景很有用。现在，您输入的内容更少了，代码也更小了，但是您可以毫无问题地获得想要的输出。在这种情况下。NET 平台为你提供了所有幕后必需的东西。今天，如果初学者从这条捷径开始，他可能很难想象背景材料和遗留代码。(但有可能几年后，所有初学者都会更喜欢从这里开始。)

事实是，当你加入一个公司团队时，不太可能每次都使用编程语言的最新特性。相反，大多数时候，您使用遗留版本来支持现有客户。除非公司决定你应该进行更新，否则你也可能会继续修复旧版本中的错误。所以，我总是努力保持平衡。在我的其他书中，我也使用了编程语言的基本特征，这样你就可以很容易地理解它们。我更喜欢编写各种版本都支持的代码。

我想知道你是否在这本书里使用了其他最新的 **特征** **。**

回答:

这是你在这本书里看到的另外两个例子:

*   C# 9.0 允许你检查一个对象是否不为空。因此，下面的代码块不会产生任何编译时错误:

    ```
    if (sample is not null){ // some code }

    ```

*   从 C# 8.0 开始，您可以使用以下语句:

    ```
    using Sample sample = new Sample();

    ```

你能给我一些一般性的建议吗？

回答:

我喜欢跟随我的前辈和老师的脚步，他们是这方面的专家。以下是他们的一些一般性建议:

*   编程到超类型(抽象类/接口)，而不是实现。

*   除了少数情况之外，尽可能选择组合而不是继承。

*   尽量做一个松散耦合的系统。

*   隔离可能与代码其余部分不同的代码。

*   封装变化的内容。

## 摘要

跟随专家的足迹并从记录的经验中学习是一个非常好的策略。所以，理解设计模式非常重要。同时，建议你明智地使用它们；否则，您可能会注意到反模式的影响。一个明显的影响是，您需要投入时间来重构代码或从头开始实现新的设计。无论如何，你应该更喜欢一个没有吸引力的更好的解决方案，而不是一个有吸引力的快速解决方案。

我还在本章末尾描述了一些常用术语。这些通常有助于你理解一个演讲者在技术会议上说了什么，或者一个技术作者在他的书中写了什么。